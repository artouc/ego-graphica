This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  1.getting-started/
    .navigation.yml
    01.introduction.md
    02.installation.md
    03.configuration.md
    04.views.md
    05.assets.md
    06.styling.md
    07.routing.md
    08.seo-meta.md
    09.transitions.md
    10.data-fetching.md
    11.state-management.md
    12.error-handling.md
    13.server.md
    14.layers.md
    15.prerendering.md
    16.deployment.md
    17.testing.md
    18.upgrade.md
  2.directory-structure/
    1.app/
      .navigation.yml
      1.assets.md
      1.components.md
      1.composables.md
      1.layouts.md
      1.middleware.md
      1.pages.md
      1.plugins.md
      1.utils.md
      3.app-config.md
      3.app.md
      3.error.md
    .navigation.yml
    0.nuxt.md
    0.output.md
    1.content.md
    1.modules.md
    1.node_modules.md
    1.public.md
    1.server.md
    1.shared.md
    2.env.md
    2.gitignore.md
    2.nuxtignore.md
    2.nuxtrc.md
    3.nuxt-config.md
    3.package.md
    3.tsconfig.md
    index.md
  3.guide/
    1.concepts/
      .navigation.yml
      1.rendering.md
      10.vuejs-development.md
      2.nuxt-lifecycle.md
      3.auto-imports.md
      4.server-engine.md
      5.modules.md
      7.esm.md
      8.typescript.md
      9.code-style.md
    2.best-practices/
      .navigation.yml
      hydration.md
      performance.md
      plugins.md
    3.ai/
      .navigation.yml
      1.mcp.md
      2.llms-txt.md
    4.modules/
      .navigation.yml
      1.getting-started.md
      2.module-anatomy.md
      3.recipes-basics.md
      4.recipes-advanced.md
      5.testing.md
      6.best-practices.md
      7.ecosystem.md
      index.md
    5.recipes/
      .navigation.yml
      1.custom-routing.md
      2.vite-plugin.md
      3.custom-usefetch.md
      4.sessions-and-authentication.md
    6.going-further/
      .navigation.yml
      1.events.md
      1.experimental-features.md
      1.features.md
      1.internals.md
      10.runtime-config.md
      11.nightly-release-channel.md
      2.hooks.md
      4.kit.md
      6.nuxt-app.md
      7.layers.md
      9.debugging.md
      index.md
    .navigation.yml
    0.index.md
  4.api/
    1.components/
      .navigation.yml
      1.client-only.md
      1.dev-only.md
      1.nuxt-client-fallback.md
      10.nuxt-picture.md
      11.teleports.md
      12.nuxt-route-announcer.md
      13.nuxt-time.md
      2.nuxt-page.md
      3.nuxt-layout.md
      4.nuxt-link.md
      5.nuxt-loading-indicator.md
      6.nuxt-error-boundary.md
      7.nuxt-welcome.md
      8.nuxt-island.md
      9.nuxt-img.md
    2.composables/
      .navigation.yml
      on-prehydrate.md
      use-app-config.md
      use-async-data.md
      use-cookie.md
      use-error.md
      use-fetch.md
      use-head-safe.md
      use-head.md
      use-hydration.md
      use-lazy-async-data.md
      use-lazy-fetch.md
      use-loading-indicator.md
      use-nuxt-app.md
      use-nuxt-data.md
      use-preview-mode.md
      use-request-event.md
      use-request-fetch.md
      use-request-header.md
      use-request-headers.md
      use-request-url.md
      use-response-header.md
      use-route-announcer.md
      use-route.md
      use-router.md
      use-runtime-config.md
      use-runtime-hook.md
      use-seo-meta.md
      use-server-seo-meta.md
      use-state.md
    3.utils/
      .navigation.yml
      $fetch.md
      abort-navigation.md
      add-route-middleware.md
      call-once.md
      clear-error.md
      clear-nuxt-data.md
      clear-nuxt-state.md
      create-error.md
      define-lazy-hydration-component.md
      define-nuxt-component.md
      define-nuxt-plugin.md
      define-nuxt-route-middleware.md
      define-page-meta.md
      define-route-rules.md
      navigate-to.md
      on-before-route-leave.md
      on-before-route-update.md
      on-nuxt-ready.md
      prefetch-components.md
      preload-components.md
      preload-route-components.md
      prerender-routes.md
      refresh-cookie.md
      refresh-nuxt-data.md
      reload-nuxt-app.md
      set-page-layout.md
      set-response-status.md
      show-error.md
      update-app-config.md
    4.commands/
      .navigation.yml
      add.md
      analyze.md
      build-module.md
      build.md
      cleanup.md
      dev.md
      devtools.md
      generate.md
      info.md
      init.md
      module.md
      prepare.md
      preview.md
      test.md
      typecheck.md
      upgrade.md
    5.kit/
      .navigation.yml
      1.modules.md
      10.runtime-config.md
      10.templates.md
      11.nitro.md
      12.resolving.md
      13.logging.md
      14.builder.md
      15.examples.md
      16.layers.md
      2.programmatic.md
      3.compatibility.md
      4.autoimports.md
      5.components.md
      6.context.md
      7.pages.md
      8.layout.md
      9.head.md
      9.plugins.md
    6.advanced/
      .navigation.yml
      1.hooks.md
      2.import-meta.md
    .navigation.yml
    6.nuxt-config.md
    index.md
  5.community/
    .navigation.yml
    2.getting-help.md
    3.reporting-bugs.md
    4.contribution.md
    5.framework-contribution.md
    6.roadmap.md
    7.changelog.md
  6.bridge/
    .navigation.yml
    1.overview.md
    10.configuration.md
    2.typescript.md
    3.bridge-composition-api.md
    4.plugins-and-middleware.md
    5.nuxt3-compatible-api.md
    6.meta.md
    7.runtime-config.md
    8.nitro.md
    9.vite.md
  7.migration/
    .navigation.yml
    1.overview.md
    10.bundling.md
    11.server.md
    2.configuration.md
    20.module-authors.md
    3.auto-imports.md
    4.meta.md
    5.plugins-and-middleware.md
    6.pages-and-layouts.md
    7.component-options.md
    8.runtime-config.md
  .navigation.yml
  package.json
  README.md
examples/
  README.md
packages/
  kit/
    src/
      internal/
        esm.ts
        trace.ts
      loader/
        config.ts
        nuxt.ts
        schema.ts
      module/
        compatibility.test.ts
        compatibility.ts
        define.ts
        install.ts
      build.ts
      compatibility.ts
      components.ts
      context.ts
      head.ts
      ignore.test.ts
      ignore.ts
      imports.ts
      index.ts
      layers.ts
      layout.ts
      logger.test.ts
      logger.ts
      nitro.ts
      pages.ts
      plugin.ts
      resolve.test.ts
      resolve.ts
      runtime-config.test.ts
      runtime-config.ts
      template.ts
      utils.ts
    test/
      components-fixture/
        Named.ts
      layer-fixture/
        custom-layers/
          a/
            nuxt.config.ts
          b/
            nuxt.config.ts
        layers/
          c/
            assets/
              foo.js
            nuxt.config.ts
          d/
            nuxt.config.ts
        nuxt.config.ts
      components.spec.ts
      generate-types.spec.ts
      load-nuxt-config.bench.ts
      load-nuxt-config.spec.ts
      load-nuxt.test.ts
      module.test.ts
      templates.spec.ts
      write-types.bench.ts
    .attw.json
    .gitignore
    build.config.ts
    package.json
  nitro-server/
    src/
      runtime/
        handlers/
          error.ts
          island.ts
          renderer.ts
        middleware/
          no-ssr.ts
        plugins/
          dev-server-logs.ts
        utils/
          renderer/
            app.ts
            build-files.ts
            inline-styles.ts
            islands.ts
            payload.ts
          app-config.ts
          cache-driver.js
          cache.ts
          config.ts
          dev.ts
          error.ts
          paths.ts
      augments.ts
      index.ts
      templates.ts
      utils.ts
    .attw.json
    .gitignore
    build.config.ts
    package.json
  nuxi/
    README.md
  nuxt/
    bin/
      nuxt.mjs
    src/
      app/
        compat/
          capi.ts
          idle-callback.ts
          interval.ts
          vue-demi.ts
        components/
          client-fallback.client.ts
          client-fallback.server.ts
          client-only.ts
          dev-only.ts
          index.ts
          injections.ts
          island-renderer.ts
          nuxt-error-boundary.vue
          nuxt-error-page.vue
          nuxt-island.ts
          nuxt-layout.ts
          nuxt-link.ts
          nuxt-loading-indicator.ts
          nuxt-root.vue
          nuxt-route-announcer.ts
          nuxt-stubs.ts
          nuxt-teleport-island-component.ts
          nuxt-teleport-island-slot.ts
          nuxt-time.vue
          route-provider.ts
          server-placeholder.ts
          test-component-wrapper.ts
          utils.ts
        composables/
          asyncContext.ts
          asyncData.ts
          chunk.ts
          component.ts
          cookie.ts
          error.ts
          fetch.ts
          head.ts
          hydrate.ts
          id.ts
          index.ts
          lazy-hydration.ts
          loading-indicator.ts
          manifest.ts
          once.ts
          payload.ts
          preload.ts
          preview.ts
          ready.ts
          route-announcer.ts
          router.ts
          runtime-hook.ts
          script-stubs.ts
          ssr.ts
          state.ts
          url.ts
        middleware/
          route-rules.ts
        plugins/
          browser-devtools-timing.client.ts
          check-if-layout-used.ts
          check-outdated-build.client.ts
          chunk-reload-immediate.client.ts
          chunk-reload.client.ts
          cross-origin-prefetch.client.ts
          debug-hooks.ts
          dev-server-logs.ts
          navigation-repaint.client.ts
          payload.client.ts
          preload.server.ts
          restore-state.client.ts
          revive-payload.client.ts
          revive-payload.server.ts
          router.ts
          utils.ts
          view-transitions.client.ts
          warn.dev.server.ts
        types/
          augments.ts
        config.ts
        entry-spa.ts
        entry.async.ts
        entry.ts
        index.ts
        nuxt.ts
        types.ts
        utils.ts
      components/
        plugins/
          component-names.ts
          islands-transform.ts
          lazy-hydration-macro-transform.ts
          lazy-hydration-transform.ts
          loader.ts
          transform.ts
          tree-shake.ts
        runtime/
          client-component.ts
          lazy-hydrated-component.ts
          server-component.ts
        module.ts
        scan.ts
        templates.ts
      core/
        plugins/
          async-context.ts
          dev-only.ts
          extract-async-data-handlers.ts
          import-protection.ts
          keyed-functions.ts
          layer-aliasing.ts
          plugin-metadata.ts
          prehydrate.ts
          tree-shake.ts
          unctx.ts
          virtual.ts
        utils/
          index.ts
          names.ts
          parse-utils.ts
          parse.ts
          plugins.ts
          types.ts
        app.ts
        builder.ts
        cache.ts
        external-config-files.ts
        features.ts
        modules.ts
        nuxt.ts
        schema.ts
        server.ts
        templates.ts
      head/
        plugins/
          unhead-imports.ts
        runtime/
          plugins/
            unhead.ts
          components.ts
          composables.ts
          types.ts
        module.ts
      imports/
        module.ts
        presets.ts
        transform.ts
      pages/
        plugins/
          page-meta.ts
          route-injection.ts
        runtime/
          plugins/
            check-if-page-unused.ts
            prefetch.client.ts
            prerender.server.ts
            router.ts
          app.vue
          component-stub.ts
          composables.ts
          index.ts
          page-placeholder.ts
          page.ts
          router.options.ts
          utils.ts
          validate.ts
        build.d.ts
        module.ts
        route-rules.ts
        utils.ts
      dirs.ts
      index.ts
      utils.ts
    test/
      __snapshots__/
        components-tree-shake.test.ts.snap
        pages-override-meta-disabled.test.ts.snap
        pages-override-meta-enabled.test.ts.snap
      components-fixture/
        components/
          client/
            ComponentWithProps.vue
            WithClientOnlySetup.vue
          global/
            Glob.vue
          islands/
            Isle.vue
          parent-folder/
            index.server.vue
          same-name/
            same/
              Same.vue
          HelloWorld.vue
          Nuxt3.client.vue
          Nuxt3.server.vue
          some-glob.global.vue
          some.island.vue
      disabled-modules-fixture/
        layers/
          base/
            layer-module-a.ts
            layer-module-b.ts
            layer-module-c.ts
            nuxt.config.ts
        nuxt.config.ts
        project-module.ts
      layers-fixture/
        custom/
          modules/
            module.ts
          module.ts
          nuxt.config.ts
        layers/
          auto/
            modules/
              module.ts
            module.ts
            nuxt.config.ts
        modules/
          module.ts
        module.ts
        nuxt.config.ts
      nitro/
        render-index.ts
      pages-fixture/
        pages/
          index.vue
        nuxt.config.ts
      app-config.test.ts
      app.test.ts
      auto-imports.test.ts
      build-plugins.bench.ts
      build.bench.ts
      builder.test.ts
      compiler.test.ts
      component-layer-priority.test.ts
      component-loader.test.ts
      component-names.test.ts
      components-transform.test.ts
      components-tree-shake.test.ts
      devonly.test.ts
      disabled-modules.test.ts
      extract-async-data-handlers.test.ts
      import-protection.test.ts
      island-transform.test.ts
      keyed-functions.test.ts
      lazy-hydration-macro-transform.test.ts
      load-nuxt.bench.ts
      load-nuxt.test.ts
      naming.test.ts
      nitro-ssr-routes.test.ts
      nuxt-link.test.ts
      page-metadata.test.ts
      pages.test.ts
      plugin-metadata.test.ts
      plugin-utils.test.ts
      prehydrate.test.ts
      render.bench.ts
      route-injection.test.ts
      route-rules.test.ts
      scan-components.test.ts
      shared-dir-config.test.ts
      tree-shake.test.ts
      unctx-transform.test.ts
      unhead-imports.test.ts
      utils.ts
      virtual.test.ts
    .attw.json
    .gitignore
    app.d.ts
    build.config.ts
    config.cjs
    config.d.ts
    config.js
    index.d.ts
    kit.d.ts
    kit.js
    meta.d.ts
    meta.js
    package.json
    schema.d.ts
    schema.js
    types.d.mts
    types.d.ts
  rspack/
    .attw.json
    build.config.ts
    builder.mjs
    package.json
  schema/
    src/
      config/
        adhoc.ts
        app.ts
        build.ts
        common.ts
        dev.ts
        esbuild.ts
        experimental.ts
        generate.ts
        index.ts
        internal.ts
        nitro.ts
        oxc.ts
        postcss.ts
        router.ts
        typescript.ts
        vite.ts
        webpack.ts
      types/
        builder-env/
          index.ts
          vite.ts
          webpack.ts
        compatibility.ts
        compiler.ts
        components.ts
        config.ts
        debug.ts
        head.ts
        hooks.ts
        imports.ts
        module.ts
        nuxt.ts
        router.ts
        schema.ts
      utils/
        definition.ts
      builder-env.ts
      index.ts
    test/
      folder-structure.spec.ts
    .attw.json
    .gitignore
    build.config.ts
    builder-env.d.ts
    package.json
  ui-templates/
    lib/
      dev.ts
      prerender.ts
      render.ts
    public/
      icons/
        book-open-solid 1.svg
        discord-brands 1.svg
        documentation-color-light.svg
        documentation-color.svg
        documentation-light.svg
        documentation.svg
        examples-color-light.svg
        examples-color.svg
        examples-light.svg
        examples.svg
        get-started-light.svg
        get-started.svg
        github-brands 1.svg
        logo.svg
        MiniGem.svg
        modules-color-light.svg
        modules-color.svg
        modules-light.svg
        modules.svg
        twitter-brands 1.svg
    templates/
      error-404/
        index.html
        messages.json
      error-500/
        index.html
        messages.json
      loading/
        index.html
        messages.json
      spa-loading-icon/
        index.html
        messages.json
      welcome/
        index.html
        messages.json
      messages.json
    test/
      __snapshots__/
        templates.spec.ts.snap
      templates.spec.ts
    index.html
    package.json
    styles.ts
    uno.config.ts
    vite.config.ts
  vite/
    src/
      plugins/
        analyze.ts
        client-manifest.ts
        dev-server.ts
        dev-style-ssr.ts
        environments.ts
        layer-dep-optimize.ts
        module-preload-polyfill.ts
        public-dirs.ts
        replace.ts
        resolve-deep-imports.ts
        resolved-externals.ts
        runtime-paths.ts
        sourcemap-preserver.ts
        ssr-styles.ts
        stable-entry.ts
        type-check.ts
        vite-node.ts
        vite-plugin-checker.ts
        vue-feature-flags.ts
      shared/
        client.ts
        server.ts
      utils/
        config.ts
        index.ts
        logger.ts
        transpile.test.ts
        transpile.ts
        warmup.ts
      client.ts
      css.ts
      dirs.ts
      index.ts
      manifest.ts
      server.ts
      vite-node-entry.ts
      vite-node.ts
      vite.ts
    .attw.json
    build.config.ts
    package.json
  webpack/
    src/
      configs/
        client.ts
        index.ts
        server.ts
      loaders/
        vue-module-identifier.ts
      plugins/
        vue/
          client.ts
          server.ts
          util.ts
        chunk.ts
        dynamic-base.ts
        rollup-compat-dynamic-import.ts
        ssr-styles.ts
        warning-ignore.ts
      presets/
        assets.ts
        base.ts
        esbuild.ts
        node.ts
        nuxt.ts
        pug.ts
        style.ts
        vue.ts
      utils/
        config.ts
        index.ts
        mfs.ts
        postcss.ts
      index.ts
      webpack.ts
    .attw.json
    build.config.ts
    builder.d.ts
    builder.mjs
    package.json
patches/
  changelogen.patch
playground/
  app/
    app.vue
  server/
    api/
      test.ts
  nuxt.config.ts
  package.json
  tsconfig.json
scripts/
  _utils.ts
  bump-nightly.ts
  bump.ts
  example.sh
  release.ts
  update-changelog.ts
test/
  e2e/
    global.setup.ts
    global.teardown.ts
    hmr.test.ts
    runtime-compiler.test.ts
    spa-preloader-body.test.ts
    spa-preloader-within.test.ts
    suspense.test.ts
    test-utils.ts
  fixtures/
    basic/
      app/
        assets/
          assets.css
          css-only-asset.svg
          functional.css
          global.css
          inline-only.css
          logo.svg
          plugin.css
        components/
          client/
            Binding.client.ts
            FragmentServer.client.vue
            FragmentServer.server.vue
            FragmentServerFragment.client.vue
            FragmentServerFragment.server.vue
            MultiRootNode.client.vue
            MultiRootNodeScript.client.vue
            NoState.client.vue
            Script.client.vue
            Server.client.vue
            Server.server.vue
            ServerFragment.client.vue
            ServerFragment.server.vue
            SetupScript.client.vue
            StringChildStateful.client.vue
            StringChildStatefulScript.client.vue
          clientFallback/
            AsyncSetup.vue
            NonStateful.vue
            NonStatefulSetup.vue
            Stateful.vue
            StatefulSetup.vue
          global/
            ClientGlobal.client.vue
            ServerComponentGlobal.server.vue
            TestGlobal.vue
          islands/
            LongAsyncComponent.vue
            PureComponent.vue
            RouteComponent.vue
          Nested/
            Counter.vue
          1thing.island.vue
          AsyncServerComponent.server.vue
          BreakInAsyncSetup.vue
          BreakInSetup.vue
          BreaksServer.client.ts
          ClientOnlyScript.client.vue
          ClientOnlySetupScript.client.vue
          ClientWrapped.client.vue
          ComponentUsingCookie.vue
          ComponentWithIds.vue
          ComponentWithRef.vue
          Counter.vue
          CounterWithNuxtClient.vue
          DelayedComponent.vue
          DelayedModel.vue
          EventView.vue
          FunctionalComponent.ts
          GlobalSync.vue
          ServerOnlyComponent.server.vue
          ServerOnlyComponentChild.vue
          ServerWithClient.server.vue
          ServerWithNestedClient.server.vue
          SharedComponent.vue
          Tsx.tsx
          WithSuffix.global.vue
          WrapClientComponent.vue
        composables/
          nested/
            bar.ts
          async-context.ts
          asyncDataTests.ts
          badSideEffect.ts
          cookie-manager.ts
          export-star.ts
          foo.ts
          ignored.ts
          keep-alive.ts
          override-base.ts
          random.ts
          template.ts
          tree-shake.ts
        layouts/
          custom-async.vue
          custom.vue
          custom2.vue
          invalid-root.vue
          PascalCase.ts
          with-props.vue
          with-route-announcer.vue
        middleware/
          abort.global.ts
          b.global.ts
          injectAuth.ts
          redirect.global.ts
          routeRulesMiddleware.ts
          sets-layout.ts
        other-components-folder/
          named-export.ts
        other-composables-folder/
          custom-keyed-composable.ts
          local.ts
        pages/
          (new-group)/
            group-page.vue
          another-parent/
            index.vue
          async-parent/
            child.vue
          catchall/
            [...slug].vue
          client-only-page/
            index.client.vue
            normal.vue
          components/
            nuxt-time.vue
          composables/
            on-prehydrate.vue
          error/
            error-boundary.vue
            index.vue
          experimental/
            decorators.vue
            node-compat.vue
          fixed-keyed-child-parent/
            [foo].vue
          hydration/
            spa-redirection/
              end.vue
              start.vue
            layout.vue
          ignore/
            composables.vue
          import-components/
            index.vue
          instance/
            error.vue
            next-request.vue
          invalid-root/
            1.vue
            2.vue
            3.vue
            4.vue
            fine.vue
          keepalive/
            keepalive-in-config.vue
            keepalive-in-nuxtpage-2.vue
            keepalive-in-nuxtpage.vue
            not-keepalive-in-nuxtpage.vue
            not-keepalive.vue
          keyed-child-parent/
            [foo].vue
          keyed-composables/
            index.vue
            local.vue
          layout-switch/
            end.vue
            start.vue
          layouts/
            with-props.vue
          lazy-import-components/
            delayed-hydration/
              macro/
                index.vue
                model-event.vue
                time.vue
              index.vue
              model-event.vue
              time.vue
            index.vue
          nested/
            [foo]/
              [bar].vue
              user-[group].vue
            [foo].vue
          nested-group/
            (deep-group)/
              group-page.vue
            (index-group)/
              index.vue
            more-nested/
              (more-deep)/
                group-page.vue
          non-ascii/
            ç.vue
          nuxt-link/
            custom-external.vue
            trailing-slash.vue
            use-link.vue
          page-load-hook/
            [slug].vue
          parent/
            index.vue
          prefetch/
            components.vue
            index.vue
            server-components.vue
          prerender/
            ç.vue
            test.vue
          preview/
            index.vue
            with-custom-enable.vue
            with-custom-state.vue
            with-use-fetch.vue
          random/
            [id].vue
          route-provider/
            index/
              bar.vue
              foo.vue
            index.vue
          route-rules/
            inline.vue
            layout.vue
            middleware.vue
            redirect.vue
            spa.vue
          route-scroll-behavior/
            scroll-to-top/
              [id].vue
            scroll-to-top.vue
          server-components/
            lazy/
              end.vue
              start.vue
            lost-page.server.vue
          suspense/
            async-[parent]/
              async-[child].vue
              sync-[child].vue
            sync-[parent]/
              async-[child].vue
              sync-[child].vue
            async-[parent].vue
            sync-[parent].vue
          useAsyncData/
            double.vue
            immediate-remove-unmounted.vue
            immediate.vue
            nuxt-data.vue
            promise-all.vue
            refresh.vue
            single.vue
            status.vue
            use-id.vue
          wrapper-expose/
            page/
              another.vue
              index.vue
            layout.vue
            page.vue
          another-parent.vue
          app-config.vue
          assets-custom.vue
          assets.vue
          async-context.vue
          async-parent.vue
          auth.vue
          chunk-error.vue
          client-fallback.vue
          client-only-components.vue
          client-only-explicit-import.vue
          client-server.vue
          client.vue
          cookies.vue
          empty.ts
          extends.vue
          fixed-keyed-child-parent.vue
          head-component.vue
          head-script-setup.vue
          head.vue
          index.vue
          inline-only-css.vue
          internal-layout.vue
          islands.vue
          isr.vue
          json-payload.vue
          jsx.vue
          keepalive.vue
          keyed-child-parent.vue
          legacy-async-data-fail.vue
          meta.vue
          middleware-abort-non-fatal.vue
          middleware-abort.vue
          namespace-nuxt-app.vue
          navigate-to-api.vue
          navigate-to-error.vue
          navigate-to-external.vue
          navigate-to-forbidden.vue
          navigate-to-redirect.vue
          navigate-to-validate-custom-error.vue
          navigate-to.vue
          no-auth.vue
          no-scripts.vue
          nuxt-teleport.vue
          once-nav-initial.vue
          once.vue
          page-load-hook.vue
          parent.vue
          plugins.vue
          redirect-with-encode.vue
          redirect.vue
          route-announcer.vue
          route-announcer2.vue
          server-page.server.vue
          ssr-modules.vue
          styles.vue
          suspense.vue
          swr.vue
          teleport.vue
          tree-shake.vue
          tsx-page-meta.vue
          url.vue
          use-id.vue
          validate-custom-error.vue
          vueuse-head.vue
          with-computed-layout.vue
          with-dynamic-layout.vue
          with-layout.vue
          with-layout2.vue
        plugins/
          10.layer-ordering.ts
          add-nuxt-link-alias.ts
          add-route.ts
          async-plugin.ts
          chunk-error.ts
          context-error.ts
          cookie.ts
          custom-type-assertion.client.ts
          custom-type-registration.ts
          dependsOnPlugin.ts
          error.server.ts
          invalid-plugin-1.ts
          my-plugin.ts
          page-hook-plugin.ts
          prerender.server.ts
          register.ts
          server-only.server.ts
          style.ts
          test.d.ts
          this-should-not-load.spec.js
        utils/
          useBar.ts
        app.config.js
        app.vue
        error.vue
        some-exports.ts
      custom-modules/
        subpath/
          index.ts
          module.ts
      custom-public/
        file.svg
      extends/
        bar/
          app/
            router.options.ts
          components/
            ExtendsOverride.vue
          composables/
            base.ts
          layouts/
            override.vue
          middleware/
            a.global.ts
            override.ts
          pages/
            override.vue
          plugins/
            09.layer-plugin-pre.ts
            11.layer-plugin-post.ts
          public/
            nuxt.svg
          app.config.ts
          index.d.ts
          nuxt.config.ts
      layers/
        bar/
          nuxt.config.ts
      modules/
        auto-registered/
          runtime/
            server/
              utils/
                some-utils.ts
            handler.ts
            some-server-import.ts
          index.ts
        import-components/
          runtime/
            components.ts
          index.ts
        lazy-import-components/
          runtime/
            components.ts
          index.ts
        page-extend/
          pages/
            big-page.vue
          index.ts
        runtime/
          middleware.ts
          page.vue
          plugin.ts
        test/
          index.ts
        example.ts
        functional.ts
      postcss/
        plugin.ts
      public/
        ignore/
          public-asset
        css-only-public-asset.svg
        public.svg
      server/
        api/
          experimental/
            decorators.ts
          hey/
            index.get.ts
            index.post.ts
          useAsyncData/
            count.ts
          app-config.ts
          auto-imports.ts
          counter.ts
          error.ts
          hello.ts
          preview.ts
          random.ts
          union.ts
          very-long-request.ts
        plugins/
          headers.ts
        routes/
          ignore/
            scanned.ts
          proxy.ts
      .gitignore
      .nuxtignore
      nuxt.config.ts
      package.json
      tsconfig.json
    basic-types/
      app/
        components/
          ServerComponent.server.vue
          WithTypes.vue
        layouts/
          custom.vue
          PascalCase.ts
          with-props.vue
        middleware/
          global.global.ts
          named.ts
        pages/
          param/
            [id]/
              view.vue
            [id].vue
            index.vue
          custom-name.vue
          page.vue
          param.vue
        plugins/
          injection.ts
        app-types.ts
        app.config.ts
      extends/
        bar/
          layouts/
            override.vue
          middleware/
            override.ts
          pages/
            override.vue
          app.config.ts
          index.d.ts
          nuxt.config.ts
      modules/
        auto-registered/
          runtime/
            handler.ts
          index.ts
        runtime/
          middleware.ts
          page.vue
          plugin.ts
        test/
          index.ts
        example.ts
        page-extend.ts
      server/
        api/
          hey/
            index.get.ts
            index.post.ts
          hello.ts
          union.ts
        type-context.ts
      shared/
        utils/
          test.ts
        other.ts
        shared-types.ts
      .gitignore
      config-types.ts
      index.d.ts
      nuxt.config.ts
      nuxt.schema.ts
      package.json
      tsconfig.json
    hmr/
      app/
        components/
          example/
            test.vue
          islands/
            HmrComponent.vue
        pages/
          issues/
            32177.vue
          routes/
            index.vue
          index.vue
          page-meta.vue
          rename-component.vue
          route-rules.vue
          server-component.vue
          state-component.vue
          top-level-await.vue
      server/
        api/
          slow.ts
      nuxt.config.ts
      package.json
      tsconfig.json
    minimal/
      app.vue
      error.vue
      nuxt.config.ts
      package.json
      tsconfig.json
    minimal-pages/
      app/
        layouts/
          default.vue
        middleware/
          test.global.ts
        pages/
          a.client.vue
          b.server.vue
          index.vue
        plugins/
          test.ts
        app.vue
        error.vue
      nuxt.config.ts
      package.json
      tsconfig.json
    minimal-types/
      app-types.ts
      app.vue
      nuxt.config.ts
      package.json
      tsconfig.json
    runtime-compiler/
      app/
        components/
          Helloworld.vue
          Name.ts
          ShowTemplate.vue
        layouts/
          default.vue
        pages/
          api-template.vue
          basic-component.vue
          component-in-setup.vue
          full-dynamic.vue
          index.vue
          typescript-component.vue
      public/
        favicon.ico
      server/
        api/
          full-component.get.ts
          template.get.ts
      .gitignore
      nuxt.config.ts
      package.json
      tsconfig.json
    spa-loader/
      app/
        spa-loading-template.html
      app.vue
      nuxt.config.ts
      package.json
      tsconfig.json
    suspense/
      pages/
        index.vue
        target.vue
      app.vue
      nuxt.config.ts
      package.json
      tsconfig.json
  mocks/
    app-config.ts
    nuxt-config.ts
    paths.ts
    router-options.ts
  nuxt/
    universal/
      router.test.ts
    client-only.test.ts
    components.test.ts
    composables.test.ts
    define-nuxt-component.test.ts
    error-boundary.test.ts
    island-pages.test.ts
    loading-indicator.test.ts
    nuxt-island.test.ts
    nuxt-layout.test.ts
    nuxt-page.test.ts
    nuxt-time.test.ts
    plugin.test.ts
    polyfills.test.ts
    router.options.test.ts
    tsconfig.json
    use-async-data.test.ts
    use-fetch.test.ts
  runtime/
    app/
      router.options.ts
  basic.test.ts
  bundle.test.ts
  matrix.ts
  prepare.ts
  setup-env.ts
  setup-runtime.ts
  typed-router.test.ts
  utils.ts
.editorconfig
.gitignore
.markdownlint.yml
CODEOWNERS
eslint.config.mjs
knip.json
LICENSE
lychee.toml
nuxt.config.ts
package.json
playwright.config.ts
pnpm-workspace.yaml
README.md
renovate.json
SECURITY.md
tsconfig.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/1.getting-started/.navigation.yml">
title: Get Started
titleTemplate: '%s · Get Started with Nuxt'
icon: i-lucide-rocket
</file>

<file path="docs/1.getting-started/01.introduction.md">
---
title: Introduction
description: Nuxt's goal is to make web development intuitive and performant with a great Developer Experience in mind.
navigation:
  icon: i-lucide-info
---

Nuxt is a free and [open-source framework](https://github.com/nuxt/nuxt) with an intuitive and extendable way to create type-safe, performant and production-grade full-stack web applications and websites with [Vue.js](https://vuejs.org).

We made everything so you can start writing `.vue` files from the beginning while enjoying hot module replacement in development and a performant application in production with server-side rendering by default.

Nuxt has no vendor lock-in, allowing you to deploy your application [**everywhere, even on the edge**](/blog/nuxt-on-the-edge).

::tip
If you want to play around with Nuxt in your browser, you can [try it out in one of our online sandboxes](/docs/4.x/getting-started/installation#play-online).
::

## Automation and Conventions

Nuxt uses conventions and an opinionated directory structure to automate repetitive tasks and allow developers to focus on pushing features. The configuration file can still customize and override its default behaviors.

- **File-based routing:** define routes based on the structure of your [`app/pages/` directory](/docs/4.x/directory-structure/app/pages). This can make it easier to organize your application and avoid the need for manual route configuration.
- **Code splitting:** Nuxt automatically splits your code into smaller chunks, which can help reduce the initial load time of your application.
- **Server-side rendering out of the box:** Nuxt comes with built-in SSR capabilities, so you don't have to set up a separate server yourself.
- **Auto-imports:** write Vue composables and components in their respective directories and use them without having to import them with the benefits of tree-shaking and optimized JS bundles.
- **Data-fetching utilities:** Nuxt provides composables to handle SSR-compatible data fetching as well as different strategies.
- **Zero-config TypeScript support:** write type-safe code without having to learn TypeScript with our auto-generated types and `tsconfig.json`.
- **Configured build tools:** we use [Vite](https://vite.dev) by default to support hot module replacement (HMR) in development and bundling your code for production with best-practices baked-in.

Nuxt takes care of these and provides both frontend and backend functionality so you can focus on what matters: **creating your web application**.

## Server-Side Rendering

Nuxt comes with built-in server-side rendering (SSR) capabilities by default, without having to configure a server yourself, which has many benefits for web applications:

- **Faster initial page load time:** Nuxt sends a fully rendered HTML page to the browser, which can be displayed immediately. This can provide a faster perceived page load time and a better user experience (UX), especially on slower networks or devices.
- **Improved SEO:** search engines can better index SSR pages because the HTML content is available immediately, rather than requiring JavaScript to render the content on the client-side.
- **Better performance on low-powered devices:** it reduces the amount of JavaScript that needs to be downloaded and executed on the client-side, which can be beneficial for low-powered devices that may struggle with processing heavy JavaScript applications.
- **Better accessibility:** the content is immediately available on the initial page load, improving accessibility for users who rely on screen readers or other assistive technologies.
- **Easier caching:** pages can be cached on the server-side, which can further improve performance by reducing the amount of time it takes to generate and send the content to the client.

Overall, server-side rendering can provide a faster and more efficient user experience, as well as improve search engine optimization and accessibility.

As Nuxt is a versatile framework, it gives you the possibility to statically render your whole application to a static hosting with `nuxt generate`,
disable SSR globally with the `ssr: false` option or leverage hybrid rendering by setting up the `routeRules` option.

:read-more{title="Nuxt rendering modes" to="/docs/4.x/guide/concepts/rendering"}

### Server engine

The Nuxt server engine [Nitro](https://nitro.build/) unlocks new full-stack capabilities.

In development, it uses Rollup and Node.js workers for your server code and context isolation. It also generates your server API by reading files in `server/api/` and server middleware from `server/middleware/`.

In production, Nitro builds your app and server into one universal `.output` directory. This output is light: minified and removed from any Node.js modules (except polyfills). You can deploy this output on any system supporting JavaScript, from Node.js, Serverless, Workers, Edge-side rendering or purely static.

:read-more{title="Nuxt server engine" to="/docs/4.x/guide/concepts/server-engine"}

### Production-ready

A Nuxt application can be deployed on a Node or Deno server, pre-rendered to be hosted in static environments, or deployed to serverless and edge providers.

:read-more{title="Deployment section" to="/docs/4.x/getting-started/deployment"}

### Modular

A module system allows you to extend Nuxt with custom features and integrations with third-party services.

:read-more{title="Nuxt Modules Concept" to="/docs/4.x/guide/concepts/modules"}

### Architecture

Nuxt is composed of different [core packages](https://github.com/nuxt/nuxt/tree/main/packages):

- Core engine: [nuxt](https://github.com/nuxt/nuxt/tree/main/packages/nuxt)
- Bundlers: [@nuxt/vite-builder](https://github.com/nuxt/nuxt/tree/main/packages/vite), [@nuxt/rspack-builder](https://github.com/nuxt/nuxt/tree/main/packages/rspack) and [@nuxt/webpack-builder](https://github.com/nuxt/nuxt/tree/main/packages/webpack)
- Command line interface: [@nuxt/cli](https://github.com/nuxt/cli)
- Server engine: [nitro](https://github.com/nitrojs/nitro)
- Development kit: [@nuxt/kit](https://github.com/nuxt/nuxt/tree/main/packages/kit)

We recommend reading each concept to have a full vision of Nuxt capabilities and the scope of each package.
</file>

<file path="docs/1.getting-started/02.installation.md">
---
title: 'Installation'
description: 'Get started with Nuxt quickly with our online starters or start locally with your terminal.'
navigation.icon: i-lucide-play
---

## Play Online

If you just want to play around with Nuxt in your browser without setting up a project, you can use one of our online sandboxes:

::card-group
  :card{title="Open on StackBlitz" icon="i-simple-icons-stackblitz" to="https://nuxt.new/s/v4" target="_blank"}
  :card{title="Open on CodeSandbox" icon="i-simple-icons-codesandbox" to="https://nuxt.new/c/v4" target="_blank"}
::

Or follow the steps below to set up a new Nuxt project on your computer.

## New Project

### Prerequisites

- **Node.js** - [`20.x`](https://nodejs.org/en) or newer (but we recommend the [active LTS release](https://github.com/nodejs/release#release-schedule))
- **Text editor** - There is no IDE requirement, but we recommend [Visual Studio Code](https://code.visualstudio.com/) with the [official Vue extension](https://marketplace.visualstudio.com/items?itemName=Vue.volar) (previously known as Volar) or [WebStorm](https://www.jetbrains.com/webstorm/), which, along with [other JetBrains IDEs](https://www.jetbrains.com/ides/), offers great Nuxt support right out-of-the-box.
- **Terminal** - In order to run Nuxt commands

::note
  ::details
  :summary[Additional notes for an optimal setup:]
  - **Node.js**: Make sure to use an even numbered version (20, 22, etc.)
  - **Nuxtr**: Install the community-developed [Nuxtr extension](https://marketplace.visualstudio.com/items?itemName=Nuxtr.nuxtr-vscode)
  - **WSL**: If you are using Windows and experience slow HMR, you may want to try using [WSL (Windows Subsystem for Linux)](https://learn.microsoft.com/en-us/windows/wsl/install) which may solve some performance issues.
  - **Windows slow DNS resolution**: Instead of using `localhost:3000` for local dev server on Windows, use `127.0.0.1` for much faster loading experience on browsers.
  ::
::

Open a terminal (if you're using [Visual Studio Code](https://code.visualstudio.com), you can open an [integrated terminal](https://code.visualstudio.com/docs/terminal/basics)) and use the following command to create a new starter project:

::code-group{sync="pm"}

```bash [npm]
npm create nuxt@latest <project-name>
```

```bash [yarn]
yarn create nuxt@latest <project-name>
```

```bash [pnpm]
pnpm create nuxt@latest <project-name>
```

```bash [bun]
bun create nuxt@latest <project-name>
```

```bash [deno]
deno -A npm:create-nuxt@latest <project-name>
```

::

::tip
Alternatively, you can find other starters or themes by opening [nuxt.new](https://nuxt.new) and following the instructions there.
::

Open your project folder in Visual Studio Code:

```bash [Terminal]
code <project-name>
```

Or change directory into your new project from your terminal:

```bash
cd <project-name>
```

## Development Server

Now you'll be able to start your Nuxt app in development mode:

::code-group{sync="pm"}

```bash [npm]
npm run dev -- -o
```

```bash [yarn]
yarn dev --open
```

```bash [pnpm]
pnpm dev -o
```

```bash [bun]
bun run dev -o

# To use the Bun runtime during development
# bun --bun run dev -o
```

```bash [deno]
deno run dev -o
```
::

::tip{icon="i-lucide-circle-check"}
Well done! A browser window should automatically open for <http://localhost:3000>.
::

## Next Steps

Now that you've created your Nuxt project, you are ready to start building your application.

:read-more{title="Nuxt Concepts" to="/docs/4.x/guide/concepts"}
</file>

<file path="docs/1.getting-started/03.configuration.md">
---
title: Configuration
description: Nuxt is configured with sensible defaults to make you productive.
navigation.icon: i-lucide-cog
---

By default, Nuxt is configured to cover most use cases. The [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) file can override or extend this default configuration.

## Nuxt Configuration

The [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) file is located at the root of a Nuxt project and can override or extend the application's behavior.

A minimal configuration file exports the `defineNuxtConfig` function containing an object with your configuration. The `defineNuxtConfig` helper is globally available without import.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  // My Nuxt config
})
```

This file will often be mentioned in the documentation, for example to add custom scripts, register modules or change rendering modes.

::read-more{to="/docs/4.x/api/configuration/nuxt-config"}
Every option is described in the **Configuration Reference**.
::

::note
You don't have to use TypeScript to build an application with Nuxt. However, it is strongly recommended to use the `.ts` extension for the `nuxt.config` file. This way you can benefit from hints in your IDE to avoid typos and mistakes while editing your configuration.
::

### Environment Overrides

You can configure fully typed, per-environment overrides in your nuxt.config

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  $production: {
    routeRules: {
      '/**': { isr: true },
    },
  },
  $development: {
    //
  },
  $env: {
    staging: {
      //
    },
  },
})
```

To select an environment when running a Nuxt CLI command, simply pass the name to the `--envName` flag, like so: `nuxt build --envName staging`.

To learn more about the mechanism behind these overrides, please refer to the `c12` documentation on [environment-specific configuration](https://github.com/unjs/c12?tab=readme-ov-file#environment-specific-configuration).

:video-accordion{title="Watch a video from Alexander Lichter about the env-aware nuxt.config.ts" videoId="DFZI2iVCrNc"}

::note
If you're authoring layers, you can also use the `$meta` key to provide metadata that you or the consumers of your layer might use.
::

### Environment Variables and Private Tokens

The `runtimeConfig` API exposes values like environment variables to the rest of your application. By default, these keys are only available server-side. The keys within `runtimeConfig.public` and `runtimeConfig.app` (which is used by Nuxt internally) are also available client-side.

Those values should be defined in `nuxt.config` and can be overridden using environment variables.

::code-group

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    // The private keys which are only available server-side
    apiSecret: '123',
    // Keys within public are also exposed client-side
    public: {
      apiBase: '/api',
    },
  },
})
```

```ini [.env]
# This will override the value of apiSecret
NUXT_API_SECRET=api_secret_token
```

::

These variables are exposed to the rest of your application using the [`useRuntimeConfig()`](/docs/4.x/api/composables/use-runtime-config) composable.

```vue [app/pages/index.vue]
<script setup lang="ts">
const runtimeConfig = useRuntimeConfig()
</script>
```

:read-more{to="/docs/4.x/guide/going-further/runtime-config"}

## App Configuration

The `app.config.ts` file, located in the source directory (by default `app/`), is used to expose public variables that can be determined at build time. Contrary to the `runtimeConfig` option, these cannot be overridden using environment variables.

A minimal configuration file exports the `defineAppConfig` function containing an object with your configuration. The `defineAppConfig` helper is globally available without import.

```ts [app/app.config.ts]
export default defineAppConfig({
  title: 'Hello Nuxt',
  theme: {
    dark: true,
    colors: {
      primary: '#ff0000',
    },
  },
})
```

These variables are exposed to the rest of your application using the [`useAppConfig`](/docs/4.x/api/composables/use-app-config) composable.

```vue [app/pages/index.vue]
<script setup lang="ts">
const appConfig = useAppConfig()
</script>
```

:read-more{to="/docs/4.x/directory-structure/app/app-config"}

## `runtimeConfig` vs. `app.config`

As stated above, `runtimeConfig` and `app.config` are both used to expose variables to the rest of your application. To determine whether you should use one or the other, here are some guidelines:

- `runtimeConfig`: Private or public tokens that need to be specified after build using environment variables.
- `app.config`: Public tokens that are determined at build time, website configuration such as theme variant, title and any project config that are not sensitive.

| Feature                   | `runtimeConfig` | `app.config` |
|---------------------------|-----------------|--------------|
| Client Side               | Hydrated        | Bundled      |
| Environment Variables     | ✅ Yes           | ❌ No         |
| Reactive                  | ✅ Yes           | ✅ Yes        |
| Types support             | ✅ Partial       | ✅ Yes        |
| Configuration per Request | ❌ No            | ✅ Yes        |
| Hot Module Replacement    | ❌ No            | ✅ Yes        |
| Non primitive JS types    | ❌ No            | ✅ Yes        |

## External Configuration Files

Nuxt uses [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) file as the single source of truth for configurations and skips reading external configuration files. During the course of building your project, you may have a need to configure those. The following table highlights common configurations and, where applicable, how they can be configured with Nuxt.

| Name                              | Config File             | How To Configure                                                          |
|-----------------------------------|-------------------------|---------------------------------------------------------------------------|
| [Nitro](https://nitro.build)      | ~~`nitro.config.ts`~~   | Use [`nitro`](/docs/4.x/api/nuxt-config#nitro) key in `nuxt.config`       |
| [PostCSS](https://postcss.org)    | ~~`postcss.config.js`~~ | Use [`postcss`](/docs/4.x/api/nuxt-config#postcss) key in `nuxt.config`   |
| [Vite](https://vite.dev)          | ~~`vite.config.ts`~~    | Use [`vite`](/docs/4.x/api/nuxt-config#vite) key in `nuxt.config`         |
| [webpack](https://webpack.js.org) | ~~`webpack.config.ts`~~ | Use [`webpack`](/docs/4.x/api/nuxt-config#webpack-1) key in `nuxt.config` |

Here is a list of other common config files:

| Name                                         | Config File           | How To Configure                                                              |
|----------------------------------------------|-----------------------|-------------------------------------------------------------------------------|
| [TypeScript](https://www.typescriptlang.org) | `tsconfig.json`       | [More Info](/docs/4.x/directory-structure/tsconfig)                           |
| [ESLint](https://eslint.org)                 | `eslint.config.js`    | [More Info](https://eslint.org/docs/latest/use/configure/configuration-files) |
| [Prettier](https://prettier.io)              | `prettier.config.js`  | [More Info](https://prettier.io/docs/configuration.html)                      |
| [Stylelint](https://stylelint.io)            | `stylelint.config.js` | [More Info](https://stylelint.io/user-guide/configure/)                       |
| [TailwindCSS](https://tailwindcss.com)       | `tailwind.config.js`  | [More Info](https://tailwindcss.nuxtjs.org/tailwindcss/configuration/)        |
| [Vitest](https://vitest.dev)                 | `vitest.config.ts`    | [More Info](https://vitest.dev/config/)                                       |

## Vue Configuration

### With Vite

If you need to pass options to `@vitejs/plugin-vue` or `@vitejs/plugin-vue-jsx`, you can do this in your `nuxt.config` file.

- `vite.vue` for `@vitejs/plugin-vue`. Check [available options](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue).
- `vite.vueJsx` for `@vitejs/plugin-vue-jsx`. Check [available options](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  vite: {
    vue: {
      customElement: true,
    },
    vueJsx: {
      mergeProps: true,
    },
  },
})
```

:read-more{to="/docs/4.x/api/configuration/nuxt-config#vue"}

### With webpack

If you use webpack and need to configure `vue-loader`, you can do this using `webpack.loaders.vue` key inside your `nuxt.config` file. The available options are [defined here](https://github.com/vuejs/vue-loader/blob/main/src/index.ts#L32-L62).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  webpack: {
    loaders: {
      vue: {
        hotReload: true,
      },
    },
  },
})
```

:read-more{to="/docs/4.x/api/configuration/nuxt-config#loaders"}

### Enabling Experimental Vue Features

You may need to enable experimental features in Vue, such as `propsDestructure`. Nuxt provides an easy way to do that in `nuxt.config.ts`, no matter which builder you are using:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  vue: {
    propsDestructure: true,
  },
})
```

#### experimental `reactivityTransform` migration from Vue 3.4 and Nuxt 3.9

Since Nuxt 3.9 and Vue 3.4, `reactivityTransform` has been moved from Vue to Vue Macros which has a [Nuxt integration](https://vue-macros.dev/guide/nuxt-integration.html).

:read-more{to="/docs/4.x/api/configuration/nuxt-config#vue-1"}
</file>

<file path="docs/1.getting-started/04.views.md">
---
title: 'Views'
description: 'Nuxt provides several component layers to implement the user interface of your application.'
navigation.icon: i-lucide-panels-top-left
---

## `app.vue`

![The app.vue file is the entry point of your application](/assets/docs/getting-started/views/app.svg)

By default, Nuxt will treat this file as the **entrypoint** and render its content for every route of the application.

```vue [app/app.vue]
<template>
  <div>
    <h1>Welcome to the homepage</h1>
  </div>
</template>
```

::tip
If you are familiar with Vue, you might wonder where `main.js` is (the file that normally creates a Vue app). Nuxt does this behind the scene.
::

## Components

![Components are reusable pieces of UI](/assets/docs/getting-started/views/components.svg)

Most components are reusable pieces of the user interface, like buttons and menus. In Nuxt, you can create these components in the [`app/components/`](/docs/4.x/directory-structure/app/components) directory, and they will be automatically available across your application without having to explicitly import them.

::code-group

```vue [app/app.vue]
<template>
  <div>
    <h1>Welcome to the homepage</h1>
    <AppAlert>
      This is an auto-imported component.
    </AppAlert>
  </div>
</template>
```

```vue [app/components/AppAlert.vue]
<template>
  <span>
    <slot />
  </span>
</template>
```

::

## Pages

![Pages are views tied to a specific route](/assets/docs/getting-started/views/pages.svg)

Pages represent views for each specific route pattern. Every file in the [`app/pages/`](/docs/4.x/directory-structure/app/pages) directory represents a different route displaying its content.

To use pages, create an `app/pages/index.vue` file and add `<NuxtPage />` component to the [`app/app.vue`](/docs/4.x/directory-structure/app/app) (or remove `app/app.vue` for default entry). You can now create more pages and their corresponding routes by adding new files in the [`app/pages/`](/docs/4.x/directory-structure/app/pages) directory.

::code-group

```vue [app/pages/index.vue]
<template>
  <div>
    <h1>Welcome to the homepage</h1>
    <AppAlert>
      This is an auto-imported component
    </AppAlert>
  </div>
</template>
```

```vue [app/pages/about.vue]
<template>
  <section>
    <p>This page will be displayed at the /about route.</p>
  </section>
</template>
```

::

:read-more{title="Routing Section" to="/docs/4.x/getting-started/routing"}

## Layouts

![Layouts are wrapper around pages](/assets/docs/getting-started/views/layouts.svg)

Layouts are wrappers around pages that contain a common User Interface for several pages, such as header and footer displays. Layouts are Vue files using `<slot />` components to display the **page** content. The `app/layouts/default.vue` file will be used by default. Custom layouts can be set as part of your page metadata.

::note
If you only have a single layout in your application, we recommend using [`app/app.vue`](/docs/4.x/directory-structure/app/app) with [`<NuxtPage />`](/docs/4.x/api/components/nuxt-page) instead.
::

::code-group

```vue [app/app.vue]
<template>
  <div>
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
  </div>
</template>
```

```vue [app/layouts/default.vue]
<template>
  <div>
    <AppHeader />
    <slot />
    <AppFooter />
  </div>
</template>
```

```vue [app/pages/index.vue]
<template>
  <div>
    <h1>Welcome to the homepage</h1>
    <AppAlert>
      This is an auto-imported component
    </AppAlert>
  </div>
</template>
```

```vue [app/pages/about.vue]
<template>
  <section>
    <p>This page will be displayed at the /about route.</p>
  </section>
</template>
```

::

If you want to create more layouts and learn how to use them in your pages, find more information in the [Layouts section](/docs/4.x/directory-structure/app/layouts).

## Advanced: Extending the HTML Template

::note
If you only need to modify the `<head>`, you can refer to the [SEO and meta section](/docs/4.x/getting-started/seo-meta).
::

You can have full control over the HTML template by adding a Nitro plugin that registers a hook.
The callback function of the `render:html` hook allows you to mutate the HTML before it is sent to the client.

<!-- TODO: figure out how to use twoslash to inject types for a different context -->

```ts [server/plugins/extend-html.ts]
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook('render:html', (html, { event }) => {
    // This will be an object representation of the html template.
    console.log(html)
    html.head.push(`<meta name="description" content="My custom description" />`)
  })
  // You can also intercept the response here.
  nitroApp.hooks.hook('render:response', (response, { event }) => { console.log(response) })
})
```

:read-more{to="/docs/4.x/guide/going-further/hooks"}
</file>

<file path="docs/1.getting-started/05.assets.md">
---
title: 'Assets'
description: 'Nuxt offers two options for your assets.'
navigation.icon: i-lucide-image
---

Nuxt uses two directories to handle assets like stylesheets, fonts or images.

- The [`public/`](/docs/4.x/directory-structure/public) directory content is served at the server root as-is.
- The [`app/assets/`](/docs/4.x/directory-structure/app/assets) directory contains by convention every asset that you want the build tool (Vite or webpack) to process.

## Public Directory

The [`public/`](/docs/4.x/directory-structure/public) directory is used as a public server for static assets publicly available at a defined URL of your application.

You can get a file in the [`public/`](/docs/4.x/directory-structure/public) directory from your application's code or from a browser by the root URL `/`.

### Example

For example, referencing an image file in the `public/img/` directory, available at the static URL `/img/nuxt.png`:

```vue [app/app.vue]
<template>
  <img
    src="/img/nuxt.png"
    alt="Discover Nuxt"
  >
</template>
```

## Assets Directory

Nuxt uses [Vite](https://vite.dev/guide/assets) (default) or [webpack](https://webpack.js.org/guides/asset-management/) to build and bundle your application. The main function of these build tools is to process JavaScript files, but they can be extended through [plugins](https://vite.dev/plugins/) (for Vite) or [loaders](https://webpack.js.org/loaders/) (for webpack) to process other kinds of assets, like stylesheets, fonts or SVGs. This step transforms the original file, mainly for performance or caching purposes (such as stylesheet minification or browser cache invalidation).

By convention, Nuxt uses the [`app/assets/`](/docs/4.x/directory-structure/app/assets) directory to store these files but there is no auto-scan functionality for this directory, and you can use any other name for it.

In your application's code, you can reference a file located in the [`app/assets/`](/docs/4.x/directory-structure/app/assets) directory by using the `~/assets/` path.

### Example

For example, referencing an image file that will be processed if a build tool is configured to handle this file extension:

```vue [app/app.vue]
<template>
  <img
    src="~/assets/img/nuxt.png"
    alt="Discover Nuxt"
  >
</template>
```

::note
Nuxt won't serve files in the [`app/assets/`](/docs/4.x/directory-structure/app/assets) directory at a static URL like `/assets/my-file.png`. If you need a static URL, use the [`public/`](/docs/4.x/getting-started/assets#public-directory) directory.
::
</file>

<file path="docs/1.getting-started/06.styling.md">
---
title: 'Styling'
description: 'Learn how to style your Nuxt application.'
navigation.icon: i-lucide-palette
---

Nuxt is highly flexible when it comes to styling. Write your own styles, or reference local and external stylesheets.
You can use CSS preprocessors, CSS frameworks, UI libraries and Nuxt modules to style your application.

## Local Stylesheets

If you're writing local stylesheets, the natural place to put them is the [`app/assets/` directory](/docs/4.x/directory-structure/app/assets).

### Importing Within Components

You can import stylesheets in your pages, layouts and components directly.
You can use a JavaScript import, or a CSS [`@import` statement](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/At-rules/@import).

```vue [app/pages/index.vue]
<script>
// Use a static import for server-side compatibility
import '~/assets/css/first.css'

// Caution: Dynamic imports are not server-side compatible
import('~/assets/css/first.css')
</script>

<style>
@import url("~/assets/css/second.css");
</style>
```

::tip
The stylesheets will be inlined in the HTML rendered by Nuxt.
::

### The CSS Property

You can also use the `css` property in the Nuxt configuration.
The natural place for your stylesheets is the [`app/assets/` directory](/docs/4.x/directory-structure/app/assets). You can then reference its path and Nuxt will include it to all the pages of your application.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['~/assets/css/main.css'],
})
```

::tip
The stylesheets will be inlined in the HTML rendered by Nuxt, injected globally and present in all pages.
::

### Working With Fonts

Place your local fonts files in your `public/` directory, for example in `public/fonts`. You can then reference them in your stylesheets using `url()`.

```css [assets/css/main.css]
@font-face {
  font-family: 'FarAwayGalaxy';
  src: url('/fonts/FarAwayGalaxy.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
```

Then reference your fonts by name in your stylesheets, pages or components:

```vue
<style>
h1 {
  font-family: 'FarAwayGalaxy', sans-serif;
}
</style>
```

### Stylesheets Distributed Through NPM

You can also reference stylesheets that are distributed through npm. Let's use the popular `animate.css` library as an example.

::code-group{sync="pm"}

```bash [npm]
npm install animate.css
```

```bash [yarn]
yarn add animate.css
```

```bash [pnpm]
pnpm install animate.css
```

```bash [bun]
bun install animate.css
```

::

Then you can reference it directly in your pages, layouts and components:

```vue [app/app.vue]
<script>
import 'animate.css'
</script>

<style>
@import url("animate.css");
</style>
```

The package can also be referenced as a string in the css property of your Nuxt configuration.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['animate.css'],
})
```

## External Stylesheets

You can include external stylesheets in your application by adding a link element in the head section of your nuxt.config file. You can achieve this result using different methods. Note that local stylesheets can also be included this way.

You can manipulate the head with the [`app.head`](/docs/4.x/api/nuxt-config#head) property of your Nuxt configuration:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    head: {
      link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }],
    },
  },
})
```

### Dynamically Adding Stylesheets

You can use the useHead composable to dynamically set a value in your head in your code.

:read-more{to="/docs/4.x/api/composables/use-head"}

```ts twoslash
useHead({
  link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }],
})
```

Nuxt uses `unhead` under the hood, and you can refer to [its full documentation](https://unhead.unjs.io).

### Modifying The Rendered Head With A Nitro Plugin

If you need more advanced control, you can intercept the rendered html with a hook and modify the head programmatically.

Create a plugin in `~/server/plugins/my-plugin.ts` like this:

<!-- TODO: figure out how to use twoslash to inject types for a different context -->

```ts [server/plugins/my-plugin.ts]
export default defineNitroPlugin((nitro) => {
  nitro.hooks.hook('render:html', (html) => {
    html.head.push('<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">')
  })
})
```

External stylesheets are render-blocking resources: they must be loaded and processed before the browser renders the page. Web pages that contain unnecessarily large styles take longer to render. You can read more about it on [web.dev](https://web.dev/articles/defer-non-critical-css).

## Using Preprocessors

To use a preprocessor like SCSS, Sass, Less or Stylus, install it first.

::code-group

```bash [Sass & SCSS]
npm install -D sass
```

```bash [Less]
npm install -D less
```

```bash [Stylus]
npm install -D stylus
```

::

The natural place to write your stylesheets is the `app/assets` directory.
You can then import your source files in your `app.vue` (or layouts files) using your preprocessor's syntax.

```vue [app/pages/app.vue]
<style lang="scss">
@use "~/assets/scss/main.scss";
</style>
```

Alternatively, you can use the `css` property of your Nuxt configuration.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  css: ['~/assets/scss/main.scss'],
})
```

::tip
In both cases, the compiled stylesheets will be inlined in the HTML rendered by Nuxt.
::

If you need to inject code in pre-processed files, like a [Sass partial](https://sass-lang.com/documentation/at-rules/use/#partials) with color variables, you can do so with the Vite [preprocessors options](https://vite.dev/config/shared-options#css-preprocessoroptions).

Create some partials in your `app/assets` directory:

::code-group{sync="preprocessor"}

```scss [assets/_colors.scss]
$primary: #49240F;
$secondary: #E4A79D;
```

```sass [assets/_colors.sass]
$primary: #49240F
$secondary: #E4A79D
```

::

Then in your `nuxt.config` :

::code-group

```ts twoslash [SCSS]
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: '@use "~/assets/_colors.scss" as *;',
        },
      },
    },
  },
})
```

```ts twoslash [SASS]
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorOptions: {
        sass: {
          additionalData: '@use "~/assets/_colors.sass" as *\n',
        },
      },
    },
  },
})
```

::

Nuxt uses Vite by default. If you wish to use webpack instead, refer to each preprocessor loader [documentation](https://webpack.js.org/loaders/sass-loader/).

### Preprocessor Workers (Experimental)

Vite has made available an [experimental option](https://vite.dev/config/shared-options#css-preprocessormaxworkers) which can speed up using preprocessors.

You can enable this in your `nuxt.config`:

```ts
export default defineNuxtConfig({
  vite: {
    css: {
      preprocessorMaxWorkers: true, // number of CPUs minus 1
    },
  },
})
```

::note
This is an experimental option and you should refer to the Vite documentation and [provide feedback](https://github.com/vitejs/vite/discussions/15835).
::

## Single File Components (SFC) Styling

One of the best things about Vue and SFC is how great it is at naturally dealing with styling. You can directly write CSS or preprocessor code in the style block of your components file, therefore you will have fantastic developer experience without having to use something like CSS-in-JS. However if you wish to use CSS-in-JS, you can find 3rd party libraries and modules that support it, such as [pinceau](https://github.com/Tahul/pinceau).

You can refer to the [Vue docs](https://vuejs.org/api/sfc-css-features) for a comprehensive reference about styling components in SFC.

### Class And Style Bindings

You can leverage Vue SFC features to style your components with class and style attributes.

::code-group

```vue [Ref and Reactive]
<script setup lang="ts">
const isActive = ref(true)
const hasError = ref(false)
const classObject = reactive({
  'active': true,
  'text-danger': false,
})
</script>

<template>
  <div
    class="static"
    :class="{ 'active': isActive, 'text-danger': hasError }"
  />
  <div :class="classObject" />
</template>
```

```vue [Computed]
<script setup lang="ts">
const isActive = ref(true)
const error = ref(null)

const classObject = computed(() => ({
  'active': isActive.value && !error.value,
  'text-danger': error.value && error.value.type === 'fatal',
}))
</script>

<template>
  <div :class="classObject" />
</template>
```

```vue [Array]
<script setup lang="ts">
const isActive = ref(true)
const errorClass = ref('text-danger')
</script>

<template>
  <div :class="[{ active: isActive }, errorClass]" />
</template>
```

```vue [Style]
<script setup lang="ts">
const activeColor = ref('red')
const fontSize = ref(30)
const styleObject = reactive({ color: 'red', fontSize: '13px' })
</script>

<template>
  <div :style="{ color: activeColor, fontSize: fontSize + 'px' }" />
  <div :style="[baseStyles, overridingStyles]" />
  <div :style="styleObject" />
</template>
```

::

Refer to the [Vue docs](https://vuejs.org/guide/essentials/class-and-style) for more information.

### Dynamic Styles With `v-bind`

You can reference JavaScript variable and expression within your style blocks with the v-bind function.
The binding will be dynamic, meaning that if the variable value changes, the style will be updated.

```vue
<script setup lang="ts">
const color = ref('red')
</script>

<template>
  <div class="text">
    hello
  </div>
</template>

<style>
.text {
  color: v-bind(color);
}
</style>
```

### Scoped Styles

The scoped attribute allows you to style components in isolation. The styles declared with this attribute will only apply to this component.

```vue
<template>
  <div class="example">
    hi
  </div>
</template>

<style scoped>
.example {
  color: red;
}
</style>
```

### CSS Modules

You can use [CSS Modules](https://github.com/css-modules/css-modules) with the module attribute. Access it with the injected `$style` variable.

```vue
<template>
  <p :class="$style.red">
    This should be red
  </p>
</template>

<style module>
.red {
  color: red;
}
</style>
```

### Preprocessors Support

SFC style blocks support preprocessor syntax. Vite comes with built-in support for .scss, .sass, .less, .styl and .stylus files without configuration. You just need to install them first, and they will be available directly in SFC with the lang attribute.

::code-group

```vue [SCSS]
<style lang="scss">
  /* Write scss here */
</style>
```

```vue [Sass]
<style lang="sass">
  /* Write sass here */
</style>
```

```vue [LESS]
<style lang="less">
  /* Write less here */
</style>
```

```vue [Stylus]
<style lang="stylus">
  /* Write stylus here */
</style>
```

::

You can refer to the [Vite CSS docs](https://vite.dev/guide/features#css) and the [@vitejs/plugin-vue docs](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue).
For webpack users, refer to the [vue loader docs](https://vue-loader.vuejs.org).

## Using PostCSS

Nuxt comes with postcss built-in. You can configure it in your `nuxt.config` file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  postcss: {
    plugins: {
      'postcss-nested': {},
      'postcss-custom-media': {},
    },
  },
})
```

For proper syntax highlighting in SFC, you can use the postcss lang attribute.

```vue
<style lang="postcss">
  /* Write postcss here */
</style>
```

By default, Nuxt comes with the following plugins already pre-configured:

- [postcss-import](https://github.com/postcss/postcss-import): Improves the `@import` rule
- [postcss-url](https://github.com/postcss/postcss-url): Transforms `url()` statements
- [autoprefixer](https://github.com/postcss/autoprefixer): Automatically adds vendor prefixes
- [cssnano](https://cssnano.github.io/cssnano/): Minification and purge

## Leveraging Layouts For Multiple Styles

If you need to style different parts of your application completely differently, you can use layouts.
Use different styles for different layouts.

```vue
<template>
  <div class="default-layout">
    <h1>Default Layout</h1>
    <slot />
  </div>
</template>

<style>
.default-layout {
  color: red;
}
</style>
```

:read-more{to="/docs/4.x/directory-structure/app/layouts"}

## Third Party Libraries And Modules

Nuxt isn't opinionated when it comes to styling and provides you with a wide variety of options. You can use any styling tool that you want, such as popular libraries like [UnoCSS](https://unocss.dev) or [Tailwind CSS](https://tailwindcss.com).

The community and the Nuxt team have developed plenty of Nuxt modules to make the integration easier.
You can discover them on the [modules section](/modules) of the website.
Here are a few modules to help you get started:

- [UnoCSS](/modules/unocss): Instant on-demand atomic CSS engine
- [Tailwind CSS](/modules/tailwindcss): Utility-first CSS framework
- [Fontaine](https://github.com/nuxt-modules/fontaine): Font metric fallback
- [Pinceau](https://github.com/Tahul/pinceau): Adaptable styling framework
- [Nuxt UI](https://ui.nuxt.com): A UI Library for Modern Web Apps
- [Panda CSS](https://panda-css.com/docs/installation/nuxt): CSS-in-JS engine that generates atomic CSS at build time

Nuxt modules provide you with a good developer experience out of the box, but remember that if your favorite tool doesn't have a module, it doesn't mean that you can't use it with Nuxt! You can configure it yourself for your own project. Depending on the tool, you might need to use a [Nuxt plugin](/docs/4.x/directory-structure/app/plugins) and/or [make your own module](/docs/4.x/guide/modules). Share them with the [community](/modules) if you do!

### Easily Load Webfonts

You can use [the Nuxt Google Fonts module](https://github.com/nuxt-modules/google-fonts) to load Google Fonts.

If you are using [UnoCSS](https://unocss.dev/integrations/nuxt), note that it comes with a [web fonts presets](https://unocss.dev/presets/web-fonts) to conveniently load fonts from common providers, including Google Fonts and more.

## Advanced

### Transitions

Nuxt comes with the same `<Transition>` element that Vue has, and also has support for the experimental [View Transitions API](/docs/4.x/getting-started/transitions#view-transitions-api-experimental).

:read-more{to="/docs/4.x/getting-started/transitions"}

### Font Advanced Optimization

We would recommend using [Fontaine](https://github.com/nuxt-modules/fontaine) to reduce your [CLS](https://web.dev/articles/cls). If you need something more advanced, consider creating a Nuxt module to extend the build process or the Nuxt runtime.

::tip
Always remember to take advantage of the various tools and techniques available in the Web ecosystem at large to make styling your application easier and more efficient. Whether you're using native CSS, a preprocessor, postcss, a UI library or a module, Nuxt has got you covered. Happy styling!
::

### LCP Advanced Optimizations

You can do the following to speed-up the download of your global CSS files:

- Use a CDN so the files are physically closer to your users
- Compress your assets, ideally using Brotli
- Use HTTP2/HTTP3 for delivery
- Host your assets on the same domain (do not use a different subdomain)

Most of these things should be done for you automatically if you're using modern platforms like Cloudflare, Netlify or Vercel.
You can find an LCP optimization guide on [web.dev](https://web.dev/articles/optimize-lcp).

If all of your CSS is inlined by Nuxt, you can (experimentally) completely stop external CSS files from being referenced in your rendered HTML.
You can achieve that with a hook, that you can place in a module, or in your Nuxt configuration file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    'build:manifest': (manifest) => {
      // find the app entry, css list
      const css = Object.values(manifest).find(options => options.isEntry)?.css
      if (css) {
        // start from the end of the array and go to the beginning
        for (let i = css.length - 1; i >= 0; i--) {
          // if it starts with 'entry', remove it from the list
          if (css[i].startsWith('entry')) {
            css.splice(i, 1)
          }
        }
      }
    },
  },
})
```
</file>

<file path="docs/1.getting-started/07.routing.md">
---
title: 'Routing'
description: Nuxt file-system routing creates a route for every file in the pages/ directory.
navigation.icon: i-lucide-milestone
---

One core feature of Nuxt is the file system router. Every Vue file inside the [`app/pages/`](/docs/4.x/directory-structure/app/pages) directory creates a corresponding URL (or route) that displays the contents of the file. By using dynamic imports for each page, Nuxt leverages code-splitting to ship the minimum amount of JavaScript for the requested route.

## Pages

Nuxt routing is based on [vue-router](https://router.vuejs.org) and generates the routes from every component created in the [`app/pages/` directory](/docs/4.x/directory-structure/app/pages), based on their filename.

This file system routing uses naming conventions to create dynamic and nested routes:

::code-group

```bash [Directory Structure]
-| pages/
---| about.vue
---| index.vue
---| posts/
-----| [id].vue
```

```json [Generated Router File]
{
  "routes": [
    {
      "path": "/about",
      "component": "pages/about.vue"
    },
    {
      "path": "/",
      "component": "pages/index.vue"
    },
    {
      "path": "/posts/:id",
      "component": "pages/posts/[id].vue"
    }
  ]
}
```

::

:read-more{to="/docs/4.x/directory-structure/app/pages"}

## Navigation

The [`<NuxtLink>`](/docs/4.x/api/components/nuxt-link) component links pages between them. It renders an `<a>` tag with the `href` attribute set to the route of the page. Once the application is hydrated, page transitions are performed in JavaScript by updating the browser URL. This prevents full-page refreshes and allows for animated transitions.

When a [`<NuxtLink>`](/docs/4.x/api/components/nuxt-link) enters the viewport on the client side, Nuxt will automatically prefetch components and payload (generated pages) of the linked pages ahead of time, resulting in faster navigation.

```vue [app/pages/index.vue]
<template>
  <header>
    <nav>
      <ul>
        <li><NuxtLink to="/about">About</NuxtLink></li>
        <li><NuxtLink to="/posts/1">Post 1</NuxtLink></li>
        <li><NuxtLink to="/posts/2">Post 2</NuxtLink></li>
      </ul>
    </nav>
  </header>
</template>
```

:read-more{to="/docs/4.x/api/components/nuxt-link"}

## Route Parameters

The [`useRoute()`](/docs/4.x/api/composables/use-route) composable can be used in a `<script setup>` block or a `setup()` method of a Vue component to access the current route details.

```vue twoslash [pages/posts/[id\\].vue]
<script setup lang="ts">
const route = useRoute()

// When accessing /posts/1, route.params.id will be 1
console.log(route.params.id)
</script>
```

:read-more{to="/docs/4.x/api/composables/use-route"}

## Route Middleware

Nuxt provides a customizable route middleware framework you can use throughout your application, ideal for extracting code that you want to run before navigating to a particular route.

::note
Route middleware runs within the Vue part of your Nuxt app. Despite the similar name, they are completely different from server middleware, which are run in the Nitro server part of your app.
::

::important
Route middleware does **not** run for server routes (e.g. `/api/*`) or other server requests. To apply middleware to these requests, use [server middleware](/docs/4.x/directory-structure/server#server-middleware) instead.
::

There are three kinds of route middleware:

1. Anonymous (or inline) route middleware, which are defined directly in the pages where they are used.
2. Named route middleware, which are placed in the [`app/middleware/`](/docs/4.x/directory-structure/app/middleware) directory and will be automatically loaded via asynchronous import when used on a page. (**Note**: The route middleware name is normalized to kebab-case, so `someMiddleware` becomes `some-middleware`.)
3. Global route middleware, which are placed in the [`app/middleware/`](/docs/4.x/directory-structure/app/middleware) directory (with a `.global` suffix) and will be automatically run on every route change.

Example of an `auth` middleware protecting the `/dashboard` page:

::code-group

```ts twoslash [middleware/auth.ts]
function isAuthenticated (): boolean { return false }
// ---cut---
export default defineNuxtRouteMiddleware((to, from) => {
  // isAuthenticated() is an example method verifying if a user is authenticated
  if (isAuthenticated() === false) {
    return navigateTo('/login')
  }
})
```

```vue twoslash [pages/dashboard.vue]
<script setup lang="ts">
definePageMeta({
  middleware: 'auth',
})
</script>

<template>
  <h1>Welcome to your dashboard</h1>
</template>
```

::

:read-more{to="/docs/4.x/directory-structure/app/middleware"}

## Route Validation

Nuxt offers route validation via the `validate` property in [`definePageMeta()`](/docs/4.x/api/utils/define-page-meta) in each page you wish to validate.

The `validate` property accepts the `route` as an argument. You can return a boolean value to determine whether or not this is a valid route to be rendered with this page. If you return `false`, this will cause a 404 error. You can also directly return an object with `status`/`statusText` to customize the error returned.

If you have a more complex use case, then you can use anonymous route middleware instead.

```vue twoslash [pages/posts/[id\\].vue]
<script setup lang="ts">
definePageMeta({
  validate (route) {
    // Check if the id is made up of digits
    return typeof route.params.id === 'string' && /^\d+$/.test(route.params.id)
  },
})
</script>
```

:read-more{to="/docs/4.x/api/utils/define-page-meta"}
</file>

<file path="docs/1.getting-started/08.seo-meta.md">
---
title: SEO and Meta
description: Improve your Nuxt app's SEO with powerful head config, composables and components.
navigation.icon: i-lucide-file-search
---

Nuxt head tag management is powered by [Unhead](https://unhead.unjs.io). It provides sensible defaults, several powerful composables
and numerous configuration options to manage your app's head and SEO meta tags.

## Nuxt Config

Providing an [`app.head`](/docs/4.x/api/nuxt-config#head) property in your [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) allows you to statically customize the head for your entire app.

::important
This method does not allow you to provide reactive data. We recommend using `useHead()` in `app.vue`.
::

It's good practice to set tags here that won't change such as your site title default, language and favicon.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    head: {
      title: 'Nuxt', // default fallback title
      htmlAttrs: {
        lang: 'en',
      },
      link: [
        { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' },
      ],
    },
  },
})
```

You can also provide any of the keys listed below in [Types](/docs/4.x/getting-started/seo-meta#types).

### Defaults Tags

Some tags are provided by Nuxt by default to ensure your website works well out of the box.

- `viewport`: `width=device-width, initial-scale=1`
- `charset`: `utf-8`

While most sites won't need to override these defaults, you can update them using the keyed shortcuts.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    head: {
      // update Nuxt defaults
      charset: 'utf-16',
      viewport: 'width=device-width, initial-scale=1, maximum-scale=1',
    },
  },
})
```

## `useHead`

The [`useHead`](/docs/4.x/api/composables/use-head) composable function supports reactive input, allowing you to manage your head tags programmatically.

```vue twoslash [app/app.vue]
<script setup lang="ts">
useHead({
  title: 'My App',
  meta: [
    { name: 'description', content: 'My amazing site.' },
  ],
  bodyAttrs: {
    class: 'test',
  },
  script: [{ innerHTML: 'console.log(\'Hello world\')' }],
})
</script>
```

We recommend taking a look at the [`useHead`](/docs/4.x/api/composables/use-head) and [`useHeadSafe`](/docs/4.x/api/composables/use-head-safe) composables.

## `useSeoMeta`

The [`useSeoMeta`](/docs/4.x/api/composables/use-seo-meta) composable lets you define your site's SEO meta tags as an object with full type safety.

This helps you avoid typos and common mistakes, such as using `name` instead of `property`.

```vue twoslash [app/app.vue]
<script setup lang="ts">
useSeoMeta({
  title: 'My Amazing Site',
  ogTitle: 'My Amazing Site',
  description: 'This is my amazing site, let me tell you all about it.',
  ogDescription: 'This is my amazing site, let me tell you all about it.',
  ogImage: 'https://example.com/image.png',
  twitterCard: 'summary_large_image',
})
</script>
```

:read-more{to="/docs/4.x/api/composables/use-seo-meta"}

## Components

While using [`useHead`](/docs/4.x/api/composables/use-head) is recommended in all cases, you may have a personal preference for defining your head tags in your template using components.

Nuxt provides the following components for this purpose: `<Title>`, `<Base>`, `<NoScript>`, `<Style>`, `<Meta>`, `<Link>`, `<Body>`, `<Html>` and `<Head>`. Note
the capitalization of these components ensuring we don't use invalid native HTML tags.

`<Head>` and `<Body>` can accept nested meta tags (for aesthetic reasons) but this does not affect _where_ the nested meta tags are rendered in the final HTML.

<!-- @case-police-ignore html -->

```vue [app/app.vue]
<script setup lang="ts">
const title = ref('Hello World')
</script>

<template>
  <div>
    <Head>
      <Title>{{ title }}</Title>
      <Meta
        name="description"
        :content="title"
      />
      <Style>
        body { background-color: green; }
      </Style>
    </Head>

    <h1>{{ title }}</h1>
  </div>
</template>
```

It's suggested to wrap your components in either a `<Head>` or `<Html>` components as tags will be deduped more intuitively.

::warning
If you need to duplicate tags across client-server boundaries, apply a `key` attribute on the `<Head>` component.
::

## Types

Below are the non-reactive types used for [`useHead`](/docs/4.x/api/composables/use-head), [`app.head`](/docs/4.x/api/nuxt-config#head) and components.

```ts
interface MetaObject {
  title?: string
  titleTemplate?: string | ((title?: string) => string)
  templateParams?: Record<string, string | Record<string, string>>
  base?: Base
  link?: Link[]
  meta?: Meta[]
  style?: Style[]
  script?: Script[]
  noscript?: Noscript[]
  htmlAttrs?: HtmlAttributes
  bodyAttrs?: BodyAttributes
}
```

See [@unhead/vue](https://github.com/unjs/unhead/blob/main/packages/vue/src/types/schema.ts) for more detailed types.

## Features

### Reactivity

Reactivity is supported on all properties, by providing a computed value, a getter, or a reactive object.

::code-group

  ```vue twoslash [useHead]
  <script setup lang="ts">
  const description = ref('My amazing site.')

  useHead({
    meta: [
      { name: 'description', content: description },
    ],
  })
  </script>
  ```

  ```vue twoslash [useSeoMeta]
  <script setup lang="ts">
  const description = ref('My amazing site.')

  useSeoMeta({
    description,
  })
  </script>
  ```

  ```vue [app/Components]
  <script setup lang="ts">
  const description = ref('My amazing site.')
  </script>

  <template>
    <div>
      <Meta
        name="description"
        :content="description"
      />
    </div>
  </template>
  ```

::

### Title Template

You can use the `titleTemplate` option to provide a dynamic template for customizing the title of your site. For example, you could add the name of your site to the title of every page.

The `titleTemplate` can either be a string, where `%s` is replaced with the title, or a function.

If you want to use a function (for full control), then this cannot be set in your `nuxt.config`. It is recommended instead to set it within your `app.vue` file where it will apply to all pages on your site:

::code-group

  ```vue twoslash [useHead]
  <script setup lang="ts">
  useHead({
    titleTemplate: (titleChunk) => {
      return titleChunk ? `${titleChunk} - Site Title` : 'Site Title'
    },
  })
  </script>
  ```

::

Now, if you set the title to `My Page` with [`useHead`](/docs/4.x/api/composables/use-head) on another page of your site, the title would appear as 'My Page - Site Title' in the browser tab. You could also pass `null` to default to 'Site Title'.

### Template Params

You can use `templateParams` to provide additional placeholders in your `titleTemplate` besides the default `%s`. This allows for more dynamic title generation.

::code-group

  ```vue twoslash [useHead]
  <script setup lang="ts">
  useHead({
    titleTemplate: (titleChunk) => {
      return titleChunk ? `${titleChunk} %separator %siteName` : '%siteName'
    },
    templateParams: {
      siteName: 'Site Title',
      separator: '-',
    },
  })
  </script>
  ```

::

### Body Tags

You can use the `tagPosition: 'bodyClose'` option on applicable tags to append them to the end of the `<body>` tag.

For example:

```vue twoslash
<script setup lang="ts">
useHead({
  script: [
    {
      src: 'https://third-party-script.com',
      // valid options are: 'head' | 'bodyClose' | 'bodyOpen'
      tagPosition: 'bodyClose',
    },
  ],
})
</script>
```

## Examples

### With `definePageMeta`

Within your [`app/pages/` directory](/docs/4.x/directory-structure/app/pages), you can use `definePageMeta` along with [`useHead`](/docs/4.x/api/composables/use-head) to set metadata based on the current route.

For example, you can first set the current page title (this is extracted at build time via a macro, so it can't be set dynamically):

```vue twoslash [pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  title: 'Some Page',
})
</script>
```

And then in your layout file, you might use the route's metadata you have previously set:

```vue twoslash [layouts/default.vue]
<script setup lang="ts">
const route = useRoute()

useHead({
  meta: [{ property: 'og:title', content: `App Name - ${route.meta.title}` }],
})
</script>
```

:link-example{to="/docs/4.x/examples/features/meta-tags"}

:read-more{to="/docs/4.x/directory-structure/app/pages/#page-metadata"}

### Dynamic Title

In the example below, `titleTemplate` is set either as a string with the `%s` placeholder or as a `function`, which allows greater flexibility in setting the page title dynamically for each route of your Nuxt app:

```vue twoslash [app/app.vue]
<script setup lang="ts">
useHead({
  // as a string,
  // where `%s` is replaced with the title
  titleTemplate: '%s - Site Title',
})
</script>
```

```vue twoslash [app/app.vue]
<script setup lang="ts">
useHead({
  // or as a function
  titleTemplate: (productCategory) => {
    return productCategory
      ? `${productCategory} - Site Title`
      : 'Site Title'
  },
})
</script>
```

`nuxt.config` is also used as an alternative way of setting the page title. However, `nuxt.config` does not allow the page title to be dynamic. Therefore, it is recommended to use `titleTemplate` in the `app.vue` file to add a dynamic title, which is then applied to all routes of your Nuxt app.

### External CSS

The example below shows how you might enable Google Fonts using either the `link` property of the [`useHead`](/docs/4.x/api/composables/use-head) composable or using the `<Link>` component:

::code-group

  ```vue twoslash [useHead]
  <script setup lang="ts">
  useHead({
    link: [
      {
        rel: 'preconnect',
        href: 'https://fonts.googleapis.com',
      },
      {
        rel: 'stylesheet',
        href: 'https://fonts.googleapis.com/css2?family=Roboto&display=swap',
        crossorigin: '',
      },
    ],
  })
  </script>
  ```

  ```vue [app/Components]
  <template>
    <div>
      <Link
        rel="preconnect"
        href="https://fonts.googleapis.com"
      />
      <Link
        rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Roboto&display=swap"
        crossorigin=""
      />
    </div>
  </template>
  ```

::
</file>

<file path="docs/1.getting-started/09.transitions.md">
---
title: 'Transitions'
description: Apply transitions between pages and layouts with Vue or native browser View Transitions.
navigation.icon: i-lucide-toggle-right
---

::note
Nuxt leverages Vue's [`<Transition>`](https://vuejs.org/guide/built-ins/transition#the-transition-component) component to apply transitions between pages and layouts.
::

## Page Transitions

You can enable page transitions to apply an automatic transition for all your [pages](/docs/4.x/directory-structure/app/pages).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    pageTransition: { name: 'page', mode: 'out-in' },
  },
})
```

::note
If you are changing layouts as well as page, the page transition you set here will not run. Instead, you should set a [layout transition](/docs/4.x/getting-started/transitions#layout-transitions).
::

To start adding transition between your pages, add the following CSS to your [`app.vue`](/docs/4.x/directory-structure/app/app):

::code-group

```vue [app/app.vue]
<template>
  <NuxtPage />
</template>

<style>
.page-enter-active,
.page-leave-active {
  transition: all 0.4s;
}
.page-enter-from,
.page-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>
```

```vue [app/pages/index.vue]
<template>
  <div>
    <h1>Home page</h1>
    <NuxtLink to="/about">About page</NuxtLink>
  </div>
</template>
```

```vue [app/pages/about.vue]
<template>
  <div>
    <h1>About page</h1>
    <NuxtLink to="/">Home page</NuxtLink>
  </div>
</template>
```

::

This produces the following result when navigating between pages:

<video controls class="rounded" poster="https://res.cloudinary.com/nuxt/video/upload/v1665061349/nuxt3/nuxt3-page-transitions_umwvmh.jpg">
  <source src="https://res.cloudinary.com/nuxt/video/upload/v1665061349/nuxt3/nuxt3-page-transitions_umwvmh.mp4" type="video/mp4">
</video>

To set a different transition for a page, set the `pageTransition` key in [`definePageMeta`](/docs/4.x/api/utils/define-page-meta) of the page:

::code-group

```vue twoslash [pages/about.vue]
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'rotate',
  },
})
</script>
```

```vue [app/app.vue]
<template>
  <NuxtPage />
</template>

<style>
/* ... */
.rotate-enter-active,
.rotate-leave-active {
  transition: all 0.4s;
}
.rotate-enter-from,
.rotate-leave-to {
  opacity: 0;
  transform: rotate3d(1, 1, 1, 15deg);
}
</style>
```

::

Moving to the about page will add the 3d rotation effect:

<video controls class="rounded" poster="https://res.cloudinary.com/nuxt/video/upload/v1665063233/nuxt3/nuxt3-page-transitions-cutom.jpg">
  <source src="https://res.cloudinary.com/nuxt/video/upload/v1665063233/nuxt3/nuxt3-page-transitions-cutom.mp4" type="video/mp4">
</video>

## Layout Transitions

You can enable layout transitions to apply an automatic transition for all your [layouts](/docs/4.x/directory-structure/app/layouts).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    layoutTransition: { name: 'layout', mode: 'out-in' },
  },
})
```

To start adding transition between your pages and layouts, add the following CSS to your [`app.vue`](/docs/4.x/directory-structure/app/app):

::code-group

```vue [app/app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>

<style>
.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}
.layout-enter-from,
.layout-leave-to {
  filter: grayscale(1);
}
</style>
```

```vue [app/layouts/default.vue]
<template>
  <div>
    <pre>default layout</pre>
    <slot />
  </div>
</template>

<style scoped>
div {
  background-color: lightgreen;
}
</style>
```

```vue [app/layouts/orange.vue]
<template>
  <div>
    <pre>orange layout</pre>
    <slot />
  </div>
</template>

<style scoped>
div {
  background-color: #eebb90;
  padding: 20px;
  height: 100vh;
}
</style>
```

```vue [app/pages/index.vue]
<template>
  <div>
    <h1>Home page</h1>
    <NuxtLink to="/about">About page</NuxtLink>
  </div>
</template>
```

```vue [app/pages/about.vue]
<script setup lang="ts">
definePageMeta({
  layout: 'orange',
})
</script>

<template>
  <div>
    <h1>About page</h1>
    <NuxtLink to="/">Home page</NuxtLink>
  </div>
</template>
```

::

This produces the following result when navigating between pages:

<video controls class="rounded" poster="https://res.cloudinary.com/nuxt/video/upload/v1665065289/nuxt3/nuxt3-layouts-transitions_c9hwlx.jpg">
  <source src="https://res.cloudinary.com/nuxt/video/upload/v1665065289/nuxt3/nuxt3-layouts-transitions_c9hwlx.mp4" type="video/mp4">
</video>

Similar to `pageTransition`, you can apply a custom `layoutTransition` to the page component using `definePageMeta`:

```vue twoslash [pages/about.vue]
<script setup lang="ts">
definePageMeta({
  layout: 'orange',
  layoutTransition: {
    name: 'slide-in',
  },
})
</script>
```

## Global Settings

You can customize these default transition names globally using `nuxt.config`.

Both `pageTransition` and `layoutTransition` keys accept [`TransitionProps`](https://vuejs.org/api/built-in-components#transition) as JSON serializable values where you can pass the `name`, `mode` and other valid transition-props of the custom CSS transition.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    pageTransition: {
      name: 'fade',
      mode: 'out-in', // default
    },
    layoutTransition: {
      name: 'slide',
      mode: 'out-in', // default
    },
  },
})
```

::warning
If you change the `name` property, you also have to rename the CSS classes accordingly.
::

To override the global transition property, use the `definePageMeta` to define page or layout transitions for a single Nuxt page and override any page or layout transitions that are defined globally in `nuxt.config` file.

```vue twoslash [pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'bounce',
    mode: 'out-in', // default
  },
})
</script>
```

## Disable Transitions

`pageTransition` and `layoutTransition` can be disabled for a specific route:

```vue twoslash [pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  pageTransition: false,
  layoutTransition: false,
})
</script>
```

Or globally in the `nuxt.config`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    pageTransition: false,
    layoutTransition: false,
  },
})
```

## JavaScript Hooks

For advanced use-cases, you can use JavaScript hooks to create highly dynamic and custom transitions for your Nuxt pages.

This way presents perfect use-cases for JavaScript animation libraries such as [GSAP](https://gsap.com).

```vue twoslash [pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'custom-flip',
    mode: 'out-in',
    onBeforeEnter: (el) => {
      console.log('Before enter...')
    },
    onEnter: (el, done) => {},
    onAfterEnter: (el) => {},
  },
})
</script>
```

::tip
Learn more about additional [JavaScript hooks](https://vuejs.org/guide/built-ins/transition#javascript-hooks) available in the `Transition` component.
::

## Dynamic Transitions

To apply dynamic transitions using conditional logic, you can leverage inline [middleware](/docs/4.x/directory-structure/app/middleware) to assign a different transition name to `to.meta.pageTransition`.

::code-group

```vue twoslash [pages/[id\\].vue]
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'slide-right',
    mode: 'out-in',
  },
  middleware (to, from) {
    if (to.meta.pageTransition && typeof to.meta.pageTransition !== 'boolean') {
      to.meta.pageTransition.name = +to.params.id! > +from.params.id! ? 'slide-left' : 'slide-right'
    }
  },
})
</script>

<template>
  <h1>#{{ $route.params.id }}</h1>
</template>

<style>
.slide-left-enter-active,
.slide-left-leave-active,
.slide-right-enter-active,
.slide-right-leave-active {
  transition: all 0.2s;
}
.slide-left-enter-from {
  opacity: 0;
  transform: translate(50px, 0);
}
.slide-left-leave-to {
  opacity: 0;
  transform: translate(-50px, 0);
}
.slide-right-enter-from {
  opacity: 0;
  transform: translate(-50px, 0);
}
.slide-right-leave-to {
  opacity: 0;
  transform: translate(50px, 0);
}
</style>
```

```vue [app/layouts/default.vue]
<script setup lang="ts">
const route = useRoute()
const id = computed(() => Number(route.params.id || 1))
const prev = computed(() => '/' + (id.value - 1))
const next = computed(() => '/' + (id.value + 1))
</script>

<template>
  <div>
    <slot />
    <div v-if="$route.params.id">
      <NuxtLink :to="prev">⬅️</NuxtLink> |
      <NuxtLink :to="next">➡️</NuxtLink>
    </div>
  </div>
</template>
```

::

The page now applies the `slide-left` transition when going to the next id and `slide-right` for the previous:

<video controls class="rounded" poster="https://res.cloudinary.com/nuxt/video/upload/v1665069410/nuxt3/nuxt-dynamic-page-transitions.jpg">
  <source src="https://res.cloudinary.com/nuxt/video/upload/v1665069410/nuxt3/nuxt-dynamic-page-transitions.mp4" type="video/mp4">
</video>

## Transition with NuxtPage

When `<NuxtPage />` is used in `app.vue`, transitions can be configured with the `transition` prop to activate transitions globally.

```vue [app/app.vue]
<template>
  <div>
    <NuxtLayout>
      <NuxtPage
        :transition="{
          name: 'bounce',
          mode: 'out-in',
        }"
      />
    </NuxtLayout>
  </div>
</template>
```

::note
Remember, this page transition cannot be overridden with `definePageMeta` on individual pages.
::

## View Transitions API (experimental)

Nuxt ships with an experimental implementation of the [**View Transitions API**](https://developer.chrome.com/docs/web-platform/view-transitions) (see [MDN](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API)). This is an exciting new way to implement native browser transitions which (among other things) have the ability to transition between unrelated elements on different pages.

You can check a demo [on StackBlitz](https://stackblitz.com/edit/nuxt-view-transitions).

The Nuxt integration can be enabled with the `experimental.viewTransition` option in your configuration file:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    viewTransition: true,
  },
})
```

The possible values are: `false`, `true`, or `'always'`.

If set to true, Nuxt will not apply transitions if the user's browser matches `prefers-reduced-motion: reduce` (recommended). If set to `always`, Nuxt will always apply the transition and it is up to you to respect the user's preference.

By default, view transitions are enabled for all [pages](/docs/4.x/directory-structure/app/pages), but you can set a different global default.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  app: {
    // Disable view transitions globally, and opt-in on a per page basis
    viewTransition: false,
  },
})
```

It is possible to override the default `viewTransition` value for a page by setting the `viewTransition` key in [`definePageMeta`](/docs/4.x/api/utils/define-page-meta) of the page:

```vue twoslash [pages/about.vue]
<script setup lang="ts">
definePageMeta({
  viewTransition: false,
})
</script>
```

::warning
Overriding view transitions on a per-page basis will only have an effect if you have enabled the `experimental.viewTransition` option.
::

If you are also using Vue transitions like `pageTransition` and `layoutTransition` (see above) to achieve the same result as the new View Transitions API, then you may wish to _disable_ Vue transitions if the user's browser supports the newer, native web API. You can do this by creating `~/middleware/disable-vue-transitions.global.ts` with the following contents:

```ts
export default defineNuxtRouteMiddleware((to) => {
  if (import.meta.server || !document.startViewTransition) {
    return
  }

  // Disable built-in Vue transitions
  to.meta.pageTransition = false
  to.meta.layoutTransition = false
})
```

### Known Issues

- If you perform data fetching within your page setup functions, you may wish to reconsider using this feature for the moment. (By design, View Transitions completely freeze DOM updates whilst they are taking place.) We're looking at restricting the View Transition to the final moments before `<Suspense>` resolves, but in the interim you may want to consider carefully whether to adopt this feature if this describes you.
</file>

<file path="docs/1.getting-started/10.data-fetching.md">
---
title: 'Data Fetching'
description: Nuxt provides composables to handle data fetching within your application.
navigation.icon: i-lucide-cable
---

Nuxt comes with two composables and a built-in library to perform data-fetching in browser or server environments: `useFetch`, [`useAsyncData`](/docs/4.x/api/composables/use-async-data) and `$fetch`.

In a nutshell:

- [`$fetch`](/docs/4.x/api/utils/dollarfetch) is the simplest way to make a network request.
- [`useFetch`](/docs/4.x/api/composables/use-fetch) is a wrapper around `$fetch` that fetches data only once in [universal rendering](/docs/4.x/guide/concepts/rendering#universal-rendering).
- [`useAsyncData`](/docs/4.x/api/composables/use-async-data) is similar to `useFetch` but offers more fine-grained control.

Both `useFetch` and `useAsyncData` share a common set of options and patterns that we will detail in the last sections.

## The need for `useFetch` and `useAsyncData`

Nuxt is a framework which can run isomorphic (or universal) code in both server and client environments. If the [`$fetch` function](/docs/4.x/api/utils/dollarfetch) is used to perform data fetching in the setup function of a Vue component, this may cause data to be fetched twice, once on the server (to render the HTML) and once again on the client (when the HTML is hydrated). This can cause hydration issues, increase the time to interactivity and cause unpredictable behavior.

The [`useFetch`](/docs/4.x/api/composables/use-fetch) and [`useAsyncData`](/docs/4.x/api/composables/use-async-data) composables solve this problem by ensuring that if an API call is made on the server, the data is forwarded to the client in the payload.

The payload is a JavaScript object accessible through [`useNuxtApp().payload`](/docs/4.x/api/composables/use-nuxt-app#payload). It is used on the client to avoid refetching the same data when the code is executed in the browser [during hydration](/docs/4.x/guide/concepts/rendering#universal-rendering).

::tip
Use the [Nuxt DevTools](https://devtools.nuxt.com) to inspect this data in the **Payload tab**.
::

```vue [app/app.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/data')

async function handleFormSubmit () {
  const res = await $fetch('/api/submit', {
    method: 'POST',
    body: {
      // My form data
    },
  })
}
</script>

<template>
  <div v-if="data == undefined">
    No data
  </div>
  <div v-else>
    <form @submit="handleFormSubmit">
      <!-- form input tags -->
    </form>
  </div>
</template>
```

In the example above, `useFetch` would make sure that the request would occur in the server and is properly forwarded to the browser. `$fetch` has no such mechanism and is a better option to use when the request is solely made from the browser.

### Suspense

Nuxt uses Vue's [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense) component under the hood to prevent navigation before every async data is available to the view. The data fetching composables can help you leverage this feature and use what suits best on a per-call basis.

::note
You can add the [`<NuxtLoadingIndicator>`](/docs/4.x/api/components/nuxt-loading-indicator) to add a progress bar between page navigations.
::

## `$fetch`

Nuxt includes the [ofetch](https://github.com/unjs/ofetch) library, and is auto-imported as the `$fetch` alias globally across your application.

```vue twoslash [pages/todos.vue]
<script setup lang="ts">
async function addTodo () {
  const todo = await $fetch('/api/todos', {
    method: 'POST',
    body: {
      // My todo data
    },
  })
}
</script>
```

::warning
Beware that using only `$fetch` will not provide [network calls de-duplication and navigation prevention](/docs/4.x/getting-started/data-fetching#the-need-for-usefetch-and-useasyncdata). :br
It is recommended to use `$fetch` for client-side interactions (event-based) or combined with [`useAsyncData`](/docs/4.x/getting-started/data-fetching#useasyncdata) when fetching the initial component data.
::

::read-more{to="/docs/4.x/api/utils/dollarfetch"}
Read more about `$fetch`.
::

### Pass Client Headers to the API

When calling `useFetch` on the server, Nuxt will use [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) to proxy client headers and cookies (with the exception of headers not meant to be forwarded, like `host`).

```vue
<script setup lang="ts">
const { data } = await useFetch('/api/echo')
</script>
```

```ts
// /api/echo.ts
export default defineEventHandler(event => parseCookies(event))
```

Alternatively, the example below shows how to use [`useRequestHeaders`](/docs/4.x/api/composables/use-request-headers) to access and send cookies to the API from a server-side request (originating on the client). Using an isomorphic `$fetch` call, we ensure that the API endpoint has access to the same `cookie` header originally sent by the user's browser. This is only necessary if you aren't using `useFetch`.

```vue
<script setup lang="ts">
const headers = useRequestHeaders(['cookie'])

async function getCurrentUser () {
  return await $fetch('/api/me', { headers })
}
</script>
```

::tip
You can also use [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) to proxy headers to the call automatically.
::

::caution
Be very careful before proxying headers to an external API and just include headers that you need. Not all headers are safe to be bypassed and might introduce unwanted behavior. Here is a list of common headers that are NOT to be proxied:

- `host`, `accept`
- `content-length`, `content-md5`, `content-type`
- `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
- `cf-connecting-ip`, `cf-ray`
::

## `useFetch`

The [`useFetch`](/docs/4.x/api/composables/use-fetch) composable uses `$fetch` under-the-hood to make SSR-safe network calls in the setup function.

```vue twoslash [app/app.vue]
<script setup lang="ts">
const { data: count } = await useFetch('/api/count')
</script>

<template>
  <p>Page visits: {{ count }}</p>
</template>
```

This composable is a wrapper around the [`useAsyncData`](/docs/4.x/api/composables/use-async-data) composable and `$fetch` utility.

:video-accordion{title="Watch a video from Alexander Lichter to avoid using useFetch the wrong way" videoId="njsGVmcWviY"}

:read-more{to="/docs/4.x/api/composables/use-fetch"}

:link-example{to="/docs/4.x/examples/features/data-fetching"}

## `useAsyncData`

The `useAsyncData` composable is responsible for wrapping async logic and returning the result once it is resolved.

::tip
`useFetch(url)` is nearly equivalent to `useAsyncData(url, () => event.$fetch(url))`. :br
It's developer experience sugar for the most common use case. (You can find out more about `event.fetch` at [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch).)
::

:video-accordion{title="Watch a video from Alexander Lichter to dig deeper into the difference between useFetch and useAsyncData" videoId="0X-aOpSGabA"}

There are some cases when using the [`useFetch`](/docs/4.x/api/composables/use-fetch) composable is not appropriate, for example when a CMS or a third-party provide their own query layer. In this case, you can use [`useAsyncData`](/docs/4.x/api/composables/use-async-data) to wrap your calls and still keep the benefits provided by the composable.

```vue [app/pages/users.vue]
<script setup lang="ts">
const { data, error } = await useAsyncData('users', () => myGetFunction('users'))

// This is also possible:
const { data, error } = await useAsyncData(() => myGetFunction('users'))
</script>
```

::note
The first argument of [`useAsyncData`](/docs/4.x/api/composables/use-async-data) is a unique key used to cache the response of the second argument, the querying function. This key can be ignored by directly passing the querying function, the key will be auto-generated.
:br :br
Since the autogenerated key only takes into account the file and line where `useAsyncData` is invoked, it is recommended to always create your own key to avoid unwanted behavior, like when you are creating your own custom composable wrapping `useAsyncData`.
:br :br
Setting a key can be useful to share the same data between components using [`useNuxtData`](/docs/4.x/api/composables/use-nuxt-data) or to [refresh specific data](/docs/4.x/api/utils/refresh-nuxt-data#refresh-specific-data).
::

```vue [app/pages/users/[id\\].vue]
<script setup lang="ts">
const { id } = useRoute().params

const { data, error } = await useAsyncData(`user:${id}`, () => {
  return myGetFunction('users', { id })
})
</script>
```

The `useAsyncData` composable is a great way to wrap and wait for multiple `$fetch` requests to be completed, and then process the results.

```vue
<script setup lang="ts">
const { data: discounts, status } = await useAsyncData('cart-discount', async (_nuxtApp, { signal }) => {
  const [coupons, offers] = await Promise.all([
    $fetch('/cart/coupons', { signal }),
    $fetch('/cart/offers', { signal }),
  ])

  return { coupons, offers }
})
// discounts.value.coupons
// discounts.value.offers
</script>
```

::note
`useAsyncData` is for fetching and caching data, not triggering side effects like calling Pinia actions, as this can cause unintended behavior such as repeated executions with nullish values. If you need to trigger side effects, use the [`callOnce`](/docs/4.x/api/utils/call-once) utility to do so.

```vue
<script setup lang="ts">
const offersStore = useOffersStore()

// you can't do this
await useAsyncData(() => offersStore.getOffer(route.params.slug))
</script>
```
::

::read-more{to="/docs/4.x/api/composables/use-async-data"}
Read more about `useAsyncData`.
::

## Return Values

`useFetch` and `useAsyncData` have the same return values listed below.

- `data`: the result of the asynchronous function that is passed in.
- `refresh`/`execute`: a function that can be used to refresh the data returned by the `handler` function.
- `clear`: a function that can be used to set `data` to `undefined` (or the value of `options.default()` if provided), set `error` to `undefined`, set `status` to `idle`, and mark any currently pending requests as cancelled.
- `error`: an error object if the data fetching failed.
- `status`: a string indicating the status of the data request (`"idle"`, `"pending"`, `"success"`, `"error"`).

::note
`data`, `error` and `status` are Vue refs accessible with `.value` in `<script setup>`
::

By default, Nuxt waits until a `refresh` is finished before it can be executed again.

::note
If you have not fetched data on the server (for example, with `server: false`), then the data _will not_ be fetched until hydration completes. This means even if you await `useFetch` on client-side, `data` will remain null within `<script setup>`.
::

## Options

[`useAsyncData`](/docs/4.x/api/composables/use-async-data) and [`useFetch`](/docs/4.x/api/composables/use-fetch) return the same object type and accept a common set of options as their last argument. They can help you control the composables behavior, such as navigation blocking, caching or execution.

### Lazy

By default, data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue's Suspense. This feature can be ignored on client-side navigation with the `lazy` option. In that case, you will have to manually handle loading state using the `status` value.

```vue twoslash [app/app.vue]
<script setup lang="ts">
const { status, data: posts } = useFetch('/api/posts', {
  lazy: true,
})
</script>

<template>
  <!-- you will need to handle a loading state -->
  <div v-if="status === 'pending'">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

You can alternatively use [`useLazyFetch`](/docs/4.x/api/composables/use-lazy-fetch) and `useLazyAsyncData` as convenient methods to perform the same.

```vue twoslash
<script setup lang="ts">
const { status, data: posts } = useLazyFetch('/api/posts')
</script>
```

::read-more{to="/docs/4.x/api/composables/use-lazy-fetch"}
Read more about `useLazyFetch`.
::

::read-more{to="/docs/4.x/api/composables/use-lazy-async-data"}
Read more about `useLazyAsyncData`.
::

:video-accordion{title="Watch a video from Vue School on blocking vs. non-blocking (lazy) requests" videoId="1022000555" platform="vimeo"}

### Client-only fetching

By default, data fetching composables will perform their asynchronous function on both client and server environments. Set the `server` option to `false` to only perform the call on the client-side. On initial load, the data will not be fetched before hydration is complete so you have to handle a pending state, though on subsequent client-side navigation the data will be awaited before loading the page.

Combined with the `lazy` option, this can be useful for data that is not needed on the first render (for example, non-SEO sensitive data).

```ts twoslash
/* This call is performed before hydration */
const articles = await useFetch('/api/article')

/* This call will only be performed on the client */
const { status, data: comments } = useFetch('/api/comments', {
  lazy: true,
  server: false,
})
```

The `useFetch` composable is meant to be invoked in setup method or called directly at the top level of a function in lifecycle hooks, otherwise you should use [`$fetch` method](/docs/4.x/getting-started/data-fetching#fetch).

### Minimize payload size

The `pick` option helps you to minimize the payload size stored in your HTML document by only selecting the fields that you want returned from the composables.

```vue
<script setup lang="ts">
/* only pick the fields used in your template */
const { data: mountain } = await useFetch('/api/mountains/everest', {
  pick: ['title', 'description'],
})
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

If you need more control or map over several objects, you can use the `transform` function to alter the result of the query.

```ts
const { data: mountains } = await useFetch('/api/mountains', {
  transform: (mountains) => {
    return mountains.map(mountain => ({ title: mountain.title, description: mountain.description }))
  },
})
```

::note
Both `pick` and `transform` don't prevent the unwanted data from being fetched initially. But they will prevent unwanted data from being added to the payload transferred from server to client.
::

:video-accordion{title="Watch a video from Vue School on minimizing payload size" videoId="1026410430" platform="vimeo"}

### Caching and refetching

#### Keys

[`useFetch`](/docs/4.x/api/composables/use-fetch) and [`useAsyncData`](/docs/4.x/api/composables/use-async-data) use keys to prevent refetching the same data.

- [`useFetch`](/docs/4.x/api/composables/use-fetch) uses the provided URL as a key. Alternatively, a `key` value can be provided in the `options` object passed as a last argument.
- [`useAsyncData`](/docs/4.x/api/composables/use-async-data) uses its first argument as a key if it is a string. If the first argument is the handler function that performs the query, then a key that is unique to the file name and line number of the instance of `useAsyncData` will be generated for you.

::tip
To get the cached data by key, you can use [`useNuxtData`](/docs/4.x/api/composables/use-nuxt-data)
::

:video-accordion{title="Watch a video from Vue School on caching data with the key option" videoId="1026410044" platform="vimeo"}

#### Shared State and Option Consistency

When multiple components use the same key with `useAsyncData` or `useFetch`, they will share the same `data`, `error` and `status` refs. This ensures consistency across components but requires some options to be consistent.

The following options **must be consistent** across all calls with the same key:
- `handler` function
- `deep` option
- `transform` function
- `pick` array
- `getCachedData` function
- `default` value

```ts
// ❌ This will trigger a development warning
const { data: users1 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { deep: false })
const { data: users2 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { deep: true })
```

The following options **can safely differ** without triggering warnings:
- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ✅ This is allowed
const { data: users1 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { immediate: true })
const { data: users2 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { immediate: false })
```

If you need independent instances, use different keys:

```ts
// These are completely independent instances
const { data: users1 } = useAsyncData('users-1', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }))
const { data: users2 } = useAsyncData('users-2', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }))
```

#### Reactive Keys

You can use computed refs, plain refs or getter functions as keys, allowing for dynamic data fetching that automatically updates when dependencies change:

```ts
// Using a computed property as a key
const userId = ref('123')
const { data: user } = useAsyncData(
  computed(() => `user-${userId.value}`),
  () => fetchUser(userId.value),
)

// When userId changes, the data will be automatically refetched
// and the old data will be cleaned up if no other components use it
userId.value = '456'
```

#### Refresh and execute

If you want to fetch or refresh data manually, use the `execute` or `refresh` function provided by the composables.

```vue twoslash
<script setup lang="ts">
const { data, error, execute, refresh } = await useFetch('/api/users')
</script>

<template>
  <div>
    <p>{{ data }}</p>
    <button @click="() => refresh()">
      Refresh data
    </button>
  </div>
</template>
```

The `execute` function is an alias for `refresh` that works in exactly the same way but is more semantic for cases when the fetch is [not immediate](/docs/4.x/getting-started/data-fetching#not-immediate).

::tip
To globally refetch or invalidate cached data, see [`clearNuxtData`](/docs/4.x/api/utils/clear-nuxt-data) and [`refreshNuxtData`](/docs/4.x/api/utils/refresh-nuxt-data).
::

#### Clear

If you want to clear the data provided, for whatever reason, without needing to know the specific key to pass to `clearNuxtData`, you can use the `clear` function provided by the composables.

```vue twoslash
<script setup lang="ts">
const { data, clear } = await useFetch('/api/users')

const route = useRoute()
watch(() => route.path, (path) => {
  if (path === '/') {
    clear()
  }
})
</script>
```

#### Watch

To re-run your fetching function each time other reactive values in your application change, use the `watch` option. You can use it for one or multiple _watchable_ elements.

```vue twoslash
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch('/api/users', {
  /* Changing the id will trigger a refetch */
  watch: [id],
})
</script>
```

Note that **watching a reactive value won't change the URL fetched**. For example, this will keep fetching the same initial ID of the user because the URL is constructed at the moment the function is invoked.

```vue
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch(`/api/users/${id.value}`, {
  watch: [id],
})
</script>
```

If you need to change the URL based on a reactive value, you may want to use a [computed URL](/docs/4.x/getting-started/data-fetching#computed-url) instead.

When reactive fetch options are provided, they'll be automatically watched and trigger refetches. In some cases, it can be useful to opt-out of this behavior by specifying `watch: false`.

```ts
const id = ref(1)

// Won't automatically refetch when id changes
const { data, execute } = await useFetch('/api/users', {
  query: { id }, // id is watched by default
  watch: false, // disables automatic watching of id
})

// doesn't trigger refetch
id.value = 2
```

#### Computed URL

Sometimes you may need to compute a URL from reactive values, and refresh the data each time these change. Instead of juggling your way around, you can attach each param as a reactive value. Nuxt will automatically use the reactive value and re-fetch each time it changes.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch('/api/user', {
  query: {
    user_id: id,
  },
})
</script>
```

In the case of more complex URL construction, you may use a callback as a [computed getter](https://vuejs.org/guide/essentials/computed) that returns the URL string.

Every time a dependency changes, the data will be fetched using the newly constructed URL. Combine this with [not-immediate](/docs/4.x/getting-started/data-fetching#not-immediate), and you can wait until the reactive element changes before fetching.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch(() => `/api/users/${id.value}`, {
  immediate: false,
})

const pending = computed(() => status.value === 'pending')
</script>

<template>
  <div>
    <!-- disable the input while fetching -->
    <input
      v-model="id"
      type="number"
      :disabled="pending"
    >

    <div v-if="status === 'idle'">
      Type an user ID
    </div>

    <div v-else-if="pending">
      Loading ...
    </div>

    <div v-else>
      {{ data }}
    </div>
  </div>
</template>
```

If you need to force a refresh when other reactive values change, you can also [watch other values](/docs/4.x/getting-started/data-fetching#watch).

### Not immediate

The `useFetch` composable will start fetching data the moment is invoked. You may prevent this by setting `immediate: false`, for example, to wait for user interaction.

With that, you will need both the `status` to handle the fetch lifecycle, and `execute` to start the data fetch.

```vue
<script setup lang="ts">
const { data, error, execute, status } = await useLazyFetch('/api/comments', {
  immediate: false,
})
</script>

<template>
  <div v-if="status === 'idle'">
    <button @click="execute">
      Get data
    </button>
  </div>

  <div v-else-if="status === 'pending'">
    Loading comments...
  </div>

  <div v-else>
    {{ data }}
  </div>
</template>
```

For finer control, the `status` variable can be:

- `idle` when the fetch hasn't started
- `pending` when a fetch has started but not yet completed
- `error` when the fetch fails
- `success` when the fetch is completed successfully

## Passing Headers and Cookies

When we call `$fetch` in the browser, user headers like `cookie` will be directly sent to the API.

Normally, during server-side-rendering, due to security considerations, the `$fetch` wouldn't include the user's browser cookies, nor pass on cookies from the fetch response.

However, when calling `useFetch` with a relative URL on the server, Nuxt will use [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) to proxy headers and cookies (with the exception of headers not meant to be forwarded, like `host`).

### Pass Cookies From Server-side API Calls on SSR Response

 If you want to pass on/proxy cookies in the other direction, from an internal request back to the client, you will need to handle this yourself.

```ts [app/composables/fetch.ts]
import { appendResponseHeader } from 'h3'
import type { H3Event } from 'h3'

export const fetchWithCookie = async (event: H3Event, url: string) => {
  /* Get the response from the server endpoint */
  const res = await $fetch.raw(url)
  /* Get the cookies from the response */
  const cookies = res.headers.getSetCookie()
  /* Attach each cookie to our incoming Request */
  for (const cookie of cookies) {
    appendResponseHeader(event, 'set-cookie', cookie)
  }
  /* Return the data of the response */
  return res._data
}
```

```vue
<script setup lang="ts">
// This composable will automatically pass cookies to the client
const event = useRequestEvent()

const { data: result } = await useAsyncData(() => fetchWithCookie(event!, '/api/with-cookie'))

onMounted(() => console.log(document.cookie))
</script>
```

## Options API Support

Nuxt provides a way to perform `asyncData` fetching within the Options API. You must wrap your component definition within `defineNuxtComponent` for this to work.

```vue
<script>
export default defineNuxtComponent({
  /* Use the fetchKey option to provide a unique key */
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello'),
    }
  },
})
</script>
```

::note
Using `<script setup>` or `<script setup lang="ts">` are the recommended way of declaring Vue components in Nuxt.
::

:read-more{to="/docs/4.x/api/utils/define-nuxt-component"}

## Serializing Data From Server to Client

When using `useAsyncData` and `useLazyAsyncData` to transfer data fetched on server to the client (as well as anything else that utilizes [the Nuxt payload](/docs/4.x/api/composables/use-nuxt-app#payload)), the payload is serialized with [`devalue`](https://github.com/sveltejs/devalue). This allows us to transfer not just basic JSON but also to serialize and revive/deserialize more advanced kinds of data, such as regular expressions, Dates, Map and Set, `ref`, `reactive`, `shallowRef`, `shallowReactive` and `NuxtError` - and more.

It is also possible to define your own serializer/deserializer for types that are not supported by Nuxt. You can read more in the [`useNuxtApp`](/docs/4.x/api/composables/use-nuxt-app#payload) docs.

::note
Note that this _does not apply_ to data passed from your server routes when fetched with `$fetch` or `useFetch` - see the next section for more information.
::

## Serializing Data From API Routes

When fetching data from the `server` directory, the response is serialized using `JSON.stringify`. However, since serialization is limited to only JavaScript primitive types, Nuxt does its best to convert the return type of `$fetch` and [`useFetch`](/docs/4.x/api/composables/use-fetch) to match the actual value.

::read-more{icon="i-simple-icons-mdnwebdocs" to="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description" target="_blank"}
Learn more about `JSON.stringify` limitations.
::

### Example

```ts [server/api/foo.ts]
export default defineEventHandler(() => {
  return new Date()
})
```

```vue [app/app.vue]
<script setup lang="ts">
// Type of `data` is inferred as string even though we returned a Date object
const { data } = await useFetch('/api/foo')
</script>
```

### Custom serializer function

To customize the serialization behavior, you can define a `toJSON` function on your returned object. If you define a `toJSON` method, Nuxt will respect the return type of the function and will not try to convert the types.

```ts [server/api/bar.ts]
export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    toJSON () {
      return {
        createdAt: {
          year: this.createdAt.getFullYear(),
          month: this.createdAt.getMonth(),
          day: this.createdAt.getDate(),
        },
      }
    },
  }
  return data
})
```

```vue [app/app.vue]
<script setup lang="ts">
// Type of `data` is inferred as
// {
//   createdAt: {
//     year: number
//     month: number
//     day: number
//   }
// }
const { data } = await useFetch('/api/bar')
</script>
```

### Using an alternative serializer

Nuxt does not currently support an alternative serializer to `JSON.stringify`. However, you can return your payload as a normal string and utilize the `toJSON` method to maintain type safety.

In the example below, we use [superjson](https://github.com/flightcontrolhq/superjson) as our serializer.

```ts [server/api/superjson.ts]
import superjson from 'superjson'

export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    // Workaround the type conversion
    toJSON () {
      return this
    },
  }

  // Serialize the output to string, using superjson
  return superjson.stringify(data) as unknown as typeof data
})
```

```vue [app/app.vue]
<script setup lang="ts">
import superjson from 'superjson'

// `date` is inferred as { createdAt: Date } and you can safely use the Date object methods
const { data } = await useFetch('/api/superjson', {
  transform: (value) => {
    return superjson.parse(value as unknown as string)
  },
})
</script>
```

## Recipes

### Consuming SSE (Server-Sent Events) via POST request

::tip
If you're consuming SSE via GET request, you can use [`EventSource`](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) or VueUse composable [`useEventSource`](https://vueuse.org/core/useeventsource/).
::

When consuming SSE via POST request, you need to handle the connection manually. Here's how you can do it:

```ts
// Make a POST request to the SSE endpoint
const response = await $fetch<ReadableStream>('/chats/ask-ai', {
  method: 'POST',
  body: {
    query: 'Hello AI, how are you?',
  },
  responseType: 'stream',
})

// Create a new ReadableStream from the response with TextDecoderStream to get the data as text
const reader = response.pipeThrough(new TextDecoderStream()).getReader()

// Read the chunk of data as we get it
while (true) {
  const { value, done } = await reader.read()

  if (done) { break }

  console.log('Received:', value)
}
```

### Making parallel requests

When requests don't rely on each other, you can make them in parallel with `Promise.all()` to boost performance.

```ts
const { data } = await useAsyncData((_nuxtApp, { signal }) => {
  return Promise.all([
    $fetch('/api/comments/', { signal }),
    $fetch('/api/author/12', { signal }),
  ])
})

const comments = computed(() => data.value?.[0])
const author = computed(() => data.value?.[1])
```

:video-accordion{title="Watch a video from Vue School on parallel data fetching" videoId="1024262536" platform="vimeo"}
</file>

<file path="docs/1.getting-started/11.state-management.md">
---
title: 'State Management'
description: Nuxt provides powerful state management libraries and the useState composable to create a reactive and SSR-friendly shared state.
navigation.icon: i-lucide-database
---

Nuxt provides the [`useState`](/docs/4.x/api/composables/use-state) composable to create a reactive and SSR-friendly shared state across components.

[`useState`](/docs/4.x/api/composables/use-state) is an SSR-friendly [`ref`](https://vuejs.org/api/reactivity-core#ref) replacement. Its value will be preserved after server-side rendering (during client-side hydration) and shared across all components using a unique key.

:video-accordion{title="Watch a video from Alexander Lichter about why and when to use useState" videoId="mv0WcBABcIk"}

::important
Because the data inside [`useState`](/docs/4.x/api/composables/use-state) will be serialized to JSON, it is important that it does not contain anything that cannot be serialized, such as classes, functions or symbols.
::

::read-more{to="/docs/4.x/api/composables/use-state"}
Read more about `useState` composable.
::

## Best Practices

::warning
Never define `const state = ref()` outside of `<script setup>` or `setup()` function.<br>
For example, doing `export myState = ref({})` would result in state shared across requests on the server and can lead to memory leaks.
::

::tip{icon="i-lucide-circle-check"}
Instead use `const useX = () => useState('x')`
::

## Examples

### Basic Usage

In this example, we use a component-local counter state. Any other component that uses `useState('counter')` shares the same reactive state.

```vue twoslash [app/app.vue]
<script setup lang="ts">
const counter = useState('counter', () => Math.round(Math.random() * 1000))
</script>

<template>
  <div>
    Counter: {{ counter }}
    <button @click="counter++">
      +
    </button>
    <button @click="counter--">
      -
    </button>
  </div>
</template>
```

:link-example{to="/docs/4.x/examples/features/state-management"}

::note
To globally invalidate cached state, see [`clearNuxtState`](/docs/4.x/api/utils/clear-nuxt-state) util.
::

### Initializing State

Most of the time, you will want to initialize your state with data that resolves asynchronously. You can use the [`app.vue`](/docs/4.x/directory-structure/app/app) component with the [`callOnce`](/docs/4.x/api/utils/call-once) util to do so.

```vue twoslash [app/app.vue]
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
})
</script>
```

::tip
This is similar to the [`nuxtServerInit` action](https://v2.nuxt.com/docs/directory-structure/store/#the-nuxtserverinit-action) in Nuxt 2, which allows filling the initial state of your store server-side before rendering the page.
::

:read-more{to="/docs/4.x/api/utils/call-once"}

### Usage with Pinia

In this example, we leverage the [Pinia module](/modules/pinia) to create a global store and use it across the app.

::important
Make sure to install the Pinia module with `npx nuxt module add pinia` or follow the [module's installation steps](https://pinia.vuejs.org/ssr/nuxt.html#Installation).
::

::code-group
```ts [app/stores/website.ts]
export const useWebsiteStore = defineStore('websiteStore', {
  state: () => ({
    name: '',
    description: '',
  }),
  actions: {
    async fetch () {
      const infos = await $fetch('https://api.nuxt.com/modules/pinia')

      this.name = infos.name
      this.description = infos.description
    },
  },
})
```
```vue [app/app.vue]
<script setup lang="ts">
const website = useWebsiteStore()

await callOnce(website.fetch)
</script>

<template>
  <main>
    <h1>{{ website.name }}</h1>
    <p>{{ website.description }}</p>
  </main>
</template>
```
::

## Advanced Usage

::code-group
```ts [app/composables/locale.ts]
import type { Ref } from 'vue'

export const useLocale = () => {
  return useState<string>('locale', () => useDefaultLocale().value)
}

export const useDefaultLocale = (fallback = 'en-US') => {
  const locale = ref(fallback)
  if (import.meta.server) {
    const reqLocale = useRequestHeaders()['accept-language']?.split(',')[0]
    if (reqLocale) {
      locale.value = reqLocale
    }
  } else if (import.meta.client) {
    const navLang = navigator.language
    if (navLang) {
      locale.value = navLang
    }
  }
  return locale
}

export const useLocales = () => {
  const locale = useLocale()
  const locales = ref([
    'en-US',
    'en-GB',
    // ...,
    'ja-JP-u-ca-japanese',
  ])
  if (!locales.value.includes(locale.value)) {
    locales.value.unshift(locale.value)
  }
  return locales
}

export const useLocaleDate = (date: Ref<Date> | Date, locale = useLocale()) => {
  return computed(() => new Intl.DateTimeFormat(locale.value, { dateStyle: 'full' }).format(unref(date)))
}
```

```vue [app/app.vue]
<script setup lang="ts">
const locales = useLocales()
const locale = useLocale()
const date = useLocaleDate(new Date('2016-10-26'))
</script>

<template>
  <div>
    <h1>Nuxt birthday</h1>
    <p>{{ date }}</p>
    <label for="locale-chooser">Preview a different locale</label>
    <select
      id="locale-chooser"
      v-model="locale"
    >
      <option
        v-for="loc of locales"
        :key="loc"
        :value="loc"
      >
        {{ loc }}
      </option>
    </select>
  </div>
</template>
```
::

:link-example{to="/docs/4.x/examples/advanced/locale"}

## Shared State

By using [auto-imported composables](/docs/4.x/directory-structure/app/composables) we can define global type-safe states and import them across the app.

```ts twoslash [composables/states.ts]
export const useColor = () => useState<string>('color', () => 'pink')
```

```vue [app/app.vue]
<script setup lang="ts">
// ---cut-start---
const useColor = () => useState<string>('color', () => 'pink')
// ---cut-end---
const color = useColor() // Same as useState('color')
</script>

<template>
  <p>Current color: {{ color }}</p>
</template>
```

:video-accordion{title="Watch a video from Daniel Roe on how to deal with global state and SSR in Nuxt" videoId="dZSNW07sO-A"}

## Using third-party libraries

Nuxt **used to rely** on the Vuex library to provide global state management. If you are migrating from Nuxt 2, please head to [the migration guide](/docs/4.x/migration/configuration#vuex).

Nuxt is not opinionated about state management, so feel free to choose the right solution for your needs. There are multiple integrations with the most popular state management libraries, including:

- [Pinia](/modules/pinia) - the official Vue recommendation
- [Harlem](/modules/harlem) - immutable global state management
- [XState](/modules/xstate) - state machine approach with tools for visualizing and testing your state logic
</file>

<file path="docs/1.getting-started/12.error-handling.md">
---
title: 'Error Handling'
description: 'Learn how to catch and handle errors in Nuxt.'
navigation.icon: i-lucide-bug-off
---

Nuxt is a full-stack framework, which means there are several sources of unpreventable user runtime errors that can happen in different contexts:

- Errors during the Vue rendering lifecycle (SSR & CSR)
- Server and client startup errors (SSR + CSR)
- Errors during Nitro server lifecycle ([`server/`](/docs/4.x/directory-structure/server) directory)
- Errors downloading JS chunks

::tip
**SSR** stands for **Server-Side Rendering** and **CSR** for **Client-Side Rendering**.
::

## Vue Errors

You can hook into Vue errors using [`onErrorCaptured`](https://vuejs.org/api/composition-api-lifecycle#onerrorcaptured).

In addition, Nuxt provides a [`vue:error`](/docs/4.x/api/advanced/hooks#app-hooks-runtime) hook that will be called if any errors propagate up to the top level.

If you are using an error reporting framework, you can provide a global handler through [`vueApp.config.errorHandler`](https://vuejs.org/api/application#app-config-errorhandler). It will receive all Vue errors, even if they are handled.

```ts twoslash [plugins/error-handler.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.config.errorHandler = (error, instance, info) => {
    // handle error, e.g. report to a service
  }

  // Also possible
  nuxtApp.hook('vue:error', (error, instance, info) => {
    // handle error, e.g. report to a service
  })
})
```

::note
Note that the `vue:error` hook is based on [`onErrorCaptured`](https://vuejs.org/api/composition-api-lifecycle#onerrorcaptured) lifecycle hook.
::

## Startup Errors

Nuxt will call the `app:error` hook if there are any errors in starting your Nuxt application.

This includes:
- running [Nuxt plugins](/docs/4.x/directory-structure/app/plugins)
- processing `app:created` and `app:beforeMount` hooks
- rendering your Vue app to HTML (during SSR)
- mounting the app (on client-side), though you should handle this case with `onErrorCaptured` or with `vue:error`
- processing the `app:mounted` hook

## Nitro Server Errors

You cannot currently define a server-side handler for these errors, but can render an error page, see the [Render an Error Page](/docs/4.x/getting-started/error-handling#error-page) section.

## Errors with JS Chunks

You might encounter chunk loading errors due to a network connectivity failure or a new deployment (which invalidates your old, hashed JS chunk URLs). Nuxt provides built-in support for handling chunk loading errors by performing a hard reload when a chunk fails to load during route navigation.

You can change this behavior by setting `experimental.emitRouteChunkError` to `false` (to disable hooking into these errors at all) or to `manual` if you want to handle them yourself. If you want to handle chunk loading errors manually, you can check out the [the automatic implementation](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/plugins/chunk-reload.client.ts) for ideas.

## Error Page

::note
When Nuxt encounters a fatal error (any unhandled error on the server, or an error created with `fatal: true` on the client) it will either render a JSON response (if requested with `Accept: application/json` header) or trigger a full-screen error page.
::

An error may occur during the server lifecycle when:
- processing your Nuxt plugins
- rendering your Vue app into HTML
- a server API route throws an error

It can also occur on the client side when:
- processing your Nuxt plugins
- before mounting the application (`app:beforeMount` hook)
- mounting your app if the error was not handled with `onErrorCaptured` or `vue:error` hook
- the Vue app is initialized and mounted in browser (`app:mounted`).

::read-more{to="/docs/4.x/api/advanced/hooks"}
Discover all the Nuxt lifecycle hooks.
::

Customize the default error page by adding `~/error.vue` in the source directory of your application, alongside `app.vue`.

<!-- TODO:twoslash: Twoslash does not support tsconfig paths yet -->

```vue [error.vue]
<script setup lang="ts">
import type { NuxtError } from '#app'

const props = defineProps({
  error: Object as () => NuxtError,
})

const handleError = () => clearError({ redirect: '/' })
</script>

<template>
  <div>
    <h2>{{ error?.status }}</h2>
    <button @click="handleError">
      Clear errors
    </button>
  </div>
</template>
```

::read-more{to="/docs/4.x/directory-structure/app/error"}
Read more about `error.vue` and its uses.
::

For custom errors we highly recommend using `onErrorCaptured` composable that can be called in a page/component setup function or `vue:error` runtime nuxt hook that can be configured in a nuxt plugin.

```ts twoslash [plugins/error-handler.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.hook('vue:error', (err) => {
    //
  })
})
```

When you are ready to remove the error page, you can call the [`clearError`](/docs/4.x/api/utils/clear-error) helper function, which takes an optional path to redirect to (for example, if you want to navigate to a 'safe' page).

::important
Make sure to check before using anything dependent on Nuxt plugins, such as `$route` or `useRouter`, as if a plugin threw an error, then it won't be re-run until you clear the error.
::

::note
Rendering an error page is an entirely separate page load, meaning any registered middleware will run again. You can use [`useError`](/docs/4.x/getting-started/error-handling#useerror) in middleware to check if an error is being handled.
::

::note
If you are running on Node 16 and you set any cookies when rendering your error page, they will [overwrite cookies previously set](https://github.com/nuxt/nuxt/pull/20585). We recommend using a newer version of Node as Node 16 reached end-of-life in September 2023.
::

## Error Utils

### `useError`

```ts [TS Signature]
function useError (): Ref<Error | { url, status, statusText, message, description, data }>
```

This function will return the global Nuxt error that is being handled.

::read-more{to="/docs/4.x/api/composables/use-error"}
Read more about `useError` composable.
::

### `createError`

```ts [TS Signature]
function createError (err: string | { cause, data, message, name, stack, status, statusText, fatal }): Error
```

Create an error object with additional metadata. You can pass a string to be set as the error `message` or an object containing error properties. It is usable in both the Vue and Server portions of your app, and is meant to be thrown.

If you throw an error created with `createError`:
- on server-side, it will trigger a full-screen error page which you can clear with [`clearError`](/docs/4.x/getting-started/error-handling#clearerror).
- on client-side, it will throw a non-fatal error for you to handle. If you need to trigger a full-screen error page, then you can do this by setting `fatal: true`.

```vue twoslash [pages/movies/[slug\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data } = await useFetch(`/api/movies/${route.params.slug}`)

if (!data.value) {
  throw createError({
    status: 404,
    statusText: 'Page Not Found',
  })
}
</script>
```

::tip
The `statusText` property is intended for short, HTTP-compliant status texts (e.g., "Not Found"). It should only contain horizontal tabs, spaces, and visible ASCII characters (`[\t\u0020-\u007E]`).

For any detailed descriptions, multi-line messages, or content with non-ASCII characters, you should always use the `message` property instead.
::

::read-more{to="/docs/4.x/api/utils/create-error"}
Read more about `createError` util.
::

### `showError`

```ts [TS Signature]
function showError (err: string | Error | { status, statusText }): Error
```

You can call this function at any point on client-side, or (on server side) directly within middleware, plugins or `setup()` functions. It will trigger a full-screen error page which you can clear with [`clearError`](/docs/4.x/getting-started/error-handling#clearerror).

It is recommended instead to use `throw createError()`.

::read-more{to="/docs/4.x/api/utils/show-error"}
Read more about `showError` util.
::

### `clearError`

```ts [TS Signature]
function clearError (options?: { redirect?: string }): Promise<void>
```

This function will clear the currently handled Nuxt error. It also takes an optional path to redirect to (for example, if you want to navigate to a 'safe' page).

::read-more{to="/docs/4.x/api/utils/clear-error"}
Read more about `clearError` util.
::

## Render Error in Component

Nuxt also provides a [`<NuxtErrorBoundary>`](/docs/4.x/api/components/nuxt-error-boundary) component that allows you to handle client-side errors within your app, without replacing your entire site with an error page.

This component is responsible for handling errors that occur within its default slot. On client-side, it will prevent the error from bubbling up to the top level, and will render the `#error` slot instead.

The `#error` slot will receive `error` as a prop. (If you set `error = null` it will trigger re-rendering the default slot; you'll need to ensure that the error is fully resolved first or the error slot will just be rendered a second time.)

::tip
If you navigate to another route, the error will be cleared automatically.
::

```vue [app/pages/index.vue]
<template>
  <!-- some content -->
  <NuxtErrorBoundary @error="someErrorLogger">
    <!-- You use the default slot to render your content -->
    <template #error="{ error, clearError }">
      You can display the error locally here: {{ error }}
      <button @click="clearError">
        This will clear the error.
      </button>
    </template>
  </NuxtErrorBoundary>
</template>
```

:link-example{to="/docs/4.x/examples/advanced/error-handling"}
</file>

<file path="docs/1.getting-started/13.server.md">
---
title: 'Server'
description: Build full-stack applications with Nuxt's server framework. You can fetch data from your database or another server, create APIs, or even generate static server-side content like a sitemap or a RSS feed - all from a single codebase.
navigation.icon: i-lucide-pc-case
---

:read-more{to="/docs/4.x/directory-structure/server"}

## Powered by Nitro

![Server engine](/assets/docs/getting-started/server.svg)

Nuxt's server is [Nitro](https://github.com/nitrojs/nitro). It was originally created for Nuxt but is now part of [UnJS](https://unjs.io) and open for other frameworks - and can even be used on its own.

Using Nitro gives Nuxt superpowers:

- Full control of the server-side part of your app
- Universal deployment on any provider (many zero-config)
- Hybrid rendering

Nitro is internally using [h3](https://github.com/h3js/h3), a minimal H(TTP) framework built for high performance and portability.

:video-accordion{title="Watch a video from Alexander Lichter to understand the responsibilities of Nuxt and Nitro in your application" videoId="DkvgJa-X31k"}

## Server Endpoints & Middleware

You can easily manage the server-only part of your Nuxt app, from API endpoints to middleware.

Both endpoints and middleware can be defined like this:

```ts twoslash [server/api/test.ts]
export default defineEventHandler(async (event) => {
  // ... Do whatever you want here
})
```

And you can directly return `text`, `json`, `html` or even a `stream`.

Out-of-the-box, it supports **hot module replacement** and **auto-import** like the other parts of your Nuxt application.

:read-more{to="/docs/4.x/directory-structure/server"}

## Universal Deployment

Nitro offers the ability to deploy your Nuxt app anywhere, from a bare metal server to the edge network, with a start time of just a few milliseconds. That's fast!

:read-more{to="/blog/nuxt-on-the-edge"}

There are more than 15 presets to build your Nuxt app for different cloud providers and servers, including:

- [Cloudflare Workers](https://workers.cloudflare.com)
- [Netlify Functions](https://www.netlify.com/platform/core/functions/)
- [Vercel Cloud](https://vercel.com/home)

Or for other runtimes:

::card-group
  :card{icon="i-logos-deno" title="Deno" to="https://deno.com" target="_blank"}
  :card{icon="i-logos-bun" title="Bun" to="https://bun.com" target="_blank"}
::

:read-more{to="/docs/4.x/getting-started/deployment"}

## Hybrid Rendering

Nitro has a powerful feature called `routeRules` which allows you to define a set of rules to customize how each route of your Nuxt app is rendered (and more).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    // Generated at build time for SEO purpose
    '/': { prerender: true },
    // Cached for 1 hour
    '/api/*': { cache: { maxAge: 60 * 60 } },
    // Redirection to avoid 404
    '/old-page': {
      redirect: { to: '/new-page', statusCode: 302 },
    },
    // ...
  },
})
```

::read-more{to="/docs/4.x/guide/concepts/rendering#hybrid-rendering"}
Learn about all available route rules are available to customize the rendering mode of your routes.
::

In addition, there are some route rules (for example, `ssr`, `appMiddleware`, and `noScripts`) that are Nuxt specific to change the behavior when rendering your pages to HTML.

Some route rules (`appMiddleware`, `redirect` and `prerender`) also affect client-side behavior.

Nitro is used to build the app for server side rendering, as well as pre-rendering.

:read-more{to="/docs/4.x/guide/concepts/rendering"}
</file>

<file path="docs/1.getting-started/14.layers.md">
---
title: 'Layers'
description: Nuxt provides a powerful system that allows you to extend the default files, configs, and much more.
navigation.icon: i-lucide-layers
---

One of the core features of Nuxt is the layers and extending support. You can extend a default Nuxt application to reuse components, utils, and configuration. The layers structure is almost identical to a standard Nuxt application which makes them easy to author and maintain.

## Use Cases

- Share reusable configuration presets across projects using `nuxt.config` and `app.config`
- Create a component library using [`app/components/`](/docs/4.x/directory-structure/app/components) directory
- Create utility and composable library using [`app/composables/`](/docs/4.x/directory-structure/app/composables) and [`app/utils/`](/docs/4.x/directory-structure/app/utils) directories
- Create Nuxt module presets
- Share standard setup across projects
- Create Nuxt themes
- Enhance code organization by implementing a modular architecture and support Domain-Driven Design (DDD) pattern in large scale projects.

## Usage

By default, any layers within your project in the `~~/layers` directory will be automatically registered as layers in your project.

::note
Layer auto-registration was introduced in Nuxt v3.12.0.
::

In addition, named layer aliases to the `srcDir` of each of these layers will automatically be created. For example, you will be able to access the `~~/layers/test` layer via `#layers/test`.

::note
Named layer aliases were introduced in Nuxt v3.16.0.
::

In addition, you can extend from a layer by adding the [extends](/docs/4.x/api/nuxt-config#extends) property to your [`nuxt.config`](/docs/4.x/directory-structure/nuxt-config) file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    // Extend from a local layer
    '../base',
    // Extend from an installed npm package
    '@my-themes/awesome',
    // Extend from a git repository
    'github:my-themes/awesome#v1',
  ],
})
```

You can also pass an authentication token if you are extending from a private GitHub repository:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    // per layer configuration
    ['github:my-themes/private-awesome', { auth: process.env.GITHUB_TOKEN }],
  ],
})
```

::note
If a branch is not specified, this will clone `main`.
::

::tip
You can override a layer's alias by specifying it in the options next to the layer source.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    [
      'github:my-themes/awesome',
      {
        meta: {
          name: 'my-awesome-theme',
        },
      },
    ],
  ],
})
```

::

Nuxt uses [unjs/c12](https://github.com/unjs/c12) and [unjs/giget](https://github.com/unjs/giget) for extending remote layers. Check the documentation for more information and all available options.

## Layer Priority

When using multiple layers, it's important to understand the override order. Layers with **higher priority** override layers with lower priority when they define the same files or components.

The priority order from highest to lowest is:

1. **Your project files** - always have the highest priority
2. **Auto-scanned layers** from `~~/layers` directory - sorted alphabetically (Z has higher priority than A)
3. **Layers in `extends`** config - first entry has higher priority than second

### When to Use Each

- **`extends`** - Use for external dependencies (npm packages, remote repositories) or layers outside your project directory
- **`~~/layers` directory** - Use for local layers that are part of your project

::tip
If you need to control the order of auto-scanned layers, you can prefix them with numbers: `~/layers/1.z-layer`, `~/layers/2.a-layer`. This way `2.a-layer` will have higher priority than `1.z-layer`.
::

### Example

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    // Local layer outside the project
    '../base',
    // NPM package
    '@my-themes/awesome',
    // Remote repository
    'github:my-themes/awesome#v1',
  ],
})
```

If you also have `~~/layers/custom`, the priority order is:
- Your project files (highest)
- `~~/layers/custom`
- `../base`
- `@my-themes/awesome`
- `github:my-themes/awesome#v1` (lowest)

This means your project files will override any layer, and `~~/layers/custom` will override anything in `extends`.

::read-more{to="/docs/4.x/guide/going-further/layers"}
Read more about layers in the **Layer Author Guide**.
::

:video-accordion{title="Watch a video from Learn Vue about Nuxt Layers" videoId="lnFCM7c9f7I"}

:video-accordion{title="Watch a video from Alexander Lichter about Nuxt Layers" videoId="fr5yo3aVkfA"}

## Examples

::card-group
  ::card{icon="i-simple-icons-github" title="Content Wind" to="https://github.com/Atinux/content-wind" target="_blank"}
  A lightweight Nuxt theme to build a Markdown driven website. Powered by Nuxt Content, TailwindCSS and Iconify.
  ::
::
</file>

<file path="docs/1.getting-started/15.prerendering.md">
---
title: "Prerendering"
description: Nuxt allows pages to be statically rendered at build time to improve certain performance or SEO metrics
navigation.icon: i-lucide-file-code-2
---

Nuxt allows for select pages from your application to be rendered at build time. Nuxt will serve the prebuilt pages when requested instead of generating them on the fly.

:read-more{title="Nuxt rendering modes" to="/docs/4.x/guide/concepts/rendering"}

## Crawl-based Pre-rendering

Use the [`nuxt generate` command](/docs/4.x/api/commands/generate) to build and pre-render your application using the [Nitro](/docs/4.x/guide/concepts/server-engine) crawler. This command is similar to `nuxt build` with the `nitro.static` option set to `true`, or running `nuxt build --prerender`.

This will build your site, stand up a nuxt instance, and, by default, prerender the root page `/` along with any of your site's pages it links to, any of your site's pages they link to, and so on.

::code-group{sync="pm"}

```bash [npm]
npx nuxt generate
```

```bash [yarn]
yarn nuxt generate
```

```bash [pnpm]
pnpm nuxt generate
```

```bash [bun]
bun x nuxt generate
```

::

You can now deploy the `.output/public` directory to any static hosting service or preview it locally with `npx serve .output/public`.

Working of the Nitro crawler:

1. Load the HTML of your application's root route (`/`), any non-dynamic pages in your `~/pages` directory, and any other routes in the `nitro.prerender.routes` array.
2. Save the HTML and `payload.json` to the `~/.output/public/` directory to be served statically.
3. Find all anchor tags (`<a href="...">`) in the HTML to navigate to other routes.
4. Repeat steps 1-3 for each anchor tag found until there are no more anchor tags to crawl.

This is important to understand since pages that are not linked to a discoverable page can't be pre-rendered automatically.

::read-more{to="/docs/4.x/api/commands/generate#nuxt-generate"}
Read more about the `nuxt generate` command.
::

### Selective Pre-rendering

You can manually specify routes that [Nitro](/docs/4.x/guide/concepts/server-engine) will fetch and pre-render during the build or ignore routes that you don't want to pre-render like `/dynamic` in the `nuxt.config` file:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    prerender: {
      routes: ['/user/1', '/user/2'],
      ignore: ['/dynamic'],
    },
  },
})
```

You can combine this with the `crawlLinks` option to pre-render a set of routes that the crawler can't discover like your `/sitemap.xml` or `/robots.txt`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    prerender: {
      crawlLinks: true,
      routes: ['/sitemap.xml', '/robots.txt'],
    },
  },
})
```

Setting `nitro.prerender` to `true` is similar to `nitro.prerender.crawlLinks` to `true`.

::read-more{to="https://nitro.build/config#prerender"}
Read more about pre-rendering in the Nitro documentation.
::

Lastly, you can manually configure this using routeRules.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    // Set prerender to true to configure it to be prerendered
    '/rss.xml': { prerender: true },
    // Set it to false to configure it to be skipped for prerendering
    '/this-DOES-NOT-get-prerendered': { prerender: false },
    // Everything under /blog gets prerendered as long as it
    // is linked to from another page
    '/blog/**': { prerender: true },
  },
})
```

::read-more{to="https://nitro.build/config#routerules"}
Read more about Nitro's `routeRules` configuration.
::

As a shorthand, you can also configure this in a page file using [`defineRouteRules`](/docs/4.x/api/utils/define-route-rules).

::read-more{to="/docs/4.x/guide/going-further/experimental-features#inlinerouterules" icon="i-lucide-star"}
This feature is experimental and in order to use it you must enable the `experimental.inlineRouteRules` option in your `nuxt.config`.
::

```vue [app/pages/index.vue]
<script setup>
// Or set at the page level
defineRouteRules({
  prerender: true,
})
</script>

<template>
  <div>
    <h1>Homepage</h1>
    <p>Pre-rendered at build time</p>
  </div>
</template>
```

This will be translated to:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    '/': { prerender: true },
  },
})
```

## Runtime Prerender Configuration

### `prerenderRoutes`

You can use this at runtime within a [Nuxt context](/docs/4.x/guide/going-further/nuxt-app#the-nuxt-context) to add more routes for Nitro to prerender.

```vue [app/pages/index.vue]
<script setup>
prerenderRoutes(['/some/other/url'])
prerenderRoutes('/api/content/article/my-article')
</script>

<template>
  <div>
    <h1>This will register other routes for prerendering when prerendered</h1>
  </div>
</template>
```

:read-more{title="prerenderRoutes" to="/docs/4.x/api/utils/prerender-routes"}

### `prerender:routes` Nuxt hook

This is called before prerendering for additional routes to be registered.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    async 'prerender:routes' (ctx) {
      const { pages } = await fetch('https://api.some-cms.com/pages').then(
        res => res.json(),
      )
      for (const page of pages) {
        ctx.routes.add(`/${page.name}`)
      }
    },
  },
})
```

### `prerender:generate` Nitro hook

This is called for each route during prerendering. You can use this for fine-grained handling of each route that gets prerendered.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    hooks: {
      'prerender:generate' (route) {
        if (route.route?.includes('private')) {
          route.skip = true
        }
      },
    },
  },
})
```
</file>

<file path="docs/1.getting-started/16.deployment.md">
---
title: 'Deployment'
description: Learn how to deploy your Nuxt application to any hosting provider.
navigation.icon: i-lucide-cloud
---

A Nuxt application can be deployed on a Node.js server, pre-rendered for static hosting, or deployed to serverless or edge (CDN) environments.

::tip
If you are looking for a list of cloud providers that support Nuxt, see the [Hosting providers](/deploy) section.
::

## Node.js Server

Discover the Node.js server preset with Nitro to deploy on any Node hosting.

- **Default output format** if none is specified or auto-detected <br>
- Loads only the required chunks to render the request for optimal cold start timing <br>
- Useful for deploying Nuxt apps to any Node.js hosting

### Entry Point

When running `nuxt build` with the Node server preset, the result will be an entry point that launches a ready-to-run Node server.

```bash [Terminal]
node .output/server/index.mjs
```

This will launch your production Nuxt server that listens on port 3000 by default.

It respects the following runtime environment variables:

- `NITRO_PORT` or `PORT` (defaults to `3000`)
- `NITRO_HOST` or `HOST` (defaults to `'0.0.0.0'`)
- `NITRO_SSL_CERT` and `NITRO_SSL_KEY` - if both are present, this will launch the server in HTTPS mode. In the vast majority of cases, this should not be used other than for testing, and the Nitro server should be run behind a reverse proxy like nginx or Cloudflare which terminates SSL.

### PM2

[PM2](https://pm2.keymetrics.io/) (Process Manager 2) is a fast and easy solution for hosting your Nuxt application on your server or VM.

To use `pm2`, use an `ecosystem.config.cjs`:

```ts [ecosystem.config.cjs]
module.exports = {
  apps: [
    {
      name: 'NuxtAppName',
      port: '3000',
      exec_mode: 'cluster',
      instances: 'max',
      script: './.output/server/index.mjs',
    },
  ],
}
```

### Cluster Mode

You can use `NITRO_PRESET=node_cluster` in order to leverage multi-process performance using Node.js [cluster](https://nodejs.org/dist/latest/docs/api/cluster.html) module.

By default, the workload gets distributed to the workers with the round robin strategy.

### Learn More

:read-more{to="https://nitro.build/deploy/runtimes/node" title="the Nitro documentation for node-server preset"}

:video-accordion{title="Watch Daniel Roe's short video on the topic" videoId="0x1H6K5yOfs"}

## Static Hosting

There are two ways to deploy a Nuxt application to any static hosting services:

- Static site generation (SSG) with `ssr: true` pre-renders routes of your application at build time. (This is the default behavior when running `nuxt generate`.) It will also generate `/200.html` and `/404.html` single-page app fallback pages, which can render dynamic routes or 404 errors on the client (though you may need to configure this on your static host).
- Alternatively, you can prerender your site with `ssr: false` (static single-page app). This will produce HTML pages with an empty `<div id="__nuxt"></div>` where your Vue app would normally be rendered. You will lose many SEO benefits of prerendering your site, so it is suggested instead to use [`<ClientOnly>`](/docs/4.x/api/components/client-only) to wrap the portions of your site that cannot be server rendered (if any).

:read-more{title="Nuxt prerendering" to="/docs/4.x/getting-started/prerendering"}

### Client-side Only Rendering

If you don't want to pre-render your routes, another way of using static hosting is to set the `ssr` property to `false` in the `nuxt.config` file. The `nuxt generate` command will then output an `.output/public/index.html` entrypoint and JavaScript bundles like a classic client-side Vue.js application.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false,
})
```

## Hosting Providers

Nuxt can be deployed to several cloud providers with a minimal amount of configuration:

:read-more{to="/deploy"}

## Presets

In addition to Node.js servers and static hosting services, a Nuxt project can be deployed with several well-tested presets and minimal amount of configuration.

You can explicitly set the desired preset in the [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) file:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    preset: 'node-server',
  },
})
```

... or use the `NITRO_PRESET` environment variable when running `nuxt build`:

```bash [Terminal]
NITRO_PRESET=node-server nuxt build
```

🔎 Check [the Nitro deployment](https://nitro.build/deploy) for all possible deployment presets and providers.

## CDN Proxy

In most cases, Nuxt can work with third-party content that is not generated or created by Nuxt itself. But sometimes such content can cause problems, especially Cloudflare's "Minification and Security Options".

Accordingly, you should make sure that the following options are unchecked / disabled in Cloudflare. Otherwise, unnecessary re-rendering or hydration errors could impact your production application.

1. Speed > Optimization > Content Optimization > Disable "Rocket Loader™"
2. Speed > Optimization > Image Optimization > Disable "Mirage"
3. Scrape Shield > Disable "Email Address Obfuscation"

With these settings, you can be sure that Cloudflare won't inject scripts into your Nuxt application that may cause unwanted side effects.

::tip
Their location on the Cloudflare dashboard sometimes changes so don't hesitate to look around.
::
</file>

<file path="docs/1.getting-started/17.testing.md">
---
title: Testing
description: How to test your Nuxt application.
navigation.icon: i-lucide-circle-check
---

::tip
If you are a module author, you can find more specific information in the [Module Author's guide](/docs/4.x/guide/modules/testing).
::

Nuxt offers first-class support for end-to-end and unit testing of your Nuxt application via `@nuxt/test-utils`, a library of test utilities and configuration that currently powers the [tests we use on Nuxt itself](https://github.com/nuxt/nuxt/tree/main/test) and tests throughout the module ecosystem.

:video-accordion{title="Watch a video from Alexander Lichter about getting started with @nuxt/test-utils" videoId="yGzwk9xi9gU"}

## Installation

In order to allow you to manage your other testing dependencies, `@nuxt/test-utils` ships with various optional peer dependencies. For example:

- you can choose between `happy-dom` and `jsdom` for a runtime Nuxt environment
- you can choose between `vitest`, `cucumber`, `jest` and `playwright` for end-to-end test runners
- `playwright-core` is only required if you wish to use the built-in browser testing utilities (and are not using `@playwright/test` as your test runner)

::code-group{sync="pm"}
```bash [npm]
npm i --save-dev @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```
```bash [yarn]
yarn add --dev @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```
```bash [pnpm]
pnpm add -D @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```
```bash [bun]
bun add --dev @nuxt/test-utils vitest @vue/test-utils happy-dom playwright-core
```
::

## Unit Testing

We currently ship an environment for unit testing code that needs a [Nuxt](https://nuxt.com) runtime environment. It currently _only has support for `vitest`_ (although contribution to add other runtimes would be welcome).

### Setup

1. Add `@nuxt/test-utils/module` to your `nuxt.config` file (optional). It adds a Vitest integration to your Nuxt DevTools which supports running your unit tests in development.

   ```ts twoslash
   export default defineNuxtConfig({
     modules: [
       '@nuxt/test-utils/module',
     ],
   })
   ```

2. Create a `vitest.config.ts` with the following content:

   ```ts twoslash
   import { defineConfig } from 'vitest/config'
   import { defineVitestProject } from '@nuxt/test-utils/config'

   export default defineConfig({
     test: {
       projects: [
         {
           test: {
             name: 'unit',
             include: ['test/unit/*.{test,spec}.ts'],
             environment: 'node',
           },
         },
         {
           test: {
             name: 'e2e',
             include: ['test/e2e/*.{test,spec}.ts'],
             environment: 'node',
           },
         },
         await defineVitestProject({
           test: {
             name: 'nuxt',
             include: ['test/nuxt/*.{test,spec}.ts'],
             environment: 'nuxt',
           },
         }),
       ],
     },
   })
   ```

::tip
When importing `@nuxt/test-utils` in your vitest config, It is necessary to have `"type": "module"` specified in your `package.json` or rename your vitest config file appropriately.
> i.e., `vitest.config.m{ts,js}`.
::

::tip
It is possible to set environment variables for testing by using the `.env.test` file.
::

### Using a Nuxt Runtime Environment

Using [Vitest projects](https://vitest.dev/guide/projects.html#test-projects), you have fine-grained control over which tests run in which environment:

- **Unit tests**: Place regular unit tests in `test/unit/` - these run in a Node environment for speed
- **Nuxt tests**: Place tests that rely on the Nuxt runtime environment in `test/nuxt/` - these will run within a Nuxt runtime environment

#### Alternative: Simple Setup

If you prefer a simpler setup and want all tests to run in the Nuxt environment, you can use the basic configuration:

```ts twoslash
import { defineVitestConfig } from '@nuxt/test-utils/config'

export default defineVitestConfig({
  test: {
    environment: 'nuxt',
    // you can optionally set Nuxt-specific environment options
    // environmentOptions: {
    //   nuxt: {
    //     rootDir: fileURLToPath(new URL('./playground', import.meta.url)),
    //     domEnvironment: 'happy-dom', // 'happy-dom' (default) or 'jsdom'
    //     overrides: {
    //       // other Nuxt config you want to pass
    //     }
    //   }
    // }
  },
})
```

If you're using the simple setup with `environment: 'nuxt'` by default, you can opt _out_ of the [Nuxt environment](https://vitest.dev/guide/environment.html#test-environment) per test file as needed.

```ts twoslash
// @vitest-environment node
import { test } from 'vitest'

test('my test', () => {
  // ... test without Nuxt environment!
})
```

::warning
This approach is not recommended as it creates a hybrid environment where Nuxt Vite plugins run but the Nuxt entry and `nuxtApp` are not initialized. This can lead to hard-to-debug errors.
::

### Organizing Your Tests

With the project-based setup, you might organize your tests as follows:

```bash [Directory structure]
test/
├── e2e/
│   └── ssr.test.ts
├── nuxt/
│   ├── components.test.ts
│   └── composables.test.ts
├── unit/
│   └── utils.test.ts
```

You can of course opt for any test structure, but keeping the Nuxt runtime environment separated from Nuxt end-to-end tests is important for test stability.

#### TypeScript Support in Tests

By default, test files in `test/nuxt/` and `tests/nuxt/` directories are included in the [Nuxt app TypeScript context](/docs/4.x/guide/concepts/typescript#how-nuxt-uses-project-references). That means they will recognise Nuxt aliases (like `~/`, `@/`, `#imports`) and TypeScript will be aware of auto-imports that work in your Nuxt app.

::tip
This matches the recommended structure where only tests that need the Nuxt runtime environment are placed in these directories. Unit tests in other directories like `test/unit/` can be added manually if needed.
::

##### Adding other test directories

If you have tests in other directories that you will be running in the Nuxt Vitest environment, you can include them in the Nuxt app TypeScript context by adding them to your configuration:

<!-- @case-police-ignore tsConfig -->

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  typescript: {
    tsConfig: {
      include: [
        // this path is relative to the generated .nuxt/tsconfig.json
        '../test/other-nuxt-context/**/*',
      ],
    },
  },
})
```

::important
Unit tests should not depend on Nuxt runtime features like auto-imports or composables. Only add TypeScript path alias support if your tests import from your source files (e.g., `~/utils/helpers`), not for Nuxt-specific features.
::

#### Running Tests

With the project setup, you can run different test suites:

```bash
# Run all tests
npx vitest

# Run only unit tests
npx vitest --project unit

# Run only Nuxt tests
npx vitest --project nuxt

# Run tests in watch mode
npx vitest --watch
```

::warning
When you run your tests within the Nuxt environment, they will be running in a [`happy-dom`](https://github.com/capricorn86/happy-dom) or [`jsdom`](https://github.com/jsdom/jsdom) environment. Before your tests run, a global Nuxt app will be initialized (including, for example, running any plugins or code you've defined in your `app.vue`).

This means you should take particular care not to mutate the global state in your tests (or, if you need to, to reset it afterwards).
::

### 🎭 Built-In Mocks

`@nuxt/test-utils` provides some built-in mocks for the DOM environment.

#### `intersectionObserver`

Default `true`, creates a dummy class without any functionality for the IntersectionObserver API

#### `indexedDB`

Default `false`, uses [`fake-indexeddb`](https://github.com/dumbmatter/fakeIndexedDB) to create a functional mock of the IndexedDB API

These can be configured in the `environmentOptions` section of your `vitest.config.ts` file:

```ts twoslash
import { defineVitestConfig } from '@nuxt/test-utils/config'

export default defineVitestConfig({
  test: {
    environmentOptions: {
      nuxt: {
        mock: {
          intersectionObserver: true,
          indexedDb: true,
        },
      },
    },
  },
})
```

### 🛠️ Helpers

`@nuxt/test-utils` provides a number of helpers to make testing Nuxt apps easier.

#### `mountSuspended`

`mountSuspended` allows you to mount any Vue component within the Nuxt environment, allowing async setup and access to injections from your Nuxt plugins.

::note
Under the hood, `mountSuspended` wraps `mount` from `@vue/test-utils`, so you can check out [the Vue Test Utils documentation](https://test-utils.vuejs.org/guide/) for more on the options you can pass, and how to use this utility.
::

For example:

```ts twoslash
// @noErrors
import { expect, it } from 'vitest'
import type { Component } from 'vue'

declare module '#components' {
  export const SomeComponent: Component
}
// ---cut---
// tests/components/SomeComponents.nuxt.spec.ts
import { mountSuspended } from '@nuxt/test-utils/runtime'
import { SomeComponent } from '#components'

it('can mount some component', async () => {
  const component = await mountSuspended(SomeComponent)
  expect(component.text()).toMatchInlineSnapshot(
    '"This is an auto-imported component"',
  )
})
```

```ts twoslash
// @noErrors
import { expect, it } from 'vitest'
// ---cut---
// tests/components/SomeComponents.nuxt.spec.ts
import { mountSuspended } from '@nuxt/test-utils/runtime'
import App from '~/app.vue'

// tests/App.nuxt.spec.ts
it('can also mount an app', async () => {
  const component = await mountSuspended(App, { route: '/test' })
  expect(component.html()).toMatchInlineSnapshot(`
      "<div>This is an auto-imported component</div>
      <div> I am a global component </div>
      <div>/</div>
      <a href="/test"> Test link </a>"
    `)
})
```

#### `renderSuspended`

`renderSuspended` allows you to render any Vue component within the Nuxt environment using `@testing-library/vue`, allowing async setup and access to injections from your Nuxt plugins.

This should be used together with utilities from Testing Library, e.g. `screen` and `fireEvent`. Install [@testing-library/vue](https://testing-library.com/docs/vue-testing-library/intro/) in your project to use these.

Additionally, Testing Library also relies on testing globals for cleanup. You should turn these on in your [Vitest config](https://vitest.dev/config/globals).

The passed in component will be rendered inside a `<div id="test-wrapper"></div>`.

Examples:

```ts twoslash
// @noErrors
import { expect, it } from 'vitest'
import type { Component } from 'vue'

declare module '#components' {
  export const SomeComponent: Component
}
// ---cut---
// tests/components/SomeComponents.nuxt.spec.ts
import { renderSuspended } from '@nuxt/test-utils/runtime'
import { SomeComponent } from '#components'
import { screen } from '@testing-library/vue'

it('can render some component', async () => {
  await renderSuspended(SomeComponent)
  expect(screen.getByText('This is an auto-imported component')).toBeDefined()
})
```

```ts twoslash
// @noErrors
import { expect, it } from 'vitest'
// ---cut---
// tests/App.nuxt.spec.ts
import { renderSuspended } from '@nuxt/test-utils/runtime'
import App from '~/app.vue'

it('can also render an app', async () => {
  const html = await renderSuspended(App, { route: '/test' })
  expect(html).toMatchInlineSnapshot(`
    "<div id="test-wrapper">
      <div>This is an auto-imported component</div>
      <div> I am a global component </div>
      <div>Index page</div><a href="/test"> Test link </a>
    </div>"
  `)
})
```

#### `mockNuxtImport`

`mockNuxtImport` allows you to mock Nuxt's auto import functionality. For example, to mock `useStorage`, you can do so like this:

```ts twoslash
import { mockNuxtImport } from '@nuxt/test-utils/runtime'

mockNuxtImport('useStorage', () => {
  return () => {
    return { value: 'mocked storage' }
  }
})

// your tests here
```

::note
`mockNuxtImport` can only be used once per mocked import per test file. It is actually a macro that gets transformed to `vi.mock` and `vi.mock` is hoisted, as described [in the Vitest docs](https://vitest.dev/api/vi#vi-mock).
::

If you need to mock a Nuxt import and provide different implementations between tests, you can do it by creating and exposing your mocks using [`vi.hoisted`](https://vitest.dev/api/vi#vi-hoisted), and then use those mocks in `mockNuxtImport`. You then have access to the mocked imports, and can change the implementation between tests. Be careful to [restore mocks](https://vitest.dev/api/mock#mockrestore) before or after each test to undo mock state changes between runs.

```ts twoslash
import { vi } from 'vitest'
import { mockNuxtImport } from '@nuxt/test-utils/runtime'

const { useStorageMock } = vi.hoisted(() => {
  return {
    useStorageMock: vi.fn(() => {
      return { value: 'mocked storage' }
    }),
  }
})

mockNuxtImport('useStorage', () => {
  return useStorageMock
})

// Then, inside a test
useStorageMock.mockImplementation(() => {
  return { value: 'something else' }
})
```

#### `mockComponent`

`mockComponent` allows you to mock Nuxt's component.
The first argument can be the component name in PascalCase, or the relative path of the component.
The second argument is a factory function that returns the mocked component.

For example, to mock `MyComponent`, you can:

```ts twoslash
import { mockComponent } from '@nuxt/test-utils/runtime'

mockComponent('MyComponent', {
  props: {
    value: String,
  },
  setup (props) {
    // ...
  },
})

// relative path or alias also works
mockComponent('~/components/my-component.vue', () => {
  // or a factory function
  return defineComponent({
    setup (props) {
      // ...
    },
  })
})

// or you can use SFC for redirecting to a mock component
mockComponent('MyComponent', () => import('./MockComponent.vue'))

// your tests here
```

> **Note**: You can't reference local variables in the factory function since they are hoisted. If you need to access Vue APIs or other variables, you need to import them in your factory function.

```ts twoslash
import { mockComponent } from '@nuxt/test-utils/runtime'

mockComponent('MyComponent', async () => {
  const { ref, h } = await import('vue')

  return defineComponent({
    setup (props) {
      const counter = ref(0)
      return () => h('div', null, counter.value)
    },
  })
})
```

#### `registerEndpoint`

`registerEndpoint` allows you create Nitro endpoint that returns mocked data. It can come in handy if you want to test a component that makes requests to API to display some data.

The first argument is the endpoint name (e.g. `/test/`).
The second argument is a factory function that returns the mocked data.

For example, to mock `/test/` endpoint, you can do:

```ts twoslash
import { registerEndpoint } from '@nuxt/test-utils/runtime'

registerEndpoint('/test/', () => ({
  test: 'test-field',
}))
```

By default, your request will be made using the `GET` method. You may use another method by setting an object as the second argument instead of a function.

```ts twoslash
import { registerEndpoint } from '@nuxt/test-utils/runtime'

registerEndpoint('/test/', {
  method: 'POST',
  handler: () => ({ test: 'test-field' }),
})
```

> **Note**: If your requests in a component go to an external API, you can use `baseURL` and then make it empty using [Nuxt Environment Override Config](/docs/4.x/getting-started/configuration#environment-overrides) (`$test`) so all your requests will go to Nitro server.

#### Conflict with End-To-End Testing

`@nuxt/test-utils/runtime` and `@nuxt/test-utils/e2e` need to run in different testing environments and so can't be used in the same file.

If you would like to use both the end-to-end and unit testing functionality of `@nuxt/test-utils`, you can split your tests into separate files. You then either specify a test environment per-file with the special `// @vitest-environment nuxt` comment, or name your runtime unit test files with the `.nuxt.spec.ts` extension.

`app.nuxt.spec.ts`

```ts twoslash
import { mockNuxtImport } from '@nuxt/test-utils/runtime'

mockNuxtImport('useStorage', () => {
  return () => {
    return { value: 'mocked storage' }
  }
})
```

`app.e2e.spec.ts`

```ts twoslash
import { $fetch, setup } from '@nuxt/test-utils/e2e'

await setup({
  setupTimeout: 10000,
})

// ...
```

### Using `@vue/test-utils`

If you prefer to use `@vue/test-utils` on its own for unit testing in Nuxt, and you are only testing components which do not rely on Nuxt composables, auto-imports or context, you can follow these steps to set it up.

1. Install the needed dependencies

   ::code-group{sync="pm"}
   ```bash [npm]
   npm i --save-dev vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ```
   ```bash [yarn]
   yarn add --dev vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ```
   ```bash [pnpm]
   pnpm add -D vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ```
   ```bash [bun]
   bun add --dev vitest @vue/test-utils happy-dom @vitejs/plugin-vue
   ```
   ::

2. Create a `vitest.config.ts` with the following content:

   ```ts
   import { defineConfig } from 'vitest/config'
   import vue from '@vitejs/plugin-vue'

   export default defineConfig({
     plugins: [vue()],
     test: {
       environment: 'happy-dom',
     },
   })
   ```

3. Add a new command for test in your `package.json`

   ```json
   "scripts": {
     "build": "nuxt build",
     "dev": "nuxt dev",
     ...
     "test": "vitest"
   },
   ```

4. Create a simple `<HelloWorld>` component `app/components/HelloWorld.vue` with the following content:

   ```vue
   <template>
     <p>Hello world</p>
   </template>
   ```

5. Create a simple unit test for this newly created component `~/components/HelloWorld.spec.ts`

   ```ts twoslash
   import { describe, expect, it } from 'vitest'
   import { mount } from '@vue/test-utils'

   import HelloWorld from './HelloWorld.vue'

   describe('HelloWorld', () => {
     it('component renders Hello world properly', () => {
       const wrapper = mount(HelloWorld)
       expect(wrapper.text()).toContain('Hello world')
     })
   })
   ```

6. Run vitest command

   ::code-group{sync="pm"}
   ```bash [npm]
   npm run test
   ```
   ```bash [yarn]
   yarn test
   ```
   ```bash [pnpm]
   pnpm run test
   ```
   ```bash [bun]
   bun run test
   ```
   ::

Congratulations, you're all set to start unit testing with `@vue/test-utils` in Nuxt! Happy testing!

## End-To-End Testing

For end-to-end testing, we support [Vitest](https://github.com/vitest-dev/vitest), [Jest](https://jestjs.io), [Cucumber](https://cucumber.io/) and [Playwright](https://playwright.dev/) as test runners.

### Setup

In each `describe` block where you are taking advantage of the `@nuxt/test-utils/e2e` helper methods, you will need to set up the test context before beginning.

```ts twoslash [test/my-test.spec.ts]
import { describe, test } from 'vitest'
import { $fetch, setup } from '@nuxt/test-utils/e2e'

describe('My test', async () => {
  await setup({
    // test context options
  })

  test('my test', () => {
    // ...
  })
})
```

Behind the scenes, `setup` performs a number of tasks in `beforeAll`, `beforeEach`, `afterEach` and `afterAll` to set up the Nuxt test environment correctly.

Please use the options below for the `setup` method.

#### Nuxt Config

- `rootDir`: Path to a directory with a Nuxt app to be put under test.
  - Type: `string`
  - Default: `'.'`
- `configFile`: Name of the configuration file.
  - Type: `string`
  - Default: `'nuxt.config'`

<!--
- `config`: Object with configuration overrides.
  - Type: `NuxtConfig`
  - Default: `{}` -->

#### Timings

- `setupTimeout`: The amount of time (in milliseconds) to allow for `setupTest` to complete its work (which could include building or generating files for a Nuxt application, depending on the options that are passed).
  - Type: `number`
  - Default: `120000` or `240000` on windows

- `teardownTimeout`: The amount of time (in milliseconds) to allow tearing down the test environment, such as closing the browser.
  - Type: `number`
  - Default: `30000`

#### Features

- `build`: Whether to run a separate build step.
  - Type: `boolean`
  - Default: `true` (`false` if `browser` or `server` is disabled, or if a `host` is provided)

- `server`: Whether to launch a server to respond to requests in the test suite.
  - Type: `boolean`
  - Default: `true` (`false` if a `host` is provided)

- `port`: If provided, set the launched test server port to the value.
  - Type: `number | undefined`
  - Default: `undefined`

- `host`: If provided, a URL to use as the test target instead of building and running a new server. Useful for running "real" end-to-end tests against a deployed version of your application, or against an already running local server (which may provide a significant reduction in test execution timings). See the [target host end-to-end example below](/docs/4.x/getting-started/testing#target-host-end-to-end-example).
  - Type: `string`
  - Default: `undefined`

- `browser`: Under the hood, Nuxt test utils uses [`playwright`](https://playwright.dev) to carry out browser testing. If this option is set, a browser will be launched and can be controlled in the subsequent test suite.
  - Type: `boolean`
  - Default: `false`
- `browserOptions`
  - Type: `object` with the following properties
    - `type`: The type of browser to launch - either `chromium`, `firefox` or `webkit`
    - `launch`: `object` of options that will be passed to playwright when launching the browser. See [full API reference](https://playwright.dev/docs/api/class-browsertype#browser-type-launch).
- `runner`: Specify the runner for the test suite. Currently, [Vitest](https://vitest.dev) is recommended.
  - Type: `'vitest' | 'jest' | 'cucumber'`
  - Default: `'vitest'`

##### Target `host` end-to-end example

A common use-case for end-to-end testing is running the tests against a deployed application running in the same environment typically used for Production.

For local development or automated deploy pipelines, testing against a separate local server can be more efficient and is typically faster than allowing the test framework to rebuild between tests.

To utilize a separate target host for end-to-end tests, simply provide the `host` property of the `setup` function with the desired URL.

```ts
import { createPage, setup } from '@nuxt/test-utils/e2e'
import { describe, expect, it } from 'vitest'

describe('login page', async () => {
  await setup({
    host: 'http://localhost:8787',
  })

  it('displays the email and password fields', async () => {
    const page = await createPage('/login')
    expect(await page.getByTestId('email').isVisible()).toBe(true)
    expect(await page.getByTestId('password').isVisible()).toBe(true)
  })
})
```

### APIs

#### `$fetch(url)`

Get the HTML of a server-rendered page.

```ts twoslash
import { $fetch } from '@nuxt/test-utils/e2e'

const html = await $fetch('/')
```

#### `fetch(url)`

Get the response of a server-rendered page.

```ts twoslash
import { fetch } from '@nuxt/test-utils/e2e'

const res = await fetch('/')
const { body, headers } = res
```

#### `url(path)`

Get the full URL for a given page (including the port the test server is running on.)

```ts twoslash
import { url } from '@nuxt/test-utils/e2e'

const pageUrl = url('/page')
// 'http://localhost:6840/page'
```

### Testing in a Browser

We provide built-in support using Playwright within `@nuxt/test-utils`, either programmatically or via the Playwright test runner.

#### `createPage(url)`

Within `vitest`, `jest` or `cucumber`, you can create a configured Playwright browser instance with `createPage`, and (optionally) point it at a path from the running server. You can find out more about the API methods available from [in the Playwright documentation](https://playwright.dev/docs/api/class-page).

```ts twoslash
import { createPage } from '@nuxt/test-utils/e2e'

const page = await createPage('/page')
// you can access all the Playwright APIs from the `page` variable
```

#### Testing with Playwright Test Runner

We also provide first-class support for testing Nuxt within [the Playwright test runner](https://playwright.dev/docs/intro).

::code-group{sync="pm"}
```bash [npm]
npm i --save-dev @playwright/test @nuxt/test-utils
```
```bash [yarn]
yarn add --dev @playwright/test @nuxt/test-utils
```
```bash [pnpm]
pnpm add -D @playwright/test @nuxt/test-utils
```
```bash [bun]
bun add --dev @playwright/test @nuxt/test-utils
```
::

You can provide global Nuxt configuration, with the same configuration details as the `setup()` function mentioned earlier in this section.

```ts [playwright.config.ts]
import { fileURLToPath } from 'node:url'
import { defineConfig, devices } from '@playwright/test'
import type { ConfigOptions } from '@nuxt/test-utils/playwright'

export default defineConfig<ConfigOptions>({
  use: {
    nuxt: {
      rootDir: fileURLToPath(new URL('.', import.meta.url)),
    },
  },
  // ...
})
```

::read-more{title="See full example config" to="https://github.com/nuxt/test-utils/blob/main/examples/app-playwright/playwright.config.ts" target="_blank"}
::

Your test file should then use `expect` and `test` directly from `@nuxt/test-utils/playwright`:

```ts [tests/example.test.ts]
import { expect, test } from '@nuxt/test-utils/playwright'

test('test', async ({ page, goto }) => {
  await goto('/', { waitUntil: 'hydration' })
  await expect(page.getByRole('heading')).toHaveText('Welcome to Playwright!')
})
```

You can alternatively configure your Nuxt server directly within your test file:

```ts [tests/example.test.ts]
import { expect, test } from '@nuxt/test-utils/playwright'

test.use({
  nuxt: {
    rootDir: fileURLToPath(new URL('..', import.meta.url)),
  },
})

test('test', async ({ page, goto }) => {
  await goto('/', { waitUntil: 'hydration' })
  await expect(page.getByRole('heading')).toHaveText('Welcome to Playwright!')
})
```
</file>

<file path="docs/1.getting-started/18.upgrade.md">
---
title: Upgrade Guide
description: 'Learn how to upgrade to the latest Nuxt version.'
navigation.icon: i-lucide-circle-arrow-up
---

## Upgrading Nuxt

### Latest release

To upgrade Nuxt to the [latest release](https://github.com/nuxt/nuxt/releases), use the `nuxt upgrade` command.

::code-group{sync="pm"}

```bash [npm]
npx nuxt upgrade
```

```bash [yarn]
yarn nuxt upgrade
```

```bash [pnpm]
pnpm nuxt upgrade
```

```bash [bun]
bun x nuxt upgrade
```

::

### Nightly Release Channel

To use the latest Nuxt build and test features before their release, read about the [nightly release channel](/docs/4.x/guide/going-further/nightly-release-channel) guide.

## Testing Nuxt 5

Nuxt 5 is **currently in development**. Until the release, it is possible to test many of Nuxt 5's breaking changes from Nuxt version 4.2+.

### Opting in to Nuxt 5

First, upgrade Nuxt to the [latest release](https://github.com/nuxt/nuxt/releases).

Then you can set your `future.compatibilityVersion` to match Nuxt 5 behavior:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  future: {
    compatibilityVersion: 5,
  },
})
```

When you set your `future.compatibilityVersion` to `5`, defaults throughout your Nuxt configuration will change to opt in to Nuxt v5 behavior, including:

- **Vite Environment API**: Automatically enables the new [Vite Environment API](/docs/4.x/getting-started/upgrade#migration-to-vite-environment-api) for improved build configuration
- Other Nuxt 5 improvements and changes as they become available

::note
This section is subject to change until the final release, so please check back here regularly if you are testing Nuxt 5 using `future.compatibilityVersion: 5`.
::

Breaking or significant changes will be noted below along with migration steps for backward/forward compatibility.

### Migration to Vite Environment API

🚦 **Impact Level**: Medium

#### What Changed

Nuxt 5 migrates to Vite 6's new [Environment API](https://vite.dev/guide/api-environment), which formalizes the concept of environments and provides better control over configuration per environment.

Previously, Nuxt used separate client and server Vite configurations. Now, Nuxt uses a shared Vite configuration with environment-specific plugins that use the `applyToEnvironment()` method to target specific environments.

::tip
You can test this feature early by setting `future.compatibilityVersion: 5` (see [Testing Nuxt 5](/docs/4.x/getting-started/upgrade#testing-nuxt-5)) or by enabling it explicitly with `experimental.viteEnvironmentApi: true`.
::

**Key changes:**

1. **Deprecated environment-specific `extendViteConfig()`**: The `server` and `client` options in `extendViteConfig()` are deprecated and will show warnings when used.

2. **Changed plugin registration**: Vite plugins registered with `addVitePlugin()` and only targeting one environment (by passing `server: false` or `client: false`) will not have their `config` or `configResolved` hooks called.

3. **Shared configuration**: The `vite:extendConfig` and `vite:configResolved` hooks now work with a shared configuration rather than separate client/server configs.

#### Reasons for Change

The Vite Environment API provides:
- Better consistency between development and production builds
- More granular control over environment-specific configuration
- Improved performance and plugin architecture
- Support for custom environments beyond just client and server

#### Migration Steps

##### 1. Migrate to use Vite plugins

We would recommend you use a Vite plugin instead of `extendViteConfig`, `vite:configResolved` and `vite:extendConfig`.

```ts
// Before
extendViteConfig((config) => {
  config.optimizeDeps.include.push('my-package')
}, { server: false })

nuxt.hook('vite:extendConfig' /* or vite:configResolved */, (config, { isClient }) => {
  if (isClient) {
    config.optimizeDeps.include.push('my-package')
  }
})

// After
addVitePlugin(() => ({
  name: 'my-plugin',
  config (config) {
    // you can set global vite configuration here
  },
  configResolved (config) {
    // you can access the fully resolved vite configuration here
  },
  configEnvironment (name, config) {
    // you can set environment-specific vite configuration here
    if (name === 'client') {
      config.optimizeDeps ||= {}
      config.optimizeDeps.include ||= []
      config.optimizeDeps.include.push('my-package')
    }
  },
  applyToEnvironment (environment) {
    return environment.name === 'client'
  },
}))
```

##### 2. Migrate Vite plugins to use environments

Instead of using `addVitePlugin` with `server: false` or `client: false`, you can instead use the new `applyToEnvironment` hook within your plugin.

```ts
// Before
addVitePlugin(() => ({
  name: 'my-plugin',
  config (config) {
    config.optimizeDeps.include.push('my-package')
  },
}), { client: false })

// After
addVitePlugin(() => ({
  name: 'my-plugin',
  config (config) {
    // you can set global vite configuration here
  },
  configResolved (config) {
    // you can access the fully resolved vite configuration here
  },
  configEnvironment (name, config) {
    // you can set environment-specific vite configuration here
    if (name === 'client') {
      config.optimizeDeps ||= {}
      config.optimizeDeps.include ||= []
      config.optimizeDeps.include.push('my-package')
    }
  },
  applyToEnvironment (environment) {
    return environment.name === 'client'
  },
}))
```

::read-more{to="https://vite.dev/guide/api-environment" target="_blank"}
Learn more about Vite's Environment API
::

## Migrating to Nuxt 4

Nuxt 4 includes significant improvements and changes. This guide will help you migrate your existing Nuxt 3 application to Nuxt 4.

First, upgrade to Nuxt 4:

::code-group{sync="pm"}

```bash [npm]
npm install nuxt@^4.0.0
```

```bash [yarn]
yarn add nuxt@^4.0.0
```

```bash [pnpm]
pnpm add nuxt@^4.0.0
```

```bash [bun]
bun add nuxt@^4.0.0
```

::

After upgrading, most Nuxt 4 behaviors are now the default. However, some features can still be configured if you need to maintain backward compatibility during your migration.

The following sections detail the key changes and migrations needed when upgrading to Nuxt 4.

Breaking or significant changes are documented below along with migration steps and available configuration options.

### Migrating Using Codemods

To facilitate the upgrade process, we have collaborated with the [Codemod](https://github.com/codemod/codemod) team to automate many migration steps with some open-source codemods.

::note
If you encounter any issues, please report them to the Codemod team with `npx codemod feedback` 🙏
::

For a complete list of Nuxt 4 codemods, detailed information on each, their source, and various ways to run them, visit the [Codemod Registry](https://app.codemod.com/registry).

You can run all the codemods mentioned in this guide using the following `codemod` recipe:

::code-group

```bash [npm]
# Using pinned version due to https://github.com/codemod/codemod/issues/1710
npx codemod@0.18.7 nuxt/4/migration-recipe
```

```bash [yarn]
# Using pinned version due to https://github.com/codemod/codemod/issues/1710
yarn dlx codemod@0.18.7 nuxt/4/migration-recipe
```

```bash [pnpm]
# Using pinned version due to https://github.com/codemod/codemod/issues/1710
pnpm dlx codemod@0.18.7 nuxt/4/migration-recipe
```

```bash [bun]
# Using pinned version due to https://github.com/codemod/codemod/issues/1710
bun x codemod@0.18.7 nuxt/4/migration-recipe
```

::

This command will execute all codemods in sequence, with the option to deselect any that you do not wish to run. Each codemod is also listed below alongside its respective change and can be executed independently.

### New Directory Structure

🚦 **Impact Level**: Significant

Nuxt now defaults to a new directory structure, with backwards compatibility (so if Nuxt detects you are using the old structure, such as with a top-level `app/pages/` directory, this new structure will not apply).

👉 [See full RFC](https://github.com/nuxt/nuxt/issues/26444)

#### What Changed

- the new Nuxt default `srcDir` is `app/` by default, and most things are resolved from there.
- `serverDir` now defaults to `<rootDir>/server` rather than `<srcDir>/server`
- `layers/`, `modules/` and `public/` are resolved relative to `<rootDir>` by default
- if using [Nuxt Content v2.13+](https://github.com/nuxt/content/pull/2649), `content/` is resolved relative to `<rootDir>`
- a new `dir.app` is added, which is the directory we look for `router.options.ts` and `spa-loading-template.html` - this defaults to `<srcDir>/`

<details>

<summary>An example v4 folder structure.</summary>

```sh
.output/
.nuxt/
app/
  assets/
  components/
  composables/
  layouts/
  middleware/
  pages/
  plugins/
  utils/
  app.config.ts
  app.vue
  router.options.ts
content/
layers/
modules/
node_modules/
public/
shared/
server/
  api/
  middleware/
  plugins/
  routes/
  utils/
nuxt.config.ts
```

::note
With this new structure, the `~` alias now points to the `app/` directory by default (your `srcDir`). This means `~/components` resolves to `app/components/`, `~/pages` to `app/pages/`, etc.
::

</details>

👉 For more details, see the [PR implementing this change](https://github.com/nuxt/nuxt/pull/27029).

#### Reasons for Change

1. **Performance** - placing all your code in the root of your repo causes issues with `.git/` and `node_modules/` folders being scanned/included by FS watchers which can significantly delay startup on non-Mac OSes.
1. **IDE type-safety** - `server/` and the rest of your app are running in two entirely different contexts with different global imports available, and making sure `server/` isn't _inside_ the same folder as the rest of your app is a big first step to ensuring you get good auto-completes in your IDE.

:video-accordion{title="Watch a video from Vue School on the new directory structure" videoId="1031028378" platform="vimeo"}

#### Migration Steps

1. Create a new directory called `app/`.
1. Move your `assets/`, `components/`, `composables/`, `app/layouts/`, `app/middleware/`, `app/pages/`, `app/plugins/` and `utils/` folders under it, as well as `app.vue`, `error.vue`, `app.config.ts`. If you have an `app/router-options.ts` or `app/spa-loading-template.html`, these paths remain the same.
1. Make sure your `nuxt.config.ts`, `content/`, `layers/`, `modules/`, `public/` and `server/` folders remain outside the `app/` folder, in the root of your project.
1. Remember to update any third-party configuration files to work with the new directory structure, such as your `tailwindcss` or `eslint` configuration (if required - `@nuxtjs/tailwindcss` should automatically configure `tailwindcss` correctly).

::tip
You can automate this migration by running `npx codemod@latest nuxt/4/file-structure`
::

However, migration is _not required_. If you wish to keep your current folder structure, Nuxt should auto-detect it. (If it does not, please raise an issue.) The one exception is that if you _already_ have a custom `srcDir`. In this case, you should be aware that your `modules/`, `public/` and `server/` folders will be resolved from your `rootDir` rather than from your custom `srcDir`. You can override this by configuring `dir.modules`, `dir.public` and `serverDir` if you need to.

You can also force a v3 folder structure with the following configuration:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // This reverts the new srcDir default from `app` back to your root directory
  srcDir: '.',
  // This specifies the directory prefix for `router.options.ts` and `spa-loading-template.html`
  dir: {
    app: 'app',
  },
})
```

### Singleton Data Fetching Layer

🚦 **Impact Level**: Moderate

#### What Changed

Nuxt's data fetching system (`useAsyncData` and `useFetch`) has been significantly reorganized for better performance and consistency:

1. **Shared refs for the same key**: All calls to `useAsyncData` or `useFetch` with the same key now share the same `data`, `error` and `status` refs. This means that it is important that all calls with an explicit key must not have conflicting `deep`, `transform`, `pick`, `getCachedData` or `default` options.

2. **More control over `getCachedData`**: The `getCachedData` function is now called every time data is fetched, even if this is caused by a watcher or calling `refreshNuxtData`. (Previously, new data was always fetched and this function was not called in these cases.) To allow more control over when to use cached data and when to refetch, the function now receives a context object with the cause of the request.

3. **Reactive key support**: You can now use computed refs, plain refs or getter functions as keys, which enables automatic data refetching (and stores data separately).

4. **Data cleanup**: When the last component using data fetched with `useAsyncData` is unmounted, Nuxt will remove that data to avoid ever-growing memory usage.

#### Reasons for Change

These changes have been made to improve memory usage and increase consistency with loading states across calls of `useAsyncData`.

#### Migration Steps

1. **Check for inconsistent options**: Review any components using the same key with different options or fetch functions.

   ```ts
   // This will now trigger a warning
   const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
   const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })
   ```

   It may be beneficial to extract any calls to `useAsyncData` that share an explicit key (and have custom options) into their own composable:

   ```ts [app/composables/useUserData.ts]
   export function useUserData (userId: string) {
     return useAsyncData(
       `user-${userId}`,
       () => fetchUser(userId),
       {
         deep: true,
         transform: user => ({ ...user, lastAccessed: new Date() }),
       },
     )
   }
   ```

2. **Update `getCachedData` implementations**:

   ```diff
   useAsyncData('key', fetchFunction, {
   -  getCachedData: (key, nuxtApp) => {
   -    return cachedData[key]
   -  }
   +  getCachedData: (key, nuxtApp, ctx) => {
   +    // ctx.cause - can be 'initial' | 'refresh:hook' | 'refresh:manual' | 'watch'
   +    
   +    // Example: Don't use cache on manual refresh
   +    if (ctx.cause === 'refresh:manual') return undefined
   +    
   +    return cachedData[key]
   +  }
   })
   ```

Alternatively, for now, you can disable this behaviour with:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    granularCachedData: false,
    purgeCachedData: false,
  },
})
```

### Corrected Module Loading Order in Layers

🚦 **Impact Level**: Minimal

#### What Changed

The order in which modules are loaded when using [Nuxt layers](/docs/4.x/guide/going-further/layers) has been corrected. Previously, modules from the project root were loaded before modules from extended layers, which was the reverse of the expected behavior.

Now modules are loaded in the correct order:

1. **Layer modules first** (in extend order - deeper layers first)
2. **Project modules last** (highest priority)

This affects both:
- Modules defined in the `modules` array in `nuxt.config.ts`
- Auto-discovered modules from the `modules/` directory

#### Reasons for Change

This change ensures that:
- Extended layers have lower priority than the consuming project
- Module execution order matches the intuitive layer inheritance pattern
- Module configuration and hooks work as expected in multi-layer setups

#### Migration Steps

**Most projects will not need changes**, as this corrects the loading order to match expected behavior.

However, if your project was relying on the previous incorrect order, you may need to:

1. **Review module dependencies**: Check if any modules depend on specific loading order
2. **Adjust module configuration**: If modules were configured to work around the incorrect order
3. **Test thoroughly**: Ensure all functionality works as expected with the corrected order

Example of the new correct order:
```ts
// Layer: my-layer/nuxt.config.ts
export default defineNuxtConfig({
  modules: ['layer-module-1', 'layer-module-2'],
})

// Project: nuxt.config.ts
export default defineNuxtConfig({
  extends: ['./my-layer'],
  modules: ['project-module-1', 'project-module-2'],
})

// Loading order (corrected):
// 1. layer-module-1
// 2. layer-module-2
// 3. project-module-1 (can override layer modules)
// 4. project-module-2 (can override layer modules)
```

If you encounter issues with module order dependencies due to needing to register a hook, consider using the [`modules:done` hook](/docs/4.x/guide/modules/recipes-advanced) for modules that need to call a hook. This is run after all other modules have been loaded, which means it is safe to use.

👉 See [PR #31507](https://github.com/nuxt/nuxt/pull/31507) and [issue #25719](https://github.com/nuxt/nuxt/issues/25719) for more details.

### Deduplication of Route Metadata

🚦 **Impact Level**: Minimal

#### What Changed

It's possible to set some route metadata using `definePageMeta`, such as the `name`, `path`, and so on. Previously these were available both on the route and on route metadata (for example, `route.name` and `route.meta.name`).

Now, they are only accessible on the route object.

#### Reasons for Change

This is a result of enabling `experimental.scanPageMeta` by default, and is a performance optimization.

#### Migration Steps

The migration should be straightforward:

```diff
  const route = useRoute()
  
- console.log(route.meta.name)
+ console.log(route.name)
```

### Normalized Component Names

🚦 **Impact Level**: Moderate

Vue will now generate component names that match the Nuxt pattern for component naming.

#### What Changed

By default, if you haven't set it manually, Vue will assign a component name that matches
the filename of the component.

```bash [Directory structure]
├─ components/
├─── SomeFolder/
├───── MyComponent.vue
```

In this case, the component name would be `MyComponent`, as far as Vue is concerned. If you wanted to use `<KeepAlive>` with it, or identify it in the Vue DevTools, you would need to use this name.

But in order to auto-import it, you would need to use `SomeFolderMyComponent`.

With this change, these two values will match, and Vue will generate a component name that matches the Nuxt pattern for component naming.

#### Migration Steps

Ensure that you use the updated name in any tests which use `findComponent` from `@vue/test-utils` and in any `<KeepAlive>` which depends on the name of your component.

Alternatively, for now, you can disable this behaviour with:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    normalizeComponentNames: false,
  },
})
```

### Unhead v2

🚦 **Impact Level**: Minimal

#### What Changed

[Unhead](https://unhead.unjs.io/), used to generate `<head>` tags, has been updated to version 2. While mostly compatible it includes several breaking changes
for lower-level APIs.

- Removed props: `vmid`, `hid`, `children`, `body`.
- Promise input no longer supported.
- Tags are now sorted using Capo.js by default.

#### Migration Steps

The above changes should have minimal impact on your app.

If you have issues you should verify:

- You're not using any of the removed props.

```diff
useHead({
  meta: [{ 
    name: 'description', 
    // meta tags don't need a vmid, or a key    
-   vmid: 'description' 
-   hid: 'description'
  }]
})
```

- If you're using [Template Params](https://unhead.unjs.io/docs/head/guides/plugins/template-params) or [Alias Tag Sorting](https://unhead.unjs.io/docs/head/guides/plugins/alias-sorting), you will need to explicitly opt in to these features now.

```ts
import { AliasSortingPlugin, TemplateParamsPlugin } from '@unhead/vue/plugins'

export default defineNuxtPlugin({
  setup () {
    const unhead = injectHead()
    unhead.use(TemplateParamsPlugin)
    unhead.use(AliasSortingPlugin)
  },
})
```

While not required it's recommended to update any imports from `@unhead/vue` to `#imports` or `nuxt/app`.

```diff
-import { useHead } from '@unhead/vue'
+import { useHead } from '#imports'
```

If you still have issues you may revert to the v1 behavior by enabling the `head.legacy` config.

```ts
export default defineNuxtConfig({
  unhead: {
    legacy: true,
  },
})
```

### New DOM Location for SPA Loading Screen

🚦 **Impact Level**: Minimal

#### What Changed

When rendering a client-only page (with `ssr: false`), we optionally render a loading screen (from `~/app/spa-loading-template.html` - note that this has also changed to `~/spa-loading-template.html` in Nuxt 4), within the Nuxt app root:

```html
<div id="__nuxt">
  <!-- spa loading template -->
</div>
```

Now, we default to rendering the template alongside the Nuxt app root:

```html
<div id="__nuxt"></div>
<!-- spa loading template -->
```

#### Reasons for Change

This allows the spa loading template to remain in the DOM until the Vue app suspense resolves, preventing a flash of white.

#### Migration Steps

If you were targeting the spa loading template with CSS or `document.queryElement` you will need to update your selectors. For this purpose you can use the new `app.spaLoaderTag` and `app.spaLoaderAttrs` configuration options.

Alternatively, you can revert to the previous behaviour with:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    spaLoadingTemplateLocation: 'within',
  },
})
```

### Parsed `error.data`

🚦 **Impact Level**: Minimal

It was possible to throw an error with a `data` property, but this was not parsed. Now, it is parsed and made available in the `error` object. Although a fix, this is technically a breaking change if you were relying on the previous behavior and parsing it manually.

#### Migration Steps

Update your custom `error.vue` to remove any additional parsing of `error.data`:

```diff
  <script setup lang="ts">
  import type { NuxtError } from '#app'

  const props = defineProps({
    error: Object as () => NuxtError
  })

- const data = JSON.parse(error.data)
+ const data = error.data
  </script>
```

### More Granular Inline Styles

🚦 **Impact Level**: Moderate

Nuxt will now only inline styles for Vue components, not global CSS.

#### What Changed

Previously, Nuxt would inline all CSS, including global styles, and remove `<link>` elements to separate CSS files. Now, Nuxt will only do this for Vue components (which previously produced separate chunks of CSS). We think this is a better balance of reducing separate network requests (just as before, there will not be separate requests for individual `.css` files per-page or per-component on the initial load), as well as allowing caching of a single global CSS file and reducing the document download size of the initial request.

#### Migration Steps

This feature is fully configurable and you can revert to the previous behavior by setting `inlineStyles: true` to inline global CSS as well as per-component CSS.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  features: {
    inlineStyles: true,
  },
})
```

### Scan Page Meta After Resolution

🚦 **Impact Level**: Minimal

#### What Changed

We now scan page metadata (defined in `definePageMeta`) _after_ calling the `pages:extend` hook rather than before.

#### Reasons for Change

This was to allow scanning metadata for pages that users wanted to add in `pages:extend`. We still offer an opportunity to change or override page metadata in a new `pages:resolved` hook.

#### Migration Steps

If you want to override page metadata, do that in `pages:resolved` rather than in `pages:extend`.

```diff
  export default defineNuxtConfig({
    hooks: {
-     'pages:extend'(pages) {
+     'pages:resolved'(pages) {
        const myPage = pages.find(page => page.path === '/')
        myPage.meta ||= {}
        myPage.meta.layout = 'overridden-layout'
      }
    }
  })
```

Alternatively, you can revert to the previous behaviour with:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    scanPageMeta: true,
  },
})
```

### Shared Prerender Data

🚦 **Impact Level**: Medium

#### What Changed

We enabled a previously experimental feature to share data from `useAsyncData` and `useFetch` calls, across different pages. See [original PR](https://github.com/nuxt/nuxt/pull/24894).

#### Reasons for Change

This feature automatically shares payload _data_ between pages that are prerendered. This can result in a significant performance improvement when prerendering sites that use `useAsyncData` or `useFetch` and fetch the same data in different pages.

For example, if your site requires a `useFetch` call for every page (for example, to get navigation data for a menu, or site settings from a CMS), this data would only be fetched once when prerendering the first page that uses it, and then cached for use when prerendering other pages.

#### Migration Steps

Make sure that any unique key of your data is always resolvable to the same data. For example, if you are using `useAsyncData` to fetch data related to a particular page, you should provide a key that uniquely matches that data. (`useFetch` should do this automatically for you.)

```ts [app/pages/test/[slug\\].vue]
// This would be unsafe in a dynamic page (e.g. `[slug].vue`) because the route slug makes a difference
// to the data fetched, but Nuxt can't know that because it's not reflected in the key.
const route = useRoute()
const { data } = await useAsyncData(async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
// Instead, you should use a key that uniquely identifies the data fetched.
const { data } = await useAsyncData(route.params.slug, async () => {
  return await $fetch(`/api/my-page/${route.params.slug}`)
})
```

Alternatively, you can disable this feature with:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false,
  },
})
```

### Default `data` and `error` values in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Minimal

#### What Changed

`data` and `error` objects returned from `useAsyncData` will now default to `undefined`.

#### Reasons for Change

Previously `data` was initialized to `null` but reset in `clearNuxtData` to `undefined`. `error` was initialized to `null`. This change is to bring greater consistency.

#### Migration Steps

If you were checking if `data.value` or `error.value` were `null`, you can update these checks to check for `undefined` instead.

::tip
You can automate this step by running `npx codemod@latest nuxt/4/default-data-error-value`
::

### Removal of deprecated `boolean` values for `dedupe` option when calling `refresh` in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Minimal

#### What Changed

Previously it was possible to pass `dedupe: boolean` to `refresh`. These were aliases of `cancel` (`true`) and `defer` (`false`).

```ts twoslash [app/app.vue]
// @errors: 2322
const { refresh } = await useAsyncData(() => Promise.resolve({ message: 'Hello, Nuxt!' }))

async function refreshData () {
  await refresh({ dedupe: true })
}
```

#### Reasons for Change

These aliases were removed, for greater clarity.

The issue came up when adding `dedupe` as an option to `useAsyncData`, and we removed the boolean values as they ended up being _opposites_.

`refresh({ dedupe: false })` meant **do not _cancel_ existing requests in favour of this new one**. But passing `dedupe: true` within the options of `useAsyncData` means **do not make any new requests if there is an existing pending request.** (See [PR](https://github.com/nuxt/nuxt/pull/24564#pullrequestreview-1764584361).)

#### Migration Steps

The migration should be straightforward:

```diff
  const { refresh } = await useAsyncData(async () => ({ message: 'Hello, Nuxt 3!' }))
  
  async function refreshData () {
-   await refresh({ dedupe: true })
+   await refresh({ dedupe: 'cancel' })

-   await refresh({ dedupe: false })
+   await refresh({ dedupe: 'defer' })
  }
```

::tip
You can automate this step by running `npx codemod@latest nuxt/4/deprecated-dedupe-value`
::

### Respect defaults when clearing `data` in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Minimal

#### What Changed

If you provide a custom `default` value for `useAsyncData`, this will now be used when calling `clear` or `clearNuxtData` and it will be reset to its default value rather than simply unset.

#### Reasons for Change

Often users set an appropriately empty value, such as an empty array, to avoid the need to check for `null`/`undefined` when iterating over it. This should be respected when resetting/clearing the data.

### Alignment of `pending` value in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Medium

The `pending` object returned from `useAsyncData`, `useFetch`, `useLazyAsyncData` and `useLazyFetch` is now a computed property that is `true` only when `status` is also pending.

#### What Changed

Now, when `immediate: false` is passed, `pending` will be `false` until the first request is made. This is a change from the previous behavior, where `pending` was always `true` until the first request was made.

#### Reasons for Change

This aligns the meaning of `pending` with the `status` property, which is also `pending` when the request is in progress.

#### Migration Steps

If you rely on the `pending` property, ensure that your logic accounts for the new behavior where `pending` will only be `true` when the status is also pending.

```diff
  <template>
-   <div v-if="!pending">
+   <div v-if="status === 'success'">
      <p>Data: {{ data }}</p>
    </div>
    <div v-else>
      <p>Loading...</p>
    </div>
  </template>
  <script setup lang="ts">
  const { data, pending, execute, status } = await useAsyncData(() => fetch('/api/data'), {
    immediate: false
  })
  onMounted(() => execute())
  </script>
```

Alternatively, you can temporarily revert to the previous behavior with:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    pendingWhenIdle: true,
  },
})
```

### Key Change Behavior in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Medium

#### What Changed

When using reactive keys in `useAsyncData` or `useFetch`, Nuxt automatically refetches data when the key changes. When `immediate: false` is set, `useAsyncData` will only fetch data when the key changes if the data has already been fetched once.

Previously, `useFetch` had slightly different behavior. It would always fetch data when the key changed.

Now, `useFetch` and `useAsyncData` behave consistently - by only fetch data when the key changes if the data has already been fetched once.

#### Reasons for Change

This ensures consistent behavior between `useAsyncData` and `useFetch`, and prevents unexpected fetches. If you have set `immediate: false`, then you must call `refresh` or `execute` or data will never be fetched in `useFetch` or `useAsyncData`.

#### Migration Steps

This change should generally improve the expected behavior, but if you were expecting changing the key or options of a non-immediate `useFetch`, you now will need to trigger it manually the first time.

```diff
  const id = ref('123')
  const { data, execute } = await useFetch('/api/test', {
    query: { id },
    immediate: false
  )
+ watch(id, () => execute(), { once: true })
```

To opt out of this behavior:

```ts
// Or globally in your Nuxt config
export default defineNuxtConfig({
  experimental: {
    alwaysRunFetchOnKeyChange: true,
  },
})
```

### Shallow Data Reactivity in `useAsyncData` and `useFetch`

🚦 **Impact Level**: Minimal

The `data` object returned from `useAsyncData`, `useFetch`, `useLazyAsyncData` and `useLazyFetch` is now a `shallowRef` rather than a `ref`.

#### What Changed

When new data is fetched, anything depending on `data` will still be reactive because the entire object is replaced. But if your code changes a property _within_ that data structure, this will not trigger any reactivity in your app.

#### Reasons for Change

This brings a **significant** performance improvement for deeply nested objects and arrays because Vue does not need to watch every single property/array for modification. In most cases, `data` should also be immutable.

#### Migration Steps

In most cases, no migration steps are required, but if you rely on the reactivity of the data object then you have two options:

1. You can granularly opt in to deep reactivity on a per-composable basis:
   ```diff
   - const { data } = useFetch('/api/test')
   + const { data } = useFetch('/api/test', { deep: true })
   ```
1. You can change the default behavior on a project-wide basis (not recommended):
   ```ts twoslash [nuxt.config.ts]
   export default defineNuxtConfig({
     experimental: {
       defaults: {
         useAsyncData: {
           deep: true,
         },
       },
     },
   })
   ```

::tip
If you need to, you can automate this step by running `npx codemod@latest nuxt/4/shallow-function-reactivity`
::

### Absolute Watch Paths in `builder:watch`

🚦 **Impact Level**: Minimal

#### What Changed

The Nuxt `builder:watch` hook now emits a path which is absolute rather than relative to your project `srcDir`.

#### Reasons for Change

This allows us to support watching paths which are outside your `srcDir`, and offers better support for layers and other more complex patterns.

#### Migration Steps

We have already proactively migrated the public Nuxt modules which we are aware use this hook. See [issue #25339](https://github.com/nuxt/nuxt/issues/25339).

However, if you are a module author using the `builder:watch` hook and wishing to remain backwards/forwards compatible, you can use the following code to ensure that your code works the same in both Nuxt v3 and Nuxt v4:

```diff
+ import { relative, resolve } from 'node:fs'
  // ...
  nuxt.hook('builder:watch', async (event, path) => {
+   path = relative(nuxt.options.srcDir, resolve(nuxt.options.srcDir, path))
    // ...
  })
```

::tip
You can automate this step by running `npx codemod@latest nuxt/4/absolute-watch-path`
::

### Removal of `window.__NUXT__` object

#### What Changed

We are removing the global `window.__NUXT__` object after the app finishes hydration.

#### Reasons for Change

This opens the way to multi-app patterns ([#21635](https://github.com/nuxt/nuxt/issues/21635)) and enables us to focus on a single way to access Nuxt app data - `useNuxtApp()`.

#### Migration Steps

The data is still available, but can be accessed with `useNuxtApp().payload`:

```diff
- console.log(window.__NUXT__)
+ console.log(useNuxtApp().payload)
```

### Directory index scanning

🚦 **Impact Level**: Medium

#### What Changed

Child folders in your `app/middleware/` folder are also scanned for `index` files and these are now also registered as middleware in your project.

#### Reasons for Change

Nuxt scans a number of folders automatically, including `app/middleware/` and `app/plugins/`.

Child folders in your `app/plugins/` folder are scanned for `index` files and we wanted to make this behavior consistent between scanned directories.

#### Migration Steps

Probably no migration is necessary but if you wish to revert to previous behavior you can add a hook to filter out these middleware:

```ts
export default defineNuxtConfig({
  hooks: {
    'app:resolve' (app) {
      app.middleware = app.middleware.filter(mw => !/\/index\.[^/]+$/.test(mw.path))
    },
  },
})
```

### Template Compilation Changes

🚦 **Impact Level**: Minimal

#### What Changed

Previously, Nuxt used `lodash/template` to compile templates located on the file system using the `.ejs` file format/syntax.

In addition, we provided some template utilities (`serialize`, `importName`, `importSources`) which could be used for code-generation within these templates, which are now being removed.

#### Reasons for Change

In Nuxt v3 we moved to a 'virtual' syntax with a `getContents()` function which is much more flexible and performant.

In addition, `lodash/template` has had a succession of security issues. These do not really apply to Nuxt projects because it is being used at build-time, not runtime, and by trusted code. However, they still appear in security audits. Moreover, `lodash` is a hefty dependency and is unused by most projects.

Finally, providing code serialization functions directly within Nuxt is not ideal. Instead, we maintain projects like [unjs/knitwork](https://github.com/unjs/knitwork) which can be dependencies of your project, and where security issues can be reported/resolved directly without requiring an upgrade of Nuxt itself.

#### Migration Steps

We have raised PRs to update modules using EJS syntax, but if you need to do this yourself, you have three backwards/forwards-compatible alternatives:

- Moving your string interpolation logic directly into `getContents()`.
- Using a custom function to handle the replacement, such as in https://github.com/nuxt-modules/color-mode/pull/240.
- Use `es-toolkit/compat` (a drop-in replacement for lodash template), as a dependency of _your_ project rather than Nuxt:

```diff
+ import { readFileSync } from 'node:fs'
+ import { template } from 'es-toolkit/compat'
  // ...
  addTemplate({
    fileName: 'appinsights-vue.js'
    options: { /* some options */ },
-   src: resolver.resolve('./runtime/plugin.ejs'),
+   getContents({ options }) {
+     const contents = readFileSync(resolver.resolve('./runtime/plugin.ejs'), 'utf-8')
+     return template(contents)({ options })
+   },
  })
```

Finally, if you are using the template utilities (`serialize`, `importName`, `importSources`), you can replace them as follows with utilities from `knitwork`:

```ts
import { genDynamicImport, genImport, genSafeVariableName } from 'knitwork'

const serialize = (data: any) => JSON.stringify(data, null, 2).replace(/"\{(.+)\}"(?=,?$)/gm, r => JSON.parse(r).replace(/^\{(.*)\}$/, '$1'))

const importSources = (sources: string | string[], { lazy = false } = {}) => {
  return toArray(sources).map((src) => {
    if (lazy) {
      return `const ${genSafeVariableName(src)} = ${genDynamicImport(src, { comment: `webpackChunkName: ${JSON.stringify(src)}` })}`
    }
    return genImport(src, genSafeVariableName(src))
  }).join('\n')
}

const importName = genSafeVariableName
```

::tip
You can automate this step by running `npx codemod@latest nuxt/4/template-compilation-changes`
::

### Default TypeScript Configuration Changes

🚦 **Impact Level**: Minimal

#### What Changed

`compilerOptions.noUncheckedIndexedAccess` is now `true` instead of `false`.

#### Reasons for Change

This change is a follow up to a prior [3.12 config update](https://github.com/nuxt/nuxt/pull/27485) where we improved our defaults, mostly adhering to [TotalTypeScript's recommendations](https://www.totaltypescript.com/tsconfig-cheat-sheet).

#### Migration Steps

There are two approaches:

1. Run a typecheck on your app and fix any new errors (recommended).

2. Override the new default in your `nuxt.config.ts`:

   <!-- @case-police-ignore tsConfig -->

   ```ts
   export default defineNuxtConfig({
     typescript: {
       tsConfig: {
         compilerOptions: {
           noUncheckedIndexedAccess: false,
         },
       },
     },
   })
   ```

### TypeScript Configuration Splitting

🚦 **Impact Level**: Minimal

#### What Changed

Nuxt now generates separate TypeScript configurations for different contexts to provide better type-checking experiences:

1. **New TypeScript configuration files**: Nuxt now generates additional TypeScript configurations:
   - `.nuxt/tsconfig.app.json` - For your app code (Vue components, composables, etc.)
   - `.nuxt/tsconfig.server.json` - For your server-side code (Nitro/server directory)  
   - `.nuxt/tsconfig.node.json` - For your build-time code (modules, `nuxt.config.ts`, etc.)
   - `.nuxt/tsconfig.shared.json` - For code shared between app and server contexts (like types and non-environment specific utilities)
   - `.nuxt/tsconfig.json` - Legacy configuration for backward compatibility

2. **Backward compatibility**: Existing projects that extend `.nuxt/tsconfig.json` will continue to work as before.

3. **Opt-in project references**: New projects or those wanting better type checking can adopt TypeScript's project references feature.

4. **Context-specific type checking**: Each context now has appropriate compiler options and includes/excludes for its specific environment.

5. **New `typescript.nodeTsConfig` option**: You can now customize the TypeScript configuration for Node.js build-time code.

#### Reasons for Change

This change provides several benefits:

1. **Better type safety**: Each context (app, server, build-time) gets appropriate type checking with context-specific globals and APIs.
2. **Improved IDE experience**: Better IntelliSense and error reporting for different parts of your codebase.
3. **Cleaner separation**: Server code won't incorrectly suggest client-side APIs and vice versa.
4. **Performance**: TypeScript can more efficiently check code with properly scoped configurations.

For example, auto-imports are not available in your `nuxt.config.ts` (but previously this was not flagged by TypeScript). And while IDEs recognized the separate context hinted by `tsconfig.json` in your `server/` directory, this was not reflected in type-checking (requiring a separate step).

#### Migration Steps

**No migration is required** - existing projects will continue to work as before.

However, to take advantage of improved type checking, you can opt in to the new project references approach:

1. **Update your root `tsconfig.json`** to use project references:

   ::note
   If your `tsconfig.json` currently has an `"extends": "./.nuxt/tsconfig.json"` line, **remove it** before adding the references. Project references and extends are mutually exclusive.
   ::

   ```json
   {
     // Remove "extends": "./.nuxt/tsconfig.json" if present
     "files": [],
     "references": [
       { "path": "./.nuxt/tsconfig.app.json" },
       { "path": "./.nuxt/tsconfig.server.json" },
       { "path": "./.nuxt/tsconfig.shared.json" },
       { "path": "./.nuxt/tsconfig.node.json" }
     ]
   }
   ```

2. **Remove any manual server `tsconfig.json`** files (like `server/tsconfig.json`) that extended `.nuxt/tsconfig.server.json`.

3. **Update your type checking scripts** to use the build flag for project references:

   ```diff
   - "typecheck": "nuxt prepare && vue-tsc --noEmit"
   + "typecheck": "nuxt prepare && vue-tsc -b --noEmit"
   ```

4. **Move all type augmentations into their appropriate context**:
   - If you are augmenting types for the app context, move the files to the `app/` directory.
   - If you are augmenting types for the server context, move the files to the `server/` directory.
   - If you are augmenting types that are **shared between the app and server**, move the files to the `shared/` directory.

    ::warning
    Augmenting types from outside the `app/`, `server/`, or `shared/` directories will not work with the new project references setup.
    ::

5. **Configure TypeScript options** if needed:
   <!-- @case-police-ignore tsConfig -->

   ```ts
   export default defineNuxtConfig({
     typescript: {
       // customize tsconfig.app.json
       tsConfig: {
         // ...
       },
       // customize tsconfig.shared.json
       sharedTsConfig: {
         // ...
       },
       // customize tsconfig.node.json
       nodeTsConfig: {
         // ...
       },
     },
     nitro: {
       typescript: {
         // customize tsconfig.server.json
         tsConfig: {
           // ...
         },
       },
     },
   })
   ```

6. **Update any CI/build scripts** that run TypeScript checking to ensure they use the new project references approach.

The new configuration provides better type safety and IntelliSense for projects that opt in, while maintaining full backward compatibility for existing setups.

### Removal of Experimental Features

🚦 **Impact Level**: Minimal

#### What Changed

Four experimental features are no longer configurable in Nuxt 4:

- `experimental.treeshakeClientOnly` will be `true` (default since v3.0)
- `experimental.configSchema` will be `true` (default since v3.3)
- `experimental.polyfillVueUseHead` will be `false` (default since v3.4)
- `experimental.respectNoSSRHeader` will be `false` (default since v3.4)
- `vite.devBundler` is no longer configurable - it will use `vite-node` by default

#### Reasons for Change

These options have been set to their current values for some time and we do not have a reason to believe that they need to remain configurable.

#### Migration Steps

- `polyfillVueUseHead` is implementable in user-land with [this plugin](https://github.com/nuxt/nuxt/blob/f209158352b09d1986aa320e29ff36353b91c358/packages/nuxt/src/head/runtime/plugins/vueuse-head-polyfill.ts#L10-L11)

- `respectNoSSRHeader`is implementable in user-land with [server middleware](https://github.com/nuxt/nuxt/blob/c660b39447f0d5b8790c0826092638d321cd6821/packages/nuxt/src/core/runtime/nitro/no-ssr.ts#L8-L9)

### Removal of Top-Level `generate` Configuration

🚦 **Impact Level**: Minimal

#### What Changed

The top-level `generate` configuration option is no longer available in Nuxt 4. This includes all of its properties:

- `generate.exclude` - for excluding routes from prerendering
- `generate.routes` - for specifying routes to prerender

#### Reasons for Change

The top level `generate` configuration was a holdover from Nuxt 2. We've supported `nitro.prerender` for a while now, and it is the preferred way to configure prerendering in Nuxt 3+.

#### Migration Steps

Replace `generate` configuration with the corresponding `nitro.prerender` options:

```diff
export default defineNuxtConfig({
- generate: {
-   exclude: ['/admin', '/private'],
-   routes: ['/sitemap.xml', '/robots.txt']
- }
+ nitro: {
+   prerender: {
+     ignore: ['/admin', '/private'],
+     routes: ['/sitemap.xml', '/robots.txt']
+   }
+ }
})
```

::read-more{to="https://nitro.build/config#prerender"}
Read more about Nitro's prerender configuration options.
::

## Nuxt 2 vs. Nuxt 3+

In the table below, there is a quick comparison between 3 versions of Nuxt:

| Feature / Version       | Nuxt 2     | Nuxt Bridge | Nuxt 3+    |
|-------------------------|------------|-------------|------------|
| Vue                     | 2          | 2           | 3          |
| Stability               | 😊 Stable  | 😊 Stable   | 😊 Stable  |
| Performance             | 🏎 Fast    | ✈️ Faster   | 🚀 Fastest |
| Nitro Engine            | ❌          | ✅           | ✅          |
| ESM support             | 🌙 Partial | 👍 Better   | ✅          |
| TypeScript              | ☑️ Opt-in  | 🚧 Partial  | ✅          |
| Composition API         | ❌          | 🚧 Partial  | ✅          |
| Options API             | ✅          | ✅           | ✅          |
| Components Auto Import  | ✅          | ✅           | ✅          |
| `<script setup>` syntax | ❌          | 🚧 Partial  | ✅          |
| Auto Imports            | ❌          | ✅           | ✅          |
| webpack                 | 4          | 4           | 5          |
| Vite                    | ⚠️ Partial | 🚧 Partial  | ✅          |
| Nuxt CLI                | ❌ Old      | ✅ nuxt      | ✅ nuxt     |
| Static sites            | ✅          | ✅           | ✅          |

## Nuxt 2 to Nuxt 3+

The migration guide provides a step-by-step comparison of Nuxt 2 features to Nuxt 3+ features and guidance to adapt your current application.

::read-more{to="/docs/4.x/migration/overview"}
Check out the **guide to migrating from Nuxt 2 to Nuxt 3**.
::

## Nuxt 2 to Nuxt Bridge

If you prefer to progressively migrate your Nuxt 2 application to Nuxt 3, you can use Nuxt Bridge. Nuxt Bridge is a compatibility layer that allows you to use Nuxt 3+ features in Nuxt 2 with an opt-in mechanism.

::read-more{to="/docs/4.x/bridge/overview"}
**Migrate from Nuxt 2 to Nuxt Bridge**
::
</file>

<file path="docs/2.directory-structure/1.app/.navigation.yml">
title: app
titleTemplate: '%s · Nuxt Directory Structure'
head.title: "app/"
defaultOpen: true
icon: i-vscode-icons-folder-type-app
</file>

<file path="docs/2.directory-structure/1.app/1.assets.md">
---
title: "assets"
description: "The assets/ directory is used to add all the website's assets that the build tool will process."
head.title: "assets/"
navigation.icon: i-vscode-icons-folder-type-asset
---

The directory usually contains the following types of files:

- Stylesheets (CSS, SASS, etc.)
- Fonts
- Images that won't be served from the [`public/`](/docs/4.x/directory-structure/public) directory.

If you want to serve assets from the server, we recommend taking a look at the [`public/`](/docs/4.x/directory-structure/public) directory.

:read-more{to="/docs/4.x/getting-started/assets"}
</file>

<file path="docs/2.directory-structure/1.app/1.components.md">
---
title: "components"
head.title: "components/"
description: "The components/ directory is where you put all your Vue components."
navigation.icon: i-vscode-icons-folder-type-component
---

Nuxt automatically imports any components in this directory (along with components that are registered by any modules you may be using).

```bash [Directory Structure]
-| components/
---| AppHeader.vue
---| AppFooter.vue
```

```html [app/app.vue]
<template>
  <div>
    <AppHeader />
    <NuxtPage />
    <AppFooter />
  </div>
</template>
```

## Component Names

If you have a component in nested directories such as:

```bash [Directory Structure]
-| components/
---| base/
-----| foo/
-------| Button.vue
```

... then the component's name will be based on its own path directory and filename, with duplicate segments being removed. Therefore, the component's name will be:

```html
<BaseFooButton />
```

::note
For clarity, we recommend that the component's filename matches its name. So, in the example above, you could rename `Button.vue` to be `BaseFooButton.vue`.
::

If you want to auto-import components based only on its name, not path, then you need to set `pathPrefix` option to `false` using extended form of the configuration object:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  components: [
    {
      path: '~/components',
      pathPrefix: false, // [!code ++]
    },
  ],
})
```

This registers the components using the same strategy as used in Nuxt 2. For example, `~/components/Some/MyComponent.vue` will be usable as `<MyComponent>` and not `<SomeMyComponent>`.

## Dynamic Components

If you want to use the Vue `<component :is="someComputedComponent">`{lang=vue} syntax, you need to use the `resolveComponent` helper provided by Vue or import the component directly from `#components` and pass it into `is` prop.

For example:

```vue [app/pages/index.vue]
<script setup lang="ts">
import { SomeComponent } from '#components'

const MyButton = resolveComponent('MyButton')
</script>

<template>
  <component :is="clickable ? MyButton : 'div'" />
  <component :is="SomeComponent" />
</template>
```

::important
If you are using `resolveComponent` to handle dynamic components, make sure not to insert anything but the name of the component, which must be a literal string and not be or contain a variable. The string is statically analyzed at the compilation step.
::

:video-accordion{title="Watch Daniel Roe's short video about resolveComponent()" videoId="4kq8E5IUM2U"}

Alternatively, though not recommended, you can register all your components globally, which will create async chunks for all your components and make them available throughout your application.

```diff
  export default defineNuxtConfig({
    components: {
+     global: true,
+     dirs: ['~/components']
    },
  })
```

You can also selectively register some components globally by placing them in a `~/components/global` directory, or by using a `.global.vue` suffix in the filename. As noted above, each global component is rendered in a separate chunk, so be careful not to overuse this feature.

::note
The `global` option can also be set per component directory.
::

## Dynamic Imports

To dynamically import a component (also known as lazy-loading a component) all you need to do is add the `Lazy` prefix to the component's name. This is particularly useful if the component is not always needed.

By using the `Lazy` prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.

```vue [app/pages/index.vue]
<script setup lang="ts">
const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button
      v-if="!show"
      @click="show = true"
    >
      Show List
    </button>
  </div>
</template>
```

## Delayed (or Lazy) Hydration

Lazy components are great for controlling the chunk sizes in your app, but they don't always enhance runtime performance, as they still load eagerly unless conditionally rendered. In real-world applications, some pages may include a lot of content and a lot of components, and most of the time not all of them need to be interactive as soon as the page is loaded. Having them all load eagerly can negatively impact performance.

In order to optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.

Nuxt supports this using lazy (or delayed) hydration, allowing you to control when components become interactive.

### Hydration Strategies

Nuxt provides a range of built-in hydration strategies. Only one strategy can be used per lazy component.

::note
Any prop change on a lazily hydrated component will trigger hydration immediately. (e.g., changing a prop on a component with `hydrate-never` will cause it to hydrate)
::

::warning
Currently Nuxt's built-in lazy hydration only works in single-file components (SFCs), and requires you to define the prop in the template (rather than spreading an object of props via `v-bind`). It also does not work with direct imports from `#components`.
::

#### `hydrate-on-visible`

Hydrates the component when it becomes visible in the viewport.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-visible />
  </div>
</template>
```

::read-more{to="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver" title="IntersectionObserver options"}
Read more about the options for `hydrate-on-visible`.
::

::note
Under the hood, this uses Vue's built-in [`hydrateOnVisible` strategy](https://vuejs.org/guide/components/async#hydrate-on-visible).
::

#### `hydrate-on-idle`

Hydrates the component when the browser is idle. This is suitable if you need the component to load as soon as possible, but not block the critical rendering path.

You can also pass a number which serves as a max timeout.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-idle />
  </div>
</template>
```

::note
Under the hood, this uses Vue's built-in [`hydrateOnIdle` strategy](https://vuejs.org/guide/components/async#hydrate-on-idle).
::

#### `hydrate-on-interaction`

Hydrates the component after a specified interaction (e.g., click, mouseover).

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-interaction="mouseover" />
  </div>
</template>
```

If you do not pass an event or list of events, it defaults to hydrating on `pointerenter`, `click` and `focus`.

::note
Under the hood, this uses Vue's built-in [`hydrateOnInteraction` strategy](https://vuejs.org/guide/components/async#hydrate-on-interaction).
::

#### `hydrate-on-media-query`

Hydrates the component when the window matches a media query.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-on-media-query="(max-width: 768px)" />
  </div>
</template>
```

::note
Under the hood, this uses Vue's built-in [`hydrateOnMediaQuery` strategy](https://vuejs.org/guide/components/async#hydrate-on-media-query).
::

#### `hydrate-after`

Hydrates the component after a specified delay (in milliseconds).

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent :hydrate-after="2000" />
  </div>
</template>
```

#### `hydrate-when`

Hydrates the component based on a boolean condition.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent :hydrate-when="isReady" />
  </div>
</template>

<script setup lang="ts">
const isReady = ref(false)
function myFunction () {
  // trigger custom hydration strategy...
  isReady.value = true
}
</script>
```

#### `hydrate-never`

Never hydrates the component.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent hydrate-never />
  </div>
</template>
```

### Listening to Hydration Events

All delayed hydration components emit a `@hydrated` event when they are hydrated.

```vue [app/pages/index.vue]
<template>
  <div>
    <LazyMyComponent
      hydrate-on-visible
      @hydrated="onHydrate"
    />
  </div>
</template>

<script setup lang="ts">
function onHydrate () {
  console.log('Component has been hydrated!')
}
</script>
```

### Caveats and Best Practices

Delayed hydration can offer performance benefits, but it's essential to use it correctly:

1. **Prioritize In-Viewport Content:** Avoid delayed hydration for critical, above-the-fold content. It's best suited for content that isn't immediately needed.

2. **Conditional Rendering:** When using `v-if="false"` on a lazy component, you might not need delayed hydration. You can just use a normal lazy component.

3. **Shared State:** Be mindful of shared state (`v-model`) across multiple components. Updating the model in one component can trigger hydration in all components bound to that model.

4. **Use Each Strategy's Intended Use Case:** Each strategy is optimized for a specific purpose.
    * `hydrate-when` is best for components that might not always need to be hydrated.
    * `hydrate-after` is for components that can wait a specific amount of time.
    * `hydrate-on-idle` is for components that can be hydrated when the browser is idle.

5. **Avoid `hydrate-never` on interactive components:** If a component requires user interaction, it should not be set to never hydrate.

## Direct Imports

You can also explicitly import components from `#components` if you want or need to bypass Nuxt's auto-importing functionality.

```vue [app/pages/index.vue]
<script setup lang="ts">
import { LazyMountainsList, NuxtLink } from '#components'

const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button
      v-if="!show"
      @click="show = true"
    >
      Show List
    </button>
    <NuxtLink to="/">Home</NuxtLink>
  </div>
</template>
```

## Custom Directories

By default, only the `~/components` directory is scanned. If you want to add other directories, or change how the components are scanned within a subfolder of this directory, you can add additional directories to the configuration:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  components: [
    // ~/calendar-module/components/event/Update.vue => <EventUpdate />
    { path: '~/calendar-module/components' },

    // ~/user-module/components/account/UserDeleteDialog.vue => <UserDeleteDialog />
    { path: '~/user-module/components', pathPrefix: false },

    // ~/components/special-components/Btn.vue => <SpecialBtn />
    { path: '~/components/special-components', prefix: 'Special' },

    // It's important that this comes last if you have overrides you wish to apply
    // to sub-directories of `~/components`.
    //
    // ~/components/Btn.vue => <Btn />
    // ~/components/base/Btn.vue => <BaseBtn />
    '~/components',
  ],
})
```

::note
Any nested directories need to be added first as they are scanned in order.
::

## npm Packages

If you want to auto-import components from an npm package, you can use [`addComponent`](/docs/4.x/api/kit/components#addcomponent) in a [local module](/docs/4.x/directory-structure/modules) to register them.

::code-group

```ts twoslash [~/modules/register-component.ts]
import { addComponent, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    // import { MyComponent as MyAutoImportedComponent } from 'my-npm-package'
    addComponent({
      name: 'MyAutoImportedComponent',
      export: 'MyComponent',
      filePath: 'my-npm-package',
    })
  },
})
```

```vue [app/app.vue]
<template>
  <div>
    <!--  the component uses the name we specified and is auto-imported  -->
    <MyAutoImportedComponent />
  </div>
</template>
```

::

## Component Extensions

By default, any file with an extension specified in the [extensions key of `nuxt.config.ts`](/docs/4.x/api/nuxt-config#extensions) is treated as a component.
If you need to restrict the file extensions that should be registered as components, you can use the extended form of the components directory declaration and its `extensions` key:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  components: [
    {
      path: '~/components',
      extensions: ['.vue'], // [!code ++]
    },
  ],
})
```

## Client Components

If a component is meant to be rendered only client-side, you can add the `.client` suffix to your component.

```bash [Directory Structure]
| components/
--| Comments.client.vue
```

```vue [app/pages/example.vue]
<template>
  <div>
    <!-- this component will only be rendered on client side -->
    <Comments />
  </div>
</template>
```

::note
This feature only works with Nuxt auto-imports and `#components` imports. Explicitly importing these components from their real paths does not convert them into client-only components.
::

::important
`.client` components are rendered only after being mounted. To access the rendered template using `onMounted()`, add `await nextTick()` in the callback of the `onMounted()` hook.
::

::read-more{to="/docs/4.x/api/components/client-only"}
You can also achieve a similar result with the `<ClientOnly>` component.
::

## Server Components

Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.

Server components can either be used on their own or paired with a [client component](/docs/4.x/directory-structure/app/components#paired-with-a-client-component).

:video-accordion{title="Watch Learn Vue video about Nuxt Server Components" videoId="u1yyXe86xJM"}

::tip{icon="i-lucide-newspaper" to="https://roe.dev/blog/nuxt-server-components" target="_blank"}
Read Daniel Roe's guide to Nuxt Server Components.
::

### Standalone server components

Standalone server components will always be rendered on the server, also known as Islands components.

When their props update, this will result in a network request that will update the rendered HTML in-place.

Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your nuxt.config:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    componentIslands: true,
  },
})
```

Now you can register server-only components with the `.server` suffix and use them anywhere in your application automatically.

```bash [Directory Structure]
-| components/
---| HighlightedMarkdown.server.vue
```

```vue [app/pages/example.vue]
<template>
  <div>
    <!--
      this will automatically be rendered on the server, meaning your markdown parsing + highlighting
      libraries are not included in your client bundle.
     -->
    <HighlightedMarkdown markdown="# Headline" />
  </div>
</template>
```

Server-only components use [`<NuxtIsland>`](/docs/4.x/api/components/nuxt-island) under the hood, meaning that `lazy` prop and `#fallback` slot are both passed down to it.

::warning
Server components (and islands) must have a single root element. (HTML comments are considered elements as well.)
::

::warning
Props are passed to server components via URL query parameters, and are therefore limited by the possible length of a URL, so be careful not to pass enormous amounts of data to server components via props.
::

::warning
Be careful when nesting islands within other islands as each island adds some extra overhead.
::

::warning
Most features for server-only components and island components, such as slots and client components, are only available for single file components.
::

#### Client components within server components

::note
This feature needs `experimental.componentIslands.selectiveClient` within your configuration to be true.
::

You can partially hydrate a component by setting a `nuxt-client` attribute on the component you wish to be loaded client-side.

```vue [app/components/ServerWithClient.vue]
<template>
  <div>
    <HighlightedMarkdown markdown="# Headline" />
    <!-- Counter will be loaded and hydrated client-side -->
    <Counter
      nuxt-client
      :count="5"
    />
  </div>
</template>
```

::note
This only works within a server component. Slots for client components are working only with `experimental.componentIsland.selectiveClient` set to `'deep'` and since they are rendered server-side, they are not interactive once client-side.
::

#### Server Component Context

When rendering a server-only or island component, `<NuxtIsland>` makes a fetch request which comes back with a `NuxtIslandResponse`. (This is an internal request if rendered on the server, or a request that you can see in the network tab if it's rendering on client-side navigation.)

This means:

* A new Vue app will be created server-side to create the `NuxtIslandResponse`.
* A new 'island context' will be created while rendering the component.
* You can't access the 'island context' from the rest of your app and you can't access the context of the rest of your app from the island component. In other words, the server component or island is _isolated_ from the rest of your app.
* Your plugins will run again when rendering the island, unless they have `env: { islands: false }` set (which you can do in an object-syntax plugin).

::important
Route middleware does not run when rendering island components. Middleware is a routing concept that applies to pages, not components, and is not designed to control component rendering.
::

Within an island component, you can access its island context through `nuxtApp.ssrContext.islandContext`. Note that while island components are still marked as experimental, the format of this context may change.

::note
Slots can be interactive and are wrapped within a `<div>` with `display: contents;`
::

### Paired with a Client component

In this case, the `.server` + `.client` components are two 'halves' of a component and can be used in advanced use cases for separate implementations of a component on server and client side.

```bash [Directory Structure]
-| components/
---| Comments.client.vue
---| Comments.server.vue
```

```vue [app/pages/example.vue]
<template>
  <div>
    <!-- this component will render Comments.server on the server then Comments.client once mounted in the browser -->
    <Comments />
  </div>
</template>
```

## Built-In Nuxt Components

There are a number of components that Nuxt provides, including `<ClientOnly>` and `<DevOnly>`. You can read more about them in the API documentation.

::read-more{to="/docs/4.x/api"}
::

## Library Authors

Making Vue component libraries with automatic tree-shaking and component registration is super easy. ✨

You can use the [`addComponentsDir`](/docs/4.x/api/kit/components#addcomponentsdir) method provided from the `@nuxt/kit` to register your components directory in your Nuxt module.

Imagine a directory structure like this:

```bash [Directory Structure]
-| node_modules/
---| awesome-ui/
-----| components/
-------| Alert.vue
-------| Button.vue
-----| nuxt.ts
-| pages/
---| index.vue
-| nuxt.config.ts
```

Then in `awesome-ui/nuxt.ts` you can use the `addComponentsDir` hook:

```ts twoslash
import { addComponentsDir, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const resolver = createResolver(import.meta.url)

    // Add ./components dir to the list
    addComponentsDir({
      path: resolver.resolve('./components'),
      prefix: 'awesome',
    })
  },
})
```

That's it! Now in your project, you can import your UI library as a Nuxt module in your `nuxt.config` file:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['awesome-ui/nuxt'],
})
```

... and directly use the module components (prefixed with `awesome-`) in our `app/pages/index.vue`:

```vue
<template>
  <div>
    My <AwesomeButton>UI button</AwesomeButton>!
    <awesome-alert>Here's an alert!</awesome-alert>
  </div>
</template>
```

It will automatically import the components only if used and also support HMR when updating your components in `node_modules/awesome-ui/components/`.

:link-example{to="/docs/4.x/examples/features/auto-imports"}
</file>

<file path="docs/2.directory-structure/1.app/1.composables.md">
---
title: 'composables'
head.title: 'composables/'
description: Use the composables/ directory to auto-import your Vue composables into your application.
navigation.icon: i-vscode-icons-folder-type-src
---

## Usage

**Method 1:** Using named export

```ts [app/composables/useFoo.ts]
export const useFoo = () => {
  return useState('foo', () => 'bar')
}
```

**Method 2:** Using default export

```ts [app/composables/use-foo.ts or composables/useFoo.ts]
// It will be available as useFoo() (camelCase of file name without extension)
export default function () {
  return useState('foo', () => 'bar')
}
```

**Usage:** You can now use auto imported composable in `.js`, `.ts` and `.vue` files

```vue [app/app.vue]
<script setup lang="ts">
const foo = useFoo()
</script>

<template>
  <div>
    {{ foo }}
  </div>
</template>
```

::note
The `app/composables/` directory in Nuxt does not provide any additional reactivity capabilities to your code. Instead, any reactivity within composables is achieved using Vue's Composition API mechanisms, such as ref and reactive. Note that reactive code is also not limited to the boundaries of the `app/composables/` directory. You are free to employ reactivity features wherever they're needed in your application.
::

:read-more{to="/docs/4.x/guide/concepts/auto-imports"}

:link-example{to="/docs/4.x/examples/features/auto-imports"}

## Types

Under the hood, Nuxt auto generates the file `.nuxt/imports.d.ts` to declare the types.

Be aware that you have to run [`nuxt prepare`](/docs/4.x/api/commands/prepare), [`nuxt dev`](/docs/4.x/api/commands/dev) or [`nuxt build`](/docs/4.x/api/commands/build) in order to let Nuxt generate the types.

::note
If you create a composable without having the dev server running, TypeScript will throw an error, such as `Cannot find name 'useBar'.`
::

## Examples

### Nested Composables

You can use a composable within another composable using auto imports:

```ts [app/composables/test.ts]
export const useFoo = () => {
  const nuxtApp = useNuxtApp()
  const bar = useBar()
}
```

### Access plugin injections

You can access [plugin injections](/docs/4.x/directory-structure/app/plugins#providing-helpers) from composables:

```ts [app/composables/test.ts]
export const useHello = () => {
  const nuxtApp = useNuxtApp()
  return nuxtApp.$hello
}
```

## How Files Are Scanned

Nuxt only scans files at the top level of the [`app/composables/` directory](/docs/4.x/directory-structure/app/composables), e.g.:

```bash [Directory Structure]
-| composables/
---| index.ts     // scanned
---| useFoo.ts    // scanned
---| nested/
-----| utils.ts   // not scanned
```

Only `app/composables/index.ts` and `app/composables/useFoo.ts` would be searched for imports.

To get auto imports working for nested modules, you could either re-export them (recommended) or configure the scanner to include nested directories:

**Example:** Re-export the composables you need from the `app/composables/index.ts` file:

```ts [app/composables/index.ts]
// Enables auto import for this export
export { utils } from './nested/utils.ts'
```

**Example:** Scan nested directories inside the `app/composables/` folder:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  imports: {
    dirs: [
      // Scan top-level composables
      '~/composables',
      // ... or scan composables nested one level deep with a specific name and file extension
      '~/composables/*/index.{ts,js,mjs,mts}',
      // ... or scan all composables within given directory
      '~/composables/**',
    ],
  },
})
```
</file>

<file path="docs/2.directory-structure/1.app/1.layouts.md">
---
title: "layouts"
head.title: "layouts/"
description: "Nuxt provides a layouts framework to extract common UI patterns into reusable layouts."
navigation.icon: i-vscode-icons-folder-type-view
---

::tip{icon="i-lucide-rocket" }
For best performance, components placed in this directory will be automatically loaded via asynchronous import when used.
::

## Enable Layouts

Layouts are enabled by adding [`<NuxtLayout>`](/docs/4.x/api/components/nuxt-layout) to your [`app.vue`](/docs/4.x/directory-structure/app/app):

```vue [app/app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

To use a layout:
- Set a `layout` property in your page with [definePageMeta](/docs/4.x/api/utils/define-page-meta).
- Set the `name` prop of `<NuxtLayout>`.
- Set the `appLayout` property in route rules.

::note
The layout name is normalized to kebab-case, so `someLayout` becomes `some-layout`.
::

::note
If no layout is specified, `app/layouts/default.vue` will be used.
::

::important
If you only have a single layout in your application, we recommend using [`app.vue`](/docs/4.x/directory-structure/app/app) instead.
::

::important
Unlike other components, your layouts must have a single root element to allow Nuxt to apply transitions between layout changes - and this root element cannot be a `<slot />`.
::

## Default Layout

Add a `~/layouts/default.vue`:

```vue [app/layouts/default.vue]
<template>
  <div>
    <p>Some default layout content shared across all pages</p>
    <slot />
  </div>
</template>
```

In a layout file, the content of the page will be displayed in the `<slot />` component.

## Named Layout

```bash [Directory Structure]
-| layouts/
---| default.vue
---| custom.vue
```

Then you can use the `custom` layout in your page:

```vue twoslash [pages/about.vue]
<script setup lang="ts">
declare module 'nuxt/app' {
  interface NuxtLayouts {
    'custom': unknown
  }
}
// ---cut---
definePageMeta({
  layout: 'custom',
})
</script>
```

::read-more{to="/docs/4.x/directory-structure/app/pages#page-metadata"}
Learn more about `definePageMeta`.
::

You can directly override the default layout for all pages using the `name` property of [`<NuxtLayout>`](/docs/4.x/api/components/nuxt-layout):

```vue [app/app.vue]
<script setup lang="ts">
// You might choose this based on an API call or logged-in status
const layout = 'custom'
</script>

<template>
  <NuxtLayout :name="layout">
    <NuxtPage />
  </NuxtLayout>
</template>
```

If you have a layout in nested directories, the layout's name will be based on its own path directory and filename, with duplicate segments being removed.

File | Layout Name
-- | --
`~/layouts/desktop/default.vue` | `desktop-default`
`~/layouts/desktop-base/base.vue` | `desktop-base`
`~/layouts/desktop/index.vue` | `desktop`

For clarity, we recommend that the layout's filename matches its name:

File | Layout Name
-- | --
`~/layouts/desktop/DesktopDefault.vue` | `desktop-default`
`~/layouts/desktop-base/DesktopBase.vue` | `desktop-base`
`~/layouts/desktop/Desktop.vue` | `desktop`

:link-example{to="/docs/4.x/examples/features/layouts"}

## Changing the Layout Dynamically

You can also use the [`setPageLayout`](/docs/4.x/api/utils/set-page-layout) helper to change the layout dynamically:

```vue twoslash
<script setup lang="ts">
declare module 'nuxt/app' {
  interface NuxtLayouts {
    'custom': unknown
  }
}
// ---cut---
function enableCustomLayout () {
  setPageLayout('custom')
}
definePageMeta({
  layout: false,
})
</script>

<template>
  <div>
    <button @click="enableCustomLayout">
      Update layout
    </button>
  </div>
</template>
```

You can also set layouts for specific routes using the `appLayout` property in route rules:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    // Set layout for specific route
    '/admin': { appLayout: 'admin' },
    // Set layout for multiple routes
    '/dashboard/**': { appLayout: 'dashboard' },
  },
})
```

:link-example{to="/docs/4.x/examples/features/layouts"}

## Overriding a Layout on a Per-page Basis

If you are using pages, you can take full control by setting `layout: false` and then using the `<NuxtLayout>` component within the page.

::code-group

```vue [app/pages/index.vue]
<script setup lang="ts">
definePageMeta({
  layout: false,
})
</script>

<template>
  <div>
    <NuxtLayout name="custom">
      <template #header>
        Some header template content.
      </template>

      The rest of the page
    </NuxtLayout>
  </div>
</template>
```

```vue [app/layouts/custom.vue]
<template>
  <div>
    <header>
      <slot name="header">
        Default header content
      </slot>
    </header>
    <main>
      <slot />
    </main>
  </div>
</template>
```

::

::important
If you use `<NuxtLayout>` within your pages, make sure it is not the root element (or [disable layout/page transitions](/docs/4.x/getting-started/transitions#disable-transitions)).
::
</file>

<file path="docs/2.directory-structure/1.app/1.middleware.md">
---
title: "middleware"
description: "Nuxt provides middleware to run code before navigating to a particular route."
head.title: "middleware/"
navigation.icon: i-vscode-icons-folder-type-middleware
---

Nuxt provides a customizable **route middleware** framework you can use throughout your application, ideal for extracting code that you want to run before navigating to a particular route.

There are three kinds of route middleware:

1. Anonymous (or inline) route middleware are defined directly within the page.
2. Named route middleware, placed in the `app/middleware/` and automatically loaded via asynchronous import when used on a page.
3. Global route middleware, placed in the `app/middleware/` with a `.global` suffix and is run on every route change.

The first two kinds of route middleware can be defined in [`definePageMeta`](/docs/4.x/api/utils/define-page-meta).

::note
Name of middleware are normalized to kebab-case: `myMiddleware` becomes `my-middleware`.
::

::note
Route middleware run within the Vue part of your Nuxt app. Despite the similar name, they are completely different from [server middleware](/docs/4.x/directory-structure/server#server-middleware), which are run in the Nitro server part of your app.
::

:video-accordion{title="Watch a video from Vue School on all 3 kinds of middleware" videoId="761471577" platform="vimeo"}

## Usage

Route middleware are navigation guards that receive the current route and the next route as arguments.

```ts twoslash [middleware/my-middleware.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  if (to.params.id === '1') {
    return abortNavigation()
  }
  // In a real app you would probably not redirect every route to `/`
  // however it is important to check `to.path` before redirecting or you
  // might get an infinite redirect loop
  if (to.path !== '/') {
    return navigateTo('/')
  }
})
```

Nuxt provides two globally available helpers that can be returned directly from the middleware.

1. [`navigateTo`](/docs/4.x/api/utils/navigate-to) - Redirects to the given route
2. [`abortNavigation`](/docs/4.x/api/utils/abort-navigation) - Aborts the navigation, with an optional error message.

Unlike [navigation guards](https://router.vuejs.org/guide/advanced/navigation-guards#Global-Before-Guards) from `vue-router`, a third `next()` argument is not passed, and **redirect or route cancellation is handled by returning a value from the middleware**.

Possible return values are:

* nothing (a simple `return` or no return at all) - does not block navigation and will move to the next middleware function, if any, or complete the route navigation
* `return navigateTo('/')` - redirects to the given path and will set the redirect code to [`302` Found](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/302) if the redirect happens on the server side
* `return navigateTo('/', { redirectCode: 301 })` - redirects to the given path and will set the redirect code to [`301` Moved Permanently](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/301) if the redirect happens on the server side
* `return abortNavigation()` - stops the current navigation
* `return abortNavigation(error)` - rejects the current navigation with an error

:read-more{to="/docs/4.x/api/utils/navigate-to"}
:read-more{to="/docs/4.x/api/utils/abort-navigation"}

::important
We recommend using the helper functions above for performing redirects or stopping navigation. Other possible return values described in [the vue-router docs](https://router.vuejs.org/guide/advanced/navigation-guards#Global-Before-Guards) may work but there may be breaking changes in future.
::

## Middleware Order

Middleware runs in the following order:

1. Global Middleware
2. Page defined middleware order (if there are multiple middleware declared with the array syntax)

For example, assuming you have the following middleware and component:

```bash [app/middleware/ directory]
-| middleware/
---| analytics.global.ts
---| setup.global.ts
---| auth.ts
```

```vue twoslash [pages/profile.vue]
<script setup lang="ts">
definePageMeta({
  middleware: [
    function (to, from) {
      // Custom inline middleware
    },
    'auth',
  ],
})
</script>
```

You can expect the middleware to be run in the following order:

1. `analytics.global.ts`
2. `setup.global.ts`
3. Custom inline middleware
4. `auth.ts`

### Ordering Global Middleware

By default, global middleware is executed alphabetically based on the filename.

However, there may be times you want to define a specific order. For example, in the last scenario, `setup.global.ts` may need to run before `analytics.global.ts`. In that case, we recommend prefixing global middleware with 'alphabetical' numbering.

```bash [Directory structure]
-| middleware/
---| 01.setup.global.ts
---| 02.analytics.global.ts
---| auth.ts
```

::note
In case you're new to 'alphabetical' numbering, remember that filenames are sorted as strings, not as numeric values. For example, `10.new.global.ts` would come before `2.new.global.ts`. This is why the example prefixes single digit numbers with `0`.
::

## When Middleware Runs

If your site is server-rendered or generated, middleware for the initial page will be executed both when the page is rendered and then again on the client. This might be needed if your middleware needs a browser environment, such as if you have a generated site, aggressively cache responses, or want to read a value from local storage.

However, if you want to avoid this behaviour you can do so:

```ts twoslash [middleware/example.ts]
export default defineNuxtRouteMiddleware((to) => {
  // skip middleware on server
  if (import.meta.server) {
    return
  }
  // skip middleware on client side entirely
  if (import.meta.client) {
    return
  }
  // or only skip middleware on initial client load
  const nuxtApp = useNuxtApp()
  if (import.meta.client && nuxtApp.isHydrating && nuxtApp.payload.serverRendered) {
    return
  }
})
```

This is true even if you throw an error in your middleware on the server, and an error page is rendered. The middleware will still run again in the browser.

::note
Rendering an error page is an entirely separate page load, meaning any registered middleware will run again. You can use [`useError`](/docs/4.x/getting-started/error-handling#useerror) in middleware to check if an error is being handled.
::

## Accessing Route in Middleware

Always use the `to` and `from` parameters in your middleware to access the next and previous routes. Avoid using the [`useRoute()`](/docs/4.x/api/composables/use-route) composable in this context altogether.
There is **no concept of a "current route" in middleware**, as middleware can abort a navigation or redirect to a different route. The `useRoute()` composable will always be inaccurate in this context.  

::warning
Sometimes, you might call a composable that uses `useRoute()` internally, which can trigger this warning even if there is no direct call in your middleware.
This leads to the **same issue as above**, so you should structure your functions to accept the route as an argument instead when they are used in middleware.
::

::code-group
```ts twoslash [middleware/access-route.ts]
// @errors: 2304
export default defineNuxtRouteMiddleware((to) => {
  // passing the route to the function to avoid calling `useRoute()` in middleware
  doSomethingWithRoute(to)

  // ❌ this will output a warning and is NOT recommended
  callsRouteInternally()
})
```

```ts twoslash [utils/handle-route.ts]
// providing the route as an argument so that it can be used in middleware correctly
export function doSomethingWithRoute (route = useRoute()) {
  // ...
}
```
```ts twoslash [utils/dont-do-this.ts]
// ❌ this function is not suitable for use in middleware
export function callsRouteInternally () {
  const route = useRoute()
  // ...
}
```

::

## Adding Middleware Dynamically

It is possible to add global or named route middleware manually using the [`addRouteMiddleware()`](/docs/4.x/api/utils/add-route-middleware) helper function, such as from within a plugin.

```ts twoslash
export default defineNuxtPlugin(() => {
  addRouteMiddleware('global-test', () => {
    console.log('this global middleware was added in a plugin and will be run on every route change')
  }, { global: true })

  addRouteMiddleware('named-test', () => {
    console.log('this named middleware was added in a plugin and would override any existing middleware of the same name')
  })
})
```

## Example

```bash [Directory Structure]
-| middleware/
---| auth.ts
```

In your page file, you can reference this route middleware:

```vue twoslash
<script setup lang="ts">
definePageMeta({
  middleware: ['auth'],
  // or middleware: 'auth'
})
</script>
```

Now, before navigation to that page can complete, the `auth` route middleware will be run.

:link-example{to="/docs/4.x/examples/routing/middleware"}

## Setting Middleware at Build Time

Instead of using `definePageMeta` on each page, you can add named route middleware within the `pages:extend` hook.

```ts twoslash [nuxt.config.ts]
import type { NuxtPage } from 'nuxt/schema'

export default defineNuxtConfig({
  hooks: {
    'pages:extend' (pages) {
      function setMiddleware (pages: NuxtPage[]) {
        for (const page of pages) {
          if (/* some condition */ Math.random() > 0.5) {
            page.meta ||= {}
            // Note that this will override any middleware set in `definePageMeta` in the page
            page.meta.middleware = ['named']
          }
          if (page.children) {
            setMiddleware(page.children)
          }
        }
      }
      setMiddleware(pages)
    },
  },
})
```
</file>

<file path="docs/2.directory-structure/1.app/1.pages.md">
---
title: "pages"
description: "Nuxt provides file-based routing to create routes within your web application."
head.title: "pages/"
navigation.icon: i-vscode-icons-folder-type-view
---

::note
To reduce your application's bundle size, this directory is **optional**, meaning that [`vue-router`](https://router.vuejs.org) won't be included if you only use [`app.vue`](/docs/4.x/directory-structure/app/app). To force the pages system, set `pages: true` in `nuxt.config` or have a [`router.options.ts`](/docs/4.x/guide/recipes/custom-routing#using-routeroptions).
::

## Usage

Pages are Vue components and can have any [valid extension](/docs/4.x/api/nuxt-config#extensions) that Nuxt supports (by default `.vue`, `.js`, `.jsx`, `.mjs`, `.ts` or `.tsx`).

Nuxt will automatically create a route for every page in your `~/pages/` directory.

::code-group

```vue [app/pages/index.vue]
<template>
  <h1>Index page</h1>
</template>
```

```ts twoslash [pages/index.ts]
// https://vuejs.org/guide/extras/render-function.html
export default defineComponent({
  render () {
    return h('h1', 'Index page')
  },
})
```

```tsx twoslash [pages/index.tsx]
// https://nuxt.com/docs/4.x/examples/advanced/jsx
// https://vuejs.org/guide/extras/render-function.html#jsx-tsx
export default defineComponent({
  render () {
    return <h1>Index page</h1>
  },
})
```

::

The `app/pages/index.vue` file will be mapped to the `/` route of your application.

If you are using [`app.vue`](/docs/4.x/directory-structure/app/app), make sure to use the [`<NuxtPage/>`](/docs/4.x/api/components/nuxt-page) component to display the current page:

```vue [app/app.vue]
<template>
  <div>
    <!-- Markup shared across all pages, ex: NavBar -->
    <NuxtPage />
  </div>
</template>
```

Pages **must have a single root element** to allow [route transitions](/docs/4.x/getting-started/transitions) between pages. HTML comments are considered elements as well.

This means that when the route is server-rendered, or statically generated, you will be able to see its contents correctly, but when you navigate towards that route during client-side navigation the transition between routes will fail and you'll see that the route will not be rendered.

Here are some examples to illustrate what a page with a single root element looks like:

::code-group

```vue [app/pages/working.vue]
<template>
  <div>
    <!-- This page correctly has only one single root element -->
    Page content
  </div>
</template>
```

```vue [app/pages/bad-1.vue]
<template>
  <!-- This page will not render when route changes during client side navigation, because of this comment -->
  <div>Page content</div>
</template>
```

```vue [app/pages/bad-2.vue]
<template>
  <div>This page</div>
  <div>Has more than one root element</div>
  <div>And will not render when route changes during client side navigation</div>
</template>
```

::

## Dynamic Routes

If you place anything within square brackets, it will be turned into a [dynamic route](https://router.vuejs.org/guide/essentials/dynamic-matching) parameter. You can mix and match multiple parameters and even non-dynamic text within a file name or directory.

If you want a parameter to be _optional_, you must enclose it in double square brackets - for example, `~/pages/[[slug]]/index.vue` or `~/pages/[[slug]].vue` will match both `/` and `/test`.

```bash [Directory Structure]
-| pages/
---| index.vue
---| users-[group]/
-----| [id].vue
```

Given the example above, you can access group/id within your component via the `$route` object:

```vue [app/pages/users-[group\\]/[id\\].vue]
<template>
  <p>{{ $route.params.group }} - {{ $route.params.id }}</p>
</template>
```

Navigating to `/users-admins/123` would render:

```html
<p>admins - 123</p>
```

If you want to access the route using Composition API, there is a global [`useRoute`](/docs/4.x/api/composables/use-route) function that will allow you to access the route just like `this.$route` in the Options API.

```vue twoslash
<script setup lang="ts">
const route = useRoute()

if (route.params.group === 'admins' && !route.params.id) {
  console.log('Warning! Make sure user is authenticated!')
}
</script>
```

::note
Named parent routes will take priority over nested dynamic routes. For the `/foo/hello` route, `~/pages/foo.vue` will take priority over `~/pages/foo/[slug].vue`. :br Use `~/pages/foo/index.vue` and `~/pages/foo/[slug].vue` to match `/foo` and `/foo/hello` with different pages,.
::

:video-accordion{title="Watch a video from Vue School on dynamic routes" videoId="754465699" platform="vimeo"}

## Catch-all Route

If you need a catch-all route, you create it by using a file named like `[...slug].vue`. This will match _all_ routes under that path.

```vue [app/pages/[...slug\\].vue]
<template>
  <p>{{ $route.params.slug }}</p>
</template>
```

Navigating to `/hello/world` would render:

```html
<p>["hello", "world"]</p>
```

## Nested Routes

It is possible to display [nested routes](https://router.vuejs.org/guide/essentials/nested-routes) with `<NuxtPage>`.

Example:

```bash [Directory Structure]
-| pages/
---| parent/
-----| child.vue
---| parent.vue
```

This file tree will generate these routes:

```js
[
  {
    path: '/parent',
    component: '~/pages/parent.vue',
    name: 'parent',
    children: [
      {
        path: 'child',
        component: '~/pages/parent/child.vue',
        name: 'parent-child',
      },
    ],
  },
]
```

To display the `child.vue` component, you have to insert the `<NuxtPage>` component inside `app/pages/parent.vue`:

```vue {}[pages/parent.vue]
<template>
  <div>
    <h1>I am the parent view</h1>
    <NuxtPage :foobar="123" />
  </div>
</template>
```

```vue {}[pages/parent/child.vue]
<script setup lang="ts">
const props = defineProps({
  foobar: String,
})

console.log(props.foobar)
</script>
```

### Child Route Keys

If you want more control over when the `<NuxtPage>` component is re-rendered (for example, for transitions), you can either pass a string or function via the `pageKey` prop, or you can define a `key` value via `definePageMeta`:

```vue {}[pages/parent.vue]
<template>
  <div>
    <h1>I am the parent view</h1>
    <NuxtPage :page-key="route => route.fullPath" />
  </div>
</template>
```

Or alternatively:

```vue twoslash {}[pages/parent/child.vue]
<script setup lang="ts">
definePageMeta({
  key: route => route.fullPath,
})
</script>
```

:link-example{to="/docs/4.x/examples/routing/pages"}

## Route Groups

In some cases, you may want to group a set of routes together in a way which doesn't affect file-based routing. For this purpose, you can put files in a folder which is wrapped in parentheses - `(` and `)`.

For example:

```bash [Directory structure]
-| pages/
---| index.vue
---| (marketing)/
-----| about.vue
-----| contact.vue
```

This will produce `/`, `/about` and `/contact` pages in your app. The `marketing` group is ignored for purposes of your URL structure.

### Accessing Route Groups

Route groups are automatically available in the route metadata as `route.meta.groups`.
This allows you to access the group information in your components for conditional logic, styling, or other purposes.

```vue {}[pages/(marketing)/about.vue]
<script setup lang="ts">
const route = useRoute()

console.log(route.meta.groups) // Output: ['marketing']
</script>

<template>
  <div>
    <p v-if="route.meta.groups?.includes('marketing')">
      This is a marketing page
    </p>
  </div>
</template>
```

## Page Metadata

You might want to define metadata for each route in your app. You can do this using the `definePageMeta` macro, which will work both in `<script>` and in `<script setup>`:

```vue twoslash
<script setup lang="ts">
definePageMeta({
  title: 'My home page',
})
</script>
```

This data can then be accessed throughout the rest of your app from the `route.meta` object.

```vue twoslash
<script setup lang="ts">
const route = useRoute()

console.log(route.meta.title) // My home page
</script>
```

If you are using nested routes, the page metadata from all these routes will be merged into a single object. For more on route meta, see the [vue-router docs](https://router.vuejs.org/guide/advanced/meta).

Much like `defineEmits` or `defineProps` (see [Vue docs](https://vuejs.org/api/sfc-script-setup#defineprops-defineemits)), `definePageMeta` is a **compiler macro**. It will be compiled away so you cannot reference it within your component. Instead, the metadata passed to it will be hoisted out of the component.
Therefore, the page meta object cannot reference the component. However, it can reference imported bindings, as well as locally defined **pure functions**.

::warning
Make sure not to reference any reactive data or functions that cause side effects. This can lead to unexpected behavior.
::

```vue
<script setup lang="ts">
import { someData } from '~/utils/example'

function validateIdParam (route) {
  return route.params.id && !Number.isNaN(Number(route.params.id))
}

const title = ref('')

definePageMeta({
  validate: validateIdParam,
  someData,
  title, // do not do this, the ref will be hoisted out of the component
})
</script>
```

### Special Metadata

Of course, you are welcome to define metadata for your own use throughout your app. But some metadata defined with `definePageMeta` has a particular purpose:

#### `alias`

You can define page aliases. They allow you to access the same page from different paths. It can be either a string or an array of strings as defined [in the vue-router documentation](https://router.vuejs.org/guide/essentials/redirect-and-alias#Alias).

#### `keepalive`

Nuxt will automatically wrap your page in [the Vue `<KeepAlive>` component](https://vuejs.org/guide/built-ins/keep-alive#keepalive) if you set `keepalive: true` in your `definePageMeta`. This might be useful to do, for example, in a parent route that has dynamic child routes, if you want to preserve page state across route changes.

When your goal is to preserve state for parent routes use this syntax: `<NuxtPage keepalive />`. You can also set props to be passed to `<KeepAlive>` (see [a full list](https://vuejs.org/api/built-in-components#keepalive)).

You can set a default value for this property [in your `nuxt.config`](/docs/4.x/api/nuxt-config#keepalive).

#### `key`

[See above](/docs/4.x/directory-structure/app/pages#child-route-keys).

#### `layout`

You can define the layout used to render the route. This can be either false (to disable any layout), a string or a ref/computed, if you want to make it reactive in some way. [More about layouts](/docs/4.x/directory-structure/app/layouts).

#### `layoutTransition` and `pageTransition`

You can define transition properties for the `<transition>` component that wraps your pages and layouts, or pass `false` to disable the `<transition>` wrapper for that route. You can see [a list of options that can be passed](https://vuejs.org/api/built-in-components#transition) or read [more about how transitions work](https://vuejs.org/guide/built-ins/transition#transition).

You can set default values for these properties [in your `nuxt.config`](/docs/4.x/api/nuxt-config#layouttransition).

#### `middleware`

You can define middleware to apply before loading this page. It will be merged with all the other middleware used in any matching parent/child routes. It can be a string, a function (an anonymous/inlined middleware function following [the global before guard pattern](https://router.vuejs.org/guide/advanced/navigation-guards#Global-Before-Guards)), or an array of strings/functions. [More about named middleware](/docs/4.x/directory-structure/app/middleware).

#### `name`

You may define a name for this page's route.

#### `path`

You may define a path matcher, if you have a more complex pattern than can be expressed with the file name. See [the `vue-router` docs](https://router.vuejs.org/guide/essentials/route-matching-syntax#Custom-regex-in-params) for more information.

#### `props`

Allows accessing the route `params` as props passed to the page component. See [the `vue-router` docs](https://router.vuejs.org/guide/essentials/passing-props) for more information.

### Typing Custom Metadata

If you add custom metadata for your pages, you may wish to do so in a type-safe way. It is possible to augment the type of the object accepted by `definePageMeta`:

```ts [index.d.ts]
declare module '#app' {
  interface PageMeta {
    pageType?: string
  }
}

// It is always important to ensure you import/export something when augmenting a type
export {}
```

## Navigation

To navigate between pages of your app, you should use the [`<NuxtLink>`](/docs/4.x/api/components/nuxt-link) component.

This component is included with Nuxt and therefore you don't have to import it as you do with other components.

A simple link to the `index.vue` page in your `app/pages` folder:

```vue
<template>
  <NuxtLink to="/">Home page</NuxtLink>
</template>
```

::read-more{to="/docs/4.x/api/components/nuxt-link"}
Learn more about `<NuxtLink>` usage.
::

## Programmatic Navigation

Nuxt allows programmatic navigation through the `navigateTo()` utility method. Using this utility method, you will be able to programmatically navigate the user in your app. This is great for taking input from the user and navigating them dynamically throughout your application. In this example, we have a simple method called `navigate()` that gets called when the user submits a search form.

::note
Make sure to always `await` on `navigateTo` or chain its result by returning from functions.
::

```vue twoslash
<script setup lang="ts">
const name = ref('')
const type = ref(1)

function navigate () {
  return navigateTo({
    path: '/search',
    query: {
      name: name.value,
      type: type.value,
    },
  })
}
</script>
```

## Client-Only Pages

You can define a page as [client only](/docs/4.x/directory-structure/app/components#client-components) by giving it a `.client.vue` suffix. None of the content of this page will be rendered on the server.

## Server-Only Pages

You can define a page as [server only](/docs/4.x/directory-structure/app/components#server-components) by giving it a `.server.vue` suffix. While you will be able to navigate to the page using client-side navigation, controlled by `vue-router`, it will be rendered with a server component automatically, meaning the code required to render the page will not be in your client-side bundle.

::warning
Server-only pages must have a single root element. (HTML comments are considered elements as well.)
::

## Custom Routing

As your app gets bigger and more complex, your routing might require more flexibility. For this reason, Nuxt directly exposes the router, routes and router options for customization in different ways.

:read-more{to="/docs/4.x/guide/recipes/custom-routing"}

## Multiple Pages Directories

By default, all your pages should be in one `app/pages` directory at the root of your project.

However, you can use [Nuxt Layers](/docs/4.x/getting-started/layers) to create groupings of your app's pages:

```bash [Directory Structure]
-| some-app/
---| nuxt.config.ts
---| pages/
-----| app-page.vue
-| nuxt.config.ts
```

```ts twoslash [some-app/nuxt.config.ts]
// some-app/nuxt.config.ts
export default defineNuxtConfig({
})
```

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  extends: ['./some-app'],
})
```

:read-more{to="/docs/4.x/guide/going-further/layers"}
</file>

<file path="docs/2.directory-structure/1.app/1.plugins.md">
---
title: "plugins"
description: "Nuxt has a plugins system to use Vue plugins and more at the creation of your Vue application."
head.title: "plugins/"
navigation.icon: i-vscode-icons-folder-type-plugin
---

Nuxt automatically reads the files in the `app/plugins/` directory and loads them at the creation of the Vue application.

::note
All plugins inside are auto-registered, you don't need to add them to your `nuxt.config` separately.
::

::note
You can use `.server` or `.client` suffix in the file name to load a plugin only on the server or client side.
::

## Registered Plugins

Only files at the top level of the directory (or index files within any subdirectories) will be auto-registered as plugins.

```bash [Directory structure]
-| plugins/
---| foo.ts      // scanned
---| bar/
-----| baz.ts    // not scanned
-----| foz.vue   // not scanned
-----| index.ts  // currently scanned but deprecated
```

Only `foo.ts` and `bar/index.ts` would be registered.

To add plugins in subdirectories, you can use the [`app/plugins`](/docs/4.x/api/nuxt-config#plugins-1) option in `nuxt.config.ts`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  plugins: [
    '~/plugins/bar/baz',
    '~/plugins/bar/foz',
  ],
})
```

## Creating Plugins

The only argument passed to a plugin is [`nuxtApp`](/docs/4.x/api/composables/use-nuxt-app).

```ts twoslash [plugins/hello.ts]
export default defineNuxtPlugin((nuxtApp) => {
  // Doing something with nuxtApp
})
```

### Object Syntax Plugins

It is also possible to define a plugin using an object syntax, for more advanced use cases. For example:

```ts twoslash [plugins/hello.ts]
export default defineNuxtPlugin({
  name: 'my-plugin',
  enforce: 'pre', // or 'post'
  async setup (nuxtApp) {
    // this is the equivalent of a normal functional plugin
  },
  hooks: {
    // You can directly register Nuxt app runtime hooks here
    'app:created' () {
      const nuxtApp = useNuxtApp()
      // do something in the hook
    },
  },
  env: {
    // Set this value to `false` if you don't want the plugin to run when rendering server-only or island components.
    islands: true,
  },
})
```

:video-accordion{title="Watch a video from Alexander Lichter about the Object Syntax for Nuxt plugins" videoId="2aXZyXB1QGQ"}

::note
If you are using the object-syntax, the properties are statically analyzed to produce a more optimized build. So you should not define them at runtime. :br
For example, setting `enforce: import.meta.server ? 'pre' : 'post'` would defeat any future optimization Nuxt is able to do for your plugins.
Nuxt does statically pre-load any hook listeners when using object-syntax, allowing you to define hooks without needing to worry about order of plugin registration.
::

## Registration Order

You can control the order in which plugins are registered by prefixing with 'alphabetical' numbering to the file names.

```bash [Directory structure]
plugins/
 | - 01.myPlugin.ts
 | - 02.myOtherPlugin.ts
```

In this example, `02.myOtherPlugin.ts` will be able to access anything that was injected by `01.myPlugin.ts`.

This is useful in situations where you have a plugin that depends on another plugin.

::note
In case you're new to 'alphabetical' numbering, remember that filenames are sorted as strings, not as numeric values. For example, `10.myPlugin.ts` would come before `2.myOtherPlugin.ts`. This is why the example prefixes single digit numbers with `0`.
::

## Loading Strategy

### Parallel Plugins

By default, Nuxt loads plugins sequentially. You can define a plugin as `parallel` so Nuxt won't wait until the end of the plugin's execution before loading the next plugin.

```ts twoslash [plugins/my-plugin.ts]
export default defineNuxtPlugin({
  name: 'my-plugin',
  parallel: true,
  async setup (nuxtApp) {
    // the next plugin will be executed immediately
  },
})
```

### Plugins With Dependencies

If a plugin needs to wait for another plugin before it runs, you can add the plugin's name to the `dependsOn` array.

```ts twoslash [plugins/depending-on-my-plugin.ts]
export default defineNuxtPlugin({
  name: 'depends-on-my-plugin',
  dependsOn: ['my-plugin'],
  async setup (nuxtApp) {
    // this plugin will wait for the end of `my-plugin`'s execution before it runs
  },
})
```

## Using Composables

You can use [composables](/docs/4.x/directory-structure/app/composables) as well as [utils](/docs/4.x/directory-structure/app/utils) within Nuxt plugins:

```ts [app/plugins/hello.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const foo = useFoo()
})
```

However, keep in mind there are some limitations and differences:

::important
**If a composable depends on another plugin registered later, it might not work.** :br

Plugins are called in order sequentially and before everything else. You might use a composable that depends on another plugin which has not been called yet.
::

::important
**If a composable depends on the Vue.js lifecycle, it won't work.** :br

Normally, Vue.js composables are bound to the current component instance while plugins are only bound to [`nuxtApp`](/docs/4.x/api/composables/use-nuxt-app) instance.
::

## Providing Helpers

If you would like to provide a helper on the [`NuxtApp`](/docs/4.x/api/composables/use-nuxt-app) instance, return it from the plugin under a `provide` key.

::code-group
```ts twoslash [plugins/hello.ts]
export default defineNuxtPlugin(() => {
  return {
    provide: {
      hello: (msg: string) => `Hello ${msg}!`,
    },
  }
})
```
```ts twoslash [plugins/hello-object-syntax.ts]
export default defineNuxtPlugin({
  name: 'hello',
  setup () {
    return {
      provide: {
        hello: (msg: string) => `Hello ${msg}!`,
      },
    }
  },
})
```
::

You can then use the helper in your components:

```vue [app/components/Hello.vue]
<script setup lang="ts">
// alternatively, you can also use it here
const { $hello } = useNuxtApp()
</script>

<template>
  <div>
    {{ $hello('world') }}
  </div>
</template>
```

::important
Note that we highly recommend using [`composables`](/docs/4.x/directory-structure/app/composables) instead of providing helpers to avoid polluting the global namespace and keep your main bundle entry small.
::

::warning
**If your plugin provides a `ref` or `computed`, it will not be unwrapped in a component `<template>`.** :br
This is due to how Vue works with refs that aren't top-level to the template. You can read more about it [in the Vue documentation](https://vuejs.org/guide/essentials/reactivity-fundamentals#caveat-when-unwrapping-in-templates).
::

## Typing Plugins

If you return your helpers from the plugin, they will be typed automatically; you'll find them typed for the return of `useNuxtApp()` and within your templates.

::note
If you need to use a provided helper _within_ another plugin, you can call [`useNuxtApp()`](/docs/4.x/api/composables/use-nuxt-app) to get the typed version. But in general, this should be avoided unless you are certain of the plugins' order.
::

For advanced use-cases, you can declare the type of injected properties like this:

```ts [index.d.ts]
declare module '#app' {
  interface NuxtApp {
    $hello (msg: string): string
  }
}

declare module 'vue' {
  interface ComponentCustomProperties {
    $hello (msg: string): string
  }
}

export {}
```

## Vue Plugins

If you want to use Vue plugins, like [vue-gtag](https://github.com/MatteoGabriele/vue-gtag) to add Google Analytics tags, you can use a Nuxt plugin to do so.

First, install the Vue plugin dependency:

::code-group{sync="pm"}
```bash [npm]
npm install --save-dev vue-gtag-next
```
```bash [yarn]
yarn add --dev vue-gtag-next
```
```bash [pnpm]
pnpm add -D vue-gtag-next
```
```bash [bun]
bun add -D vue-gtag-next
```
::

Then create a plugin file:

```ts [app/plugins/vue-gtag.client.ts]
import VueGtag, { trackRouter } from 'vue-gtag-next'

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(VueGtag, {
    property: {
      id: 'GA_MEASUREMENT_ID',
    },
  })
  trackRouter(useRouter())
})
```

## Vue Directives

Similarly, you can register a custom Vue directive in a plugin.

```ts twoslash [plugins/my-directive.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.directive('focus', {
    mounted (el) {
      el.focus()
    },
    getSSRProps (binding, vnode) {
      // you can provide SSR-specific props here
      return {}
    },
  })
})
```

::warning
If you register a Vue directive, you _must_ register it on both client and server side unless you are only using it when rendering one side. If the directive only makes sense from a client side, you can always move it to `~/plugins/my-directive.client.ts` and provide a 'stub' directive for the server in `~/plugins/my-directive.server.ts`.
::

:read-more{icon="i-simple-icons-vuedotjs" title="Custom Directives on Vue Docs" to="https://vuejs.org/guide/reusability/custom-directives.html" target="_blank"}
</file>

<file path="docs/2.directory-structure/1.app/1.utils.md">
---
title: 'utils'
head.title: 'utils/'
description: Use the utils/ directory to auto-import your utility functions throughout your application.
navigation.icon: i-vscode-icons-folder-type-tools
---

The main purpose of the [`app/utils/` directory](/docs/4.x/directory-structure/app/utils) is to allow a semantic distinction between your Vue composables and other auto-imported utility functions.

## Usage

**Method 1:** Using named export

```ts twoslash [utils/index.ts]
export const { format: formatNumber } = Intl.NumberFormat('en-GB', {
  notation: 'compact',
  maximumFractionDigits: 1,
})
```

**Method 2:** Using default export

```ts twoslash [utils/random-entry.ts or utils/randomEntry.ts]
// It will be available as randomEntry() (camelCase of file name without extension)
export default function (arr: Array<any>) {
  return arr[Math.floor(Math.random() * arr.length)]
}
```

You can now use auto imported utility functions in `.js`, `.ts` and `.vue` files

```vue [app/app.vue]
<template>
  <p>{{ formatNumber(1234) }}</p>
</template>
```

:read-more{to="/docs/4.x/guide/concepts/auto-imports"}

:link-example{to="/docs/4.x/examples/features/auto-imports"}

::tip
The way `app/utils/` auto-imports work and are scanned is identical to the [`app/composables/`](/docs/4.x/directory-structure/app/composables) directory.
::

::important
These utils are only available within the Vue part of your app. :br
Only `server/utils` are auto-imported in the [`server/`](/docs/4.x/directory-structure/server#server-utilities) directory.
::
</file>

<file path="docs/2.directory-structure/1.app/3.app-config.md">
---
title: app.config.ts
head.title: 'app.config.ts'
description: Expose reactive configuration within your application with the App Config file.
navigation.icon: i-vscode-icons-file-type-light-config
---

Nuxt provides an `app/app.config.ts` config file to expose reactive configuration within your application with the ability to update it at runtime within lifecycle or using a nuxt plugin and editing it with HMR (hot-module-replacement).

You can easily provide runtime app configuration using `app.config.ts` file. It can have either of `.ts`, `.js`, or `.mjs` extensions.

```ts twoslash [app/app.config.ts]
export default defineAppConfig({
  foo: 'bar',
})
```

::caution
Do not put any secret values inside `app.config` file. It is exposed to the user client bundle.
::

::note
When configuring a custom [`srcDir`](/docs/4.x/api/nuxt-config#srcdir), make sure to place the `app.config` file at the root of the new `srcDir` path.
::

## Usage

To expose config and environment variables to the rest of your app, you will need to define configuration in `app.config` file.

```ts twoslash [app/app.config.ts]
export default defineAppConfig({
  theme: {
    primaryColor: '#ababab',
  },
})
```

We can now universally access `theme` both when server-rendering the page and in the browser using [`useAppConfig`](/docs/4.x/api/composables/use-app-config) composable.

```vue [app/pages/index.vue]
<script setup lang="ts">
const appConfig = useAppConfig()

console.log(appConfig.theme)
</script>
```

The [`updateAppConfig`](/docs/4.x/api/utils/update-app-config) utility can be used to update the `app.config` at runtime.

```vue [app/pages/index.vue]
<script setup>
const appConfig = useAppConfig() // { foo: 'bar' }

const newAppConfig = { foo: 'baz' }

updateAppConfig(newAppConfig)

console.log(appConfig) // { foo: 'baz' }
</script>
```

::read-more{to="/docs/4.x/api/utils/update-app-config"}
Read more about the `updateAppConfig` utility.
::

## Typing App Config

Nuxt tries to automatically generate a TypeScript interface from provided app config so you won't have to type it yourself.

However, there are some cases where you might want to type it yourself. There are two possible things you might want to type.

### App Config Input

`AppConfigInput` might be used by module authors who are declaring what valid _input_ options are when setting app config. This will not affect the type of `useAppConfig()`.

```ts [index.d.ts]
declare module 'nuxt/schema' {
  interface AppConfigInput {
    /** Theme configuration */
    theme?: {
      /** Primary app color */
      primaryColor?: string
    }
  }
}

// It is always important to ensure you import/export something when augmenting a type
export {}
```

### App Config Output

If you want to type the result of calling [`useAppConfig()`](/docs/4.x/api/composables/use-app-config), then you will want to extend `AppConfig`.

::warning
Be careful when typing `AppConfig` as you will overwrite the types Nuxt infers from your actually defined app config.
::

```ts [index.d.ts]
declare module 'nuxt/schema' {
  interface AppConfig {
    // This will entirely replace the existing inferred `theme` property
    theme: {
      // You might want to type this value to add more specific types than Nuxt can infer,
      // such as string literal types
      primaryColor?: 'red' | 'blue'
    }
  }
}

// It is always important to ensure you import/export something when augmenting a type
export {}
```

## Merging Strategy

Nuxt uses a custom merging strategy for the `AppConfig` within [the layers](/docs/4.x/getting-started/layers) of your application.

This strategy is implemented using a [Function Merger](https://github.com/unjs/defu#function-merger), which allows defining a custom merging strategy for every key in `app.config` that has an array as value.

::note
The function merger can only be used in the extended layers and not the main `app.config` in project.
::

Here's an example of how you can use:

::code-group

```ts twoslash [layer/app/app.config.ts]
export default defineAppConfig({
  // Default array value
  array: ['hello'],
})
```

```ts twoslash [app/app.config.ts]
export default defineAppConfig({
  // Overwrite default array value by using a merger function
  array: () => ['bonjour'],
})
```

::

## Known Limitations

As of Nuxt v3.3, the `app.config.ts` file is shared with Nitro, which results in the following limitations:

1. You cannot import Vue components directly in `app.config.ts`.
2. Some auto-imports are not available in the Nitro context.

These limitations occur because Nitro processes the app config without full Vue component support.

While it's possible to use Vite plugins in the Nitro config as a workaround, this approach is not recommended:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    vite: {
      plugins: [vue()],
    },
  },
})
```

::warning
Using this workaround may lead to unexpected behavior and bugs. The Vue plugin is one of many that are not available in the Nitro context.
::

Related issues:
- [Issue #19858](https://github.com/nuxt/nuxt/issues/19858)
- [Issue #19854](https://github.com/nuxt/nuxt/issues/19854)

::note
Nitro v3 will resolve these limitations by removing support for the app config.
You can track the progress in [this pull request](https://github.com/nitrojs/nitro/pull/2521).
::
</file>

<file path="docs/2.directory-structure/1.app/3.app.md">
---
title: "app.vue"
description: "The app.vue file is the main component of your Nuxt application."
head.title: "app.vue"
navigation.icon: i-vscode-icons-file-type-vue
---

::tip
If you have a `app/pages/` directory, the `app.vue` file is optional. Nuxt will automatically include a default `app.vue`, but you can still add your own to customize the structure and content as needed.
::

## Usage

### Minimal Usage

With Nuxt, the [`app/pages/`](/docs/4.x/directory-structure/app/pages) directory is optional. If it is not present, Nuxt will not include the [vue-router](https://router.vuejs.org) dependency. This is useful when building a landing page or an application that does not require routing.

```vue [app/app.vue]
<template>
  <h1>Hello World!</h1>
</template>
```

:link-example{to="/docs/4.x/examples/hello-world"}

### Usage with Pages

When you have a [`app/pages/`](/docs/4.x/directory-structure/app/pages) directory, you need to use the [`<NuxtPage>`](/docs/4.x/api/components/nuxt-page) component to display the current page:

```vue [app/app.vue]
<template>
  <NuxtPage />
</template>
```

You can also define the common structure of your application directly in `app.vue`. This is useful when you want to include global elements such as a header or footer:

```vue [app/app.vue]
<template>
  <header>
    Header content
  </header>
  <NuxtPage />
  <footer>
    Footer content
  </footer>
</template>
```

::note
Remember that `app.vue` acts as the main component of your Nuxt application. Anything you add to it (JS and CSS) will be global and included in every page.
::

::read-more{to="/docs/4.x/directory-structure/app/pages"}
Learn more about how to structure your pages using the `app/pages/` directory.
::

### Usage with Layouts

When your application requires different layouts for different pages, you can use the `app/layouts/` directory with the [`<NuxtLayout>`](/docs/4.x/api/components/nuxt-layout) component. This allows you to define multiple layouts and apply them per page.

```vue [app/app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

::read-more{to="/docs/4.x/directory-structure/app/layouts"}
Learn more about how to structure your layouts using the `app/layouts/` directory.
::
</file>

<file path="docs/2.directory-structure/1.app/3.error.md">
---
title: "error.vue"
description: "The error.vue file is the error page in your Nuxt application."
head.title: "error.vue"
navigation.icon: i-vscode-icons-file-type-vue
---

During the lifespan of your application, some errors may appear unexpectedly at runtime. In such case, we can use the `error.vue` file to override the default error files and display the error nicely.

```vue [error.vue]
<script setup lang="ts">
import type { NuxtError } from '#app'

const props = defineProps<{ error: NuxtError }>()
</script>

<template>
  <div>
    <h1>{{ error.status }}</h1>
    <NuxtLink to="/">Go back home</NuxtLink>
  </div>
</template>
```

::note
Although it is called an 'error page' it's not a route and shouldn't be placed in your `~/pages` directory. For the same reason, you shouldn't use `definePageMeta` within this page. That being said, you can still use layouts in the error file, by utilizing the [`NuxtLayout`](/docs/4.x/api/components/nuxt-layout) component and specifying the name of the layout.
::

The error page has a single prop - `error` which contains an error for you to handle.

The `error` object provides the following fields:
```ts
interface NuxtError {
  status: number
  fatal: boolean
  unhandled: boolean
  statusText?: string
  data?: unknown
  cause?: unknown
  // legacy/deprecated equivalent of `status`
  statusCode: number
  // legacy/deprecated equivalent of `statusText`
  statusMessage?: string
}
```

If you have an error with custom fields they will be lost; you should assign them to `data` instead:

```ts
throw createError({
  status: 404,
  statusText: 'Page Not Found',
  data: {
    myCustomField: true,
  },
})
```
</file>

<file path="docs/2.directory-structure/.navigation.yml">
title: Directory Structure
titleTemplate: '%s · Nuxt Directory Structure'
icon: i-vscode-icons-default-folder
</file>

<file path="docs/2.directory-structure/0.nuxt.md">
---
title: ".nuxt"
description: "Nuxt uses the .nuxt/ directory in development to generate your Vue application."
head.title: ".nuxt/"
navigation.icon: i-vscode-icons-folder-type-temp
---

::important
This directory should be added to your [`.gitignore`](/docs/4.x/directory-structure/gitignore) file to avoid pushing the dev build output to your repository.
::

This directory is interesting if you want to learn more about the files Nuxt generates based on your directory structure.

Nuxt also provides a Virtual File System (VFS) for modules to add templates to this directory without writing them to disk.

You can explore the generated files by opening the [Nuxt DevTools](https://devtools.nuxt.com) in development mode and navigating to the **Virtual Files** tab.

::warning
You should not touch any files inside since the whole directory will be re-created when running [`nuxt dev`](/docs/4.x/api/commands/dev).
::
</file>

<file path="docs/2.directory-structure/0.output.md">
---
title: ".output"
description: "Nuxt creates the .output/ directory when building your application for production."
head.title: ".output/"
navigation.icon: i-vscode-icons-folder-type-package
---

::important
This directory should be added to your [`.gitignore`](/docs/4.x/directory-structure/gitignore) file to avoid pushing the build output to your repository.
::

Use this directory to deploy your Nuxt application to production.

:read-more{to="/docs/4.x/getting-started/deployment"}

::warning
You should not touch any files inside since the whole directory will be re-created when running [`nuxt build`](/docs/4.x/api/commands/build).
::
</file>

<file path="docs/2.directory-structure/1.content.md">
---
title: 'content'
head.title: 'content/'
description: Use the content/ directory to create a file-based CMS for your application.
navigation.icon: i-vscode-icons-folder-type-log
---

[Nuxt Content](https://content.nuxt.com) reads the `content/` directory in your project and parses `.md`, `.yml`, `.csv` and `.json` files to create a file-based CMS for your application.

- Render your content with built-in components.
- Query your content with a MongoDB-like API.
- Use your Vue components in Markdown files with the MDC syntax.
- Automatically generate your navigation.

::read-more{to="https://content.nuxt.com" target="_blank"}
Learn more in **Nuxt Content** documentation.
::

## Enable Nuxt Content

Install the `@nuxt/content` module in your project as well as adding it to your `nuxt.config.ts` with one command:

```bash [Terminal]
npx nuxt module add content
```

## Create Content

Place your markdown files inside the `content/` directory:

```md [content/index.md]
# Hello Content
```

The module automatically loads and parses them.

## Render Content

To render content pages, add a [catch-all route](/docs/4.x/directory-structure/app/pages/#catch-all-route) using the [`<ContentRenderer>`](https://content.nuxt.com/docs/components/content-renderer) component:

```vue [app/pages/[...slug\\].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('content').path(route.path).first()
})
</script>

<template>
  <div>
    <header><!-- ... --></header>

    <ContentRenderer
      v-if="page"
      :value="page"
    />

    <footer><!-- ... --></footer>
  </div>
</template>
```

## Documentation

::tip{ icon="i-lucide-book" }
Head over to <https://content.nuxt.com> to learn more about the Content module features, such as how to build queries and use Vue components in your Markdown files with the MDC syntax.
::
</file>

<file path="docs/2.directory-structure/1.modules.md">
---
title: 'modules'
head.title: 'modules/'
description: Use the modules/ directory to automatically register local modules within your application.
navigation.icon: i-vscode-icons-folder-type-nuxt
---

It is a good place to place any local modules you develop while building your application.

The auto-registered files patterns are:
- `modules/*/index.ts`
- `modules/*.ts`

You don't need to add those local modules to your [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) separately.

::code-group

```ts twoslash [modules/hello/index.ts]
// `nuxt/kit` is a helper subpath import you can use when defining local modules
// that means you do not need to add `@nuxt/kit` to your project's dependencies
import { addServerHandler, createResolver, defineNuxtModule } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'hello',
  },
  setup () {
    const resolver = createResolver(import.meta.url)

    // Add an API route
    addServerHandler({
      route: '/api/hello',
      handler: resolver.resolve('./runtime/api-route'),
    })
  },
})
```

```ts twoslash [modules/hello/runtime/api-route.ts]
export default defineEventHandler(() => {
  return { hello: 'world' }
})
```

::

When starting Nuxt, the `hello` module will be registered and the `/api/hello` route will be available.

Modules are executed in the following sequence:
- First, the modules defined in [`nuxt.config.ts`](/docs/4.x/api/nuxt-config#modules-1) are loaded.
- Then, modules found in the `modules/` directory are executed, and they load in alphabetical order.

You can change the order of local module by adding a number to the front of each directory name:

```bash [Directory structure]
modules/
  1.first-module/
    index.ts
  2.second-module.ts
```

:read-more{to="/docs/4.x/guide/modules"}

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/creating-your-first-module-from-scratch?friend=nuxt" target="_blank"}
Watch Vue School video about Nuxt private modules.
::
</file>

<file path="docs/2.directory-structure/1.node_modules.md">
---
title: "node_modules"
description: "The package manager stores the dependencies of your project in the node_modules/ directory."
head.title: "node_modules/"
navigation.icon: i-vscode-icons-folder-type-node
---

The package manager ([`npm`](https://docs.npmjs.com/cli/commands/npm/) or [`yarn`](https://yarnpkg.com) or [`pnpm`](https://pnpm.io/cli/install) or [`bun`](https://bun.com/package-manager) or [`deno`](https://docs.deno.com/runtime/getting_started/installation/)) creates this directory to store the dependencies of your project.

::important
This directory should be added to your [`.gitignore`](/docs/4.x/directory-structure/gitignore) file to avoid pushing the dependencies to your repository.
::
</file>

<file path="docs/2.directory-structure/1.public.md">
---
title: "public"
description: "The public/ directory is used to serve your website's static assets."
head.title: "public/"
navigation.icon: i-vscode-icons-folder-type-public
---

Files contained within the `public/` directory are served at the root and are not modified by the build process. This is suitable for files that have to keep their names (e.g. `robots.txt`) _or_ likely won't change (e.g. `favicon.ico`).

```bash [Directory structure]
-| public/
---| favicon.ico
---| og-image.png
---| robots.txt
```

```vue [app/app.vue]
<script setup lang="ts">
useSeoMeta({
  ogImage: '/og-image.png',
})
</script>
```

::tip{to="https://v2.nuxt.com/docs/directory-structure/static/" target="_blank"}
This is known as the [`static/`] directory in Nuxt 2.
::
</file>

<file path="docs/2.directory-structure/1.server.md">
---
title: server
head.title: 'server/'
description: The server/ directory is used to register API and server handlers to your application.
navigation.icon: i-vscode-icons-folder-type-server
---

Nuxt automatically scans files inside these directories to register API and server handlers with Hot Module Replacement (HMR) support.

```bash [Directory structure]
-| server/
---| api/
-----| hello.ts      # /api/hello
---| routes/
-----| bonjour.ts    # /bonjour
---| middleware/
-----| log.ts        # log all requests
```

Each file should export a default function defined with `defineEventHandler()` or `eventHandler()` (alias).

The handler can directly return JSON data, a `Promise`, or use `event.node.res.end()` to send a response.

```ts twoslash [server/api/hello.ts]
export default defineEventHandler((event) => {
  return {
    hello: 'world',
  }
})
```

You can now universally call this API in your pages and components:

```vue [app/pages/index.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/hello')
</script>

<template>
  <pre>{{ data }}</pre>
</template>
```

## Server Routes

Files inside the `~/server/api` are automatically prefixed with `/api` in their route.

:video-accordion{title="Watch a video from Vue School on API routes" videoId="761468863" platform="vimeo"}

To add server routes without `/api` prefix, put them into `~/server/routes` directory.

**Example:**

```ts [server/routes/hello.ts]
export default defineEventHandler(() => 'Hello World!')
```

Given the example above, the `/hello` route will be accessible at <http://localhost:3000/hello>.

::note
Note that currently server routes do not support the full functionality of dynamic routes as [pages](/docs/4.x/directory-structure/app/pages#dynamic-routes) do.
::

## Server Middleware

Nuxt will automatically read in any file in the `~/server/middleware` to create server middleware for your project.

Middleware handlers will run on every request before any other server route to add or check headers, log requests, or extend the event's request object.

::note
Middleware handlers should not return anything (nor close or respond to the request) and only inspect or extend the request context or throw an error.
::

**Examples:**

```ts [server/middleware/log.ts]
export default defineEventHandler((event) => {
  console.log('New request: ' + getRequestURL(event))
})
```

```ts [server/middleware/auth.ts]
export default defineEventHandler((event) => {
  event.context.auth = { user: 123 }
})
```

## Server Plugins

Nuxt will automatically read any files in the `~/server/plugins` directory and register them as Nitro plugins. This allows extending Nitro's runtime behavior and hooking into lifecycle events.

**Example:**

```ts [server/plugins/nitroPlugin.ts]
export default defineNitroPlugin((nitroApp) => {
  console.log('Nitro plugin', nitroApp)
})
```

:read-more{to="https://nitro.build/guide/plugins" title="Nitro Plugins" target="_blank"}

## Server Utilities

Server routes are powered by [h3js/h3](https://github.com/h3js/h3) which comes with a handy set of helpers.

:read-more{to="https://www.jsdocs.io/package/h3#package-index-functions" title="Available H3 Request Helpers" target="_blank"}

You can add more helpers yourself inside the `~/server/utils` directory.

For example, you can define a custom handler utility that wraps the original handler and performs additional operations before returning the final response.

**Example:**

```ts [server/utils/handler.ts]
import type { EventHandler, EventHandlerRequest } from 'h3'

export const defineWrappedResponseHandler = <T extends EventHandlerRequest, D> (
  handler: EventHandler<T, D>,
): EventHandler<T, D> =>
  defineEventHandler<T>(async (event) => {
    try {
      // do something before the route handler
      const response = await handler(event)
      // do something after the route handler
      return { response }
    } catch (err) {
      // Error handling
      return { err }
    }
  })
```
```ts [server/api/hello.get.ts]
export default defineWrappedResponseHandler(event => 'hello world')
```

## Server Alias

You can use the `#server` alias to import files from anywhere within the `server/` directory, regardless of the importing file's location.

```ts [server/api/users/[id]/profile.ts]
// Instead of relative paths like this:
// import { formatUser } from '../../../utils/formatUser'

// Use the #server alias:
import { formatUser } from '#server/utils/formatUser'
```

This alias ensures consistent imports across your server code, especially useful in deeply nested route handlers.

::note
The `#server` alias can only be used within the `server/` directory. Importing from `#server` in client code will result in an error.
::

## Server Types

Auto-imports and other types are different for the `server/` directory, as it is running in a different context from the `app/` directory.

By default, Nuxt 4 generates a [`tsconfig.json`](/docs/4.x/directory-structure/tsconfig) which includes a project reference covering the `server/` folder which ensures accurate typings.

## Recipes

### Route Parameters

Server routes can use dynamic parameters within brackets in the file name like `/api/hello/[name].ts` and be accessed via `event.context.params`.

```ts [server/api/hello/[name\\].ts]
export default defineEventHandler((event) => {
  const name = getRouterParam(event, 'name')

  return `Hello, ${name}!`
})
```

::tip{to="https://h3.dev/examples/validate-data#validate-params"}
Alternatively, use `getValidatedRouterParams` with a schema validator such as Zod for runtime and type safety.
::

You can now universally call this API on `/api/hello/nuxt` and get `Hello, nuxt!`.

### Matching HTTP Method

Handle file names can be suffixed with `.get`, `.post`, `.put`, `.delete`, ... to match request's [HTTP Method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods).

```ts [server/api/test.get.ts]
export default defineEventHandler(() => 'Test get handler')
```

```ts [server/api/test.post.ts]
export default defineEventHandler(() => 'Test post handler')
```

Given the example above, fetching `/test` with:

- **GET** method: Returns `Test get handler`
- **POST** method: Returns `Test post handler`
- Any other method: Returns 405 error

You can also use `index.[method].ts` inside a directory for structuring your code differently, this is useful to create API namespaces.

::code-group
```ts [server/api/foo/index.get.ts]
export default defineEventHandler((event) => {
  // handle GET requests for the `api/foo` endpoint
})
```
```ts [server/api/foo/index.post.ts]
export default defineEventHandler((event) => {
  // handle POST requests for the `api/foo` endpoint
})
```
```ts [server/api/foo/bar.get.ts]
export default defineEventHandler((event) => {
  // handle GET requests for the `api/foo/bar` endpoint
})
```
::

### Catch-all Route

Catch-all routes are helpful for fallback route handling.

For example, creating a file named `~/server/api/foo/[...].ts` will register a catch-all route for all requests that do not match any route handler, such as `/api/foo/bar/baz`.

```ts [server/api/foo/[...\\].ts]
export default defineEventHandler((event) => {
  // event.context.path to get the route path: '/api/foo/bar/baz'
  // event.context.params._ to get the route segment: 'bar/baz'
  return `Default foo handler`
})
```

You can set a name for the catch-all route by using `~/server/api/foo/[...slug].ts` and access it via `event.context.params.slug`.

```ts [server/api/foo/[...slug\\].ts]
export default defineEventHandler((event) => {
  // event.context.params.slug to get the route segment: 'bar/baz'
  return `Default foo handler`
})
```

### Body Handling

```ts [server/api/submit.post.ts]
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  return { body }
})
```

::tip{to="https://unjs.io/blog/2023-08-15-h3-towards-the-edge-of-the-web/#runtime-type-safe-request-utils"}
Alternatively, use `readValidatedBody` with a schema validator such as Zod for runtime and type safety.
::

You can now universally call this API using:

```vue [app/app.vue]
<script setup lang="ts">
async function submit () {
  const { body } = await $fetch('/api/submit', {
    method: 'post',
    body: { test: 123 },
  })
}
</script>
```

::note
We are using `submit.post.ts` in the filename only to match requests with `POST` method that can accept the request body. When using `readBody` within a GET request, `readBody` will throw a `405 Method Not Allowed` HTTP error.
::

### Query Parameters

Sample query `/api/query?foo=bar&baz=qux`

```ts [server/api/query.get.ts]
export default defineEventHandler((event) => {
  const query = getQuery(event)

  return { a: query.foo, b: query.baz }
})
```

::tip{to="https://unjs.io/blog/2023-08-15-h3-towards-the-edge-of-the-web#runtime-type-safe-request-utils"}
Alternatively, use `getValidatedQuery` with a schema validator such as Zod for runtime and type safety.
::

### Error Handling

If no errors are thrown, a status code of `200 OK` will be returned.

Any uncaught errors will return a `500 Internal Server Error` HTTP Error.

To return other error codes, throw an exception with [`createError`](/docs/4.x/api/utils/create-error):

```ts [server/api/validation/[id\\].ts]
export default defineEventHandler((event) => {
  const id = Number.parseInt(event.context.params.id) as number

  if (!Number.isInteger(id)) {
    throw createError({
      status: 400,
      statusText: 'ID should be an integer',
    })
  }
  return 'All good'
})
```

### Status Codes

To return other status codes, use the [`setResponseStatus`](/docs/4.x/api/utils/set-response-status) utility.

For example, to return `202 Accepted`

```ts [server/api/validation/[id\\].ts]
export default defineEventHandler((event) => {
  setResponseStatus(event, 202)
})
```

### Runtime Config

::code-group
```ts [server/api/foo.ts]
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)

  const repo = await $fetch('https://api.github.com/repos/nuxt/nuxt', {
    headers: {
      Authorization: `token ${config.githubToken}`,
    },
  })

  return repo
})
```
```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    githubToken: '',
  },
})
```
```ini [.env]
NUXT_GITHUB_TOKEN='<my-super-token>'
```
::

::note
Giving the `event` as argument to `useRuntimeConfig` is optional, but it is recommended to pass it to get the runtime config overwritten by [environment variables](/docs/4.x/guide/going-further/runtime-config#environment-variables) at runtime for server routes.
::

### Request Cookies

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const cookies = parseCookies(event)

  return { cookies }
})
```

### Forwarding Context & Headers

By default, neither the headers from the incoming request nor the request context are forwarded when
making fetch requests in server routes. You can use `event.$fetch` to forward the request context and headers when making fetch requests in server routes.

```ts [server/api/forward.ts]
export default defineEventHandler((event) => {
  return event.$fetch('/api/forwarded')
})
```

::note
Headers that are **not meant to be forwarded** will **not be included** in the request. These headers include, for example:
`transfer-encoding`, `connection`, `keep-alive`, `upgrade`, `expect`, `host`, `accept`
::

### Awaiting Promises After Response

When handling server requests, you might need to perform asynchronous tasks that shouldn't block the response to the client (for example, caching and logging). You can use `event.waitUntil` to await a promise in the background without delaying the response.

The `event.waitUntil` method accepts a promise that will be awaited before the handler terminates, ensuring the task is completed even if the server would otherwise terminate the handler right after the response is sent. This integrates with runtime providers to leverage their native capabilities for handling asynchronous operations after the response is sent.

```ts [server/api/background-task.ts]
const timeConsumingBackgroundTask = async () => {
  await new Promise(resolve => setTimeout(resolve, 1000))
}

export default eventHandler((event) => {
  // schedule a background task without blocking the response
  event.waitUntil(timeConsumingBackgroundTask())

  // immediately send the response to the client
  return 'done'
})
```

## Advanced Usage

### Nitro Config

You can use `nitro` key in `nuxt.config` to directly set [Nitro configuration](https://nitro.build/config).

::warning
This is an advanced option. Custom config can affect production deployments, as the configuration interface might change over time when Nitro is upgraded in semver-minor versions of Nuxt.
::

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  // https://nitro.build/config
  nitro: {},
})
```

:read-more{to="/docs/4.x/guide/concepts/server-engine"}

### Nested Router

```ts [server/api/hello/[...slug\\].ts]
import { createRouter, defineEventHandler, useBase } from 'h3'

const router = createRouter()

router.get('/test', defineEventHandler(() => 'Hello World'))

export default useBase('/api/hello', router.handler)
```

### Sending Streams

::tip
This is an experimental feature and is available in all environments.
::

```ts [server/api/foo.get.ts]
import fs from 'node:fs'
import { sendStream } from 'h3'

export default defineEventHandler((event) => {
  return sendStream(event, fs.createReadStream('/path/to/file'))
})
```

### Sending Redirect

```ts [server/api/foo.get.ts]
export default defineEventHandler(async (event) => {
  await sendRedirect(event, '/path/redirect/to', 302)
})
```

### Legacy Handler or Middleware

```ts [server/api/legacy.ts]
export default fromNodeMiddleware((req, res) => {
  res.end('Legacy handler')
})
```

::important
Legacy support is possible using [h3js/h3](https://github.com/h3js/h3), but it is advised to avoid legacy handlers as much as you can.
::

```ts [server/middleware/legacy.ts]
export default fromNodeMiddleware((req, res, next) => {
  console.log('Legacy middleware')
  next()
})
```

::warning
Never combine `next()` callback with a legacy middleware that is `async` or returns a `Promise`.
::

### Server Storage

Nitro provides a cross-platform [storage layer](https://nitro.build/guide/storage). In order to configure additional storage mount points, you can use `nitro.storage`, or [server plugins](/docs/4.x/directory-structure/server#server-plugins).

**Example of adding a Redis storage:**

Using `nitro.storage`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    storage: {
      redis: {
        driver: 'redis',
        /* redis connector options */
        port: 6379, // Redis port
        host: '127.0.0.1', // Redis host
        username: '', // needs Redis >= 6
        password: '',
        db: 0, // Defaults to 0
        tls: {}, // tls/ssl
      },
    },
  },
})
```

Then in your API handler:

```ts [server/api/storage/test.ts]
export default defineEventHandler(async (event) => {
  // List all keys with
  const keys = await useStorage('redis').getKeys()

  // Set a key with
  await useStorage('redis').setItem('foo', 'bar')

  // Remove a key with
  await useStorage('redis').removeItem('foo')

  return {}
})
```

::read-more{to="https://nitro.build/guide/storage" target="_blank"}
Read more about Nitro Storage Layer.
::

Alternatively, you can create a storage mount point using a server plugin and runtime config:

::code-group
```ts [server/plugins/storage.ts]
import redisDriver from 'unstorage/drivers/redis'

export default defineNitroPlugin(() => {
  const storage = useStorage()

  // Dynamically pass in credentials from runtime configuration, or other sources
  const driver = redisDriver({
    base: 'redis',
    host: useRuntimeConfig().redis.host,
    port: useRuntimeConfig().redis.port,
    /* other redis connector options */
  })

  // Mount driver
  storage.mount('redis', driver)
})
```

``` ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    redis: { // Default values
      host: '',
      port: 0,
      /* other redis connector options */
    },
  },
})
```
::
</file>

<file path="docs/2.directory-structure/1.shared.md">
---
title: 'shared'
head.title: 'shared/'
description: 'Use the shared/ directory to share functionality between the Vue app and the Nitro server.'
navigation.icon: i-vscode-icons-folder-type-shared
---

The `shared/` directory allows you to share code that can be used in both the Vue app and the Nitro server.

::note
The `shared/` directory is available in Nuxt v3.14+.
::

::important
Code in the `shared/` directory cannot import any Vue or Nitro code.
::

:video-accordion{title="Watch a video from Vue School on sharing utils and types between app and server" videoId="nnAR-MO3q5M"}

## Usage

**Method 1:** Named export

```ts twoslash [shared/utils/capitalize.ts]
export const capitalize = (input: string) => {
  return input[0] ? input[0].toUpperCase() + input.slice(1) : ''
}
```

**Method 2:** Default export

```ts twoslash [shared/utils/capitalize.ts]
export default function (input: string) {
  return input[0] ? input[0].toUpperCase() + input.slice(1) : ''
}
```

You can now use [auto-imported](/docs/4.x/directory-structure/shared) utilities in your Nuxt app and `server/` directory.

```vue [app/app.vue]
<script setup lang="ts">
const hello = capitalize('hello')
</script>

<template>
  <div>
    {{ hello }}
  </div>
</template>
```

```ts [server/api/hello.get.ts]
export default defineEventHandler((event) => {
  return {
    hello: capitalize('hello'),
  }
})
```

## How Files Are Scanned

Only files in the `shared/utils/` and `shared/types/` directories will be auto-imported. Files nested within subdirectories of these directories will not be auto-imported unless you add these directories to `imports.dirs` and `nitro.imports.dirs`.

::tip
The way `shared/utils` and `shared/types` auto-imports work and are scanned is identical to the [`app/composables/`](/docs/4.x/directory-structure/app/composables) and [`app/utils/`](/docs/4.x/directory-structure/app/utils) directories.
::

:read-more{to="/docs/4.x/directory-structure/app/composables#how-files-are-scanned"}

```bash [Directory Structure]
-| shared/
---| capitalize.ts        # Not auto-imported
---| formatters
-----| lower.ts           # Not auto-imported
---| utils/
-----| lower.ts           # Auto-imported
-----| formatters
-------| upper.ts         # Not auto-imported
---| types/
-----| bar.ts             # Auto-imported
```

Any other files you create in the `shared/` folder must be manually imported using the `#shared` alias (automatically configured by Nuxt):

```ts
// For files directly in the shared directory
import capitalize from '#shared/capitalize'

// For files in nested directories
import lower from '#shared/formatters/lower'

// For files nested in a folder within utils
import upper from '#shared/utils/formatters/upper'
```

This alias ensures consistent imports across your application, regardless of the importing file's location.

:read-more{to="/docs/4.x/guide/concepts/auto-imports"}
</file>

<file path="docs/2.directory-structure/2.env.md">
---
title: ".env"
description: "A .env file specifies your build/dev-time environment variables."
head.title: ".env"
navigation.icon: i-vscode-icons-file-type-dotenv
---

::important
This file should be added to your [`.gitignore`](/docs/4.x/directory-structure/gitignore) file to avoid pushing secrets to your repository.
::

## Dev, Build and Generate Time

Nuxt CLI has built-in [dotenv](https://github.com/motdotla/dotenv) support in development mode and when running [`nuxt build`](/docs/4.x/api/commands/build) and [`nuxt generate`](/docs/4.x/api/commands/generate).

In addition to any process environment variables, if you have a `.env` file in your project root directory, it will be automatically loaded **at dev, build and generate time**. Any environment variables set there will be accessible within your `nuxt.config` file and modules.

```ini [.env]
MY_ENV_VARIABLE=hello
```

::note
Note that removing a variable from `.env` or removing the `.env` file entirely will not unset values that have already been set.
::

## Custom File

If you want to use a different file - for example, to use `.env.local` or `.env.production` - you can do so by passing the `--dotenv` flag when using the Nuxt CLI.

```bash [Terminal]
npx nuxt dev --dotenv .env.local
```

When updating `.env` in development mode, the Nuxt instance is automatically restarted to apply new values to the `process.env`.

::important
In your application code, you should use [Runtime Config](/docs/4.x/guide/going-further/runtime-config) instead of plain env variables.
::

## Production

**After your server is built**, you are responsible for setting environment variables when you run the server.

Your `.env` files will not be read at this point. How you do this is different for every environment.

This design decision was made to ensure compatibility across various deployment environments, some of which may not have a traditional file system available, such as serverless platforms or edge networks like Cloudflare Workers.

Since `.env` files are not used in production, you must explicitly set environment variables using the tools and methods provided by your hosting environment. Here are some common approaches:

* You can pass the environment variables as arguments using the terminal:

   `$ DATABASE_HOST=mydatabaseconnectionstring node .output/server/index.mjs`

* You can set environment variables in shell configuration files like `.bashrc` or `.profile`.

* Many cloud service providers, such as Vercel, Netlify, and AWS, provide interfaces for setting environment variables via their dashboards, CLI tools or configuration files.

::important
`runtimeConfig` [won't pick up environment variables that don't start with `NUXT_` in production] (https://nuxt.com/docs/4.x/guide/going-further/runtime-config#environment-variables).
::

## Production Preview

For local production preview purpose, we recommend using [`nuxt preview`](/docs/4.x/api/commands/preview) since using this command, the `.env` file will be loaded into `process.env` for convenience. Note that this command requires dependencies to be installed in the package directory.

Or you could pass the environment variables as arguments using the terminal. For example, on Linux or macOS:

```bash [Terminal]
DATABASE_HOST=mydatabaseconnectionstring node .output/server/index.mjs
```

Note that for a purely static site, it is not possible to set runtime configuration config after your project is prerendered.

:read-more{to="/docs/4.x/guide/going-further/runtime-config"}

::note
If you want to use environment variables set at build time but do not care about updating these down the line (or only need to update them reactively _within_ your app) then `appConfig` may be a better choice. You can define `appConfig` both within your `nuxt.config` (using environment variables) and also within an `~/app.config.ts` file in your project.
:read-more{to="/docs/4.x/directory-structure/app/app-config"}
::
</file>

<file path="docs/2.directory-structure/2.gitignore.md">
---
title: ".gitignore"
description: "A .gitignore file specifies intentionally untracked files that git should ignore."
head.title: ".gitignore"
navigation.icon: i-vscode-icons-file-type-git
---

A `.gitignore` file specifies intentionally untracked files that git should ignore.

:read-more{icon="i-simple-icons-git" title="the git documentation" to="https://git-scm.com/docs/gitignore" target="_blank"}

We recommend having a `.gitignore` file that has **at least** the following entries present:

```bash [.gitignore]
# Nuxt dev/build outputs
.output
.data
.nuxt
.nitro
.cache
dist

# Node dependencies
node_modules

# Logs
logs
*.log

# Misc
.DS_Store

# Local env files
.env
.env.*
!.env.example
```
</file>

<file path="docs/2.directory-structure/2.nuxtignore.md">
---
title: .nuxtignore
head.title: '.nuxtignore'
description: The .nuxtignore file lets Nuxt ignore files in your project’s root directory during the build phase.
navigation.icon: i-vscode-icons-file-type-nuxt

---

The `.nuxtignore` file tells Nuxt to ignore files in your project’s root directory ([`rootDir`](/docs/4.x/api/nuxt-config#rootdir)) during the build phase.

It is subject to the same specification as [`.gitignore`](/docs/4.x/directory-structure/gitignore) and `.eslintignore` files, in which each line is a glob pattern indicating which files should be ignored.

::tip
You can also configure [`ignoreOptions`](/docs/4.x/api/nuxt-config#ignoreoptions), [`ignorePrefix`](/docs/4.x/api/nuxt-config#ignoreprefix) and [`ignore`](/docs/4.x/api/nuxt-config#ignore) in your `nuxt.config` file.
::

## Usage

```bash [.nuxtignore]
# ignore layout foo.vue
app/layouts/foo.vue
# ignore layout files whose name ends with -ignore.vue
app/layouts/*-ignore.vue

# ignore page bar.vue
app/pages/bar.vue
# ignore page inside ignore folder
app/pages/ignore/*.vue

# ignore route middleware files under foo folder except foo/bar.js
app/middleware/foo/*.js
!app/middleware/foo/bar.js
```

::read-more{icon="i-simple-icons-git" title="the git documentation" to="https://git-scm.com/docs/gitignore" target="_blank"}
More details about the spec are in the **gitignore documentation**.
::
</file>

<file path="docs/2.directory-structure/2.nuxtrc.md">
---
title: ".nuxtrc"
description: "The .nuxtrc file allows you to define nuxt configurations in a flat syntax."
head.title: ".nuxtrc"
navigation.icon: i-vscode-icons-file-type-nuxt
---

The `.nuxtrc` file can be used to configure Nuxt with a flat syntax. It is based on [`unjs/rc9`](https://github.com/unjs/rc9).

::tip
For more advanced configurations, use [`nuxt.config`](/docs/4.x/directory-structure/nuxt-config).
::

## Usage

```bash [.nuxtrc]
# Disable SSR
ssr=false

# Configuration for `@nuxt/devtools`
devtools.enabled=true

# Add Nuxt modules
modules[]=@nuxt/image
modules[]=nuxt-security
```

If present, the properties in the `nuxt.config` file will overwrite the properties in `.nuxtrc` file.

::note
Nuxt automatically adds a `setups` section to track module installation and upgrade state. This is used internally for [module lifecycle hooks](/docs/4.x/api/kit/modules#using-lifecycle-hooks-for-module-installation-and-upgrade) and should not be modified manually.
::

::read-more{to="/docs/4.x/api/configuration/nuxt-config"}
Discover all the available options in the **Nuxt configuration** documentation.
::

## Global `.nuxtrc` File

You can also create a global `.nuxtrc` file in your home directory to apply configurations globally.

- On macOS/Linux, this file is located at:

  ```md
  ~/.nuxtrc
  ```

- On Windows, it is located at:

  ```md
  C:\Users\{username}\.nuxtrc
  ```

This global `.nuxtrc` file allows you to define default settings that apply to all Nuxt projects on your system. However, project-level `.nuxtrc` files will override these global settings, and `nuxt.config` will take precedence over both.
</file>

<file path="docs/2.directory-structure/3.nuxt-config.md">
---
title: "nuxt.config.ts"
description: "Nuxt can be easily configured with a single nuxt.config file."
head.title: "nuxt.config.ts"
navigation.icon: i-vscode-icons-file-type-nuxt
---

The `nuxt.config` file extension can either be `.js`, `.ts` or `.mjs`.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  // My Nuxt config
})
```

::tip
`defineNuxtConfig` helper is globally available without import.
::

You can explicitly import `defineNuxtConfig` from `nuxt/config` if you prefer:

```ts twoslash [nuxt.config.ts]
import { defineNuxtConfig } from 'nuxt/config'

export default defineNuxtConfig({
  // My Nuxt config
})
```

::read-more{to="/docs/4.x/api/configuration/nuxt-config"}
Discover all the available options in the **Nuxt configuration** documentation.
::

To ensure your configuration is up to date, Nuxt will make a full restart when detecting changes in the main configuration file, the [`.env`](/docs/4.x/directory-structure/env), [`.nuxtignore`](/docs/4.x/directory-structure/nuxtignore) and [`.nuxtrc`](/docs/4.x/directory-structure/nuxtrc) dotfiles.
</file>

<file path="docs/2.directory-structure/3.package.md">
---
title: package.json
head.title: package.json
description: The package.json file contains all the dependencies and scripts for your application.
navigation.icon: i-vscode-icons-file-type-npm
---

The minimal `package.json` of your Nuxt application should looks like:

```json [package.json]
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "nuxt": "latest",
    "vue": "latest",
    "vue-router": "latest"
  }
}
```

::read-more{icon="i-simple-icons-npm" to="https://docs.npmjs.com/cli/configuring-npm/package-json/" target="_blank"}
Read more about the `package.json` file.
::
</file>

<file path="docs/2.directory-structure/3.tsconfig.md">
---
title: "tsconfig.json"
description: "Learn how Nuxt manages TypeScript configuration across different parts of your project."
head.title: "tsconfig.json"
navigation.icon: i-vscode-icons-file-type-tsconfig
---

Nuxt [automatically generates](/docs/4.x/guide/concepts/typescript#auto-generated-types) multiple TypeScript configuration files (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, `.nuxt/tsconfig.node.json` and `.nuxt/tsconfig.shared.json`) that include recommended basic TypeScript configuration for your project, references to [auto-imports](/docs/4.x/guide/concepts/auto-imports), [API route types](/docs/4.x/guide/concepts/server-engine#typed-api-routes), path aliases, and more.

Your Nuxt project should include the following `tsconfig.json` file at the root of the project:

```json [tsconfig.json]
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
```

::warning
We do not recommend modifying the contents of this file directly, as doing so could overwrite important settings that Nuxt or other modules rely on. Instead, extend it via `nuxt.config.ts`.
::

::read-more{to="/docs/4.x/guide/concepts/typescript#project-references"}
Read more about the different type contexts of a Nuxt project here.
::

## Extending TypeScript Configuration

You can customize the TypeScript configuration of your Nuxt project for each context (`app`, `shared`, `node`, and `server`) in the `nuxt.config.ts` file.
<!-- @case-police-ignore tsConfig -->
```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  typescript: {
    // customize tsconfig.app.json
    tsConfig: {
      // ...
    },
    // customize tsconfig.shared.json
    sharedTsConfig: {
      // ...
    },
    // customize tsconfig.node.json
    nodeTsConfig: {
      // ...
    },
  },
  nitro: {
    typescript: {
      // customize tsconfig.server.json
      tsConfig: {
        // ...
      },
    },
  },
})
```
</file>

<file path="docs/2.directory-structure/index.md">
---
title: 'Nuxt Directory Structure'
description: 'Learn about the directory structure of a Nuxt application and how to use it.'
navigation: false
---

Nuxt applications have a specific directory structure that is used to organize the code. This structure is designed to be easy to understand and to be used in a consistent way.

## Root Directory

The root directory of a Nuxt application is the directory that contains the `nuxt.config.ts` file. This file is used to configure the Nuxt application.

## App Directory

The `app/` directory is the main directory of the Nuxt application. It contains the following subdirectories:
- [`assets/`](/docs/4.x/directory-structure/app/assets): website's assets that the build tool (Vite or webpack) will process
- [`components/`](/docs/4.x/directory-structure/app/components): Vue components of the application
- [`composables/`](/docs/4.x/directory-structure/app/composables): add your Vue composables
- [`layouts/`](/docs/4.x/directory-structure/app/layouts): Vue components that wrap around your pages and avoid re-rendering between pages
- [`middleware/`](/docs/4.x/directory-structure/app/middleware): run code before navigating to a particular route
- [`pages/`](/docs/4.x/directory-structure/app/pages): file-based routing to create routes within your web application
- [`plugins/`](/docs/4.x/directory-structure/app/plugins): use Vue plugins and more at the creation of your Nuxt application
- [`utils/`](/docs/4.x/directory-structure/app/utils): add functions throughout your application that can be used in your components, composables, and pages.

This directory also includes specific files:
- [`app.config.ts`](/docs/4.x/directory-structure/app/app-config): a reactive configuration within your application
- [`app.vue`](/docs/4.x/directory-structure/app/app): the root component of your Nuxt application
- [`error.vue`](/docs/4.x/directory-structure/app/error): the error page of your Nuxt application

## Public Directory

The [`public/`](/docs/4.x/directory-structure/public) directory is the directory that contains the public files of the Nuxt application. Files contained within this directory are served at the root and are not modified by the build process.

This is suitable for files that have to keep their names (e.g. `robots.txt`) _or_ likely won't change (e.g. `favicon.ico`).

## Server Directory

The [`server/`](/docs/4.x/directory-structure/server) directory is the directory that contains the server-side code of the Nuxt application. It contains the following subdirectories:
- [`api/`](/docs/4.x/directory-structure/server#server-routes): contains the API routes of the application.
- [`routes/`](/docs/4.x/directory-structure/server#server-routes): contains the server routes of the application (e.g. dynamic `/sitemap.xml`).
- [`middleware/`](/docs/4.x/directory-structure/server#server-middleware): run code before a server route is processed
- [`plugins/`](/docs/4.x/directory-structure/server#server-plugins): use plugins and more at the creation of the Nuxt server
- [`utils/`](/docs/4.x/directory-structure/server#server-utilities): add functions throughout your application that can be used in your server  code.

## Shared Directory

The [`shared/`](/docs/4.x/directory-structure/shared) directory is the directory that contains the shared code of the Nuxt application and Nuxt server. This code can be used in both the Vue app and the Nitro server.

## Content Directory

The [`content/`](/docs/4.x/directory-structure/content) directory is enabled by the [Nuxt Content](https://content.nuxt.com) module. It is used to create a file-based CMS for your application using Markdown files.

## Modules Directory

The [`modules/`](/docs/4.x/directory-structure/modules) directory is the directory that contains the local modules of the Nuxt application. Modules are used to extend the functionality of the Nuxt application.

## Nuxt Files

- [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) file is the main configuration file for the Nuxt application.
- [`.nuxtrc`](/docs/4.x/directory-structure/nuxtrc) file is another syntax for configuring the Nuxt application (useful for global configurations).
- [`.nuxtignore`](/docs/4.x/directory-structure/nuxtignore) file is used to ignore files in the root directory during the build phase.
</file>

<file path="docs/3.guide/1.concepts/.navigation.yml">
title: Key Concepts
titleTemplate: '%s · Nuxt Concepts'
icon: i-lucide-medal
</file>

<file path="docs/3.guide/1.concepts/1.rendering.md">
---
title: 'Rendering Modes'
description: 'Learn about the different rendering modes available in Nuxt.'
---

Nuxt supports different rendering modes, [universal rendering](/docs/4.x/guide/concepts/rendering#universal-rendering), [client-side rendering](/docs/4.x/guide/concepts/rendering#client-side-rendering) but also offers [hybrid-rendering](/docs/4.x/guide/concepts/rendering#hybrid-rendering) and the possibility to render your application on [CDN Edge Servers](/docs/4.x/guide/concepts/rendering#edge-side-rendering).

Both the browser and server can interpret JavaScript code to turn Vue.js components into HTML elements. This step is called **rendering**. Nuxt supports both **universal** and **client-side** rendering. The two approaches have benefits and downsides that we will cover.

By default, Nuxt uses **universal rendering** to provide better user experience, performance and to optimize search engine indexing, but you can switch rendering modes in [one line of configuration](/docs/4.x/api/nuxt-config#ssr).

## Universal Rendering

This step is similar to traditional **server-side rendering** performed by PHP or Ruby applications. When the browser requests a URL with universal rendering enabled, Nuxt runs the JavaScript (Vue.js) code in a server environment and returns a fully rendered HTML page to the browser. Nuxt may also return a fully rendered HTML page from a cache if the page was generated in advance. Users immediately get the entirety of the initial content of the application, contrary to client-side rendering.

Once the HTML document has been downloaded, the browser interprets this and Vue.js takes control of the document. The same JavaScript code that once ran on the server runs on the client (browser) **again** in the background now enabling interactivity (hence **Universal rendering**) by binding its listeners to the HTML. This is called **Hydration**. When hydration is complete, the page can enjoy benefits such as dynamic interfaces and page transitions.

Universal rendering allows a Nuxt application to provide quick page load times while preserving the benefits of client-side rendering. Furthermore, as the content is already present in the HTML document, crawlers can index it without overhead.

![Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity](/assets/docs/concepts/rendering/ssr.svg)

**What's server-rendered and what's client-rendered?**

It is normal to ask which parts of a Vue file runs on the server and/or the client in universal rendering mode.

```vue [app/app.vue]
<script setup lang="ts">
const counter = ref(0) // executes in server and client environments

const handleClick = () => {
  counter.value++ // executes only in a client environment
}
</script>

<template>
  <div>
    <p>Count: {{ counter }}</p>
    <button @click="handleClick">
      Increment
    </button>
  </div>
</template>
```

On the initial request, the `counter` ref is initialized in the server since it is rendered inside the `<p>` tag. The contents of `handleClick` is never executed here. During hydration in the browser, the `counter` ref is re-initialized. The `handleClick` finally binds itself to the button; Therefore it is reasonable to deduce that the body of `handleClick` will always run in a browser environment.

[Middlewares](/docs/4.x/directory-structure/app/middleware) and [pages](/docs/4.x/directory-structure/app/pages) run in the server and on the client during hydration. [Plugins](/docs/4.x/directory-structure/app/plugins) can be rendered on the server or client or both. [Components](/docs/4.x/directory-structure/app/components) can be forced to run on the client only as well. [Composables](/docs/4.x/directory-structure/app/composables) and [utilities](/docs/4.x/directory-structure/app/utils) are rendered based on the context of their usage.

**Benefits of server-side rendering:**
- **Performance**: Users can get immediate access to the page's content because browsers can display static content much faster than JavaScript-generated content. At the same time, Nuxt preserves the interactivity of a web application during the hydration process.
- **Search Engine Optimization**: Universal rendering delivers the entire HTML content of the page to the browser as a classic server application. Web crawlers can directly index the page's content, which makes Universal rendering a great choice for any content that you want to index quickly.

**Downsides of server-side rendering:**
- **Development constraints:** Server and browser environments don't provide the same APIs, and it can be tricky to write code that can run on both sides seamlessly. Fortunately, Nuxt provides guidelines and specific variables to help you determine where a piece of code is executed.
- **Cost:** A server needs to be running in order to render pages on the fly. This adds a monthly cost like any traditional server. However, the server calls are highly reduced thanks to universal rendering with the browser taking over on client-side navigation. A cost reduction is possible by leveraging [edge-side-rendering](/docs/4.x/guide/concepts/rendering#edge-side-rendering).

Universal rendering is very versatile and can fit almost any use case, and is especially appropriate for any content-oriented websites: **blogs, marketing websites, portfolios, e-commerce sites, and marketplaces.**

::tip
For more examples about writing Vue code without hydration mismatch, see [the Vue docs](https://vuejs.org/guide/scaling-up/ssr#hydration-mismatch).
::

::important
When importing a library that relies on browser APIs and has side effects, make sure the component importing it is only called client-side. Bundlers do not treeshake imports of modules containing side effects.
::

## Client-Side Rendering

Out of the box, a traditional Vue.js application is rendered in the browser (or **client**). Then, Vue.js generates HTML elements after the browser downloads and parses all the JavaScript code containing the instructions to create the current interface.

![Users have to wait for the browser to download, parse and execute the JavaScript before seeing the page's content](/assets/docs/concepts/rendering/csr.svg)

**Benefits of client-side rendering:**
- **Development speed**: When working entirely on the client-side, we don't have to worry about the server compatibility of the code, for example, by using browser-only APIs like the `window` object.
- **Cheaper:** Running a server adds a cost of infrastructure as you would need to run on a platform that supports JavaScript. We can host client-only applications on any static server with HTML, CSS, and JavaScript files.
- **Offline:** Because code entirely runs in the browser, it can nicely keep working while the internet is unavailable.

**Downsides of client-side rendering:**
- **Performance**: The user has to wait for the browser to download, parse and run JavaScript files. Depending on the network for the download part and the user's device for the parsing and execution, this can take some time and impact the user's experience.
- **Search Engine Optimization**: Indexing and updating the content delivered via client-side rendering takes more time than with a server-rendered HTML document. This is related to the performance drawback we discussed, as search engine crawlers won't wait for the interface to be fully rendered on their first try to index the page. Your content will take more time to show and update in search results pages with pure client-side rendering.

Client-side rendering is a good choice for heavily interactive **web applications** that don't need indexing or whose users visit frequently. It can leverage browser caching to skip the download phase on subsequent visits, such as **SaaS, back-office applications, or online games**.

You can enable client-side only rendering with Nuxt in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false,
})
```

::note
If you do use `ssr: false`, you should also place an HTML file in `~/spa-loading-template.html` with some HTML you would like to use to render a loading screen that will be rendered until your app is hydrated.
:read-more{title="SPA Loading Template" to="/docs/4.x/api/configuration/nuxt-config#spaloadingtemplate"}
::

:video-accordion{title="Watch a video from Alexander Lichter about Building a plain SPA with Nuxt" videoId="7Lr0QTP1Ro8"}

### Deploying a Static Client-Rendered App

If you deploy your app to [static hosting](/docs/4.x/getting-started/deployment#static-hosting) with the `nuxt generate` or `nuxt build --prerender` commands, then by default, Nuxt will render every page as a separate static HTML file.

::warning
If you prerender your app with the `nuxt generate` or `nuxt build --prerender` commands, then you will not be able to use any server endpoints as no server will be included in your output folder. If you need server functionality, use `nuxt build` instead.
::

If you are using purely client-side rendering, then this might be unnecessary. You might only need a single `index.html` file, plus `200.html` and `404.html` fallbacks, which you can tell your static web host to serve up for all requests.

In order to achieve this we can change how the routes are prerendered. Just add this to [your hooks](/docs/4.x/api/advanced/hooks#nuxt-hooks-build-time) in your `nuxt.config.ts`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    'prerender:routes' ({ routes }) {
      routes.clear() // Do not generate any routes (except the defaults)
    },
  },
})
```

This will produce three files:

- `index.html`
- `200.html`
- `404.html`

The `200.html` and `404.html` might be useful for the hosting provider you are using.

#### Skipping Client Fallback Generation

When prerendering a client-rendered app, Nuxt will generate `index.html`, `200.html` and `404.html` files by default. However, if you need to prevent any (or all) of these files from being generated in your build, you can use the `'prerender:generate'` hook from [Nitro](/docs/4.x/getting-started/prerendering#prerendergenerate-nitro-hook).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false,
  nitro: {
    hooks: {
      'prerender:generate' (route) {
        const routesToSkip = ['/index.html', '/200.html', '/404.html']
        if (routesToSkip.includes(route.route)) {
          route.skip = true
        }
      },
    },
  },
})
```

## Hybrid Rendering

Hybrid rendering allows different caching rules per route using **Route Rules** and decides how the server should respond to a new request on a given URL.

Previously every route/page of a Nuxt application and server must use the same rendering mode, universal or client-side. In various cases, some pages could be generated at build time, while others should be client-side rendered. For example, think of a content website with an admin section. Every content page should be primarily static and generated once, but the admin section requires registration and behaves more like a dynamic application.

Nuxt includes route rules and hybrid rendering support. Using route rules you can define rules for a group of nuxt routes, change rendering mode or assign a cache strategy based on route!

Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using [Nitro caching layer](https://nitro.build/guide/cache).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    // Homepage pre-rendered at build time
    '/': { prerender: true },
    // Products page generated on demand, revalidates in background, cached until API response changes
    '/products': { swr: true },
    // Product pages generated on demand, revalidates in background, cached for 1 hour (3600 seconds)
    '/products/**': { swr: 3600 },
    // Blog posts page generated on demand, revalidates in background, cached on CDN for 1 hour (3600 seconds)
    '/blog': { isr: 3600 },
    // Blog post page generated on demand once until next deployment, cached on CDN
    '/blog/**': { isr: true },
    // Admin dashboard renders only on client-side
    '/admin/**': { ssr: false },
    // Add cors headers on API routes
    '/api/**': { cors: true },
    // Redirects legacy urls
    '/old-page': { redirect: '/new-page' },
  },
})
```

### Route Rules

The different properties you can use are the following:
- `redirect: string`{lang=ts} - Define server-side redirects.
- `ssr: boolean`{lang=ts} - Disables server-side rendering of the HTML for sections of your app and make them render only in the browser with `ssr: false`
- `cors: boolean`{lang=ts} - Automatically adds cors headers with `cors: true` - you can customize the output by overriding with `headers`
- `headers: object`{lang=ts} - Add specific headers to sections of your site - for example, your assets
- `swr: number | boolean`{lang=ts} - Add cache headers to the server response and cache it on the server or reverse proxy for a configurable TTL (time to live). The `node-server` preset of Nitro is able to cache the full response. When the TTL expired, the cached response will be sent while the page will be regenerated in the background. If true is used, a `stale-while-revalidate` header is added without a MaxAge.
- `isr: number | boolean`{lang=ts} - The behavior is the same as `swr` except that we are able to add the response to the CDN cache on platforms that support this (currently Netlify or Vercel). If `true` is used, the content persists until the next deploy inside the CDN.
- `prerender: boolean`{lang=ts} - Prerenders routes at build time and includes them in your build as static assets
- `noScripts: boolean`{lang=ts} - Disables rendering of Nuxt scripts and JS resource hints for sections of your site.
- `appMiddleware: string | string[] | Record<string, boolean>`{lang=ts} - Allows you to define middleware that should or should not run for page paths within the Vue app part of your application (that is, not your Nitro routes)

Whenever possible, route rules will be automatically applied to the deployment platform's native rules for optimal performances (Netlify and Vercel are currently supported).

::important
Note that Hybrid Rendering is not available when using [`nuxt generate`](/docs/4.x/api/commands/generate).
::

**Examples:**

::card-group
  ::card
  ---
  icon: i-simple-icons-github
  title: Nuxt Vercel ISR
  to: https://github.com/danielroe/nuxt-vercel-isr
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Example of a Nuxt application with hybrid rendering deployed on Vercel.
  ::
::

## Edge-Side Rendering

Edge-Side Rendering (ESR) is a powerful feature introduced in Nuxt that allows the rendering of your Nuxt application closer to your users via edge servers of a Content Delivery Network (CDN). By leveraging ESR, you can ensure improved performance and reduced latency, thereby providing an enhanced user experience.

With ESR, the rendering process is pushed to the 'edge' of the network - the CDN's edge servers. Note that ESR is more a deployment target than an actual rendering mode.

When a request for a page is made, instead of going all the way to the original server, it's intercepted by the nearest edge server. This server generates the HTML for the page and sends it back to the user. This process minimizes the physical distance the data has to travel, **reducing latency and loading the page faster**.

Edge-side rendering is possible thanks to [Nitro](https://nitro.build/), the [server engine](/docs/4.x/guide/concepts/server-engine) that powers Nuxt. It offers cross-platform support for Node.js, Deno, Cloudflare Workers, and more.

The current platforms where you can leverage ESR are:
- [Cloudflare Pages](https://pages.cloudflare.com) with zero configuration using the git integration and the `nuxt build` command
- [Vercel Cloud](https://vercel.com/home) using the `nuxt build` command and `NITRO_PRESET=vercel-edge` environment variable
- [Netlify Edge Functions](https://www.netlify.com/platform/#netlify-edge-functions) using the `nuxt build` command and `NITRO_PRESET=netlify-edge` environment variable

Note that **Hybrid Rendering** can be used when using Edge-Side Rendering with route rules.
</file>

<file path="docs/3.guide/1.concepts/10.vuejs-development.md">
---
title: 'Vue.js Development'
description: "Nuxt uses Vue.js and adds features such as component auto-imports, file-based routing and composables for an SSR-friendly usage."
navigation: false
---

Nuxt integrates Vue 3, the new major release of Vue that enables new patterns for Nuxt users.

::note
While an in-depth knowledge of Vue is not required to use Nuxt, we recommend that you read the documentation and go through some of the examples on [vuejs.org](https://vuejs.org).
::

Nuxt has always used Vue as a frontend framework.

We chose to build Nuxt on top of Vue for these reasons:

- The reactivity model of Vue, where a change in data automatically triggers a change in the interface.
- The component-based templating, while keeping HTML as the common language of the web, enables intuitive patterns to keep your interface consistent, yet powerful.
- From small projects to large web applications, Vue keeps performing well at scale to ensure that your application keeps delivering value to your users.

## Vue with Nuxt

### Single File Components

[Vue’s single-file components](https://vuejs.org/guide/scaling-up/sfc) (SFC or `*.vue` files) encapsulate the markup (`<template>`), logic (`<script>`) and styling (`<style>`) of a Vue component. Nuxt provides a zero-config experience for SFCs with [Hot Module Replacement](https://vite.dev/guide/features#hot-module-replacement) that offers a seamless developer experience.

### Auto-imports

Every Vue component created in the [`app/components/`](/docs/4.x/directory-structure/app/components) directory of a Nuxt project will be available in your project without having to import it. If a component is not used anywhere, your production’s code will not include it.

:read-more{to="/docs/4.x/guide/concepts/auto-imports"}

### Vue Router

Most applications need multiple pages and a way to navigate between them. This is called **routing**. Nuxt uses an [`app/pages/`](/docs/4.x/directory-structure/app/pages) directory and naming conventions to directly create routes mapped to your files using the official [Vue Router library](https://router.vuejs.org).

:read-more{to="/docs/4.x/getting-started/routing"}

:link-example{to="/docs/4.x/examples/features/auto-imports"}

## Differences with Nuxt 2 / Vue 2

Nuxt 3+ is based on Vue 3. The new major Vue version introduces several changes that Nuxt takes advantage of:

- Better performance
- Composition API
- TypeScript support

### Faster Rendering

The Vue Virtual DOM (VDOM) has been rewritten from the ground up and allows for better rendering performance. On top of that, when working with compiled Single-File Components, the Vue compiler can further optimize them at build time by separating static and dynamic markup.

This results in faster first rendering (component creation) and updates, and less memory usage. In Nuxt 3, it enables faster server-side rendering as well.

### Smaller Bundle

With Vue 3 and Nuxt 3, a focus has been put on bundle size reduction. With version 3, most of Vue’s functionality, including template directives and built-in components, is tree-shakable. Your production bundle will not include them if you don’t use them.

This way, a minimal Vue 3 application can be reduced to 12 kb gzipped.

### Composition API

The only way to provide data and logic to components in Vue 2 was through the Options API, which allows you to return data and methods to a template with pre-defined properties like `data` and `methods`:

```vue twoslash
<script>
export default {
  data () {
    return {
      count: 0,
    }
  },
  methods: {
    increment () {
      this.count++
    },
  },
}
</script>
```

The [Composition API](https://vuejs.org/guide/extras/composition-api-faq) introduced in Vue 3 is not a replacement of the Options API, but it enables better logic reuse throughout an application, and is a more natural way to group code by concern in complex components.

Used with the `setup` keyword in the `<script>` definition, here is the above component rewritten with Composition API and Nuxt 3’s auto-imported Reactivity APIs:

```vue twoslash [components/Counter.vue]
<script setup lang="ts">
const count = ref(0)
const increment = () => count.value++
</script>
```

The goal of Nuxt is to provide a great developer experience around the Composition API.

- Use auto-imported [Reactivity functions](https://vuejs.org/api/reactivity-core) from Vue and Nuxt [built-in composables](/docs/4.x/api/composables/use-async-data).
- Write your own auto-imported reusable functions in the [`app/composables/` directory](/docs/4.x/directory-structure/app/composables).

### TypeScript Support

Both Vue 3 and Nuxt 3+ are written in TypeScript. A fully typed codebase prevents mistakes and documents APIs usage. This doesn’t mean that you have to write your application in TypeScript to take advantage of it. With Nuxt 3, you can opt-in by renaming your file from `.js` to `.ts` , or add `<script setup lang="ts">` in a component.

::read-more{to="/docs/4.x/guide/concepts/typescript"}
Read the details about TypeScript in Nuxt
::
</file>

<file path="docs/3.guide/1.concepts/2.nuxt-lifecycle.md">
---
title: 'Nuxt Lifecycle'
description: "Understanding the lifecycle of Nuxt applications can help you gain deeper insights into how the framework operates, especially for both server-side and client-side rendering."
---

The goal of this chapter is to provide a high-level overview of the different parts of the framework, their execution order, and how they work together.

## Server lifecycle

On the server, the following steps are executed for every initial request to your application:

::steps
### Server plugins :badge[once]{color="info" class="align-middle"}

Nuxt is powered by [Nitro](https://nitro.build/), a modern server engine.

When Nitro starts, it initializes and executes the plugins under the [`/server/plugins`](/docs/4.x/directory-structure/server#server-plugins) directory. These plugins can:
- Capture and handle application-wide errors.
- Register hooks that execute when Nitro shuts down.
- Register hooks for request lifecycle events, such as modifying responses.

::callout{icon="i-lucide-lightbulb"}
Nitro plugins are executed only once when the server starts. In a serverless environment, the server boots on each incoming request, and so do the Nitro plugins. However, they are not awaited.
::

:read-more{to="/docs/4.x/directory-structure/server#server-plugins"}

### Server middleware

After initializing the Nitro server, middleware under `server/middleware/` is executed for every request. Middleware can be used for tasks such as authentication, logging, or request transformation.

::warning
Returning a value from middleware will terminate the request and send the returned value as the response. This behavior should generally be avoided to ensure proper request handling!
::

:read-more{to="/docs/4.x/directory-structure/server#server-middleware"}

### App plugins

The Vue and Nuxt instances are created first. Afterward, Nuxt executes its app plugins. This includes:
- Built-in plugins, such as Vue Router and `unhead`.
- Custom plugins located in the `app/plugins/` directory, including those without a suffix (e.g., `myPlugin.ts`) and those with the `.server` suffix (e.g., `myServerPlugin.server.ts`).

Plugins execute in a specific order and may have dependencies on one another. For more details, including execution order and parallelism, refer to the [Plugins documentation](/docs/4.x/directory-structure/app/plugins).

::callout{icon="i-lucide-lightbulb"}
After this step, Nuxt calls the [`app:created`](/docs/4.x/api/advanced/hooks#app-hooks-runtime) hook, which can be used to execute additional logic.
::

:read-more{to="/docs/4.x/directory-structure/app/plugins"}

### Route validation

After initializing plugins and before executing middleware, Nuxt calls the `validate` method if it is defined in the `definePageMeta` function. The `validate` method, which can be synchronous or asynchronous, is often used to validate dynamic route parameters.

- The `validate` function should return `true` if the parameters are valid.
- If validation fails, it should return `false` or an object containing a `status` and/or `statusText` to terminate the request.

For more information, see the [Route Validation documentation](/docs/4.x/getting-started/routing#route-validation).

:read-more{to="/docs/4.x/getting-started/routing#route-validation"}

### App middleware

Middleware allows you to run code before navigating to a particular route. It is often used for tasks such as authentication, redirection, or logging.

In Nuxt, there are three types of middleware:
- **Global route middleware**
- **Named route middleware**
- **Anonymous (or inline) route middleware**

Nuxt executes all global middleware on the initial page load (both on server and client) and then again before any client-side navigation. Named and anonymous middleware are executed only on the routes specified in the middleware property of the page(route) meta defined in the corresponding page components.

For details about each type and examples, see the [Middleware documentation](/docs/4.x/directory-structure/app/middleware).

Any redirection on the server will result in a `Location:` header being sent to the browser; the browser then makes a fresh request to this new location. All application state will be reset when this happens, unless persisted in a cookie.

:read-more{to="/docs/4.x/directory-structure/app/middleware"}

### Page and components

Nuxt renders the page and its components and fetches any required data with `useFetch` and `useAsyncData` during this step. Since there are no dynamic updates and no DOM operations occur on the server, Vue lifecycle hooks such as `onBeforeMount`, `onMounted`, and subsequent hooks are **NOT** executed during SSR.

By default, Vue pauses dependency tracking during SSR for better performance.

::callout{icon="i-lucide-lightbulb"}
There is no reactivity on the server side because Vue SSR renders the app top-down as static HTML, making it impossible to go back and modify content that has already been rendered.
::

::important
You should avoid code that produces side effects that need cleanup in root scope of `<script setup>`. An example of such side effects is setting up timers with `setInterval`. In client-side only code we may setup a timer and then tear it down in `onBeforeUnmount` or `onUnmounted`. However, because the unmount hooks will never be called during SSR, the timers will stay around forever. To avoid this, move your side-effect code into `onMounted` instead.
::

::tip{icon="i-lucide-video" to="https://youtu.be/dZSNW07sO-A" target="_blank"}
Watch a video from Daniel Roe explaining Server Rendering and Global State.
::

### HTML Output

After all required data is fetched and the components are rendered, Nuxt combines the rendered components with settings from `unhead` to generate a complete HTML document. This HTML, along with the associated data, is then sent back to the client to complete the SSR process.

::callout{icon="i-lucide-lightbulb"}
After rendering the Vue application to HTML, Nuxt calls the [`app:rendered`](/docs/4.x/api/advanced/hooks#app-hooks-runtime) hook.
::

::callout{icon="i-lucide-lightbulb"}
Before finalizing and sending the HTML, Nitro will call the [`render:html`](/docs/4.x/api/advanced/hooks#nitro-app-hooks-runtime-server-side) hook. This hook allows you to manipulate the generated HTML, such as injecting additional scripts or modifying meta tags.
::

::

## Client lifecycle

This part of the lifecycle is fully executed in the browser, no matter which Nuxt mode you've chosen.

::steps

### App plugins

This step is similar to the server-side execution and includes both built-in and custom plugins.

Custom plugins in the `app/plugins/` directory, such as those without a suffix (e.g., `myPlugin.ts`) and with the `.client` suffix (e.g., `myClientPlugin.client.ts`), are executed on the client side.

::callout{icon="i-lucide-lightbulb"}
After this step, Nuxt calls the [`app:created`](/docs/4.x/api/advanced/hooks#app-hooks-runtime) hook, which can be used to execute additional logic.
::

:read-more{to="/docs/4.x/directory-structure/app/plugins"}

### Route validation

This step is the same as the server-side execution and includes the `validate` method if defined in the `definePageMeta` function.

### App middleware

Nuxt middleware runs on both the server and the client. If you want certain code to run in specific environments, consider splitting it by using `import.meta.client` for the client and `import.meta.server` for the server.

:read-more{to="/docs/4.x/directory-structure/app/middleware#when-middleware-runs"}

### Mount Vue app and hydrate

Calling `app.mount('#__nuxt')` mounts the Vue application to the DOM. If the application uses SSR or SSG mode, Vue performs a hydration step to make the client-side application interactive. During hydration, Vue recreates the application (excluding [Server Components](/docs/4.x/directory-structure/app/components#server-components)), matches each component to its corresponding DOM nodes, and attaches DOM event listeners.

To ensure proper hydration, it's important to maintain consistency between the data on the server and the client. For API requests, it is recommended to use `useAsyncData`, `useFetch`, or other SSR-friendly composables. These methods ensure that the data fetched on the server side is reused during hydration, avoiding repeated requests. Any new requests should only be triggered after hydration, preventing hydration errors.

::callout{icon="i-lucide-lightbulb"}
Before mounting the Vue application, Nuxt calls the [`app:beforeMount`](/docs/4.x/api/advanced/hooks#app-hooks-runtime) hook.
::

::callout{icon="i-lucide-lightbulb"}
After mounting the Vue application, Nuxt calls the [`app:mounted`](/docs/4.x/api/advanced/hooks#app-hooks-runtime) hook.
::

### Vue lifecycle

Unlike on the server, the browser executes the full [Vue lifecycle](https://vuejs.org/guide/essentials/lifecycle).

::
</file>

<file path="docs/3.guide/1.concepts/3.auto-imports.md">
---
title: Auto-imports
description: "Nuxt auto-imports components, composables, helper functions and Vue APIs."
---

Nuxt auto-imports components, composables and [Vue.js APIs](https://vuejs.org/api/) to use across your application without explicitly importing them.

```vue twoslash [app/app.vue]
<script setup lang="ts">
const count = ref(1) // ref is auto-imported
</script>
```

Thanks to its opinionated directory structure, Nuxt can auto-import your [`app/components/`](/docs/4.x/directory-structure/app/components), [`app/composables/`](/docs/4.x/directory-structure/app/composables) and [`app/utils/`](/docs/4.x/directory-structure/app/utils).

Contrary to a classic global declaration, Nuxt preserves typings, IDEs completions and hints, and **only includes what is used in your production code**.

::note
In the docs, every function that is not explicitly imported is auto-imported by Nuxt and can be used as-is in your code. You can find a reference for auto-imported components, composables and utilities in the [API section](/docs/4.x/api).
::

::note
In the [`server`](/docs/4.x/directory-structure/server) directory, Nuxt auto-imports exported functions and variables from `server/utils/`.
::

::note
You can also auto-import functions exported from custom folders or third-party packages by configuring the [`imports`](/docs/4.x/api/nuxt-config#imports) section of your `nuxt.config` file.
::

## Built-in Auto-imports

Nuxt auto-imports functions and composables to perform [data fetching](/docs/4.x/getting-started/data-fetching), get access to the [app context](/docs/4.x/api/composables/use-nuxt-app) and [runtime config](/docs/4.x/guide/going-further/runtime-config), manage [state](/docs/4.x/getting-started/state-management) or define components and plugins.

```vue twoslash
<script setup lang="ts">
/* useFetch() is auto-imported */
const { data, refresh, status } = await useFetch('/api/hello')
</script>
```

Vue exposes Reactivity APIs like `ref` or `computed`, as well as lifecycle hooks and helpers that are auto-imported by Nuxt.

```vue twoslash
<script setup lang="ts">
/* ref() and computed() are auto-imported */
const count = ref(1)
const double = computed(() => count.value * 2)
</script>
```

### Vue and Nuxt Composables

<!-- TODO: move to separate page with https://github.com/nuxt/nuxt/issues/14723 and add more information -->

When you are using the built-in Composition API composables provided by Vue and Nuxt, be aware that many of them rely on being called in the right _context_.

During a component lifecycle, Vue tracks the temporary instance of the current component (and similarly, Nuxt tracks a temporary instance of `nuxtApp`) via a global variable, and then unsets it in the same tick. This is essential when server rendering, both to avoid cross-request state pollution (leaking a shared reference between two users) and to avoid leakage between different components.

That means that (with very few exceptions) you cannot use them outside a Nuxt plugin, Nuxt route middleware or Vue setup function. On top of that, you must use them synchronously - that is, you cannot use `await` before calling a composable, except within `<script setup>` blocks, within the setup function of a component declared with `defineNuxtComponent`, in `defineNuxtPlugin` or in `defineNuxtRouteMiddleware`, where we perform a transform to keep the synchronous context even after the `await`.

If you get an error message like `Nuxt instance is unavailable` then it probably means you are calling a Nuxt composable in the wrong place in the Vue or Nuxt lifecycle.

:video-accordion{title="Watch a video from Alexander Lichter about avoiding the 'Nuxt instance is unavailable' error" videoId="ofuKRZLtOdY"}

::tip
When using a composable that requires the Nuxt context inside a non-SFC component, you need to wrap your component with `defineNuxtComponent` instead of `defineComponent`
::

::read-more{to="/docs/4.x/guide/going-further/experimental-features#asynccontext" icon="i-lucide-star"}
Checkout the `asyncContext` experimental feature to use Nuxt composables in async functions.
::

::read-more{to="https://github.com/nuxt/nuxt/issues/14269#issuecomment-1397352832" target="_blank"}
See the full explanation in this GitHub comment.
::

**Example of breaking code:**

```ts twoslash [composables/example.ts]
// trying to access runtime config outside a composable
const config = useRuntimeConfig()

export const useMyComposable = () => {
  // accessing runtime config here
}
```

**Example of working code:**

```ts twoslash [composables/example.ts]
export const useMyComposable = () => {
  // Because your composable is called in the right place in the lifecycle,
  // useRuntimeConfig will work here
  const config = useRuntimeConfig()

  // ...
}
```

## Directory-based Auto-imports

Nuxt directly auto-imports files created in defined directories:

- `app/components/` for [Vue components](/docs/4.x/directory-structure/app/components).
- `app/composables/` for [Vue composables](/docs/4.x/directory-structure/app/composables).
- `app/utils/` for helper functions and other utilities.

:link-example{to="/docs/4.x/examples/features/auto-imports"}

::warning
**Auto-imported `ref` and `computed` won't be unwrapped in a component `<template>`.** :br
This is due to how Vue works with refs that aren't top-level to the template. You can read more about it [in the Vue documentation](https://vuejs.org/guide/essentials/reactivity-fundamentals#caveat-when-unwrapping-in-templates).
::

### Explicit Imports

Nuxt exposes every auto-import with the `#imports` alias that can be used to make the import explicit if needed:

<!-- TODO:twoslash: Twoslash does not support tsconfig paths yet -->

```vue
<script setup lang="ts">
import { computed, ref } from '#imports'

const count = ref(1)
const double = computed(() => count.value * 2)
</script>
```

### Disabling Auto-imports

If you want to disable auto-importing composables and utilities, you can set `imports.autoImport` to `false` in the `nuxt.config` file.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  imports: {
    autoImport: false,
  },
})
```

This will disable auto-imports completely but it's still possible to use [explicit imports](/docs/4.x/guide/concepts/auto-imports#explicit-imports) from `#imports`.

### Partially Disabling Auto-imports

If you want framework-specific functions like `ref` to remain auto-imported but wish to disable auto-imports for your own code (e.g., custom composables), you can set the `imports.scan` option to `false` in your `nuxt.config.ts` file:

```ts
export default defineNuxtConfig({
  imports: {
    scan: false,
  },
})
```

With this configuration:
- Framework functions like `ref`, `computed`, or `watch` will still work without needing manual imports.
- Custom code, such as composables, will need to be manually imported in your files.

::warning
**Caution:** This setup has certain limitations:
- If you structure your project with layers, you will need to explicitly import the composables from each layer, rather than relying on auto-imports.
- This breaks the layer system’s override feature. If you use `imports.scan: false`, ensure you understand this side-effect and adjust your architecture accordingly.
::

## Auto-imported Components

Nuxt also automatically imports components from your `~/components` directory, although this is configured separately from auto-importing composables and utility functions.

:read-more{to="/docs/4.x/directory-structure/app/components"}

To disable auto-importing components from your own `~/components` directory, you can set `components.dirs` to an empty array (though note that this will not affect components added by modules).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  components: {
    dirs: [],
  },
})
```

## Auto-import from Third-Party Packages

Nuxt also allows auto-importing from third-party packages.

::tip
If you are using the Nuxt module for that package, it is likely that the module has already configured auto-imports for that package.
::

For example, you could enable the auto-import of the `useI18n` composable from the `vue-i18n` package like this:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  imports: {
    presets: [
      {
        from: 'vue-i18n',
        imports: ['useI18n'],
      },
    ],
  },
})
```

:video-accordion{title="Watch a video from Alexander Lichter on how to easily set up custom auto imports" videoId="FT2LQJ2NvVI"}
</file>

<file path="docs/3.guide/1.concepts/4.server-engine.md">
---
title: Server Engine
description: 'Nuxt is powered by a new server engine: Nitro.'
---

While building Nuxt, we created a new server engine: [Nitro](https://nitro.build/).

It is shipped with many features:

- Cross-platform support for Node.js, browsers, service workers and more.
- Serverless support out-of-the-box.
- API routes support.
- Automatic code-splitting and async-loaded chunks.
- Hybrid mode for static + serverless sites.
- Development server with hot module reloading.

## API Layer

Server [API endpoints](/docs/4.x/directory-structure/server#server-routes) and [Middleware](/docs/4.x/directory-structure/server#server-middleware) are added by Nitro that internally uses [h3](https://github.com/h3js/h3).

Key features include:

- Handlers can directly return objects/arrays for an automatically-handled JSON response
- Handlers can return promises, which will be awaited (`res.end()` and `next()` are also supported)
- Helper functions for body parsing, cookie handling, redirects, headers and more

Check out [the h3 docs](https://github.com/h3js/h3) for more information.

::read-more{to="/docs/4.x/directory-structure/server#server-routes"}
Learn more about the API layer in the `server/` directory.
::

## Direct API Calls

Nitro allows 'direct' calling of routes via the globally-available [`$fetch`](/docs/4.x/api/utils/dollarfetch) helper. This will make an API call to the server if run on the browser, but will directly call the relevant function if run on the server, **saving an additional API call**.

[`$fetch`](/docs/4.x/api/utils/dollarfetch) API is using [ofetch](https://github.com/unjs/ofetch), with key features including:

- Automatic parsing of JSON responses (with access to raw response if needed)
- Request body and params are automatically handled, with correct `Content-Type` headers

For more information on `$fetch` features, check out [ofetch](https://github.com/unjs/ofetch).

## Typed API Routes

When using API routes (or middleware), Nitro will generate typings for these routes as long as you are returning a value instead of using `res.end()` to send a response.

You can access these types when using [`$fetch()`](/docs/4.x/api/utils/dollarfetch) or [`useFetch()`](/docs/4.x/api/composables/use-fetch).

## Standalone Server

Nitro produces a standalone server dist that is independent of `node_modules`.

The server in Nuxt 2 is not standalone and requires part of Nuxt core to be involved by running `nuxt start` (with the [`nuxt-start`](https://www.npmjs.com/package/nuxt-start) or [`nuxt`](https://www.npmjs.com/package/nuxt) distributions) or custom programmatic usage, which is fragile and prone to breakage and not suitable for serverless and service worker environments.

Nuxt generates this dist when running `nuxt build` into a [`.output`](/docs/4.x/directory-structure/output) directory.

The output contains runtime code to run your Nuxt server in any environment (including experimental browser service workers!) and serve your static files, making it a true hybrid framework for the JAMstack. In addition, Nuxt implements a native storage layer, supporting multi-source drivers and local assets.

::read-more{icon="i-simple-icons-github" to="https://github.com/nitrojs/nitro" target="_blank"}
Read more about Nitro engine on GitHub.
::
</file>

<file path="docs/3.guide/1.concepts/5.modules.md">
---
title: 'Modules'
description: "Nuxt provides a module system to extend the framework core and simplify integrations."
---

## Exploring Nuxt Modules

When developing production-grade applications with Nuxt you might find that the framework's core functionality is not enough. Nuxt can be extended with configuration options and plugins, but maintaining these customizations across multiple projects can be tedious, repetitive and time-consuming. On the other hand, supporting every project's needs out of the box would make Nuxt very complex and hard to use.

This is one of the reasons why Nuxt provides a module system that makes it possible to extend the core. Nuxt modules are async functions that sequentially run when starting Nuxt in development mode using [`nuxt dev`](/docs/4.x/api/commands/dev) or building a project for production with [`nuxt build`](/docs/4.x/api/commands/build). They can override templates, configure webpack loaders, add CSS libraries, and perform many other useful tasks.

Best of all, Nuxt modules can be distributed in npm packages. This makes it possible for them to be reused across projects and shared with the community, helping create an ecosystem of high-quality add-ons.

::read-more{to="/modules"}
Explore Nuxt Modules
::

## Add Nuxt Modules

Once you have installed the modules you can add them to your [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) file under the `modules` property. Module developers usually provide additional steps and details for usage.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  modules: [
    // Using package name (recommended usage)
    '@nuxtjs/example',

    // Load a local module
    './modules/example',

    // Add module with inline-options
    ['./modules/example', { token: '123' }],

    // Inline module definition
    async (inlineOptions, nuxt) => { },
  ],
})
```

::warning
Nuxt modules are now build-time-only, and the `buildModules` property used in Nuxt 2 is deprecated in favor of `modules`.
::

## Create a Nuxt Module

Everyone has the opportunity to develop modules and we cannot wait to see what you will build.

:read-more{to="/docs/4.x/guide/modules" title="Module Author Guide"}
</file>

<file path="docs/3.guide/1.concepts/7.esm.md">
---
title: 'ES Modules'
description: "Nuxt uses native ES modules."
navigation: false
---

This guide helps explain what ES Modules are and how to make a Nuxt app (or upstream library) compatible with ESM.

## Background

### CommonJS Modules

CommonJS (CJS) is a format introduced by Node.js that allows sharing functionality between isolated JavaScript modules ([read more](https://nodejs.org/api/modules.html)).
You might be already familiar with this syntax:

```js
const a = require('./a')

module.exports.a = a
```

Bundlers like webpack and Rollup support this syntax and allow you to use modules written in CommonJS in the browser.

### ESM Syntax

Most of the time, when people talk about ESM vs. CJS, they are talking about a different syntax for writing [modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules).

```js
import a from './a'

export { a }
```

Before ECMAScript Modules (ESM) became a standard (it took more than 10 years!), tooling like
[webpack](https://webpack.js.org/guides/ecma-script-modules/) and even languages like TypeScript started supporting so-called **ESM syntax**.
However, there are some key differences with actual spec; here's [a helpful explainer](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/).

### What is 'Native' ESM?

You may have been writing your app using ESM syntax for a long time. After all, it's natively supported by the browser, and in Nuxt 2 we compiled all the code you wrote to the appropriate format (CJS for server, ESM for browser).

When adding modules to your package, things were a little different. A sample library might expose both CJS and ESM versions, and let us pick which one we wanted:

```json
{
  "name": "sample-library",
  "main": "dist/sample-library.cjs.js",
  "module": "dist/sample-library.esm.js"
}
```

So in Nuxt 2, the bundler (webpack) would pull in the CJS file ('main') for the server build and use the ESM file ('module') for the client build.

::note
The `module` field is a convention used by bundlers like webpack and Rollup, but is not recognized by Node.js itself. Node.js only uses the [`exports`](https://nodejs.org/api/packages.html#exports) and [`main`](https://nodejs.org/api/packages.html#main) fields for module resolution.
::

However, in recent Node.js LTS releases, it is now possible to [use native ESM module](https://nodejs.org/api/esm.html) within Node.js. That means that Node.js itself can process JavaScript using ESM syntax, although it doesn't do it by default. The two most common ways to enable ESM syntax are:

- set `"type": "module"` within your `package.json` and keep using `.js` extension
- use the `.mjs` file extensions (recommended)

This is what we do for Nuxt Nitro; we output a `.output/server/index.mjs` file. That tells Node.js to treat this file as a native ES module.

### What Are Valid Imports in a Node.js Context?

When you `import` a module rather than `require` it, Node.js resolves it differently. For example, when you import `sample-library`, Node.js will look for the `exports` entry in that library's `package.json`, or fall back to the `main` entry if `exports` is not defined.

This is also true of dynamic imports, like `const b = await import('sample-library')`.

Node supports the following kinds of imports (see [docs](https://nodejs.org/api/packages.html#determining-module-system)):

1. files ending in `.mjs` - these are expected to use ESM syntax
1. files ending in `.cjs` - these are expected to use CJS syntax
1. files ending in `.js` - these are expected to use CJS syntax unless their `package.json` has `"type": "module"`

### What Kinds of Problems Can There Be?

For a long time module authors have been producing ESM-syntax builds but using conventions like `.esm.js` or `.es.js`, which they have added to the `module` field in their `package.json`. This hasn't been a problem until now because they have only been used by bundlers like webpack, which don't especially care about the file extension.

However, if you try to import a package with an `.esm.js` file in a Node.js ESM context, it won't work, and you'll get an error like:

```bash [Terminal]
(node:22145) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.
/path/to/index.js:1

export default {}
^^^^^^

SyntaxError: Unexpected token 'export'
    at wrapSafe (internal/modules/cjs/loader.js:1001:16)
    at Module._compile (internal/modules/cjs/loader.js:1049:27)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    ....
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

You might also get this error if you have a named import from an ESM-syntax build that Node.js thinks is CJS:

```bash [Terminal]
file:///path/to/index.mjs:5
import { named } from 'sample-library'
         ^^^^^
SyntaxError: Named export 'named' not found. The requested module 'sample-library' is a CommonJS module, which may not support all module.exports as named exports.

CommonJS modules can always be imported via the default export, for example using:

import pkg from 'sample-library';
const { named } = pkg;

    at ModuleJob._instantiate (internal/modules/esm/module_job.js:120:21)
    at async ModuleJob.run (internal/modules/esm/module_job.js:165:5)
    at async Loader.import (internal/modules/esm/loader.js:177:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

## Troubleshooting ESM Issues

If you encounter these errors, the issue is almost certainly with the upstream library. They need to [fix their library](/docs/4.x/guide/concepts/esm#library-author-guide) to support being imported by Node.

### Transpiling Libraries

In the meantime, you can tell Nuxt not to try to import these libraries by adding them to `build.transpile`:

```ts twoslash
export default defineNuxtConfig({
  build: {
    transpile: ['sample-library'],
  },
})
```

You may find that you _also_ need to add other packages that are being imported by these libraries.

### Aliasing Libraries

In some cases, you may also need to manually alias the library to the CJS version, for example:

```ts twoslash
export default defineNuxtConfig({
  alias: {
    'sample-library': 'sample-library/dist/sample-library.cjs.js',
  },
})
```

### Default Exports

A dependency with CommonJS format, can use `module.exports` or `exports` to provide a default export:

```js [node_modules/cjs-pkg/index.js]
module.exports = { test: 123 }
// or
exports.test = 123
```

This normally works well if we `require` such dependency:

```js [test.cjs]
const pkg = require('cjs-pkg')

console.log(pkg) // { test: 123 }
```

[Node.js in native ESM mode](https://nodejs.org/api/esm.html#interoperability-with-commonjs), [typescript with `esModuleInterop` enabled](https://www.typescriptlang.org/tsconfig/#esModuleInterop) and bundlers such as webpack, provide a compatibility mechanism so that we can default import such library.
This mechanism is often referred to as "interop require default":

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { test: 123 }
```

However, because of the complexities of syntax detection and different bundle formats, there is always a chance that the interop default fails and we end up with something like this:

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { default: { test: 123 } }
```

Also when using dynamic import syntax (in both CJS and ESM files), we always have this situation:

```js
import('cjs-pkg').then(console.log) // [Module: null prototype] { default: { test: '123' } }
```

In this case, we need to manually interop the default export:

<!-- eslint-disable import/no-named-default -->

```js
// Static import
import { default as pkg } from 'cjs-pkg'

// Dynamic import
import('cjs-pkg').then(m => m.default || m).then(console.log)
```

For handling more complex situations and more safety, we recommend and internally use [mlly](https://github.com/unjs/mlly) in Nuxt that can preserve named exports.

```js
import { interopDefault } from 'mlly'

// Assuming the shape is { default: { foo: 'bar' }, baz: 'qux' }
import myModule from 'my-module'

console.log(interopDefault(myModule)) // { foo: 'bar', baz: 'qux' }
```

## Library Author Guide

The good news is that it's relatively simple to fix issues of ESM compatibility. There are two main options:

1. **You can rename your ESM files to end with `.mjs`.**

   _This is the recommended and simplest approach._ You may have to sort out issues with your library's dependencies and possibly with your build system, but in most cases, this should fix the problem for you. It's also recommended to rename your CJS files to end with `.cjs`, for the greatest explicitness.

1. **You can opt to make your entire library ESM-only**.

   This would mean setting `"type": "module"` in your `package.json` and ensuring that your built library uses ESM syntax. However, you may face issues with your dependencies - and this approach means your library can _only_ be consumed in an ESM context.

### Migration

The initial step from CJS to ESM is updating any usage of `require` to use `import` instead:

::code-group

```ts [Before]
module.exports = function () { /* ... */ }

exports.hello = 'world'
```

```ts [After]
export default function () { /* ... */ }

export const hello = 'world'
```

::

::code-group

```js [Before]
const myLib = require('my-lib')
```

```js [After]
import myLib from 'my-lib'
// or
const dynamicMyLib = await import('my-lib').then(lib => lib.default || lib)
```

::

In ESM Modules, unlike CJS, `require`, `require.resolve`, `__filename` and `__dirname` globals are not available
and should be replaced with `import()` and `import.meta.filename`.

::code-group

```js [Before]
const { join } = require('node:path')

const newDir = join(__dirname, 'new-dir')
```

```js [After]
import { fileURLToPath } from 'node:url'

const newDir = fileURLToPath(new URL('./new-dir', import.meta.url))
```

::

::code-group

```js [Before]
const someFile = require.resolve('./lib/foo.js')
```

```js [After]
import { resolvePath } from 'mlly'

const someFile = await resolvePath('my-lib', { url: import.meta.url })
```

::

### Best Practices

- Prefer named exports rather than default export. This helps reduce CJS conflicts. (see [Default exports](/docs/4.x/guide/concepts/esm#default-exports) section)

- Avoid depending on Node.js built-ins and CommonJS or Node.js-only dependencies as much as possible to make your library usable in Browsers and Edge Workers without needing Nitro polyfills.

- Use new `exports` field with conditional exports. ([read more](https://nodejs.org/api/packages.html#conditional-exports)).

```json
{
  "exports": {
    ".": {
      "import": "./dist/mymodule.mjs"
    }
  }
}
```
</file>

<file path="docs/3.guide/1.concepts/8.typescript.md">
---
title: 'TypeScript'
description: "Nuxt is fully typed and provides helpful shortcuts to ensure you have access to accurate type information when you are coding."
---

## Type-checking

By default, Nuxt doesn't check types when you run [`nuxt dev`](/docs/4.x/api/commands/dev) or [`nuxt build`](/docs/4.x/api/commands/build), for performance reasons.

To enable type-checking at build or development time, install `vue-tsc` and `typescript` as development dependency:

::code-group{sync="pm"}

  ```bash [npm]
  npm install --save-dev vue-tsc typescript
  ```

  ```bash [yarn]
  yarn add --dev vue-tsc typescript
  ```

  ```bash [pnpm]
  pnpm add -D vue-tsc typescript
  ```

  ```bash [bun]
  bun add -D vue-tsc typescript
  ```

::

Then, run [`nuxt typecheck`](/docs/4.x/api/commands/typecheck) command to check your types:

```bash [Terminal]
npx nuxt typecheck
```

To enable type-checking at build or development time, you can also use the [`typescript.typeCheck`](/docs/4.x/api/nuxt-config#typecheck) option in your `nuxt.config` file:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  typescript: {
    typeCheck: true,
  },
})
```

## Auto-generated Types

Nuxt projects rely on auto-generated types to work properly. These types are stored in the [`.nuxt`](/docs/4.x/directory-structure/nuxt) directory and are generated when you run the dev server or build your application. You can also generate these files manually by running `nuxt prepare`.

The generated `tsconfig.json` files inside the [`.nuxt`](/docs/4.x/directory-structure/nuxt) directory include **recommended basic TypeScript configuration** for your project, references to [auto-imports](/docs/4.x/guide/concepts/auto-imports), [API route types](/docs/4.x/guide/concepts/server-engine#typed-api-routes), path aliases like `#imports`, `~/file`, or `#build/file`, and more.

::warning
Nuxt relies on this configuration, and [Nuxt modules](/docs/4.x/guide/modules) can extend it as well. For this reason, it is not recommended to modify your `tsconfig.json` file directly, as doing so could overwrite important settings. Instead, extend it via `nuxt.config.ts`. [Learn more about extending the configuration here](/docs/4.x/directory-structure/tsconfig).
::

::tip{icon="i-lucide-video" to="https://youtu.be/umLI7SlPygY" target="_blank"}
Watch a video from Daniel Roe explaining built-in Nuxt aliases.
::

## Project References

Nuxt uses [TypeScript project references](https://www.typescriptlang.org/docs/handbook/project-references.html) to improve type-checking performance and provide better IDE support. This feature allows TypeScript to break up your codebase into smaller, more manageable pieces.

### How Nuxt Uses Project References

When you run `nuxt dev`, `nuxt build` or `nuxt prepare`, Nuxt will generate multiple `tsconfig.json` files for different parts of your application.

- **`.nuxt/tsconfig.app.json`** - Configuration for your application code within the `app/` directory
- **`.nuxt/tsconfig.node.json`** - Configuration for your `nuxt.config.ts` and files outside the other contexts
- **`.nuxt/tsconfig.server.json`** - Configuration for server-side code (when applicable)
- **`.nuxt/tsconfig.shared.json`** - For code shared between app and server contexts (like types and non-environment specific utilities)

Each of these files is configured to reference the appropriate dependencies and provide optimal type-checking for their specific context.

::note
For backward compatibility, Nuxt still generates `.nuxt/tsconfig.json`. However, we recommend using [TypeScript project references](/docs/4.x/directory-structure/tsconfig) with the new configuration files (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, etc.) for better type safety and performance. This legacy file will be removed in a future version of Nuxt.
::

### Benefits of Project References

- **Faster builds**: TypeScript can skip rebuilding unchanged projects
- **Better IDE performance**: Your IDE can provide faster IntelliSense and error checking
- **Isolated compilation**: Errors in one part of your application don't prevent compilation of other parts
- **Clearer dependency management**: Each project explicitly declares its dependencies

### Augmenting Types with Project References

Since the project is divided into **multiple type contexts**, it's important to **augment types within the correct context** to ensure they're properly recognized. TypeScript will not recognize augmentations placed outside these directories unless they are explicitly included in the appropriate context.

For example, if you want to augment types for the `app` context, the augmentation file should be placed in the `app/` directory.

Similarly:
- For the `server` context, place the augmentation file in the `server/` directory.
- For types that are **shared between the app and server**, place the file in the `shared/` directory.

::read-more{to="/docs/4.x/guide/modules/recipes-advanced#extend-typescript-config"}
Read more about augmenting specific type contexts from **files outside those contexts** in the Module Author Guide.
::

## Strict Checks

TypeScript comes with certain checks to give you more safety and analysis of your program.

[Strict checks](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-stricter-checks) are enabled by default in Nuxt when the [`typescript.typeCheck`](/docs/4.x/guide/concepts/typescript#type-checking) option is enabled to give you greater type safety.

If you are currently converting your codebase to TypeScript, you may want to temporarily disable strict checks by setting `strict` to `false` in your `nuxt.config`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  typescript: {
    strict: false,
  },
})
```
</file>

<file path="docs/3.guide/1.concepts/9.code-style.md">
---
title: 'Code Style'
description: "Nuxt supports ESLint out of the box"
---

## ESLint

The recommended approach for Nuxt is to enable ESLint support using the [`@nuxt/eslint`](https://eslint.nuxt.com/packages/module) module, that will setup project-aware ESLint configuration for you.

:::callout{icon="i-lucide-lightbulb"}
The module is designed for the [new ESLint flat config format](https://eslint.org/docs/latest/use/configure/configuration-files) which is the [default format since ESLint v9](https://eslint.org/blog/2024/04/eslint-v9.0.0-released/). If you are using the legacy `.eslintrc` config, you will need to [configure manually with `@nuxt/eslint-config`](https://eslint.nuxt.com/packages/config#customizing-the-config). We highly recommend you to migrate over the flat config to be future-proof.
:::

## Quick Setup

```bash
npx nuxt module add eslint
```

Start your Nuxt app, a `eslint.config.mjs` file will be generated under your project root. You can customize it as needed.

You can learn more about the module and customizations in [Nuxt ESLint's documentation](https://eslint.nuxt.com/packages/module).
</file>

<file path="docs/3.guide/2.best-practices/.navigation.yml">
title: Best Practices
titleTemplate: '%s · Best Practices'
icon: i-lucide-square-check
</file>

<file path="docs/3.guide/2.best-practices/hydration.md">
---
navigation.title: 'Nuxt and hydration'
title: Nuxt and hydration
description: Why fixing hydration issues is important
---

When developing, you may face hydration issues. Don't ignore those warnings.

# Why is it important to fix them?

Hydration mismatches are not just warnings - they are indicators of serious problems that can break your application:

## Performance Impact

- **Increased time to interactive**: Hydration errors force Vue to re-render the entire component tree, which will increase the time for your Nuxt app to become interactive
- **Poor user experience**: Users may see content flashing or unexpected layout shifts

## Functionality Issues

- **Broken interactivity**: Event listeners may not attach properly, leaving buttons and forms non-functional
- **State inconsistencies**: Application state can become out of sync between what the user sees and what the application thinks is rendered
- **SEO problems**: Search engines may index different content than what users actually see

# How to detect them

## Development Console Warnings

Vue will log hydration mismatch warnings in the browser console during development:

![Screenshot of Vue hydration mismatch warning in the browser console](/assets/docs/best-practices/vue-console-hydration.png)

# Common reasons

## Browser-only APIs in Server Context

**Problem**: Using browser-specific APIs during server-side rendering.

```html
<template>
  <div>User preference: {{ userTheme }}</div>
</template>

<script setup>
// This will cause hydration mismatch!
// localStorage doesn't exist on the server!
const userTheme = localStorage.getItem('theme') || 'light'
</script>
```

**Solution**: You can use [`useCookie`](/docs/4.x/api/composables/use-cookie):

```html
<template>
  <div>User preference: {{ userTheme }}</div>
</template>

<script setup>
// This works on both server and client
const userTheme = useCookie('theme', { default: () => 'light' })
</script>
```

## Inconsistent Data

**Problem**: Different data between server and client.

```html
<template>
  <div>{{ Math.random() }}</div>
</template>
```

**Solution**: Use SSR-friendly state:

```html
<template>
  <div>{{ state }}</div>
</template>

<script setup>
const state = useState('random', () => Math.random())
</script>
```

## Conditional Rendering Based on Client State

**Problem**: Using client-only conditions during SSR.

```html
<template>
  <div v-if="window?.innerWidth > 768">
    Desktop content
  </div>
</template>
```

**Solution**: Use media queries or handle it client-side:

```html
<template>
  <div class="responsive-content">
    <div class="hidden md:block">Desktop content</div>
    <div class="md:hidden">Mobile content</div>
  </div>
</template>
```

## Third-party Libraries with Side Effects

**Problem**: Libraries that modify the DOM or have browser dependencies (this happens a LOT with tag managers).

```html
<script setup>
if (import.meta.client) {
    const { default: SomeBrowserLibrary } = await import('browser-only-lib')
    SomeBrowserLibrary.init()
}
</script>
```

**Solution**: Initialise libraries after hydration has completed:

```html
<script setup>
onMounted(async () => {
  const { default: SomeBrowserLibrary } = await import('browser-only-lib')
  SomeBrowserLibrary.init()
})
</script>
```

## Dynamic Content Based on Time

**Problem**: Content that changes based on current time.

```html
<template>
  <div>{{ greeting }}</div>
</template>

<script setup>
const hour = new Date().getHours()
const greeting = hour < 12 ? 'Good morning' : 'Good afternoon'
</script>
```

**Solution**: Use [`NuxtTime`](/docs/4.x/api/components/nuxt-time) component or handle it client-side:

```html
<template>
  <div>
    <NuxtTime :date="new Date()" format="HH:mm" />
  </div>
</template>
```

```html
<template>
  <div>
    <ClientOnly>
      {{ greeting }}
      <template #fallback>
        Hello!
      </template>
    </ClientOnly>
  </div>
</template>

<script setup>
const greeting = ref('Hello!')

onMounted(() => {
  const hour = new Date().getHours()
  greeting.value = hour < 12 ? 'Good morning' : 'Good afternoon'
})
</script>
```

## In summary

1. **Use SSR-friendly composables**: [`useFetch`](/docs/4.x/api/composables/use-fetch), [`useAsyncData`](/docs/4.x/api/composables/use-async-data), [`useState`](/docs/4.x/api/composables/use-state)
2. **Wrap client-only code**: Use [`ClientOnly`](/docs/4.x/api/components/client-only) component for browser-specific content
3. **Consistent data sources**: Ensure server and client uses the same data
4. **Avoid side effects in setup**: Move browser-dependent code to `onMounted`

::tip
You can read the [Vue documentation on SSR hydration mismatch](https://vuejs.org/guide/scaling-up/ssr#hydration-mismatch) for a better understanding of hydration.
::
</file>

<file path="docs/3.guide/2.best-practices/performance.md">
---
navigation.title: 'Nuxt Performance'
title: Nuxt performance
description: Best practices for improving performance of Nuxt apps.
---

Nuxt comes with built-in features designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals). There are also multiple Nuxt core modules that assist in improving performance in specific areas. This guide outlines best practices to optimize performance of your Nuxt application.

## Built-in Features

Nuxt offers several built-in features that help you optimize performance of your website. Understanding how these features work is crucial for achieving blazingly-fast performance.

### Links

[`<NuxtLink>`](/docs/4.x/api/components/nuxt-link) is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)

```html
<template>
  <NuxtLink to="/about">About page</NuxtLink>
</template>

<!-- Which will render to with Vue Router & Smart Prefetching -->
<a href="/about">About page</a>
```

Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.

You can also opt for prefetching on interaction instead:

```ts
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        prefetchOn: 'interaction',
      },
    },
  },
})
```

:read-more{title="NuxtLink" to="/docs/4.x/api/components/nuxt-link"}

### Hybrid Rendering

In more complex applications, we may need a full control over how our application is rendered to support cases where some pages could be generated at build time, while others should be client-side rendered

Hybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL:

```ts
export default defineNuxtConfig({
  routeRules: {
    '/': {
      prerender: true,
    },
    '/products/**': {
      swr: 3600,
    },
    '/blog': {
      isr: 3600,
    },
    '/admin/**': {
      ssr: false,
    },
  },
})
```

Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.

:read-more{title="Hybrid rendering" to="/docs/4.x/guide/concepts/rendering#hybrid-rendering"}

### Lazy Loading Components

To dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is useful if the component is not always needed.

```html
<script setup lang="ts">
const show = ref(false)
</script>

<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
  </div>
</template>
```

By using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.

:read-more{title="Lazy loading components" to="/docs/4.x/directory-structure/app/components#dynamic-imports"}

### Lazy Hydration

It is not always necessary to hydrate (or make interactive) all the components of your site on the initial load. Using lazy hydration, you can control when components can have their code loaded, which can improve the time-to-interactive metric for your app. Nuxt allows you to control when components become interactive with lazy hydration (added in Nuxt v3.16).

```html
<template>
  <div>
    <LazyMyComponent hydrate-on-visible />
  </div>
</template>
```

To optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.

:read-more{title="Lazy hydration" to="/docs/4.x/directory-structure/app/components#delayed-or-lazy-hydration"}

### Fetching data

To avoid fetching same data twice (once on the server and once on client) Nuxt provides [`useFetch`](/docs/4.x/api/composables/use-fetch) and [`useAsyncData`](/docs/4.x/api/composables/use-async-data). They ensure that if an API call is made on the server, the data is forwarded to the client in the payload instead of being fetched again.

:read-more{title="Data fetching" to="/docs/4.x/getting-started/data-fetching"}

## Core Nuxt Modules

Apart from Nuxt's built-in features, there are also core modules maintained by the Nuxt team which help improve performance even further. These modules help handle assets such as images, custom fonts, or third party scripts.

### Images

Unoptimized images can have a significant negative impact on your website performance, specifically the [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp) score.

In Nuxt we can use [Nuxt Image](https://image.nuxt.com/) module that is a plug-and-play image optimization for Nuxt apps. It allows resizing and transforming your images using built-in optimizer or your favorite images CDN.

:video-accordion{title="Watch the video by LearnVue about Nuxt Image" videoId="_UBff2eqGY0"}

[`<NuxtImg>`](/docs/4.x/api/components/nuxt-img) is a drop-in replacement for the native `<img>` tag that comes with following enhancements:

* Uses built-in provider to optimize local and remote images
* Converts `src` to provider optimized URLs with modern formats such as WebP or Avif
* Automatically resizes images based on `width` and `height`
* Generates responsive `sizes` when providing sizes option
* Supports native `lazy loading` as well as other `<img>` attributes

Images in your website can usually be separated by importance; the ones that are needed to be delivered first at initial load (i.e. `Largest Contentful Paint`), and the ones that can be loaded later or when specifically needed. For that, we could use the following optimizations:

```html
<template>
  <!-- 🚨 Needs to be loaded ASAP -->
  <NuxtImg
    src="/hero-banner.jpg"
    format="webp"
    preload
    loading="eager"
    fetch-priority="high"
    width="200"
    height="100"
  />

  <!-- 🐌 Can be loaded later -->
  <NuxtImg
    src="/facebook-logo.jpg"
    format="webp"
    loading="lazy"
    fetch-priority="low"
    width="200"
    height="100"
  />
</template>
```

:read-more{title="Nuxt Image" to="https://image.nuxt.com/usage/nuxt-img"}

### Fonts

[Nuxt Fonts](https://fonts.nuxt.com/) will automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.

It includes built-in automatic self-hosting for any font file which means you can optimally load web fonts with reduced layout shift, thanks to the underlying package [fontaine](https://github.com/unjs/fontaine).

:video-accordion{title="Watch the talk by Daniel Roe about the idea behind Nuxt Fonts" videoId="D3F683UViBY"}

Nuxt Fonts processes all your CSS and does the following things automatically when it encounters a font-family declaration.

1. **Resolves fonts** – Looks for font files in public/, then checks web providers like Google, Bunny, and Fontshare.
2. **Generates @font-face rules** – Injects CSS rules to load fonts from the correct sources.
3. **Proxies & caches fonts** – Rewrites URLs to `/_fonts`, downloads and caches fonts locally.
4. **Creates fallback metrics** – Adjusts local system fonts to match web fonts, reducing layout shift ([CLS](https://web.dev/articles/cls)).
5. **Includes fonts in build** – Bundles fonts with your project, hashing file names and setting long-lived cache headers.

It supports multiple providers that are designed to be pluggable and extensible, so no matter your setup you should be able to use an existing provider or write your own.

### Scripts

Third-party resources like analytics tools, video embeds, maps, and social media integrations enhance website functionality but can significantly degrade user experience and negatively impact [Interaction to Next Paint (INP)](https://web.dev/articles/inp) and Largest Contentful Paint (LCP) scores.

[Nuxt Scripts](https://scripts.nuxt.com/) lets you load third-party scripts with better performance, privacy, security and DX.

:video-accordion{title="Watch the video by Alex Lichter about Nuxt Scripts" videoId="sjMqUUvH9AE"}

Nuxt Scripts provides an abstraction layer on top of third-party scripts, providing SSR support and type-safety and while still giving you full low-level control over how a script is loaded.

```ts
const { onLoaded, proxy } = useScriptGoogleAnalytics(
  {
    id: 'G-1234567',
    scriptOptions: {
      trigger: 'manual',
    },
  },
)
// queue events to be sent when ga loads
proxy.gtag('config', 'UA-123456789-1')
// or wait until ga is loaded
onLoaded((gtag) => {
  // script loaded
})
```

:read-more{title="Nuxt Scripts" to="https://scripts.nuxt.com/scripts"}

## Profiling Tools

To improve performance, we need to first know how to measure it, starting with measuring performance during development - on local environment, and then moving to auditing application that are deployed on production.

### Nuxi Analyze

[This](/docs/4.x/api/commands/analyze) command of `nuxi` allows to analyze the production bundle or your Nuxt application. It leverages `vite-bundle-visualizer` (similar to `webpack-bundle-analyzer`) to generate a visual representation of your application's bundle, making it easier to identify which components take up the most space.

When you see a large block in the visualization, it often signals an opportunity for optimization—whether by splitting it into smaller parts, implementing lazy loading, or replacing it with a more efficient alternative, especially for third-party libraries.

Large blocks containing multiple elements can often be reduced by importing only the necessary components rather than entire modules while large standalone blocks may be better suited for lazy loading rather than being included in the main bundle.

### Nuxt DevTools

The [Nuxt DevTools](https://devtools.nuxt.com/) gives you insights and transparency about your Nuxt App to identify performance gaps and seamlessly manage your app configurations.

![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)

It comes with several features we can use to measure performance of Nuxt apps:
1. **Timeline** – Tracks time spent on rendering, updating, and initializing components to identify performance bottlenecks.  
2. **Assets** – Displays file sizes (e.g., images) without transformations.  
3. **Render Tree** – Shows connections between Vue components, scripts, and styles to optimize dynamic loading.  
4. **Inspect** – Lists all files used in the Vue app with their size and evaluation time.

### Chrome DevTools

Chrome DevTools come with two useful tabs for measuring performance; `Performance` and `Lighthouse`.

When you open the [Performance](https://developer.chrome.com/docs/devtools/performance/overview) panel, it instantly shows your local **Largest Contentful Paint (LCP)** and **Cumulative Layout Shift (CLS)** scores (good, needs improvement, or bad).  

If you interact with the page, it also captures **Interaction to Next Paint (INP)**, giving you a full view of your Core Web Vitals based on your device and network.

![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)

[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse) audits performance, accessibility, SEO, progressive web apps, and best practices. It runs tests on your page and generates a report. Use failing audits as a guide to improve your site.

![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)

Each audit has a reference document explaining why the audit is important, as well as how to fix it.

### PageSpeed Insights

[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about) reports on the user experience of a page on both mobile and desktop devices, and provides suggestions on how that page may be improved.

It provides both lab and field data about a page. Lab data is useful for debugging issues, as it is collected in a controlled environment while field data is useful for capturing true, real-world user experience.

### Web Page Test

[WebPageTest](https://www.webpagetest.org/) is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.

Each test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.

## Common problems

When building more complex Nuxt applications, you will probably encounter some of the problems listed below. Understanding these problems and fixing them will help you improve performance of your website.

### Overusing plugins

**Problem**: A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.

**Solution**: Inspect your plugins and see if some of them could be implemented rather as a composable or utility function instead.

### Unused code / dependencies

**Problem**: With the development of the project, there can be a case where there will be some unused code or a dependency. This additional functionality may not be used or needed while it will be increase the bundle size of our project.

**Solution**: Inspect your `package.json` for unused dependencies and analyze your code for unused utils/composables/functions.

### Not using Vue Performance tips

**Problem**: [Vue documentation](https://vuejs.org/guide/best-practices/performance) lists several Performance improvements we can use in our Nuxt projects as well but as they are part of Vue documentation, developers tend to forget about it and focus on Nuxt specific improvements only - while Nuxt application is still a Vue project.

**Solution**: Use concepts such as `shallowRef`, `v-memo`, `v-once`, etc to improve performance.

### Not following patterns

**Problem**: The more people are currently working on the project, the more difficult it will be to maintain the stable codebase. Developers have a tendency to introduce new concepts they've seen in another project which can cause conflicts and problems with performance.

**Solution**: Establish rules and patterns in the project such as [Good practices and Design Patterns for Vue Composables](https://dev.to/jacobandrewsky/good-practices-and-design-patterns-for-vue-composables-24lk)

### Trying to load everything at the same time

**Problem**: When a page is loaded and it is not correctly instructed about the order of loading elements it will result in fetching everything at the same time - which can be slow and result in bad User Experience.

**Solution**: Use concepts such as Progressive Enhancement where core webpage content is set first, then more nuanced and technically rigorous layers of presentation and features are added on top as the browser/internet connection allow.

## Useful Resources

To learn more about various techniques for improving performance, take a look at the following resources:

1. [Apply instant loading with the PRPL pattern](https://web.dev/articles/apply-instant-loading-with-prpl)
2. [Perceived performance](https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/Perceived_performance)
3. [Understanding Critical Rendering Path](https://developer.mozilla.org/en-US/docs/Web/Performance/Guides/Critical_rendering_path)
</file>

<file path="docs/3.guide/2.best-practices/plugins.md">
---
navigation.title: 'Nuxt Plugins'
title: Nuxt Plugins
description: Best practices when using Nuxt plugins.
---

Plugins in Nuxt allow you to extend your application with additional functionality. However, improper use can lead to performance bottlenecks. This guide outlines best practices to optimize your Nuxt plugins.

## Avoid costly plugin setup

A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.

## Use Composition whenever possible

Whenever possible, favor composition over plugins. Just like in Vue, many utilities and composables can be used directly without the need for a plugin. This keeps your project lightweight and improves maintainability.

## If `async`, enable `parallel`

By default, all plugins loads synchronously.
When defining asynchronous plugins, setting `parallel: true` allows multiple plugins to load concurrently, improving performance by preventing blocking operations.
</file>

<file path="docs/3.guide/3.ai/.navigation.yml">
title: 'Working with AI'
titleTemplate: 'Working with AI: %s'
icon: i-lucide-bot
</file>

<file path="docs/3.guide/3.ai/1.mcp.md">
---
title: Nuxt MCP Server
description: Use Nuxt documentation in your AI assistants with Model Context Protocol support.
navigation.title: MCP Server
---

## What is MCP?

MCP (Model Context Protocol) is a standardized protocol that enables AI assistants to access external data sources and tools. Nuxt provides an MCP server that allows AI assistants like Claude Code, Cursor, and Windsurf to access documentation, blog posts, and deployment guides directly.

The MCP server provides structured access to the Nuxt documentation, making it easy for AI tools to understand and assist with Nuxt development.

## Resources

The Nuxt MCP server provides the following resources for discovery:

- **`resource://nuxt-com/documentation-pages`**: Browse all available documentation pages (defaults to v4.x)
- **`resource://nuxt-com/blog-posts`**: Browse all Nuxt blog posts including releases and tutorials
- **`resource://nuxt-com/deploy-providers`**: Browse all deployment providers and hosting platforms

You're able to access these resources with tools like Claude Code by using `@`.

## Tools

The Nuxt MCP server provides the following tools organized by category:

### Documentation

- **`list_documentation_pages`**: Lists all available Nuxt documentation pages with their categories and basic information. Supports version filtering (3.x, 4.x, or all)
- **`get_documentation_page`**: Retrieves documentation page content and details by path
- **`get_getting_started_guide`**: Gets the getting started guide for a specific Nuxt version

### Blog

- **`list_blog_posts`**: Lists all Nuxt blog posts with metadata including dates, categories, and tags
- **`get_blog_post`**: Retrieves blog post content and details by path

### Deployment

- **`list_deploy_providers`**: Lists all deployment providers and hosting platforms for Nuxt applications
- **`get_deploy_provider`**: Retrieves deployment provider details and instructions by path

## Prompts

The Nuxt MCP server provides guided prompts for common workflows:

- **`find_documentation_for_topic`**: Find the best Nuxt documentation for a specific topic or feature
- **`deployment_guide`**: Get deployment instructions for a specific hosting provider
- **`migration_help`**: Get help with migrating between Nuxt versions

You're able to access these resources with tools like Claude Code by using `/`.

## Setup

The Nuxt MCP server uses HTTP transport and can be installed in different AI assistants.

### ChatGPT

::note{icon="i-lucide-info"}
**Custom connectors using MCP are available on ChatGPT for Pro and Plus accounts** on the web.
::

Follow these steps to set up Nuxt as a connector within ChatGPT:

1. **Enable Developer mode:**
   - Go to Settings → Connectors → Advanced settings → Developer mode

2. **Open ChatGPT settings**

3. **In the Connectors tab, Create a new connector:**
   - Give it a name: `Nuxt`
   - MCP server URL: `https://nuxt.com/mcp`
   - Authentication: `None`

4. **Click Create**

The Nuxt connector will appear in the composer's "Developer mode" tool later during conversations.

### Claude Code

::note{icon="i-lucide-info"}
**Ensure Claude Code is installed** - Visit [Anthropic's documentation](https://docs.claude.com/en/docs/claude-code/quickstart) for installation instructions.
::

Add the server using the CLI command:

```bash
claude mcp add --transport http nuxt-remote https://nuxt.com/mcp
```

### Claude Desktop

#### Setup Instructions

1. Open Claude Desktop and navigate to "Settings" > "Developer".
2. Click on "Edit Config". This will open the local Claude directory.
3. Modify the `claude_desktop_config.json` file with your custom MCP server configuration.
    ```json [claude_desktop_config.json]
    {
      "mcpServers": {
        "nuxt": {
          "command": "npx",
          "args": [
            "mcp-remote",
            "https://nuxt.com/mcp"
          ]
        }
      }
    }
    ```
4. Restart Claude Desktop app. The Nuxt MCP server should now be registered.

### Cursor

Click the button below to install the Nuxt MCP server directly in Cursor:

::u-button
---
to: "cursor://anysphere.cursor-deeplink/mcp/install?name=nuxt&config=eyJ0eXBlIjoiaHR0cCIsInVybCI6Imh0dHBzOi8vbnV4dC5jb20vbWNwIn0%3D"
label: Install MCP Server
color: neutral
icon: i-custom-cursor
---
::

For manual setup, follow these steps:

1. Open Cursor and go to "Settings" > "Tools & MCP"
2. Add the Nuxt MCP server configuration

Or manually create/update `.cursor/mcp.json` in your project root:

```json [.cursor/mcp.json]
{
  "mcpServers": {
    "nuxt": {
      "type": "http",
      "url": "https://nuxt.com/mcp"
    }
  }
}
```

### Le Chat Mistral

1. Navigate to "Intelligence" > "Connectors"
2. Click on "Add Connector" button, then select "Custom MCP Connector"
3. Create your Custom MCP Connector:
    - Connector Name : `Nuxt`
    - Connector Server : `https://nuxt.com/mcp`

### Visual Studio Code

::note{icon="i-lucide-info"}
**Install required extensions** - Ensure you have [GitHub Copilot](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot) and [GitHub Copilot Chat](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot-chat) extensions installed.
::

1. Open VS Code and access the Command Palette (Ctrl/Cmd + Shift + P)
2. Type "Preferences: Open Workspace Settings (JSON)" and select it
3. Navigate to your project's `.vscode` folder or create one if it doesn't exist
4. Create or edit the `mcp.json` file with the following configuration:

```json [.vscode/mcp.json]
{
  "servers": {
    "nuxt": {
      "type": "http",
      "url": "https://nuxt.com/mcp"
    }
  }
}
```

### GitHub Copilot Agent

::note{icon="i-lucide-info"}
**Repository administrator access required** to configure MCP servers for GitHub Copilot coding agent.
::

If you have already configured MCP servers in VS Code (replace the `servers` key with `mcpServers` for GitHub Copilot Agent), you can leverage a similar configuration for GitHub Copilot coding agent. You will need to add a `tools` key specifying which tools are available to Copilot.

1. Navigate to your GitHub repository
2. Go to **Settings** > **Code & automation** > **Copilot** > **Coding agent**
3. In the **MCP configuration** section, add the following configuration:
    ```json
    {
      "mcpServers": {
        "nuxt": {
          "type": "http",
          "url": "https://nuxt.com/mcp",
          "tools": ["*"]
        }
      }
    }
    ```
4. Click **Save**

#### Validating the Configuration

To verify the MCP server is configured correctly:

1. Create an issue in your repository and assign it to Copilot
2. Wait for Copilot to create a pull request
3. In the pull request, click **View session** in the "Copilot started work" timeline event
4. Click the ellipsis button (**...**) at the top right, then click **Copilot** in the sidebar
5. Expand the **Start MCP Servers** step to see the configured Nuxt tools

For more information on using MCP with GitHub Copilot coding agent, see [Extend coding agent with MCP](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/extend-coding-agent-with-mcp).

### Windsurf

1. Open Windsurf and navigate to "Settings" > "Windsurf Settings" > "Cascade"
2. Click the "Manage MCPs" button, then select the "View raw config" option
3. Add the following configuration to your MCP settings:

```json [.codeium/windsurf/mcp_config.json]
{
  "mcpServers": {
    "nuxt": {
      "type": "http",
      "url": "https://nuxt.com/mcp"
    }
  }
}
```

### Zed

1. Open Zed and go to "Settings" > "Open Settings"
2. Navigate to the JSON settings file
3. Add the following context server configuration to your settings:

```json [.config/zed/settings.json]
{
  "context_servers": {
    "nuxt": {
      "source": "custom",
      "command": "npx",
      "args": ["mcp-remote", "https://nuxt.com/mcp"],
      "env": {}
    }
  }
}
```

### Opencode

1. In your project root, create `opencode.json`
2. Add the following configuration:

```json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "nuxt": {
      "type": "remote",
      "url": "https://nuxt.com/mcp",
      "enabled": true
    }
  }
}
```

## Prompts Examples

Once configured, you can ask your AI assistant questions like:

- "List all available Nuxt documentation pages"
- "Get the introduction documentation"
- "What's the difference between v3 and v4?"
- "How do I deploy to Vercel?"
- "Show me the latest blog posts"
- "Help me migrate from Nuxt 3 to Nuxt 4"
- "Search documentation about composables"
- "Find deployment guides for Cloudflare"

The AI assistant will use the MCP server to fetch structured JSON data and provide guided assistance for Nuxt development.
</file>

<file path="docs/3.guide/3.ai/2.llms-txt.md">
---
title: Nuxt LLMs.txt
description: How to get AI tools like Cursor, Windsurf, GitHub Copilot, ChatGPT, and Claude to understand Nuxt concepts, APIs, and best practices.
navigation.title: LLMs.txt
---

## What is LLMs.txt?

LLMs.txt is a structured documentation format specifically designed for large language models (LLMs). Nuxt provides LLMs.txt files that contain comprehensive information about the framework, making it easy for AI tools to understand and assist with Nuxt development.

These files are optimized for AI consumption and contain structured information about concepts, APIs, usage patterns, and best practices.

## Available routes

We provide LLMs.txt routes to help AI tools access our documentation:

- **`/llms.txt`** - Contains a structured overview of all documentation pages and their links (~5K tokens)
- **`/llms-full.txt`** - Provides comprehensive documentation including getting started guides, API references, blog posts, and deployment guides (~1M+ tokens)

## Choosing the Right File

::note{icon="i-lucide-info"}
**Most users should start with `/llms.txt`** - it contains all essential information and works with standard LLM context windows.

Use `/llms-full.txt` only if you need comprehensive implementation details and your AI tool supports large contexts (200K+ tokens).
::

## Important usage notes

::warning{icon="i-lucide-alert-triangle"}
**@-symbol must be typed manually** - When using tools like Cursor or Windsurf, the `@` symbol must be typed by hand in the chat interface. Copy-pasting breaks the tool's ability to recognize it as a context reference.
::

## Usage with AI Tools

### Cursor

Nuxt provides specialized LLMs.txt files that you can reference in Cursor for better AI assistance with Nuxt development.

#### How to use

1. **Direct reference**: Mention the LLMs.txt URLs when asking questions
2. Add these specific URLs to your project context using `@docs`

[Read more about Cursor Web and Docs Search](https://cursor.com/docs/context/symbols)

### Windsurf

Windsurf can directly access the Nuxt LLMs.txt files to understand framework usage and best practices.

#### Using LLMs.txt with Windsurf

- Use `@docs` to reference specific LLMs.txt URLs
- Create persistent rules referencing these URLs in your workspace

[Read more about Windsurf Web and Docs Search](https://docs.windsurf.com/windsurf/cascade/web-search)

### Other AI Tools

Any AI tool that supports LLMs.txt can use these routes to better understand Nuxt.

#### Examples for ChatGPT, Claude, or other LLMs

- "Using Nuxt documentation from https://nuxt.com/llms.txt"
- "Follow complete Nuxt guidelines from https://nuxt.com/llms-full.txt"
</file>

<file path="docs/3.guide/4.modules/.navigation.yml">
title: Module Author Guide
titleTemplate: '%s · Nuxt Modules Author Guide'
icon: i-lucide-box
</file>

<file path="docs/3.guide/4.modules/1.getting-started.md">
---
title: "Create Your First Module"
description: "Learn how to create your first Nuxt module using the official starter template."
---

## Create a Module

We recommend you get started with Nuxt modules using our [starter template](https://github.com/nuxt/starter/tree/module):

::code-group{sync="pm"}

```bash [npm]
npm create nuxt -- -t module my-module
```

```bash [yarn]
yarn create nuxt -t module my-module
```

```bash [pnpm]
pnpm create nuxt -t module my-module
```

```bash [bun]
bun create nuxt --template=module my-module
```
::

This will create a `my-module` project with all the boilerplate necessary to develop and publish your module.

**Next steps:**

1. Open `my-module` in your IDE of choice
2. Install dependencies using your favorite package manager
3. Prepare local files for development using `npm run dev:prepare`
4. Follow this document to learn more about Nuxt modules

## Use the Starter Template

Learn how to perform basic tasks with the module starter.

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/navigating-the-official-starter-template?friend=nuxt" target="_blank"}
Watch Vue School video about Nuxt module starter template.
::

### Develop Your Module

While your module source code lives inside the `src` directory, to develop a module you often need a Nuxt application to test it against. That's what the `playground` directory is for. It's a Nuxt application you can tinker with that is already configured to run with your module.

You can interact with the playground like with any Nuxt application.

- Launch its development server with `npm run dev`, it should reload itself as you make changes to your module in the `src` directory
- Build it with `npm run dev:build`

::note
All other `nuxt` commands can be used against the `playground` directory (e.g. `nuxt <COMMAND> playground`). Feel free to declare additional `dev:*` scripts within your `package.json` referencing them for convenience.
::

### Run Tests

The module starter comes with a basic test suite:

- A linter powered by [ESLint](https://eslint.org), run it with `npm run lint`
- A test runner powered by [Vitest](https://vitest.dev), run it with `npm run test` or `npm run test:watch`

::tip
Feel free to augment this default test strategy to better suit your needs.
::

### Build Your Module

Nuxt modules come with their own builder provided by [`@nuxt/module-builder`](https://github.com/nuxt/module-builder#readme). This builder doesn't require any configuration on your end, supports TypeScript, and makes sure your assets are properly bundled to be distributed to other Nuxt applications.

You can build your module by running `npm run prepack`.

::tip
While building your module can be useful in some cases, most of the time you won't need to build it on your own: the `playground` takes care of it while developing, and the release script also has you covered when publishing.
::

### Publish to npm

::important
Before publishing your module to npm, makes sure you have an [npmjs.com](https://www.npmjs.com) account and that you're authenticated to it locally with `npm login`.
::

While you can publish your module by bumping its version and using the `npm publish` command, the module starter comes with a release script that helps you make sure you publish a working version of your module to npm and more.

To use the release script, first, commit all your changes (we recommend you follow [Conventional Commits](https://www.conventionalcommits.org) to also take advantage of automatic version bump and changelog update), then run the release script with `npm run release`.

When running the release script, the following will happen:

- First, it will run your test suite by:
  - Running the linter (`npm run lint`)
  - Running unit, integration, and e2e tests (`npm run test`)
  - Building the module (`npm run prepack`)
- Then, if your test suite went well, it will proceed to publish your module by:
  - Bumping your module version and generating a changelog according to your Conventional Commits
  - Publishing the module to npm (for that purpose, the module will be built again to ensure its updated version number is taken into account in the published artifact)
  - Pushing a git tag representing the newly published version to your git remote origin

::tip
As with other scripts, feel free to fine-tune the default `release` script in your `package.json` to better suit your needs.
::
</file>

<file path="docs/3.guide/4.modules/2.module-anatomy.md">
---
title: "Understand Module Structure"
description: "Learn how Nuxt modules are structured and how to define them."
---

There are two types of Nuxt modules:

- published modules are distributed on npm - you can see a list of some community modules on [the Nuxt website](/modules).
- "local" modules exist within a Nuxt project, either [inlined in Nuxt config](/docs/4.x/api/nuxt-config#modules) or within [the `modules` directory](/docs/4.x/directory-structure/modules).

In either case, they work in the same way.

## Define Your Module

::note
When using the starter, your module definition is available at `src/module.ts`.
::

The module definition is the entry point of your module. It's what gets loaded by Nuxt when your module is referenced within a Nuxt configuration.

At a low level, a Nuxt module definition is a simple, potentially asynchronous, function accepting inline user options and a `nuxt` object to interact with Nuxt.

```ts
export default function (inlineOptions, nuxt) {
  // You can do whatever you like here..
  console.log(inlineOptions.token) // `123`
  console.log(nuxt.options.dev) // `true` or `false`
  nuxt.hook('ready', (nuxt) => {
    console.log('Nuxt is ready')
  })
}
```

You can get type hinting for this function using the higher-level `defineNuxtModule` helper provided by [Nuxt Kit](/docs/4.x/guide/going-further/kit).

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule((options, nuxt) => {
  nuxt.hook('pages:extend', (pages) => {
    console.log(`Discovered ${pages.length} pages`)
  })
})
```

However, **we do not recommend** using this low-level function definition. Instead, to define a module, **we recommend** using the object-syntax with `meta` property to identify your module, especially when publishing to npm.

This helper makes writing Nuxt modules more straightforward by implementing many common patterns needed by modules, guaranteeing future compatibility and improving the experience for both module authors and users.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    // Usually the npm package name of your module
    name: '@nuxtjs/example',
    // The key in `nuxt.config` that holds your module options
    configKey: 'sample',
    // Compatibility constraints
    compatibility: {
      // Semver version of supported nuxt versions
      nuxt: '>=3.0.0',
    },
  },
  // Default configuration options for your module, can also be a function returning those
  defaults: {},
  // Shorthand sugar to register Nuxt hooks
  hooks: {},
  // Configuration for other modules - this does not ensure the module runs before
  // your module, but it allows you to change the other module's configuration before it runs
  moduleDependencies: {
    'some-module': {
      // You can specify a version constraint for the module. If the user has a different
      // version installed, Nuxt will throw an error on startup.
      version: '>=2',
      // By default moduleDependencies will be added to the list of modules to be installed
      // by Nuxt unless `optional` is set.
      optional: true,
      // Any configuration that should override `nuxt.options`.
      overrides: {},
      // Any configuration that should be set. It will override module defaults but
      // will not override any configuration set in `nuxt.options`.
      defaults: {},
    },
  },
  // The function holding your module logic, it can be asynchronous
  setup (moduleOptions, nuxt) {
    // ...
  },
})
```

`defineNuxtModule` returns a wrapper function with the lower level `(inlineOptions, nuxt)` module signature. This wrapper function applies defaults and other necessary steps before calling your `setup` function:

- Support `defaults` and `meta.configKey` for automatically merging module options
- Type hints and automated type inference
- Ensure module gets installed only once using a unique key computed from `meta.name` or `meta.configKey`
- Automatically register Nuxt hooks
- Automatically check for compatibility issues based on module meta
- Expose `getOptions` and `getMeta` for internal usage of Nuxt
- Ensuring backward and upward compatibility as long as the module is using `defineNuxtModule` from the latest version of `@nuxt/kit`
- Integration with module builder tooling

## Add Runtime Code

::note
When using the starter, the runtime directory is `src/runtime/`.
::

Modules, like everything in a Nuxt configuration, aren't included in your application runtime. However, you might want your module to provide, or inject runtime code to the application it's installed on. That's what the runtime directory enables you to do.

Inside the runtime directory, you can provide any kind of assets related to the Nuxt app:
- Vue components
- Composables
- [Nuxt plugins](/docs/4.x/directory-structure/app/plugins)

To the [server engine](/docs/4.x/guide/concepts/server-engine), Nitro:
- API routes
- Middlewares
- Nitro plugins

Or any other kind of asset you want to inject in users' Nuxt applications:
- Stylesheets
- 3D models
- Images
- etc.

You'll then be able to inject all those assets inside the application from your [module definition](#define-your-module).

::tip
Learn more about asset injection in [the recipes section](/docs/4.x/guide/modules/recipes-basics).
::

::warning
Published modules cannot leverage auto-imports for assets within their runtime directory. Instead, they have to import them explicitly from `#imports` or alike.
:br :br
Auto-imports are not enabled for files within `node_modules` (the location where a published module will eventually live) for performance reasons.
::
</file>

<file path="docs/3.guide/4.modules/3.recipes-basics.md">
---
title: "Add Plugins, Components & More"
description: "Learn how to inject plugins, components, composables and server routes from your module."
---

Here are some common patterns used by module authors.

## Modify Nuxt Configuration

Nuxt configuration can be read and altered by modules. Here's an example of a module enabling an experimental feature.

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // We create the `experimental` object if it doesn't exist yet
    nuxt.options.experimental ||= {}
    nuxt.options.experimental.componentIslands = true
  },
})
```

When you need to handle more complex configuration alterations, you should consider using [defu](https://github.com/unjs/defu).

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/extending-and-altering-nuxt-configuration-and-options?friend=nuxt" target="_blank"}
Watch Vue School video about altering Nuxt configuration.
::

## Expose Options to Runtime

Because modules aren't part of the application runtime, their options aren't either. However, in many cases, you might need access to some of these module options within your runtime code. We recommend exposing the needed config using Nuxt's [`runtimeConfig`](/docs/4.x/api/nuxt-config#runtimeconfig).

<!-- TODO: Update after #18466 (or equivalent) -->

```js
import { defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.options.runtimeConfig.public.myModule = defu(nuxt.options.runtimeConfig.public.myModule, {
      foo: options.foo,
    })
  },
})
```

Note that we use [`defu`](https://github.com/unjs/defu) to extend the public runtime configuration the user provides instead of overwriting it.

You can then access your module options in a plugin, component, the application like any other runtime configuration:

```js
import { useRuntimeConfig } from '@nuxt/kit'

const options = useRuntimeConfig().public.myModule
```

::warning
Be careful not to expose any sensitive module configuration on the public runtime config, such as private API keys, as they will end up in the public bundle.
::

:read-more{to="/docs/4.x/guide/going-further/runtime-config"}

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/passing-and-exposing-module-options?friend=nuxt" target="_blank"}
Watch Vue School video about passing and exposing Nuxt module options.
::

## Add Plugins

Plugins are a common way for a module to add runtime logic. You can use the `addPlugin` utility to register them from your module.

```js
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // Create resolver to resolve relative paths
    const resolver = createResolver(import.meta.url)

    addPlugin(resolver.resolve('./runtime/plugin'))
  },
})
```

:read-more{to="/docs/4.x/guide/going-further/kit"}

## Add Components

If your module should provide Vue components, you can use the `addComponent` utility to add them as auto-imports for Nuxt to resolve.

```ts twoslash
import { addComponent, createResolver, defineNuxtModule, useRuntimeConfig } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // From the runtime directory
    addComponent({
      name: 'MySuperComponent', // name of the component to be used in vue templates
      export: 'MySuperComponent', // (optional) if the component is a named (rather than default) export
      filePath: resolver.resolve('runtime/components/MySuperComponent.vue'),
    })

    // From a library
    addComponent({
      name: 'MyAwesomeComponent', // name of the component to be used in vue templates
      export: 'MyAwesomeComponent', // (optional) if the component is a named (rather than default) export
      filePath: '@vue/awesome-components',
    })
  },
})
```

Alternatively, you can add an entire directory by using `addComponentsDir`.

```ts
import { addComponentsDir, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addComponentsDir({
      path: resolver.resolve('runtime/components'),
    })
  },
})
```

::tip{icon="i-lucide-lightbulb"}
It is highly recommended to prefix your exports to avoid conflicts with user code or other modules.

:read-more{to="/docs/4.x/guide/modules/best-practices#prefix-your-exports"}
::

## Add Composables

If your module should provide composables, you can use the `addImports` utility to add them as auto-imports for Nuxt to resolve.

```ts
import { addImports, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImports({
      name: 'useComposable', // name of the composable to be used
      as: 'useMyComposable', // optional alias that will be available for the consuming apps
      from: resolver.resolve('runtime/composables/useComposable'), // path of composable
    })
  },
})
```

Multiple entries can be passed as an array:

```ts
import { addImports, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImports([
      { name: 'useFirstComposable', from: resolver.resolve('runtime/composables/useFirstComposable') },
      { name: 'useSecondComposable', from: resolver.resolve('runtime/composables/useSecondComposable') },
    ])
  },
})
```

Alternatively, you can add an entire directory by using `addImportsDir`.

```ts
import { addImportsDir, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImportsDir(resolver.resolve('runtime/composables'))
  },
})
```

::tip{icon="i-lucide-lightbulb"}
It is highly recommended to prefix your exports to avoid conflicts with user code or other modules.

:read-more{to="/docs/4.x/guide/modules/best-practices#prefix-your-exports"}
::

## Add Server Routes

```ts
import { addServerHandler, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/_my-module/hello',
      handler: resolver.resolve('./runtime/server/api/hello/index.get'),
    })
  },
})
```

You can also add a dynamic server route:

```ts
import { addServerHandler, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/_my-module/hello/:name',
      handler: resolver.resolve('./runtime/server/api/hello/[name].get'),
    })
  },
})
```

::tip{icon="i-lucide-lightbulb"}
It is highly recommended to prefix your server routes to avoid conflicts with user-defined routes. Common paths like `/api/auth`, `/api/login`, or `/api/user` may already be used by the application.

:read-more{to="/docs/4.x/guide/modules/best-practices#prefix-your-exports"}
::

## Add Other Assets

If your module should provide other kinds of assets, they can also be injected. Here's a simple example module injecting a stylesheet through Nuxt's `css` array.

```js
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.options.css.push(resolver.resolve('./runtime/style.css'))
  },
})
```

And a more advanced one, exposing a folder of assets through [Nitro](/docs/4.x/guide/concepts/server-engine)'s `publicAssets` option:

```js
import { createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('nitro:config', (nitroConfig) => {
      nitroConfig.publicAssets ||= []
      nitroConfig.publicAssets.push({
        dir: resolver.resolve('./runtime/public'),
        maxAge: 60 * 60 * 24 * 365, // 1 year
      })
    })
  },
})
```

## Use Other Modules

If your module depends on other modules, you can specify them using the `moduleDependencies` option. This provides a more robust way to handle module dependencies with version constraints and configuration merging:

```ts
import { createResolver, defineNuxtModule } from '@nuxt/kit'

const resolver = createResolver(import.meta.url)

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'my-module',
  },
  moduleDependencies: {
    '@nuxtjs/tailwindcss': {
      // You can specify a version constraint for the module
      version: '>=6',
      // Any configuration that should override `nuxt.options`
      overrides: {
        exposeConfig: true,
      },
      // Any configuration that should be set. It will override module defaults but
      // will not override any configuration set in `nuxt.options`
      defaults: {
        config: {
          darkMode: 'class',
          content: {
            files: [
              resolver.resolve('./runtime/components/**/*.{vue,mjs,ts}'),
              resolver.resolve('./runtime/*.{mjs,js,ts}'),
            ],
          },
        },
      },
    },
  },
  setup (options, nuxt) {
    // We can inject our CSS file which includes Tailwind's directives
    nuxt.options.css.push(resolver.resolve('./runtime/assets/styles.css'))
  },
})
```

::callout{type="info"}
The `moduleDependencies` option replaces the deprecated `installModule` function and ensures proper setup order and configuration merging.
::
</file>

<file path="docs/3.guide/4.modules/4.recipes-advanced.md">
---
title: "Use Hooks & Extend Types"
description: "Master lifecycle hooks, virtual files and TypeScript declarations in your modules."
---

Here are some advanced patterns for authoring modules, including hooks, templates, and type augmentation.

## Use Lifecycle Hooks

[Lifecycle hooks](/docs/4.x/guide/going-further/hooks) allow you to expand almost every aspect of Nuxt. Modules can hook to them programmatically or through the `hooks` map in their definition.

```js
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  // Hook to the `app:error` hook through the `hooks` map
  hooks: {
    'app:error': (err) => {
      console.info(`This error happened: ${err}`)
    },
  },
  setup (options, nuxt) {
    // Programmatically hook to the `pages:extend` hook
    nuxt.hook('pages:extend', (pages) => {
      console.info(`Discovered ${pages.length} pages`)
    })
  },
})
```

:read-more{to="/docs/4.x/api/advanced/hooks"}

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/nuxt-lifecycle-hooks?friend=nuxt" target="_blank"}
Watch Vue School video about using Nuxt lifecycle hooks in modules.
::

::note
**Module cleanup**
:br
:br
If your module opens, handles, or starts a watcher, you should close it when the Nuxt lifecycle is done. The `close` hook is available for this.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.hook('close', async (nuxt) => {
      // Your custom code here
    })
  },
})
```
::

### Create Custom Hooks

Modules can also define and call their own hooks, which is a powerful pattern for making your module extensible.

If you expect other modules to be able to subscribe to your module's hooks, you should call them in the `modules:done` hook. This ensures that all other modules have had a chance to be set up and register their listeners to your hook during their own `setup` function.

```ts
// my-module/module.ts
import { defineNuxtModule } from '@nuxt/kit'

export interface ModuleHooks {
  'my-module:custom-hook': (payload: { foo: string }) => void
}

export default defineNuxtModule({
  setup (options, nuxt) {
    // Call your hook in `modules:done`
    nuxt.hook('modules:done', async () => {
      const payload = { foo: 'bar' }
      await nuxt.callHook('my-module:custom-hook', payload)
    })
  },
})
```

## Add Virtual Files

If you need to add a virtual file that can be imported into the user's app, you can use the `addTemplate` utility.

```ts
import { addTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // The file is added to Nuxt's internal virtual file system and can be imported from '#build/my-module-feature.mjs'
    addTemplate({
      filename: 'my-module-feature.mjs',
      getContents: () => 'export const myModuleFeature = () => "hello world !"',
    })
  },
})
```

For the server, you should use the `addServerTemplate` utility instead.

```ts
import { addServerTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // The file is added to Nitro's virtual file system and can be imported in the server code from 'my-server-module.mjs'
    addServerTemplate({
      filename: 'my-server-module.mjs',
      getContents: () => 'export const myServerModule = () => "hello world !"',
    })
  },
})
```

## Update Virtual Files

If you need to update your templates/virtual files, you can leverage the `updateTemplates` utility like this:

```ts
nuxt.hook('builder:watch', (event, path) => {
  if (path.includes('my-module-feature.config')) {
    // This will reload the template that you registered
    updateTemplates({ filter: t => t.filename === 'my-module-feature.mjs' })
  }
})
```

## Add Type Declarations

You might also want to add a type declaration to the user's project (for example, to augment a Nuxt interface
or provide a global type of your own). For this, Nuxt provides the `addTypeTemplate` utility that both
writes a template to the disk and adds a reference to it in the generated `nuxt.d.ts` file.

If your module should augment types handled by Nuxt, you can use `addTypeTemplate` to perform this operation:

```js
import { addTemplate, addTypeTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    addTypeTemplate({
      filename: 'types/my-module.d.ts',
      getContents: () => `// Generated by my-module
        interface MyModuleNitroRules {
          myModule?: { foo: 'bar' }
        }
        declare module 'nitropack/types' {
          interface NitroRouteRules extends MyModuleNitroRules {}
          interface NitroRouteConfig extends MyModuleNitroRules {}
        }
        export {}`,
    })
  },
})
```

If you need more granular control, you can use the `prepare:types` hook to register a callback that will inject your types.

```ts
const template = addTemplate({ /* template options */ })
nuxt.hook('prepare:types', ({ references }) => {
  references.push({ path: template.dst })
})
```

## Extend TypeScript Config

There are multiple ways to extend the TypeScript configuration of the user's project from your module.

The simplest way is to modify the Nuxt configuration directly like this:

<!-- @case-police-ignore tsConfig -->
```ts
// extend tsconfig.app.json
nuxt.options.typescript.tsConfig.include ??= []
nuxt.options.typescript.tsConfig.include.push(resolve('./augments.d.ts'))

// extend tsconfig.shared.json
nuxt.options.typescript.sharedTsConfig.include ??= []
nuxt.options.typescript.sharedTsConfig.include.push(resolve('./augments.d.ts'))

// extend tsconfig.node.json
nuxt.options.typescript.nodeTsConfig.include ??= []
nuxt.options.typescript.nodeTsConfig.include.push(resolve('./augments.d.ts'))

// extend tsconfig.server.json
nuxt.options.nitro.typescript ??= {}
nuxt.options.nitro.typescript.tsConfig ??= {}
nuxt.options.nitro.typescript.tsConfig.include ??= []
nuxt.options.nitro.typescript.tsConfig.include.push(resolve('./augments.d.ts'))
```

Alternatively, you can use the `prepare:types` and `nitro:prepare:types` hooks to extend the TypeScript references for specific type contexts, or modify the TypeScript configuration similar to the example above.

```ts
nuxt.hook('prepare:types', ({ references, sharedReferences, nodeReferences }) => {
  // extend app context
  references.push({ path: resolve('./augments.d.ts') })
  // extend shared context
  sharedReferences.push({ path: resolve('./augments.d.ts') })
  // extend node context
  nodeReferences.push({ path: resolve('./augments.d.ts') })
})

nuxt.hook('nitro:prepare:types', ({ references }) => {
  // extend server context
  references.push({ path: resolve('./augments.d.ts') })
})
```

::note
TypeScript references add files to the type context [without being affected by the `exclude` option in `tsconfig.json`](https://www.typescriptlang.org/tsconfig/#exclude).
::

## Augment Types

Nuxt automatically includes your module's directories in the appropriate type contexts. To augment types from your module, all you need to do is place the type declaration file in the appropriate directory based on the augmented type context. Alternatively, you can [extend the TypeScript configuration](#extend-typescript-config) to augment from an arbitrary location.

- `my-module/runtime/` - app type context (except for the `runtime/server` directory)
- `my-module/runtime/server/` - server type context
- `my-module/` - node type context (except for the `runtime/` and `runtime/server` directories)

```bash [Directory Structure]
-| my-module/   # node type context
---| runtime/   # app type context
------| augments.app.d.ts
------| server/ # server type context
---------| augments.server.d.ts
---| module.ts
---| augments.node.d.ts
```
</file>

<file path="docs/3.guide/4.modules/5.testing.md">
---
title: "Test Your Module"
description: "Learn how to test your Nuxt module with unit, integration and E2E tests."
---

Testing helps ensure your module works as expected given various setups. Find in this section how to perform various kinds of tests against your module.

## Write Unit Tests

::tip
We're still discussing and exploring how to ease unit and integration testing on Nuxt modules.
:br :br
[Check out this RFC to join the conversation](https://github.com/nuxt/nuxt/discussions/18399).
::

## Write E2E Tests

[Nuxt Test Utils](/docs/4.x/getting-started/testing) is the go-to library to help you test your module in an end-to-end way. Here's the workflow to adopt with it:

1. Create a Nuxt application to be used as a "fixture" inside `test/fixtures/*`
2. Setup Nuxt with this fixture inside your test file
3. Interact with the fixture using utilities from `@nuxt/test-utils` (e.g. fetching a page)
4. Perform checks related to this fixture (e.g. "HTML contains ...")
5. Repeat

In practice, the fixture:

```ts [test/fixtures/ssr/nuxt.config.ts]
// 1. Create a Nuxt application to be used as a "fixture"
import MyModule from '../../../src/module'

export default defineNuxtConfig({
  ssr: true,
  modules: [
    MyModule,
  ],
})
```

And its test:

```ts [test/rendering.ts]
import { describe, expect, it } from 'vitest'
import { fileURLToPath } from 'node:url'
import { $fetch, setup } from '@nuxt/test-utils/e2e'

describe('ssr', async () => {
  // 2. Setup Nuxt with this fixture inside your test file
  await setup({
    rootDir: fileURLToPath(new URL('./fixtures/ssr', import.meta.url)),
  })

  it('renders the index page', async () => {
    // 3. Interact with the fixture using utilities from `@nuxt/test-utils`
    const html = await $fetch('/')

    // 4. Perform checks related to this fixture
    expect(html).toContain('<div>ssr</div>')
  })
})

// 5. Repeat
describe('csr', async () => { /* ... */ })
```

::tip
An example of such a workflow is available on [the module starter](https://github.com/nuxt/starter/blob/module/test/basic.test.ts).
::

## Test Manually

Having a playground Nuxt application to test your module when developing it is really useful. [The module starter integrates one for that purpose](/docs/4.x/guide/modules/getting-started#develop-your-module).

You can test your module with other Nuxt applications (applications that are not part of your module repository) locally. To do so, you can use [`npm pack`](https://docs.npmjs.com/cli/commands/npm-pack/) command, or your package manager equivalent, to create a tarball from your module. Then in your test project, you can add your module to `package.json` packages as: `"my-module": "file:/path/to/tarball.tgz"`.

After that, you should be able to reference `my-module` like in any regular project.
</file>

<file path="docs/3.guide/4.modules/6.best-practices.md">
---
title: "Follow Best Practices"
description: "Build performant and maintainable Nuxt modules with these guidelines."
---

With great power comes great responsibility. While modules are powerful, here are some best practices to keep in mind while authoring modules to keep applications performant and developer experience great.

## Handle Async Setup

As we've seen, Nuxt modules can be asynchronous. For example, you may want to develop a module that needs fetching some API or calling an async function.

However, be careful with asynchronous behaviors as Nuxt will wait for your module to setup before going to the next module and starting the development server, build process, etc. Prefer deferring time-consuming logic to Nuxt hooks.

::warning
If your module takes more than **1 second** to setup, Nuxt will emit a warning about it.
::

## Prefix Your Exports

Nuxt modules should provide an explicit prefix for any exposed configuration, plugin, API, composable, component, or server route to avoid conflicts with other modules, Nuxt internals, or user-defined code.

Ideally, prefix them with your module's name. For example, if your module is called `nuxt-foo`:

| Type | ❌ Avoid | ✅ Prefer |
| --- | --- | --- |
| Components | `<Button>`, `<Modal>` | `<FooButton>`, `<FooModal>` |
| Composables | `useData()`, `useModal()` | `useFooData()`, `useFooModal()` |
| Server routes | `/api/track`, `/api/data` | `/api/_foo/track`, `/api/_foo/data` |

### Server Routes

This is particularly important for server routes, where common paths like `/api/auth`, `/api/login`, or `/api/user` are very likely already used by the application.

Use a unique prefix based on your module name:
- `/api/_foo/...` (using underscore prefix)
- `/_foo/...` (for non-API routes)

## Use Lifecycle Hooks

When your module needs to perform one-time setup tasks (like generating configuration files, setting up databases, or installing dependencies), use lifecycle hooks instead of running the logic in your main `setup` function.

```ts
import { addServerHandler, defineNuxtModule } from 'nuxt/kit'
import semver from 'semver'

export default defineNuxtModule({
  meta: {
    name: 'my-database-module',
    version: '1.0.0',
  },
  async onInstall (nuxt) {
    // One-time setup: create database schema, generate config files, etc.
    await generateDatabaseConfig(nuxt.options.rootDir)
  },
  async onUpgrade (nuxt, options, previousVersion) {
    // Handle version-specific migrations
    if (semver.lt(previousVersion, '1.0.0')) {
      await migrateLegacyData()
    }
  },
  setup (options, nuxt) {
    // Regular setup logic that runs on every build
    addServerHandler({ /* ... */ })
  },
})
```

This pattern prevents unnecessary work on every build and provides a better developer experience. See the [lifecycle hooks documentation](/docs/4.x/api/kit/modules#using-lifecycle-hooks-for-module-installation-and-upgrade) for more details.

## Be TypeScript Friendly

Nuxt has first-class TypeScript integration for the best developer experience.

Exposing types and using TypeScript to develop modules benefits users even when not using TypeScript directly.

## Use ESM Syntax

Nuxt relies on native ESM. Please read [Native ES Modules](/docs/4.x/guide/concepts/esm) for more information.

## Document Your Module

Consider documenting module usage in the readme file:

- Why use this module?
- How to use this module?
- What does this module do?

Linking to the integration website and documentation is always a good idea.

## Provide a Demo

It's a good practice to make a minimal reproduction with your module and [StackBlitz](https://nuxt.new/s/v4) that you add to your module readme.

This not only provides potential users of your module a quick and easy way to experiment with the module but also an easy way for them to build minimal reproductions they can send you when they encounter issues.

## Stay Version Agnostic

Nuxt, Nuxt Kit, and other new toolings are made to have both forward and backward compatibility in mind.

Please use "X for Nuxt" instead of "X for Nuxt 3" to avoid fragmentation in the ecosystem and prefer using `meta.compatibility` to set Nuxt version constraints.

## Follow Starter Conventions

The module starter comes with a default set of tools and configurations (e.g. ESLint configuration). If you plan on open-sourcing your module, sticking with those defaults ensures your module shares a consistent coding style with other [community modules](/modules) out there, making it easier for others to contribute.
</file>

<file path="docs/3.guide/4.modules/7.ecosystem.md">
---
title: "Publish & Share Your Module"
description: "Join the Nuxt module ecosystem and publish your module to npm."
---

The [Nuxt module ecosystem](/modules) represents more than 35 million monthly NPM downloads and provides extended functionalities and integrations with all sort of tools. You can be part of this ecosystem!

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/exploring-nuxt-modules-ecosystem-and-module-types?friend=nuxt" target="_blank"}
Watch Vue School video about Nuxt module types.
::

## Understand Module Types

**Official modules** are modules prefixed (scoped) with `@nuxt/` (e.g. [`@nuxt/content`](https://content.nuxt.com)). They are made and maintained actively by the Nuxt team. Like with the framework, contributions from the community are more than welcome to help make them better!

**Community modules** are modules prefixed (scoped) with `@nuxtjs/` (e.g. [`@nuxtjs/tailwindcss`](https://tailwindcss.nuxtjs.org)). They are proven modules made and maintained by community members. Again, contributions are welcome from anyone.

**Third-party and other community modules** are modules (often) prefixed with `nuxt-`. Anyone can make them, using this prefix allows these modules to be discoverable on npm. This is the best starting point to draft and try an idea!

**Private or personal modules** are modules made for your own use case or company. They don't need to follow any naming rules to work with Nuxt and are often seen scoped under an npm organization (e.g. `@my-company/nuxt-auth`)

## List Your Module

Any community modules are welcome to be listed on [the module list](/modules). To be listed, [open an issue in the nuxt/modules](https://github.com/nuxt/modules/issues/new?template=module_request.yml) repository. The Nuxt team can help you to apply best practices before listing.

## Join nuxt-modules

By moving your modules to [nuxt-modules](https://github.com/nuxt-modules), there is always someone else to help, and this way, we can join forces to make one perfect solution.

If you have an already published and working module, and want to transfer it to `nuxt-modules`, [open an issue in nuxt/modules](https://github.com/nuxt/modules/issues/new).

By joining `nuxt-modules` we can rename your community module under the `@nuxtjs/` scope and provide a subdomain (e.g. `my-module.nuxtjs.org`) for its documentation.
</file>

<file path="docs/3.guide/4.modules/index.md">
---
title: 'Module Author Guide'
titleTemplate: '%s'
description: 'Learn how to create a Nuxt module to integrate, enhance or extend any Nuxt applications.'
navigation: false
surround: false
---

Nuxt's [configuration](/docs/4.x/api/nuxt-config) and [hooks](/docs/4.x/guide/going-further/hooks) systems make it possible to customize every aspect of Nuxt and add any integration you might need (Vue plugins, CMS, server routes, components, logging, etc.).

**Nuxt modules** are functions that sequentially run when starting Nuxt in development mode using `nuxt dev` or building a project for production with `nuxt build`.
With modules, you can encapsulate, properly test, and share custom solutions as npm packages without adding unnecessary boilerplate to your project, or requiring changes to Nuxt itself.

::card-group{class="sm:grid-cols-1"}
  ::card{icon="i-lucide-rocket" title="Create Your First Module" to="/docs/4.x/guide/modules/getting-started"}
  Learn how to create your first Nuxt module using the official starter template.
  ::
  ::card{icon="i-lucide-box" title="Understand Module Structure" to="/docs/4.x/guide/modules/module-anatomy"}
  Learn how Nuxt modules are structured and how to define them.
  ::
  ::card{icon="i-lucide-code" title="Add Plugins, Components & More" to="/docs/4.x/guide/modules/recipes-basics"}
  Learn how to inject plugins, components, composables and server routes from your module.
  ::
  ::card{icon="i-lucide-layers" title="Use Hooks & Extend Types" to="/docs/4.x/guide/modules/recipes-advanced"}
  Master lifecycle hooks, virtual files and TypeScript declarations in your modules.
  ::
  ::card{icon="i-lucide-test-tube" title="Test Your Module" to="/docs/4.x/guide/modules/testing"}
  Learn how to test your Nuxt module with unit, integration and E2E tests.
  ::
  ::card{icon="i-lucide-medal" title="Follow Best Practices" to="/docs/4.x/guide/modules/best-practices"}
  Build performant and maintainable Nuxt modules with these guidelines.
  ::
  ::card{icon="i-lucide-globe" title="Publish & Share Your Module" to="/docs/4.x/guide/modules/ecosystem"}
  Join the Nuxt module ecosystem and publish your module to npm.
  ::
::
</file>

<file path="docs/3.guide/5.recipes/.navigation.yml">
title: Recipes
titleTemplate: '%s · Recipes'
icon: i-lucide-cooking-pot
</file>

<file path="docs/3.guide/5.recipes/1.custom-routing.md">
---
title: "Custom Routing"
description: "In Nuxt, your routing is defined by the structure of your files inside the pages directory. However, since it uses vue-router under the hood, Nuxt offers you several ways to add custom routes in your project."
---

## Adding custom routes

In Nuxt, your routing is defined by the structure of your files inside the [app/pages directory](/docs/4.x/directory-structure/app/pages). However, since it uses [vue-router](https://router.vuejs.org) under the hood, Nuxt offers you several ways to add custom routes in your project.

### Router Config

Using [router options](/docs/4.x/guide/recipes/custom-routing#router-options), you can optionally override or extend your routes using a function that accepts the scanned routes and returns customized routes.

If it returns `null` or `undefined`, Nuxt will fall back to the default routes (useful to modify input array).

```ts [router.options.ts]
import type { RouterConfig } from '@nuxt/schema'

export default {
  // https://router.vuejs.org/api/interfaces/routeroptions#routes
  routes: _routes => [
    {
      name: 'home',
      path: '/',
      component: () => import('~/pages/home.vue'),
    },
  ],
} satisfies RouterConfig
```

::note
Nuxt will not augment any new routes you return from the `routes` function with metadata defined in `definePageMeta` of the component you provide. If you want that to happen, you should use the `pages:extend` hook which is [called at build-time](/docs/4.x/api/advanced/hooks#nuxt-hooks-build-time).
::

### Pages Hook

You can add, change or remove pages from the scanned routes with the `pages:extend` nuxt hook.

For example, to prevent creating routes for any `.ts` files:

```ts [nuxt.config.ts]
import type { NuxtPage } from '@nuxt/schema'

export default defineNuxtConfig({
  hooks: {
    'pages:extend' (pages) {
      // add a route
      pages.push({
        name: 'profile',
        path: '/profile',
        file: '~/extra-pages/profile.vue',
      })

      // remove routes
      function removePagesMatching (pattern: RegExp, pages: NuxtPage[] = []) {
        const pagesToRemove: NuxtPage[] = []
        for (const page of pages) {
          if (page.file && pattern.test(page.file)) {
            pagesToRemove.push(page)
          } else {
            removePagesMatching(pattern, page.children)
          }
        }
        for (const page of pagesToRemove) {
          pages.splice(pages.indexOf(page), 1)
        }
      }
      removePagesMatching(/\.ts$/, pages)
    },
  },
})
```

### Nuxt Module

If you plan to add a whole set of pages related with a specific functionality, you might want to use a [Nuxt module](/modules).

The [Nuxt kit](/docs/4.x/guide/going-further/kit) provides a few ways [to add routes](/docs/4.x/api/kit/pages):
- [`extendPages`](/docs/4.x/api/kit/pages#extendpages) (callback: pages => void)
- [`extendRouteRules`](/docs/4.x/api/kit/pages#extendrouterules) (route: string, rule: NitroRouteConfig, options: ExtendRouteRulesOptions)

## Router Options

On top of customizing options for [`vue-router`](https://router.vuejs.org/api/interfaces/routeroptions), Nuxt offers [additional options](/docs/4.x/api/nuxt-config#router) to customize the router.

### Using `router.options`

This is the recommended way to specify [router options](/docs/4.x/api/nuxt-config#router).

```ts [app/router.options.ts]
import type { RouterConfig } from '@nuxt/schema'

export default {
} satisfies RouterConfig
```

It is possible to add more router options files by adding files within the `pages:routerOptions` hook. Later items in the array override earlier ones.

::callout
Adding a router options file in this hook will switch on page-based routing, unless `optional` is set, in which case it will only apply when page-based routing is already enabled.
::

```ts [nuxt.config.ts]
import { createResolver } from '@nuxt/kit'

export default defineNuxtConfig({
  hooks: {
    'pages:routerOptions' ({ files }) {
      const resolver = createResolver(import.meta.url)
      // add a route
      files.push({
        path: resolver.resolve('./runtime/router-options'),
        optional: true,
      })
    },
  },
})
```

### Using `nuxt.config`

**Note:** Only JSON serializable [options](/docs/4.x/api/nuxt-config#router) are configurable:

- `linkActiveClass`
- `linkExactActiveClass`
- `end`
- `sensitive`
- `strict`
- `hashMode`
- `scrollBehaviorType`

```ts [nuxt.config]
export default defineNuxtConfig({
  router: {
    options: {},
  },
})
```

### Hash Mode (SPA)

You can enable hash history in SPA mode using the `hashMode` [config](/docs/4.x/api/nuxt-config#router). In this mode, router uses a hash character (#) before the actual URL that is internally passed. When enabled, the **URL is never sent to the server** and **SSR is not supported**.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false,
  router: {
    options: {
      hashMode: true,
    },
  },
})
```

### Scroll Behavior for hash links

You can optionally customize the scroll behavior for hash links. When you set the [config](/docs/4.x/api/nuxt-config#router) to be `smooth` and you load a page with a hash link (e.g. `https://example.com/blog/my-article#comments`), you will see that the browser smoothly scrolls to this anchor.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  router: {
    options: {
      scrollBehaviorType: 'smooth',
    },
  },
})
```

#### Custom History (advanced)

You can optionally override history mode using a function that accepts the base URL and returns the history mode. If it returns `null` or `undefined`, Nuxt will fallback to the default history.

```ts [router.options.ts]
import type { RouterConfig } from '@nuxt/schema'
import { createMemoryHistory } from 'vue-router'

export default {
  // https://router.vuejs.org/api/interfaces/routeroptions
  history: base => import.meta.client ? createMemoryHistory(base) : null, /* default */
} satisfies RouterConfig
```
</file>

<file path="docs/3.guide/5.recipes/2.vite-plugin.md">
---
navigation.title: 'Vite Plugins'
title: Using Vite Plugins in Nuxt
description: Learn how to integrate Vite plugins into your Nuxt project.
---

While Nuxt modules offer extensive functionality, sometimes a specific Vite plugin might meet your needs more directly.

First, we need to install the Vite plugin, for our example, we'll use `@rollup/plugin-yaml`:

::code-group{sync="pm"}

  ```bash [npm]
  npm install @rollup/plugin-yaml
  ```

  ```bash [yarn]
  yarn add @rollup/plugin-yaml
  ```

  ```bash [pnpm]
  pnpm add @rollup/plugin-yaml
  ```

  ```bash [bun]
  bun add @rollup/plugin-yaml
  ```

::

Next, we need to import and add it to our [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) file:

```ts [nuxt.config.ts]
import yaml from '@rollup/plugin-yaml'

export default defineNuxtConfig({
  vite: {
    plugins: [
      yaml(),
    ],
  },
})
```

Now we installed and configured our Vite plugin, we can start using YAML files directly in our project.

For example, we can have a `config.yaml` that stores configuration data and import this data in our Nuxt components:

::code-group

```yaml [data/hello.yaml]
greeting: "Hello, Nuxt with Vite!"
```

```vue [app/components/Hello.vue]
<script setup>
import config from '~/data/hello.yaml'
</script>

<template>
  <h1>{{ config.greeting }}</h1>
</template>
```

::

## Using Vite Plugins in Nuxt Modules

If you're developing a Nuxt module and need to add Vite plugins, you should use the [`addVitePlugin`](/docs/4.x/api/kit/builder#addviteplugin) utility:

```ts [modules/my-module.ts]
import { addVitePlugin, defineNuxtModule } from '@nuxt/kit'
import yaml from '@rollup/plugin-yaml'

export default defineNuxtModule({
  setup () {
    addVitePlugin(yaml())
  },
})
```

For environment-specific plugins in Nuxt 5+, use the `applyToEnvironment()` method:

```ts [modules/my-module.ts]
import { addVitePlugin, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addVitePlugin(() => ({
      name: 'my-client-plugin',
      applyToEnvironment (environment) {
        return environment.name === 'client'
      },
      // Plugin configuration
    }))
  },
})
```

::important
If you're writing code that needs to access resolved Vite configuration, you should use the `config` and `configResolved` hooks _within_ your Vite plugin, rather than using Nuxt's `vite:extend`, `vite:extendConfig` and `vite:configResolved`.
::

::read-more{to="/docs/4.x/api/kit/builder#addviteplugin"}
Read more about `addVitePlugin` in the Nuxt Kit documentation.
::
</file>

<file path="docs/3.guide/5.recipes/3.custom-usefetch.md">
---
navigation.title: 'Custom useFetch'
title: Custom useFetch in Nuxt
description: How to create a custom fetcher for calling your external API in Nuxt.
---

When working with Nuxt, you might be making the frontend and fetching an external API, and you might want to set some default options for fetching from your API.

The [`$fetch`](/docs/4.x/api/utils/dollarfetch) utility function (used by the [`useFetch`](/docs/4.x/api/composables/use-fetch) composable) is intentionally not globally configurable. This is important so that fetching behavior throughout your application remains consistent, and other integrations (like modules) can rely on the behavior of core utilities like `$fetch`.

However, Nuxt provides a way to create a custom fetcher for your API (or multiple fetchers if you have multiple APIs to call).

## Custom `$fetch`

Let's create a custom `$fetch` instance with a [Nuxt plugin](/docs/4.x/directory-structure/app/plugins).

::note
`$fetch` is a configured instance of [ofetch](https://github.com/unjs/ofetch) which supports adding the base URL of your Nuxt server as well as direct function calls during SSR (avoiding HTTP roundtrips).
::

Let's pretend here that:
- The main API is https://api.nuxt.com
- We are storing the JWT token in a session with [nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils)
- If the API responds with a `401` status code, we redirect the user to the `/login` page

```ts [app/plugins/api.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const { session } = useUserSession()

  const api = $fetch.create({
    baseURL: 'https://api.nuxt.com',
    onRequest ({ request, options, error }) {
      if (session.value?.token) {
        // note that this relies on ofetch >= 1.4.0 - you may need to refresh your lockfile
        options.headers.set('Authorization', `Bearer ${session.value?.token}`)
      }
    },
    async onResponseError ({ response }) {
      if (response.status === 401) {
        await nuxtApp.runWithContext(() => navigateTo('/login'))
      }
    },
  })

  // Expose to useNuxtApp().$api
  return {
    provide: {
      api,
    },
  }
})
```

With this Nuxt plugin, `$api` is exposed from `useNuxtApp()` to make API calls directly from the Vue components:

```vue [app/app.vue]
<script setup>
const { $api } = useNuxtApp()
const { data: modules } = await useAsyncData('modules', () => $api('/modules'))
</script>
```

::callout
Wrapping with [`useAsyncData`](/docs/4.x/api/composables/use-async-data) **avoid double data fetching when doing server-side rendering** (server & client on hydration).
::

## Custom `useFetch`/`useAsyncData`

Now that `$api` has the logic we want, let's create a `useAPI` composable to replace the usage of `useAsyncData` + `$api`:

```ts [app/composables/useAPI.ts]
import type { UseFetchOptions } from 'nuxt/app'

export function useAPI<T> (
  url: string | (() => string),
  options?: UseFetchOptions<T>,
) {
  return useFetch(url, {
    ...options,
    $fetch: useNuxtApp().$api as typeof $fetch,
  })
}
```

Let's use the new composable and have a nice and clean component:

```vue [app/app.vue]
<script setup>
const { data: modules } = await useAPI('/modules')
</script>
```

If you want to customize the type of any error returned, you can also do so:

```ts
import type { FetchError } from 'ofetch'
import type { UseFetchOptions } from 'nuxt/app'

interface CustomError {
  message: string
  status: number
}

export function useAPI<T> (
  url: string | (() => string),
  options?: UseFetchOptions<T>,
) {
  return useFetch<T, FetchError<CustomError>>(url, {
    ...options,
    $fetch: useNuxtApp().$api,
  })
}
```

::note
This example demonstrates how to use a custom `useFetch`, but the same structure is identical for a custom `useAsyncData`.
::

:link-example{to="/docs/4.x/examples/advanced/use-custom-fetch-composable"}

:video-accordion{title="Watch a video about custom $fetch and Repository Pattern in Nuxt" videoId="jXH8Tr-exhI"}

::note
We are currently discussing to find a cleaner way to let you create a custom fetcher, see https://github.com/nuxt/nuxt/issues/14736.
::
</file>

<file path="docs/3.guide/5.recipes/4.sessions-and-authentication.md">
---
title: 'Sessions and Authentication'
description: "Authentication is an extremely common requirement in web apps. This recipe will show you how to implement basic user registration and authentication in your Nuxt app."
---

## Introduction

In this recipe we'll be setting up authentication in a full-stack Nuxt app using [Nuxt Auth Utils](https://github.com/Atinux/nuxt-auth-utils) which provides convenient utilities for managing client-side and server-side session data.

The module uses secured & sealed cookies to store session data, so you don't need to setup a database to store session data.

## Install nuxt-auth-utils

Install the `nuxt-auth-utils` module using the `nuxt` CLI.

```bash [Terminal]
npx nuxt module add auth-utils
```

::callout
This command will install `nuxt-auth-utils` as dependency and push it in the `modules` section of our `nuxt.config.ts`
::

## Cookie Encryption Key

As `nuxt-auth-utils` uses sealed cookies to store session data, session cookies are encrypted using a secret key from the `NUXT_SESSION_PASSWORD` environment variable.

::note
If not set, this environment variable will be added to your `.env` automatically when running in development mode.
::

```ini [.env]
NUXT_SESSION_PASSWORD=a-random-password-with-at-least-32-characters
```

::important
You'll need to add this environment variable to your production environment before deploying.
::

## Login API Route

For this recipe, we'll create a simple API route to sign-in a user based on static data.

Let's create a `/api/login` API route that will accept a POST request with the email and password in the request body.

```ts [server/api/login.post.ts]
import { z } from 'zod'

const bodySchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
})

export default defineEventHandler(async (event) => {
  const { email, password } = await readValidatedBody(event, bodySchema.parse)

  if (email === 'admin@admin.com' && password === 'iamtheadmin') {
    // set the user session in the cookie
    // this server util is auto-imported by the auth-utils module
    await setUserSession(event, {
      user: {
        name: 'John Doe',
      },
    })
    return {}
  }
  throw createError({
    status: 401,
    message: 'Bad credentials',
  })
})
```

::callout
Make sure to install the `zod` dependency in your project (`npm i zod`).
::

::tip{to="https://github.com/atinux/nuxt-auth-utils#server-utils"}
Read more about the `setUserSession` server helper exposed by `nuxt-auth-utils`.
::

## Login Page

The module exposes a Vue composable to know if a user is authenticated in our application:

```vue
<script setup>
const { loggedIn, session, user, clear, fetch } = useUserSession()
</script>
```

Let's create a login page with a form to submit the login data to our `/api/login` route.

```vue [app/pages/login.vue]
<script setup lang="ts">
const { loggedIn, user, fetch: refreshSession } = useUserSession()
const credentials = reactive({
  email: '',
  password: '',
})
async function login () {
  try {
    await $fetch('/api/login', {
      method: 'POST',
      body: credentials,
    })

    // Refresh the session on client-side and redirect to the home page
    await refreshSession()
    await navigateTo('/')
  } catch {
    alert('Bad credentials')
  }
}
</script>

<template>
  <form @submit.prevent="login">
    <input
      v-model="credentials.email"
      type="email"
      placeholder="Email"
    >
    <input
      v-model="credentials.password"
      type="password"
      placeholder="Password"
    >
    <button type="submit">
      Login
    </button>
  </form>
</template>
```

## Protect API Routes

Protecting server routes is key to making sure your data is safe. Client-side middleware is helpful for the user, but without server-side protection your data can still be accessed. It is critical to protect any routes with sensitive data, we should return a 401 error if the user is not logged in on those.

The `auth-utils` module provides the `requireUserSession` utility function to help make sure that users are logged in and have an active session.

Let's create an example of a `/api/user/stats` route that only authenticated users can access.

```ts [server/api/user/stats.get.ts]
export default defineEventHandler(async (event) => {
  // make sure the user is logged in
  // This will throw a 401 error if the request doesn't come from a valid user session
  const { user } = await requireUserSession(event)

  // TODO: Fetch some stats based on the user

  return {}
})
```

## Protect App Routes

Our data is safe with the server-side route in place, but without doing anything else, unauthenticated users would probably get some odd data when trying to access the `/users` page. We should create a [client-side middleware](https://nuxt.com/docs/4.x/directory-structure/app/middleware) to protect the route on the client side and redirect users to the login page.

`nuxt-auth-utils` provides a convenient `useUserSession` composable which we'll use to check if the user is logged in, and redirect them if they are not.

We'll create a middleware in the `/middleware` directory. Unlike on the server, client-side middleware is not automatically applied to all endpoints, and we'll need to specify where we want it applied.

```typescript [app/middleware/authenticated.ts]
export default defineNuxtRouteMiddleware(() => {
  const { loggedIn } = useUserSession()

  // redirect the user to the login screen if they're not authenticated
  if (!loggedIn.value) {
    return navigateTo('/login')
  }
})
```

## Home Page

Now that we have our app middleware to protect our routes, we can use it on our home page that display our authenticated user information. If the user is not authenticated, they will be redirected to the login page.

We'll use [`definePageMeta`](/docs/4.x/api/utils/define-page-meta) to apply the middleware to the route that we want to protect.

```vue [app/pages/index.vue]
<script setup lang="ts">
definePageMeta({
  middleware: ['authenticated'],
})

const { user, clear: clearSession } = useUserSession()

async function logout () {
  await clearSession()
  await navigateTo('/login')
}
</script>

<template>
  <div>
    <h1>Welcome {{ user.name }}</h1>
    <button @click="logout">
      Logout
    </button>
  </div>
</template>
```

We also added a logout button to clear the session and redirect the user to the login page.

## Conclusion

We've successfully set up a very basic user authentication and session management in our Nuxt app. We've also protected sensitive routes on the server and client side to ensure that only authenticated users can access them.

As next steps, you can:
- Add authentication using the [20+ supported OAuth providers](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#supported-oauth-providers)
- Add a database to store users, see [Nitro SQL Database](https://nitro.build/guide/database) or [NuxtHub SQL Database](https://hub.nuxt.com/docs/features/database)
- Let user signup with email & password using [password hashing](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#password-hashing)
- Add support for [WebAuthn / Passkeys](https://github.com/atinux/nuxt-auth-utils?tab=readme-ov-file#webauthn-passkey)

Checkout the open source [atidone repository](https://github.com/atinux/atidone) for a full example of a Nuxt app with OAuth authentication, database and CRUD operations.
</file>

<file path="docs/3.guide/6.going-further/.navigation.yml">
title: Going Further
titleTemplate: '%s · Nuxt Advanced'
icon: i-lucide-star
</file>

<file path="docs/3.guide/6.going-further/1.events.md">
---
title: "Creating Custom Events"
description: "Nuxt provides a powerful event system powered by hookable."
navigation.title: "Custom Events"
---

Using events is a great way to decouple your application and allow for more flexible and modular communication between different parts of your code. Events can have multiple listeners that do not depend on each other. For example, you may wish to send an email to your user each time an order has shipped. Instead of coupling your order processing code to your email code, you can emit an event which a listener can receive and use to dispatch an email.

The Nuxt event system is powered by [unjs/hookable](https://github.com/unjs/hookable), which is the same library that powers the Nuxt hooks system.

## Creating Events and Listeners

You can create your own custom events using the `hook` method:

```ts
const nuxtApp = useNuxtApp()

nuxtApp.hook('app:user:registered', (payload) => {
  console.log('A new user has registered!', payload)
})
```

To emit an event and notify any listeners, use `callHook`:

```ts
const nuxtApp = useNuxtApp()

await nuxtApp.callHook('app:user:registered', {
  id: 1,
  name: 'John Doe',
})
```

You can also use the payload object to enable two-way communication between the emitter and listeners. Since the payload is passed by reference, a listener can modify it to send data back to the emitter.

```ts
const nuxtApp = useNuxtApp()

nuxtApp.hook('app:user:registered', (payload) => {
  payload.message = 'Welcome to our app!'
})

const payload = {
  id: 1,
  name: 'John Doe',
}

await nuxtApp.callHook('app:user:registered', {
  id: 1,
  name: 'John Doe',
})

// payload.message will be 'Welcome to our app!'
```

::tip
You can inspect all events using the **Nuxt DevTools** Hooks panel.
::

::read-more{to="/docs/4.x/guide/going-further/hooks"}
Learn more about Nuxt's built-in hooks and how to extend them
::
</file>

<file path="docs/3.guide/6.going-further/1.experimental-features.md">
---
title: "Experimental Features"
description: "Enable Nuxt experimental features to unlock new possibilities."
---

Nuxt includes experimental features that you can enable in your configuration file.

Internally, Nuxt uses `@nuxt/schema` to define these experimental features. You can refer to the [API documentation](/docs/4.x/guide/going-further/experimental-features) or the [source code](https://github.com/nuxt/nuxt/blob/main/packages/schema/src/config/experimental.ts) for more information.

::note
Note that these features are experimental and could be removed or modified in the future.
::

## alwaysRunFetchOnKeyChange

Whether to run `useFetch` when the key changes, even if it is set to `immediate: false` and it has not been triggered yet.

`useFetch` and `useAsyncData` will always run when the key changes if `immediate: true` or if it has been already triggered.

This flag is disabled by default, but you can enable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    alwaysRunFetchOnKeyChange: true,
  },
})
```

## appManifest

Use app manifests to respect route rules on client-side.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    appManifest: false,
  },
})
```

## asyncContext

Enable native async context to be accessible for nested composables in Nuxt and in Nitro. This opens the possibility to use composables inside async composables and reduce the chance to get the `Nuxt instance is unavailable` error.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    asyncContext: true,
  },
})
```

::read-more{icon="i-simple-icons-github" to="https://github.com/nuxt/nuxt/pull/20918" target="_blank"}
See full explanation on the GitHub pull-request.
::

## asyncEntry

Enables generation of an async entry point for the Vue bundle, aiding module federation support.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    asyncEntry: true,
  },
})
```

## externalVue

Externalizes `vue`, `@vue/*` and `vue-router` when building.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    externalVue: false,
  },
})
```

::warning
This feature will likely be removed in a near future.
::

## extractAsyncDataHandlers

Extracts handler functions from `useAsyncData` and `useLazyAsyncData` calls into separate chunks for improved code splitting and caching efficiency.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    extractAsyncDataHandlers: true,
  },
})
```

This feature transforms inline handler functions into dynamically imported chunks:

```vue
<!-- Before -->
<script setup>
const { data } = await useAsyncData('user', async () => {
  return await $fetch('/api/user')
})
</script>
```

```vue
<!-- After transformation -->
<script setup>
const { data } = await useAsyncData('user', () =>
  import('/generated-chunk.js').then(r => r.default()),
)
</script>
```

The benefit of this transformation is that we can split out data fetching logic &mdash; while still allowing the code to be loaded if required.

::important
This feature is only recommended for **static builds** with payload extraction, and where data does not need to be re-fetched at runtime.
::

## emitRouteChunkError

Emits `app:chunkError` hook when there is an error loading vite/webpack chunks. Default behavior is to perform a reload of the new route on navigation to a new route when a chunk fails to load.

By default, Nuxt will also perform a reload of the new route when a chunk fails to load when navigating to a new route (`automatic`).

Setting `automatic-immediate` will lead Nuxt to perform a reload of the current route right when a chunk fails to load (instead of waiting for navigation). This is useful for chunk errors that are not triggered by navigation, e.g., when your Nuxt app fails to load a [lazy component](/docs/4.x/directory-structure/app/components#dynamic-imports). A potential downside of this behavior is undesired reloads, e.g., when your app does not need the chunk that caused the error.

You can disable automatic handling by setting this to `false`, or handle chunk errors manually by setting it to `manual`.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    emitRouteChunkError: 'automatic', // or 'automatic-immediate', 'manual' or false
  },
})
```

## enforceModuleCompatibility

Whether Nuxt should throw an error (and fail to load) if a Nuxt module is incompatible.

This feature is disabled by default.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    enforceModuleCompatibility: true,
  },
})
```

## restoreState

Allows Nuxt app state to be restored from `sessionStorage` when reloading the page after a chunk error or manual [`reloadNuxtApp()`](/docs/4.x/api/utils/reload-nuxt-app) call.

To avoid hydration errors, it will be applied only after the Vue app has been mounted, meaning there may be a flicker on initial load.

::important
Consider carefully before enabling this as it can cause unexpected behavior,
and consider providing explicit keys to [`useState`](/docs/4.x/api/composables/use-state) as auto-generated keys may not match across builds.
::

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    restoreState: true,
  },
})
```

## inlineRouteRules

Define route rules at the page level using [`defineRouteRules`](/docs/4.x/api/utils/define-route-rules).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    inlineRouteRules: true,
  },
})
```

Matching route rules will be created, based on the page's `path`.

::read-more{to="/docs/4.x/api/utils/define-route-rules" icon="i-lucide-square-function"}
Read more in `defineRouteRules` utility.
::

:read-more{to="/docs/4.x/guide/concepts/rendering#hybrid-rendering" icon="i-lucide-medal"}

## renderJsonPayloads

Allows rendering of JSON payloads with support for revivifying complex types.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    renderJsonPayloads: false,
  },
})
```

## noVueServer

Disables Vue server renderer endpoint within Nitro.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    noVueServer: true,
  },
})
```

## parseErrorData

Whether to parse `error.data` when rendering a server error page.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    parseErrorData: false,
  },
})
```

## payloadExtraction

Enables extraction of payloads of pages generated with `nuxt generate`.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    payloadExtraction: true,
  },
})
```

## clientFallback

Enables the experimental [`<NuxtClientFallback>`](/docs/4.x/api/components/nuxt-client-fallback) component for rendering content on the client if there's an error in SSR.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    clientFallback: true,
  },
})
```

## crossOriginPrefetch

Enables cross-origin prefetch using the Speculation Rules API.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    crossOriginPrefetch: true,
  },
})
```

::read-more{icon="i-simple-icons-w3c" to="https://wicg.github.io/nav-speculation/prefetch.html" target="_blank"}
Read more about the **Speculation Rules API**.
::

## viewTransition

Enables View Transition API integration with client-side router.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    viewTransition: true,
  },
})
```

:link-example{to="https://stackblitz.com/edit/nuxt-view-transitions?file=app.vue" target="_blank"}

::read-more{icon="i-simple-icons-mdnwebdocs" to="https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API" target="_blank"}
Read more about the **View Transition API**.
::

## writeEarlyHints

Enables writing of early hints when using node server.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    writeEarlyHints: true,
  },
})
```

## componentIslands

Enables experimental component islands support with [`<NuxtIsland>`](/docs/4.x/api/components/nuxt-island) and `.island.vue` files.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    componentIslands: true, // false or 'local+remote'
  },
})
```

:read-more{to="/docs/4.x/directory-structure/app/components#server-components"}

::read-more{icon="i-simple-icons-github" to="https://github.com/nuxt/nuxt/issues/19772" target="_blank"}
You can follow the server components roadmap on GitHub.
::

## localLayerAliases

Resolve `~`, `~~`, `@` and `@@` aliases located within layers with respect to their layer source and root directories.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    localLayerAliases: false,
  },
})
```

## typedPages

Enable the new experimental typed router using [`unplugin-vue-router`](https://github.com/posva/unplugin-vue-router).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    typedPages: true,
  },
})
```

Out of the box, this will enable typed usage of [`navigateTo`](/docs/4.x/api/utils/navigate-to), [`<NuxtLink>`](/docs/4.x/api/components/nuxt-link), [`router.push()`](/docs/4.x/api/composables/use-router) and more.

You can even get typed params within a page by using `const route = useRoute('route-name')`.

::important
If you use `pnpm` without `shamefully-hoist=true`, you will need to have `unplugin-vue-router` installed as a devDependency in order for this feature to work.
::

:video-accordion{title="Watch a video from Daniel Roe explaining type-safe routing in Nuxt" videoId="SXk-L19gTZk"}

## watcher

Set an alternative watcher that will be used as the watching service for Nuxt.

Nuxt uses `chokidar-granular` by default, which will ignore top-level directories
(like `node_modules` and `.git`) that are excluded from watching.

You can set this instead to `parcel` to use `@parcel/watcher`, which may improve
performance in large projects or on Windows platforms.

You can also set this to `chokidar` to watch all files in your source directory.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    watcher: 'chokidar-granular', // 'chokidar' or 'parcel' are also options
  },
})
```

## sharedPrerenderData

Nuxt automatically shares payload *data* between pages that are prerendered. This can result in a significant performance improvement when prerendering sites that use `useAsyncData` or `useFetch` and fetch the same data in different pages.

You can disable this feature if needed.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    sharedPrerenderData: false,
  },
})
```

:video-accordion{title="Watch a video from Alexander Lichter about the experimental sharedPrerenderData" videoId="1jUupYHVvrU"}

It is particularly important when enabling this feature to make sure that any unique key of your data
is always resolvable to the same data. For example, if you are using `useAsyncData` to fetch
data related to a particular page, you should provide a key that uniquely matches that data. (`useFetch`
should do this automatically for you.)

```ts
// This would be unsafe in a dynamic page (e.g. `[slug].vue`) because the route slug makes a difference
// to the data fetched, but Nuxt can't know that because it's not reflected in the key.
const route = useRoute()
const { data } = await useAsyncData(async (_nuxtApp, { signal }) => {
  return await $fetch(`/api/my-page/${route.params.slug}`, { signal })
})
// Instead, you should use a key that uniquely identifies the data fetched.
const { data } = await useAsyncData(route.params.slug, async (_nuxtApp, { signal }) => {
  return await $fetch(`/api/my-page/${route.params.slug}`, { signal })
})
```

## clientNodeCompat

With this feature, Nuxt will automatically polyfill Node.js imports in the client build using [`unenv`](https://github.com/unjs/unenv).

::note
To make globals like `Buffer` work in the browser, you need to manually inject them.

```ts
import { Buffer } from 'node:buffer'

globalThis.Buffer ||= Buffer
```
::

## scanPageMeta

Nuxt exposing some route metadata defined in `definePageMeta` at build-time to modules (specifically `alias`, `name`, `path`, `redirect`, `props` and `middleware`).

This only works with static or strings/arrays rather than variables or conditional assignment. See [original issue](https://github.com/nuxt/nuxt/issues/24770) for more information and context.

By default page metadata is only scanned after all routes have been registered in `pages:extend`. Then another hook, `pages:resolved` will be called.

You can disable this feature if it causes issues in your project.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    scanPageMeta: false,
  },
})
```

## cookieStore

Enables CookieStore support to listen for cookie updates (if supported by the browser) and refresh `useCookie` ref values.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    cookieStore: false,
  },
})
```

::read-more{icon="i-simple-icons-mdnwebdocs" to="https://developer.mozilla.org/en-US/docs/Web/API/CookieStore" target="_blank"}
Read more about the **CookieStore**.
::

## buildCache

Caches Nuxt build artifacts based on a hash of the configuration and source files.

This only works for source files within `srcDir` and `serverDir` for the Vue/Nitro parts of your app.

This flag is disabled by default, but you can enable it:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    buildCache: true,
  },
})
```

When enabled, changes to the following files will trigger a full rebuild:

```bash [Directory structure]
.nuxtrc
.npmrc
package.json
package-lock.json
yarn.lock
pnpm-lock.yaml
tsconfig.json
bun.lock
bun.lockb
```

In addition, any changes to files within `srcDir` will trigger a rebuild of the Vue client/server bundle. Nitro will always be rebuilt (though work is in progress to allow Nitro to announce its cacheable artifacts and their hashes).

::note
A maximum of 10 cache tarballs are kept.
::

## checkOutdatedBuildInterval

Set the time interval (in ms) to check for new builds. Disabled when `experimental.appManifest` is `false`.

Set to `false` to disable.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    checkOutdatedBuildInterval: 3600000, // 1 hour, or false to disable
  },
})
```

## extraPageMetaExtractionKeys

The `definePageMeta()` macro is a useful way to collect build-time meta about pages. Nuxt itself provides a set list of supported keys which is used to power some of the internal features such as redirects, page aliases and custom paths.

This option allows passing additional keys to extract from the page metadata when using `scanPageMeta`.

```vue
<script lang="ts" setup>
definePageMeta({
  foo: 'bar',
})
</script>
```

```ts
export default defineNuxtConfig({
  experimental: {
    extraPageMetaExtractionKeys: ['foo'],
  },
  hooks: {
    'pages:resolved' (ctx) {
      // ✅ foo is available
    },
  },
})
```

This allows modules to access additional metadata from the page metadata in the build context. If you are using this within a module, it's recommended also to [augment the `NuxtPage` types with your keys](/docs/4.x/directory-structure/app/pages#typing-custom-metadata).

## navigationRepaint

Wait for a single animation frame before navigation, which gives an opportunity for the browser to repaint, acknowledging user interaction.

It can reduce INP when navigating on prerendered routes.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    navigationRepaint: false,
  },
})
```

## normalizeComponentNames

Nuxt updates auto-generated Vue component names to match the full component name you would use to auto-import the component.

If you encounter issues, you can disable this feature.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    normalizeComponentNames: false,
  },
})
```

By default, if you haven't set it manually, Vue will assign a component name that matches
the filename of the component.

```bash [Directory structure]
├─ components/
├─── SomeFolder/
├───── MyComponent.vue
```

In this case, the component name would be `MyComponent`, as far as Vue is concerned. If you wanted to use `<KeepAlive>` with it, or identify it in the Vue DevTools, you would need to use this component.

But in order to auto-import it, you would need to use `SomeFolderMyComponent`.

By setting `experimental.normalizeComponentNames`, these two values match, and Vue will generate a component name that matches the Nuxt pattern for component naming.

## spaLoadingTemplateLocation

When rendering a client-only page (with `ssr: false`), we optionally render a loading screen (from `~/spa-loading-template.html`).

It can be set to `within`, which will render it like this:

```html
<div id="__nuxt">
  <!-- spa loading template -->
</div>
```

Alternatively, you can render the template alongside the Nuxt app root by setting it to `body`:

```html
<div id="__nuxt"></div>
<!-- spa loading template -->
```

This avoids a white flash when hydrating a client-only page.

## browserDevtoolsTiming

Enables performance markers for Nuxt hooks in browser devtools. This adds performance markers that you can track in the Performance tab of Chromium-based browsers, which is useful for debugging and optimizing performance.

This is enabled by default in development mode. If you need to disable this feature, it is possible to do so:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    browserDevtoolsTiming: false,
  },
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="https://github.com/nuxt/nuxt/pull/29922" target="_blank"}
See PR #29922 for implementation details.
::

::read-more{icon="i-simple-icons-googlechrome" color="gray" to="https://developer.chrome.com/docs/devtools/performance/extension#tracks" target="_blank"}
Learn more about Chrome DevTools Performance API.
::

## debugModuleMutation

Records mutations to `nuxt.options` in module context, helping to debug configuration changes made by modules during the Nuxt initialization phase.

This is enabled by default when `debug` mode is enabled. If you need to disable this feature, it is possible to do so:

To enable it explicitly:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    debugModuleMutation: true,
  },
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="https://github.com/nuxt/nuxt/pull/30555" target="_blank"}
See PR #30555 for implementation details.
::

## lazyHydration

This enables hydration strategies for `<Lazy>` components, which improves performance by deferring hydration of components until they're needed.

Lazy hydration is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    lazyHydration: false,
  },
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="/docs/4.x/directory-structure/app/components#delayed-or-lazy-hydration"}
Read more about lazy hydration.
::

## templateImportResolution

Disable resolving imports into Nuxt templates from the path of the module that added the template.

By default, Nuxt attempts to resolve imports in templates relative to the module that added them. Setting this to `false` disables this behavior, which may be useful if you're experiencing resolution conflicts in certain environments.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    templateImportResolution: false,
  },
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="https://github.com/nuxt/nuxt/pull/31175" target="_blank"}
See PR #31175 for implementation details.
::

## templateRouteInjection

By default the route object returned by the auto-imported `useRoute()` composable is kept in sync with the current page in view in `<NuxtPage>`. This is not true for `vue-router`'s exported `useRoute` or for the default `$route` object available in your Vue templates.

By enabling this option a mixin will be injected to keep the `$route` template object in sync with Nuxt's managed `useRoute()`.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    templateRouteInjection: false,
  },
})
```

## decorators

This option enables enabling decorator syntax across your entire Nuxt/Nitro app, powered by [esbuild](https://github.com/evanw/esbuild/releases/tag/v0.21.3).

For a long time, TypeScript has had support for decorators via `compilerOptions.experimentalDecorators`. This implementation predated the TC39 standardization process. Now, decorators are a [Stage 3 Proposal](https://github.com/tc39/proposal-decorators), and supported without special configuration in TS 5.0+ (see https://github.com/microsoft/TypeScript/pull/52582 and https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#decorators).

Enabling `experimental.decorators` enables support for the TC39 proposal, **NOT** for TypeScript's previous `compilerOptions.experimentalDecorators` implementation.

::warning
Note that there may be changes before this finally lands in the JS standard.
::

### Usage

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    decorators: true,
  },
})
```

```ts [app/app.vue]
function something (_method: () => unknown) {
  return () => 'decorated'
}

class SomeClass {
  @something
  public someMethod () {
    return 'initial'
  }
}

const value = new SomeClass().someMethod()
// this will return 'decorated'
```

## defaults

This allows specifying the default options for core Nuxt components and composables.

These options will likely be moved elsewhere in the future, such as into `app.config` or into the `app/` directory.

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        componentName: 'NuxtLink',
        prefetch: true,
        prefetchOn: {
          visibility: true,
        },
      },
      useAsyncData: {
        deep: true,
      },
    },
  },
})
```

## purgeCachedData

Whether to clean up Nuxt static and asyncData caches on route navigation.

Nuxt will automatically purge cached data from `useAsyncData` and `nuxtApp.static.data`. This helps prevent memory leaks and ensures fresh data is loaded when needed, but it is possible to disable it.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    purgeCachedData: false,
  },
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="https://github.com/nuxt/nuxt/pull/31379" target="_blank"}
See PR #31379 for implementation details.
::

## granularCachedData

Whether to call and use the result from `getCachedData` when refreshing data for `useAsyncData` and `useFetch` (whether by `watch`, `refreshNuxtData()`, or a manual `refresh()` call.

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    granularCachedData: false,
  },
})
```

::read-more{icon="i-simple-icons-github" color="gray" to="https://github.com/nuxt/nuxt/pull/31373" target="_blank"}
See PR #31373 for implementation details.
::

## headNext

Use head optimisations:

- Add the capo.js head plugin in order to render tags in of the head in a more performant way.
- Uses the hash hydration plugin to reduce initial hydration

This flag is enabled by default, but you can disable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    headNext: false,
  },
})
```

## pendingWhenIdle

For `useAsyncData` and `useFetch`, whether `pending` should be `true` when data has not yet started to be fetched.

This flag is disabled by default, but you can enable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    pendingWhenIdle: true,
  },
})
```

## entryImportMap

By default, Nuxt improves chunk stability by using an import map to resolve the entry chunk of the bundle.

This injects an import map at the top of your `<head>` tag:

```html
<script type="importmap">{"imports":{"#entry":"/_nuxt/DC5HVSK5.js"}}</script>
```

Within the script chunks emitted by Vite, imports will be from `#entry`. This means that changes to the entry will not invalidate chunks which are otherwise unchanged.

::note
Nuxt smartly disables this feature if you have configured `vite.build.target` to include a browser that doesn't support import maps, or if you have configured `vite.build.rollupOptions.output.entryFileNames` to a value that does not include `[hash]`.
::

If you need to disable this feature you can do so:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    entryImportMap: false,
  },
  // or, better, simply tell vite your desired target
  // which nuxt will respect
  vite: {
    build: {
      target: 'safari13',
    },
  },
})
```

## typescriptPlugin

Enable enhanced TypeScript developer experience with the `@dxup/nuxt` module.

This experimental plugin provides improved TypeScript integration and development tooling for better DX when working with TypeScript in Nuxt applications.

This flag is disabled by default, but you can enable this feature:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    typescriptPlugin: true,
  },
})
```

::important
To use this feature, you need to:
- Have `typescript` installed as a dependency
- Configure VS Code to use your workspace TypeScript version (see [VS Code documentation](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript))
::

::read-more{icon="i-simple-icons-github" to="https://github.com/KazariEX/dxup" target="_blank"}
Learn more about **@dxup/nuxt**.
::

## viteEnvironmentApi

Enable Vite 6's new [Environment API](https://vite.dev/guide/api-environment) for improved build configuration and plugin architecture.

When you set `future.compatibilityVersion` to `5`, this feature is enabled by default. You can also enable it explicitly for testing:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    viteEnvironmentApi: true,
  },
})
```

The Vite Environment API provides better consistency between development and production builds, more granular control over environment-specific configuration, and improved performance.

::important
Enabling this feature changes how Vite plugins are registered and configured. See the [Vite Environment API migration guide](/docs/4.x/getting-started/upgrade#migration-to-vite-environment-api) for details on updating your plugins.
::

::read-more{to="https://vite.dev/guide/api-environment" target="_blank"}
Learn more about Vite's Environment API.
::
</file>

<file path="docs/3.guide/6.going-further/1.features.md">
---
title: "Features"
description: "Enable or disable optional Nuxt features to unlock new possibilities."
---

Some features of Nuxt are available on an opt-in basis, or can be disabled based on your needs.

## `features`

### devLogs

Stream server logs to the client as you are developing. These logs can be handled in the `dev:ssr-logs` hook.

By default, this is enabled in development (when test mode is not active).

If set to `silent`, the logs will not be printed to the browser console.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  features: {
    devLogs: true,
  },
})
```

### inlineStyles

Inlines styles when rendering HTML. This is currently available only when using Vite.

You can also pass a function that receives the path of a Vue component and returns a boolean indicating whether to inline the styles for that component.

It defaults to `(id) => id.includes('.vue')`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  features: {
    inlineStyles: false, // or a function to determine inlining
  },
})
```

### noScripts

Turn off rendering of Nuxt scripts and JavaScript resource hints. Can also be configured granularly within `routeRules`.

You can also disable scripts more granularly within `routeRules`.

If set to 'production' or `true`, JavaScript will be disabled in production mode only. If set to 'all', JavaScript will be disabled in both development and production modes.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  features: {
    noScripts: true, // or 'production' | 'all' | false
  },
})
```

## `future`

There is also a `future` namespace for early opting-in to new features that will become default in a future (possibly major) version of the framework.

### compatibilityVersion

This enables early access to Nuxt features or flags.

Setting `compatibilityVersion` to `5` changes defaults throughout your Nuxt configuration to opt in to Nuxt v5 behaviour, including enabling the [Vite Environment API](/docs/4.x/guide/going-further/experimental-features#viteenvironmentapi).

```ts
export default defineNuxtConfig({
  future: {
    compatibilityVersion: 5,
  },
})
```

::read-more{to="/docs/4.x/getting-started/upgrade#testing-nuxt-5"}
Learn more about testing Nuxt 5.
::

### multiApp

This enables early access to the experimental multi-app support. You can follow the [tracker issue #21635](https://github.com/nuxt/nuxt/issues/21635) to see the progress of multi-app support in Nuxt.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  future: {
    multiApp: true,
  },
})
```

### typescriptBundlerResolution

This enables 'Bundler' module resolution mode for TypeScript, which is the recommended setting for frameworks like Nuxt and [Vite](https://vite.dev/guide/performance#reduce-resolve-operations).

It improves type support when using modern libraries with `exports`.

See [the original TypeScript pull request](https://github.com/microsoft/TypeScript/pull/51669).

You can set it to false to use the legacy 'Node' mode, which is the default for TypeScript.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  future: {
    typescriptBundlerResolution: false,
  },
})
```
</file>

<file path="docs/3.guide/6.going-further/1.internals.md">
---
title: "How Nuxt Works?"
description: "Nuxt is a minimal but highly customizable framework to build web applications."
navigation: false
---

This guide helps you better understand Nuxt internals to develop new solutions and module integrations on top of Nuxt.

## The Nuxt Interface

When you start Nuxt in development mode with [`nuxt dev`](/docs/4.x/api/commands/dev) or building a production application with [`nuxt build`](/docs/4.x/api/commands/build),
a common context will be created, referred to as `nuxt` internally. It holds normalized options merged with `nuxt.config` file,
some internal state, and a powerful [hooking system](/docs/4.x/api/advanced/hooks) powered by [unjs/hookable](https://github.com/unjs/hookable)
allowing different components to communicate with each other. You can think of it as **Builder Core**.

This context is globally available to be used with [Nuxt Kit](/docs/4.x/guide/going-further/kit) composables.
Therefore only one instance of Nuxt is allowed to run per process.

To extend the Nuxt interface and hook into different stages of the build process, we can use [Nuxt modules](/docs/4.x/guide/modules).

For more details, check out [the source code](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/core/nuxt.ts).

## The NuxtApp Interface

When rendering a page in the browser or on the server, a shared context will be created, referred to as `nuxtApp`.
This context keeps vue instance, runtime hooks, and internal states like ssrContext and payload for hydration.
You can think of it as **Runtime Core**.

This context can be accessed using [`useNuxtApp()`](/docs/4.x/api/composables/use-nuxt-app) composable within Nuxt plugins and `<script setup>` and vue composables.
Global usage is possible for the browser but not on the server, to avoid sharing context between users.

Since [`useNuxtApp`](/docs/4.x/api/composables/use-nuxt-app) throws an exception if context is currently unavailable, if your composable does not always require `nuxtApp`, you can use [`tryUseNuxtApp`](/docs/4.x/api/composables/use-nuxt-app#tryusenuxtapp) instead, which will return `null` instead of throwing an exception.

To extend the `nuxtApp` interface and hook into different stages or access contexts, we can use [Nuxt Plugins](/docs/4.x/directory-structure/app/plugins).

Check [Nuxt App](/docs/4.x/api/composables/use-nuxt-app) for more information about this interface.

`nuxtApp` has the following properties:

```ts
interface NuxtApp {
  vueApp // the global Vue application: https://vuejs.org/api/application.html#application-api

  versions // an object containing Nuxt and Vue versions

  // These let you call and add runtime NuxtApp hooks
  // https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts#L18
  hooks
  hook
  callHook

  // Only accessible on server-side
  ssrContext: {
    url
    req
    res
    runtimeConfig
    noSSR
  }

  // This will be stringified and passed from server to client
  payload: {
    serverRendered: true
    data: {}
    state: {}
  }

  provide: (name: string, value: any) => void
}
```

For more details, check out [the source code](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts).

## Runtime Context vs. Build Context

Nuxt builds and bundles project using Node.js but also has a runtime side.

While both areas can be extended, that runtime context is isolated from build-time. Therefore, they are not supposed to share state, code, or context other than runtime configuration!

`nuxt.config` and [Nuxt modules](/docs/4.x/guide/modules) can be used to extend the build context, and [Nuxt Plugins](/docs/4.x/directory-structure/app/plugins) can be used to extend runtime.

When building an application for production, `nuxt build` will generate a standalone build in the `.output` directory, independent of `nuxt.config` and [Nuxt modules](/docs/4.x/guide/modules).
</file>

<file path="docs/3.guide/6.going-further/10.runtime-config.md">
---
title: "Runtime Config"
description: "Nuxt provides a runtime config API to expose configuration and secrets within your application."
---

## Exposing

To expose config and environment variables to the rest of your app, you will need to define runtime configuration in your [`nuxt.config`](/docs/4.x/directory-structure/nuxt-config) file, using the [`runtimeConfig`](/docs/4.x/api/nuxt-config#runtimeconfig) option.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    // The private keys which are only available within server-side
    apiSecret: '123',
    // Keys within public, will be also exposed to the client-side
    public: {
      apiBase: '/api',
    },
  },
})
```

When adding `apiBase` to the `runtimeConfig.public`, Nuxt adds it to each page payload. We can universally access `apiBase` in both server and browser.

```ts
const runtimeConfig = useRuntimeConfig()

console.log(runtimeConfig.apiSecret)
console.log(runtimeConfig.public.apiBase)
```

::tip
Public runtime config is accessible in Vue templates with `$config.public`.
::

### Serialization

Your runtime config will be serialized before being passed to Nitro. This means that anything that cannot be serialized and then deserialized (such as functions, Sets, Maps, and so on), should not be set in your `nuxt.config`.

Instead of passing non-serializable objects or functions into your application from your `nuxt.config`, you can place this code in a Nuxt or Nitro plugin or middleware.

### Environment Variables

The most common way to provide configuration is by using environment variables.

::note
The Nuxt CLI has built-in support for reading your `.env` file in development, build and generate. But when you run your built server, **your `.env` file will not be read**.
:read-more{to="/docs/4.x/directory-structure/env"}
::

Runtime config values are **automatically replaced by matching environment variables at runtime**.

There are two key requirements:

1. Your desired variables must be defined in your `nuxt.config`. This ensures that arbitrary environment variables are not exposed to your application code.

1. Only a specially-named environment variable can override a runtime config property. That is, an uppercase environment variable starting with `NUXT_` which uses `_` to separate keys and case changes.

::warning
Setting the default of `runtimeConfig` values to *differently named environment variables* (for example setting `myVar` to `process.env.OTHER_VARIABLE`) will only work during build-time and will break on runtime.
It is advised to use environment variables that match the structure of your `runtimeConfig` object.
::

::tip{icon="i-lucide-video" to="https://youtu.be/_FYV5WfiWvs" target="_blank"}
Watch a video from Alexander Lichter showcasing the top mistake developers make using runtimeConfig.
::

#### Example

```ini [.env]
NUXT_API_SECRET=api_secret_token
NUXT_PUBLIC_API_BASE=https://nuxtjs.org
```

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    apiSecret: '', // can be overridden by NUXT_API_SECRET environment variable
    public: {
      apiBase: '', // can be overridden by NUXT_PUBLIC_API_BASE environment variable
    },
  },
})
```

## Reading

### Vue App

Within the Vue part of your Nuxt app, you will need to call [`useRuntimeConfig()`](/docs/4.x/api/composables/use-runtime-config) to access the runtime config.

::important
The behavior is different between the client-side and server-side:

- On client-side, only keys in `runtimeConfig.public` and `runtimeConfig.app` (which is used by Nuxt internally) are available, and the object is both writable and reactive.

- On server-side, the entire runtime config is available, but it is read-only to avoid context sharing.
::

```vue [app/pages/index.vue]
<script setup lang="ts">
const config = useRuntimeConfig()

console.log('Runtime config:', config)
if (import.meta.server) {
  console.log('API secret:', config.apiSecret)
}
</script>

<template>
  <div>
    <div>Check developer console!</div>
  </div>
</template>
```

::caution
**Security note:** Be careful not to expose runtime config keys to the client-side by either rendering them or passing them to `useState`.
::

### Plugins

If you want to use the runtime config within any (custom) plugin, you can use [`useRuntimeConfig()`](/docs/4.x/api/composables/use-runtime-config) inside of your `defineNuxtPlugin` function.

```ts [app/plugins/config.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const config = useRuntimeConfig()

  console.log('API base URL:', config.public.apiBase)
})
```

### Server Routes

You can access runtime config within the server routes as well using `useRuntimeConfig`.

```ts [server/api/test.ts]
export default defineEventHandler(async (event) => {
  const { apiSecret } = useRuntimeConfig(event)
  const result = await $fetch('https://my.api.com/test', {
    headers: {
      Authorization: `Bearer ${apiSecret}`,
    },
  })
  return result
})
```

::note
Giving the `event` as argument to `useRuntimeConfig` is optional, but it is recommended to pass it to get the runtime config overwritten by [environment variables](/docs/4.x/guide/going-further/runtime-config#environment-variables) at runtime for server routes.
::

## Typing Runtime Config

Nuxt tries to automatically generate a typescript interface from provided runtime config using [unjs/untyped](https://github.com/unjs/untyped).

But it is also possible to type your runtime config manually:

```ts [index.d.ts]
declare module 'nuxt/schema' {
  interface RuntimeConfig {
    apiSecret: string
  }
  interface PublicRuntimeConfig {
    apiBase: string
  }
}
// It is always important to ensure you import/export something when augmenting a type
export {}
```

::note
`nuxt/schema` is provided as a convenience for end-users to access the version of the schema used by Nuxt in their project. Module authors should instead augment `@nuxt/schema`.
::
</file>

<file path="docs/3.guide/6.going-further/11.nightly-release-channel.md">
---
title: "Nightly Release Channel"
description: "The nightly release channel allows using Nuxt built directly from the latest commits to the repository."
---

Nuxt lands commits, improvements, and bug fixes every day. You can opt in to test them earlier before the next release.

After a commit is merged into the `main` branch of [nuxt/nuxt](https://github.com/nuxt/nuxt) and **passes all tests**, we trigger an automated npm release, using GitHub Actions.

You can use these 'nightly' releases to beta test new features and changes.

The build and publishing method and quality of these 'nightly' releases are the same as stable ones. The only difference is that you should often check the GitHub repository for updates. There is a slight chance of regressions not being caught during the review process and by the automated tests. Therefore, we internally use this channel to double-check everything before each release.

::note
Features that are only available on the nightly release channel are marked with an alert in the documentation.
::

::warning
The `latest` nightly release channel is currently tracking the Nuxt v4 branch, meaning that it is particularly likely to have breaking changes right now &mdash; be careful! You can opt in to the 3.x branch nightly releases with `"nuxt": "npm:nuxt-nightly@3x"`.
::

## Opting In

Update `nuxt` dependency inside `package.json`:

```diff [package.json]
{
  "devDependencies": {
--    "nuxt": "^4.0.0"
++    "nuxt": "npm:nuxt-nightly@latest"
  }
}
```

Remove lockfile (`package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`, `bun.lock` or `bun.lockb`) and reinstall dependencies.

## Opting Out

Update `nuxt` dependency inside `package.json`:

```diff [package.json]
{
  "devDependencies": {
--    "nuxt": "npm:nuxt-nightly@latest"
++    "nuxt": "^4.0.0"
  }
}
```

Remove lockfile (`package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`, `bun.lock` or `bun.lockb`) and reinstall dependencies.

## Using Nightly `@nuxt/cli`

To try the latest version of [nuxt/cli](https://github.com/nuxt/cli):

```bash [Terminal]
npx @nuxt/cli-nightly@latest [command]
```

::read-more{to="/docs/4.x/api/commands"}
Read more about the available commands.
::
</file>

<file path="docs/3.guide/6.going-further/2.hooks.md">
---
title: "Lifecycle Hooks"
description: "Nuxt provides a powerful hooking system to expand almost every aspect using hooks."
---

::tip
The hooking system is powered by [unjs/hookable](https://github.com/unjs/hookable).
::

## Nuxt Hooks (Build Time)

These hooks are available for [Nuxt modules](/docs/4.x/guide/modules) and build context.

### Within `nuxt.config.ts`

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    close: () => { },
  },
})
```

### Within Nuxt Modules

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.hook('close', async () => { })
  },
})
```

::read-more{to="/docs/4.x/api/advanced/hooks#nuxt-hooks-build-time"}
Explore all available Nuxt hooks.
::

## App Hooks (Runtime)

App hooks can be mainly used by [Nuxt Plugins](/docs/4.x/directory-structure/app/plugins) to hook into rendering lifecycle but could also be used in Vue composables.

```ts [app/plugins/test.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.hook('page:start', () => {
    /* your code goes here */
  })
})
```

::read-more{to="/docs/4.x/api/advanced/hooks#app-hooks-runtime"}
Explore all available App hooks.
::

## Server Hooks (Runtime)

These hooks are available for [server plugins](/docs/4.x/directory-structure/server#server-plugins) to hook into Nitro's runtime behavior.

```ts [~/server/plugins/test.ts]
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook('render:html', (html, { event }) => {
    console.log('render:html', html)
    html.bodyAppend.push('<hr>Appended by custom plugin')
  })

  nitroApp.hooks.hook('render:response', (response, { event }) => {
    console.log('render:response', response)
  })
})
```

::read-more{to="/docs/4.x/api/advanced/hooks#nitro-app-hooks-runtime-server-side"}
Learn more about available Nitro lifecycle hooks.
::

## Adding Custom Hooks

You can define your own custom hooks support by extending Nuxt's hook interfaces.

```ts
import type { HookResult } from '@nuxt/schema'

declare module '#app' {
  interface RuntimeNuxtHooks {
    'your-nuxt-runtime-hook': () => HookResult
  }
  interface NuxtHooks {
    'your-nuxt-hook': () => HookResult
  }
}

declare module 'nitropack/types' {
  interface NitroRuntimeHooks {
    'your-nitro-hook': () => void
  }
}
```
</file>

<file path="docs/3.guide/6.going-further/4.kit.md">
---
title: "Nuxt Kit"
description: "@nuxt/kit provides features for module authors."
---

Nuxt Kit provides composable utilities to make interacting with [Nuxt Hooks](/docs/4.x/api/advanced/hooks), the [Nuxt Interface](/docs/4.x/guide/going-further/internals#the-nuxt-interface) and developing [Nuxt modules](/docs/4.x/guide/modules) super easy.

::read-more{to="/docs/4.x/api/kit"}
Discover all Nuxt Kit utilities.
::

## Usage

### Install Dependency

You can install the latest Nuxt Kit by adding it to the `dependencies` section of your `package.json`. However, please consider always explicitly installing the `@nuxt/kit` package even if it is already installed by Nuxt.

::note
`@nuxt/kit` and `@nuxt/schema` are key dependencies for Nuxt. If you are installing it separately, make sure that the versions of `@nuxt/kit` and `@nuxt/schema` are equal to or greater than your `nuxt` version to avoid any unexpected behavior.
::

```json [package.json]
{
  "dependencies": {
    "@nuxt/kit": "npm:@nuxt/kit-nightly@latest"
  }
}
```

### Import Kit Utilities

```ts [test.mjs]
import { useNuxt } from '@nuxt/kit'
```

:read-more{to="/docs/4.x/api/kit"}

::note
Nuxt Kit utilities are only available for modules and not meant to be imported in runtime (components, Vue composables, pages, plugins, or server routes).
::

Nuxt Kit is an [esm-only package](/docs/4.x/guide/concepts/esm) meaning that you **cannot** `require('@nuxt/kit')`. As a workaround, use dynamic import in the CommonJS context:

```ts [test.cjs]
// This does NOT work!
// const kit = require('@nuxt/kit')
async function main () {
  const kit = await import('@nuxt/kit')
}
main()
```
</file>

<file path="docs/3.guide/6.going-further/6.nuxt-app.md">
---
title: "NuxtApp"
description: "In Nuxt, you can access runtime app context within composables, components and plugins."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts
---

In Nuxt, you can access runtime app context within composables, components and plugins.

::read-more{to="https://v2.nuxt.com/docs/internals-glossary/context/#the-context" target="_blank"}
In Nuxt 2, this was referred to as **Nuxt context**.
::

## Nuxt App Interface

::read-more{to="/docs/4.x/guide/going-further/internals#the-nuxtapp-interface"}
Jump over the `NuxtApp` interface documentation.
::

## The Nuxt Context

Many composables and utilities, both built-in and user-made, may require access to the Nuxt instance. This doesn't exist everywhere on your application, because a fresh instance is created on every request.

Currently, the Nuxt context is only accessible in [plugins](/docs/4.x/directory-structure/app/plugins), [Nuxt hooks](/docs/4.x/guide/going-further/hooks), [Nuxt middleware](/docs/4.x/directory-structure/app/middleware) (if wrapped in `defineNuxtRouteMiddleware`), and [setup functions](https://vuejs.org/api/composition-api-setup) (in pages and components).

If a composable is called without access to the context, you may get an error stating that 'A composable that requires access to the Nuxt instance was called outside of a plugin, Nuxt hook, Nuxt middleware, or Vue setup function.' In that case, you can also explicitly call functions within this context by using [`nuxtApp.runWithContext`](/docs/4.x/api/composables/use-nuxt-app#runwithcontext).

## Accessing NuxtApp

Within composables, plugins and components you can access `nuxtApp` with [`useNuxtApp()`](/docs/4.x/api/composables/use-nuxt-app):

```ts [app/composables/useMyComposable.ts]
export function useMyComposable () {
  const nuxtApp = useNuxtApp()
  // access runtime nuxt app instance
}
```

If your composable does not always need `nuxtApp` or you simply want to check if it is present or not, since [`useNuxtApp`](/docs/4.x/api/composables/use-nuxt-app) throws an exception, you can use [`tryUseNuxtApp`](/docs/4.x/api/composables/use-nuxt-app#tryusenuxtapp) instead.

Plugins also receive `nuxtApp` as the first argument for convenience.

:read-more{to="/docs/4.x/directory-structure/app/plugins"}

## Providing Helpers

You can provide helpers to be usable across all composables and application. This usually happens within a Nuxt plugin.

```ts
const nuxtApp = useNuxtApp()
nuxtApp.provide('hello', name => `Hello ${name}!`)

console.log(nuxtApp.$hello('name')) // Prints "Hello name!"
```

::read-more{to="/docs/4.x/directory-structure/app/plugins#providing-helpers"}
It is possible to inject helpers by returning an object with a `provide` key in plugins.
::

::read-more{to="https://v2.nuxt.com/docs/directory-structure/plugins/#inject-in-root--context" target="_blank"}
In Nuxt 2 plugins, this was referred to as **inject function**.
::
</file>

<file path="docs/3.guide/6.going-further/7.layers.md">
---
title: Authoring Nuxt Layers
description: Nuxt provides a powerful system that allows you to extend the default files, configs, and much more.
---

Nuxt layers are a powerful feature that you can use to share and reuse partial Nuxt applications within a monorepo, or from a git repository or npm package. The layers structure is almost identical to a standard Nuxt application, which makes them easy to author and maintain.

:read-more{to="/docs/4.x/getting-started/layers"}

A minimal Nuxt layer directory should contain a [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) file to indicate it is a layer.

```ts [base/nuxt.config.ts]
export default defineNuxtConfig({})
```

Additionally, certain other files in the layer directory will be auto-scanned and used by Nuxt for the project extending this layer.

- [`app/components/*`](/docs/4.x/directory-structure/app/components)   - Extend the default components
- [`app/composables/*`](/docs/4.x/directory-structure/app/composables)  - Extend the default composables
- [`app/layouts/*`](/docs/4.x/directory-structure/app/layouts)  - Extend the default layouts
- [`app/middleware/*`](/docs/4.x/directory-structure/app/middleware)  - Extend the default middleware
- [`app/pages/*`](/docs/4.x/directory-structure/app/pages)        - Extend the default pages
- [`app/plugins/*`](/docs/4.x/directory-structure/app/plugins)        - Extend the default plugins
- [`app/utils/*`](/docs/4.x/directory-structure/app/utils)   - Extend the default utils
- [`app/app.config.ts`](/docs/4.x/directory-structure/app/app-config)  - Extend the default app config
- [`server/*`](/docs/4.x/directory-structure/server)       - Extend the default server endpoints & middleware
- [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config)- Extend the default nuxt config

## Basic Example

::code-tree{defaultValue="nuxt.config.ts" expandAll}

  ```ts [nuxt.config.ts]
  export default defineNuxtConfig({
    extends: [
      './base',
    ],
  })
  ```

  ```vue [app/app.vue]
  <template>
    <BaseComponent />
  </template>
  ```

  ```ts [base/nuxt.config.ts]
  export default defineNuxtConfig({
    // Extending from base nuxt.config.ts!
    app: {
      head: {
        title: 'Extending Configs is Fun!',
        meta: [
          { name: 'description', content: 'I am using the extends feature in Nuxt!' },
        ],
      },
    },
  })
  ```

  ```vue [base/app/components/BaseComponent.vue]
  <template>
    <h1>Extending Components is Fun!</h1>
  </template>
  ```

::

## Layer Priority

When extending from multiple layers, it's important to understand the override order. Layers with **higher priority** override layers with lower priority when they define the same files or components.

The priority order from highest to lowest is:

1. **Your project files** - always have the highest priority
2. **Auto-scanned layers** from `~~/layers` directory - sorted alphabetically (Z has higher priority than A)
3. **Layers in `extends`** config - first entry has higher priority than second

### When to Use Each

- **`extends`** - Use for external dependencies (npm packages, remote repositories) or layers outside your project directory
- **`~~/layers` directory** - Use for local layers that are part of your project

::tip
If you need to control the order of auto-scanned layers, you can prefix them with numbers: `~/layers/1.z-layer`, `~/layers/2.a-layer`. This way `2.a-layer` will have higher priority than `1.z-layer`.
::

### Example

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    // Local layer outside the project
    '../base',
    // NPM package
    '@my-themes/awesome',
    // Remote repository
    'github:my-themes/awesome#v1',
  ],
})
```

If you also have `~~/layers/custom`, the priority order is:
- Your project files (highest)
- `~~/layers/custom`
- `../base`
- `@my-themes/awesome`
- `github:my-themes/awesome#v1` (lowest)

This means your project files will override any layer, and `~~/layers/custom` will override anything in `extends`.

## Starter Template

To get started you can initialize a layer with the [nuxt/starter/layer template](https://github.com/nuxt/starter/tree/layer). This will create a basic structure you can build upon. Execute this command within the terminal to get started:

```bash [Terminal]
npm create nuxt -- --template layer nuxt-layer
```

Follow up on the README instructions for the next steps.

## Publishing Layers

You can publish and share layers by either using a remote source or an npm package.

### Git Repository

You can use a git repository to share your Nuxt layer. Some examples:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    // GitHub Remote Source
    'github:username/repoName',
    // GitHub Remote Source within /base directory
    'github:username/repoName/base',
    // GitHub Remote Source from dev branch
    'github:username/repoName#dev',
    // GitHub Remote Source from v1.0.0 tag
    'github:username/repoName#v1.0.0',
    // GitLab Remote Source example
    'gitlab:username/repoName',
    // Bitbucket Remote Source example
    'bitbucket:username/repoName',
  ],
})
```

::tip
If you want to extend a private remote source, you need to add the environment variable `GIGET_AUTH=<token>` to provide a token.
::

::tip
If you want to extend a remote source from a self-hosted GitHub or GitLab instance, you need to supply its URL with the `GIGET_GITHUB_URL=<url>` or `GIGET_GITLAB_URL=<url>` environment variable - or directly configure it with [the `auth` option](https://github.com/unjs/c12#extending-config-layer-from-remote-sources) in your `nuxt.config`.
::

::warning
Bear in mind that if you are extending a remote source as a layer, you will not be able to access its dependencies outside of Nuxt. For example, if the remote layer depends on an eslint plugin, this will not be usable in your eslint config. That is because these dependencies will be located in a special location (`node_modules/.c12/layer_name/node_modules/`) that is not accessible to your package manager.
::

::note
When using git remote sources, if a layer has npm dependencies and you wish to install them, you can do so by specifying `install: true` in your layer options.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    ['github:username/repoName', { install: true }],
  ],
})
```
::

### npm Package

You can publish Nuxt layers as an npm package that contains the files and dependencies you want to extend. This allows you to share your config with others, use it in multiple projects or use it privately.

To extend from an npm package, you need to make sure that the module is published to npm and installed in the user's project as a devDependency. Then you can use the module name to extend the current nuxt config:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  extends: [
    // Node Module with scope
    '@scope/moduleName',
    // or just the module name
    'moduleName',
  ],
})
```

To publish a layer directory as an npm package, you want to make sure that the `package.json` has the correct properties filled out. This will make sure that the files are included when the package is published.

```json [package.json]
{
  "name": "my-theme",
  "version": "1.0.0",
  "type": "module",
  "main": "./nuxt.config.ts",
  "dependencies": {},
  "devDependencies": {
    "nuxt": "^3.0.0"
  }
}
```

::important
Make sure any dependency imported in the layer is **explicitly added** to the `dependencies`. The `nuxt` dependency, and anything only used for testing the layer before publishing, should remain in the `devDependencies` field.
::

Now you can proceed to publish the module to npm, either publicly or privately.

::important
When publishing the layer as a private npm package, you need to make sure you log in, to authenticate with npm to download the node module.
::

## Tips

### Named Layer Aliases

Auto-scanned layers (from your `~~/layers` directory) automatically create aliases. For example, you can access your `~~/layers/test` layer via `#layers/test`.

If you want to create named layer aliases for other layers, you can specify a name in the configuration of the layer.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  $meta: {
    name: 'example',
  },
})
```

This will produce an alias of `#layers/example` which points to your layer.

### Relative Paths and Aliases

When importing using global aliases (such as `~/` and `@/`) in a layer components and composables, note that these aliases are resolved relative to the user's project paths. As a workaround, you can **use relative paths** to import them, or use named layer aliases.

Also when using relative paths in `nuxt.config` file of a layer, (with exception of nested `extends`) they are resolved relative to user's project instead of the layer. As a workaround, use full resolved paths in `nuxt.config`:

```ts [nuxt.config.ts]
import { fileURLToPath } from 'node:url'
import { dirname, join } from 'node:path'

const currentDir = dirname(fileURLToPath(import.meta.url))

export default defineNuxtConfig({
  css: [
    join(currentDir, './app/assets/main.css'),
  ],
})
```

## Multi-Layer Support for Nuxt Modules

You can use the [`getLayerDirectories`](/docs/4.x/api/kit/layers#getlayerdirectories) utility from Nuxt Kit to support custom multi-layer handling for your modules.

```ts [modules/my-module.ts]
import { defineNuxtModule, getLayerDirectories } from 'nuxt/kit'

export default defineNuxtModule({
  setup (_options, nuxt) {
    const layerDirs = getLayerDirectories()

    for (const [index, layer] of layerDirs.entries()) {
      console.log(`Layer ${index}:`)
      console.log(`  Root: ${layer.root}`)
      console.log(`  App: ${layer.app}`)
      console.log(`  Server: ${layer.server}`)
      console.log(`  Pages: ${layer.appPages}`)
      // ... other directories
    }
  },
})
```

**Notes:**
- Earlier items in the array have higher priority and override later ones
- The user's project is the first item in the array

## Going Deeper

Configuration loading and extends support is handled by [unjs/c12](https://github.com/unjs/c12), merged using [unjs/defu](https://github.com/unjs/defu) and remote git sources are supported using [unjs/giget](https://github.com/unjs/giget). Check the docs and source code to learn more.

::read-more{icon="i-simple-icons-github" to="https://github.com/nuxt/nuxt/issues/13367" target="_blank"}
Checkout our ongoing development to bring more improvements for layers support on GitHub.
::
</file>

<file path="docs/3.guide/6.going-further/9.debugging.md">
---
title: "Debugging"
description: "In Nuxt, you can get started with debugging your application directly in the browser as well as in your IDE."
---

## Sourcemaps

Sourcemaps are enabled for your server build by default, and for the client build in dev mode, but you can enable them more specifically in your configuration.

```ts
export default defineNuxtConfig({
  // or sourcemap: true
  sourcemap: {
    server: true,
    client: true,
  },
})
```

## Debugging with Node Inspector

You can use [Node inspector](https://nodejs.org/en/learn/getting-started/debugging) to debug Nuxt server-side.

```bash
nuxt dev --inspect
```
This will start Nuxt in `dev` mode with debugger active. If everything is working correctly a Node.js icon will appear on your Chrome DevTools and you can attach to the debugger.

::important
Note that the Node.js and Chrome processes need to be run on the same platform. This doesn't work inside of Docker.
::

## Debugging in Your IDE

It is possible to debug your Nuxt app in your IDE while you are developing it.

### Example VS Code Debug Configuration

You may need to update the config below with a path to your web browser. For more information, visit the [VS Code documentation about debug configuration](https://code.visualstudio.com/docs/debugtest/debugging#_launch-configurations).

```json5
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  "version": "0.2.0",
  "configurations": [
    {
      "type": "chrome",
      "request": "launch",
      "name": "client: chrome",
      "url": "http://localhost:3000",
      // this should point to your Nuxt `srcDir`, which is `app` by default
      "webRoot": "${workspaceFolder}/app"
    },
    {
      "type": "node",
      "request": "launch",
      "name": "server: nuxt",
      "outputCapture": "std",
      "program": "${workspaceFolder}/node_modules/nuxt/bin/nuxt.mjs",
      "args": [
        "dev"
      ],
    }
  ],
  "compounds": [
    {
      "name": "fullstack: nuxt",
      "configurations": [
        "server: nuxt",
        "client: chrome"
      ]
    }
  ]
}
```

If you prefer your usual browser extensions, add this to the _chrome_ configuration above:

```json5
"userDataDir": false,
```

### Example JetBrains IDEs Debug Configuration

You can also debug your Nuxt app in JetBrains IDEs such as IntelliJ IDEA, WebStorm, or PhpStorm.

1. Create a new file in your project root directory and name it `nuxt.run.xml`.

2. Open the `nuxt.run.xml` file and paste the following debug configuration:

```html
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="client: chrome" type="JavascriptDebugType" uri="http://localhost:3000" useFirstLineBreakpoints="true">
    <method v="2" />
  </configuration>

  <configuration default="false" name="server: nuxt" type="NodeJSConfigurationType" application-parameters="dev" path-to-js-file="$PROJECT_DIR$/node_modules/nuxt/bin/nuxt.mjs" working-dir="$PROJECT_DIR$">
    <method v="2" />
  </configuration>

  <configuration default="false" name="fullstack: nuxt" type="CompoundRunConfigurationType">
    <toRun name="client: chrome" type="JavascriptDebugType" />
    <toRun name="server: nuxt" type="NodeJSConfigurationType" />
    <method v="2" />
  </configuration>
</component>
```

### Other IDEs

If you have another IDE and would like to contribute sample configuration, feel free to [open a PR](https://github.com/nuxt/nuxt/edit/main/docs/2.guide/3.going-further/9.debugging.md)!
</file>

<file path="docs/3.guide/6.going-further/index.md">
---
navigation: false
redirect: /guide/going-further/tooling
---
</file>

<file path="docs/3.guide/.navigation.yml">
title: 'Guide'
icon: i-lucide-book-open
</file>

<file path="docs/3.guide/0.index.md">
---
title: 'Nuxt Guide'
titleTemplate: '%s'
description: 'Learn how Nuxt works with in-depth guides.'
navigation: false
surround: false
---

::card-group{class="sm:grid-cols-1"}
  ::card{icon="i-lucide-medal" title="Key Concepts" to="/docs/4.x/guide/concepts"}
  Discover the main concepts behind Nuxt, from auto-import, hybrid rendering to its TypeScript support.
  ::
  ::card{icon="i-lucide-square-check" title="Best Practices" to="/docs/4.x/guide/best-practices"}
  Learn about best practices when developing with Nuxt.
  ::
  ::card{icon="i-lucide-bot" title="Working with AI" to="/docs/4.x/guide/ai"}
  Integrate AI tools into your Nuxt workflow with MCP Server and LLMs.txt.
  ::
  ::card{icon="i-lucide-box" title="Module Author Guide" to="/docs/4.x/guide/modules"}
  Learn how to create Nuxt modules to integrate, enhance or extend any Nuxt application.
  ::
  ::card{icon="i-lucide-book-open" title="Recipes" to="/docs/4.x/guide/recipes"}
  Find solutions to common problems and learn how to implement them in your Nuxt project.
  ::
  ::card{icon="i-lucide-star" title="Going Further" to="/docs/4.x/guide/going-further"}
  Master Nuxt with advanced concepts like experimental features, hooks, and more.
  ::
::
</file>

<file path="docs/4.api/1.components/.navigation.yml">
title: 'Components'
titleTemplate: '%s · Nuxt Components'
icon: i-lucide-box
</file>

<file path="docs/4.api/1.components/1.client-only.md">
---
title: '<ClientOnly>'
description: Render components only in client-side with the <ClientOnly> component.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/client-only.ts
    size: xs
---

The `<ClientOnly>` component is used for purposely rendering a component only on client side.

::note
The content of the default slot will be tree-shaken out of the server build. (This does mean that any CSS used by components within it may not be inlined when rendering the initial HTML.)
::

## Props

- `placeholderTag` | `fallbackTag`: specify a tag to be rendered server-side.
- `placeholder` | `fallback`: specify a content to be rendered server-side.

```vue
<template>
  <div>
    <Sidebar />
    <!-- The <Comment> component will only be rendered on client-side -->
    <ClientOnly
      fallback-tag="span"
      fallback="Loading comments..."
    >
      <Comment />
    </ClientOnly>
  </div>
</template>
```

## Slots

- `#fallback`: specify a content to be rendered on the server and displayed until `<ClientOnly>` is mounted in the browser.

```vue [app/pages/example.vue]
<template>
  <div>
    <Sidebar />
    <!-- This renders the "span" element on the server side -->
    <ClientOnly fallback-tag="span">
      <!-- this component will only be rendered on client side -->
      <Comments />
      <template #fallback>
        <!-- this will be rendered on server side -->
        <p>Loading comments...</p>
      </template>
    </ClientOnly>
  </div>
</template>
```

## Examples

### Accessing HTML Elements

Components inside `<ClientOnly>` are rendered only after being mounted. To access the rendered elements in the DOM, you can watch a template ref:

```vue [app/pages/example.vue]
<script setup lang="ts">
const nuxtWelcomeRef = useTemplateRef('nuxtWelcomeRef')

// The watch will be triggered when the component is available
watch(nuxtWelcomeRef, () => {
  console.log('<NuxtWelcome /> mounted')
}, { once: true })
</script>

<template>
  <ClientOnly>
    <NuxtWelcome ref="nuxtWelcomeRef" />
  </ClientOnly>
</template>
```
</file>

<file path="docs/4.api/1.components/1.dev-only.md">
---
title: '<DevOnly>'
description: Render components only during development with the <DevOnly> component.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/dev-only.ts
    size: xs
---

Nuxt provides the `<DevOnly>` component to render a component only during development.

The content will not be included in production builds.

```vue [app/pages/example.vue]
<template>
  <div>
    <Sidebar />
    <DevOnly>
      <!-- this component will only be rendered during development -->
      <LazyDebugBar />

      <!-- if you ever require to have a replacement during production -->
      <!-- be sure to test these using `nuxt preview` -->
      <template #fallback>
        <div><!-- empty div for flex.justify-between --></div>
      </template>
    </DevOnly>
  </div>
</template>
```

## Slots

- `#fallback`: if you ever require to have a replacement during production.

```vue
<template>
  <div>
    <Sidebar />
    <DevOnly>
      <!-- this component will only be rendered during development -->
      <LazyDebugBar />
      <!-- be sure to test these using `nuxt preview` -->
      <template #fallback>
        <div><!-- empty div for flex.justify-between --></div>
      </template>
    </DevOnly>
  </div>
</template>
```
</file>

<file path="docs/4.api/1.components/1.nuxt-client-fallback.md">
---
title: "<NuxtClientFallback>"
description: "Nuxt provides the <NuxtClientFallback> component to render its content on the client if any of its children trigger an error in SSR"
links:
  - label: Source (client)
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/client-fallback.client.ts
    size: xs
  - label: Source (server)
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/client-fallback.server.ts
    size: xs
---

Nuxt provides the `<NuxtClientFallback>` component to render its content on the client if any of its children trigger an error in SSR.

::note{to="/docs/4.x/guide/going-further/experimental-features#clientfallback"}
This component is experimental and in order to use it you must enable the `experimental.clientFallback` option in your `nuxt.config`.
::

```vue [app/pages/example.vue]
<template>
  <div>
    <Sidebar />
    <!-- this component will be rendered on client-side -->
    <NuxtClientFallback fallback-tag="span">
      <Comments />
      <BrokeInSSR />
    </NuxtClientFallback>
  </div>
</template>
```

## Events

- `@ssr-error`: Event emitted when a child triggers an error in SSR. Note that this will only be triggered on the server.

  ```vue
  <template>
    <NuxtClientFallback @ssr-error="logSomeError">
      <!-- ... -->
    </NuxtClientFallback>
  </template>
  ```

## Props

- `placeholderTag` | `fallbackTag`: Specify a fallback tag to be rendered if the slot fails to render on the server.
  - **type**: `string`
  - **default**: `div`
- `placeholder` | `fallback`: Specify fallback content to be rendered if the slot fails to render.
  - **type**: `string`
- `keepFallback`: Keep the fallback content if it failed to render server-side.
  - **type**: `boolean`
  - **default**: `false`

```vue
<template>
  <!-- render <span>Hello world</span> server-side if the default slot fails to render -->
  <NuxtClientFallback
    fallback-tag="span"
    fallback="Hello world"
  >
    <BrokeInSSR />
  </NuxtClientFallback>
</template>
```

## Slots

- `#fallback`: specify content to be displayed server-side if the slot fails to render.

```vue
<template>
  <NuxtClientFallback>
    <!-- ... -->
    <template #fallback>
      <!-- this will be rendered on server side if the default slot fails to render in ssr -->
      <p>Hello world</p>
    </template>
  </NuxtClientFallback>
</template>
```
</file>

<file path="docs/4.api/1.components/10.nuxt-picture.md">
---
title: "<NuxtPicture>"
description: "Nuxt provides a <NuxtPicture> component to handle automatic image optimization."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/image/blob/main/src/runtime/components/NuxtPicture.vue
    size: xs
---

`<NuxtPicture>` is a drop-in replacement for the native `<picture>` tag.

Usage of `<NuxtPicture>` is almost identical to [`<NuxtImg>`](/docs/4.x/api/components/nuxt-img) but it also allows serving modern formats like `webp` when possible.

Learn more about the [`<picture>` tag on MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/picture).

## Setup

In order to use `<NuxtPicture>` you should install and enable the Nuxt Image module:

```bash [Terminal]
npx nuxt module add image
```

::read-more{to="https://image.nuxt.com/usage/nuxt-picture" target="_blank"}
Read more about the `<NuxtPicture>` component.
::
</file>

<file path="docs/4.api/1.components/11.teleports.md">
---
title: '<Teleport>'
description: The <Teleport> component teleports a component to a different location in the DOM.
---

::warning
The `to` target of [`<Teleport>`](https://vuejs.org/guide/built-ins/teleport) expects a CSS selector string or an actual DOM node. Nuxt currently has SSR support for teleports to `#teleports` only, with client-side support for other targets using a `<ClientOnly>` wrapper.
::

## Body Teleport

```vue
<template>
  <button @click="open = true">
    Open Modal
  </button>
  <Teleport to="#teleports">
    <div
      v-if="open"
      class="modal"
    >
      <p>Hello from the modal!</p>
      <button @click="open = false">
        Close
      </button>
    </div>
  </Teleport>
</template>
```

## Client-side Teleport

```vue
<template>
  <ClientOnly>
    <Teleport to="#some-selector">
      <!-- content -->
    </Teleport>
  </ClientOnly>
</template>
```

:link-example{to="/docs/4.x/examples/advanced/teleport"}
</file>

<file path="docs/4.api/1.components/12.nuxt-route-announcer.md">
---
title: '<NuxtRouteAnnouncer>'
description: 'The <NuxtRouteAnnouncer> component adds a hidden element with the page title to announce route changes to assistive technologies.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-route-announcer.ts
    size: xs
---

::important
This component is available in Nuxt v3.12+.
::

## Usage

Add `<NuxtRouteAnnouncer/>` in your [`app.vue`](/docs/4.x/directory-structure/app/app) or [`app/layouts/`](/docs/4.x/directory-structure/app/layouts) to enhance accessibility by informing assistive technologies about page title changes. This ensures that navigational changes are announced to users relying on screen readers.

```vue [app/app.vue]
<template>
  <NuxtRouteAnnouncer />
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

## Slots

You can pass custom HTML or components through the route announcer's default slot.

```vue
<template>
  <NuxtRouteAnnouncer>
    <template #default="{ message }">
      <p>{{ message }} was loaded.</p>
    </template>
  </NuxtRouteAnnouncer>
</template>
```

## Props

- `atomic`: Controls if screen readers only announce changes or the entire content. Set to true for full content readouts on updates, false for changes only. (default `false`)
- `politeness`: Sets the urgency for screen reader announcements: `off` (disable the announcement), `polite` (waits for silence), or `assertive` (interrupts immediately). (default `polite`)

::callout
This component is optional. :br
To achieve full customization, you can implement your own one based on [its source code](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-route-announcer.ts).
::

::callout
You can hook into the underlying announcer instance using [the `useRouteAnnouncer` composable](/docs/4.x/api/composables/use-route-announcer), which allows you to set a custom announcement message.
::
</file>

<file path="docs/4.api/1.components/13.nuxt-time.md">
---
title: '<NuxtTime>'
description: 'The <NuxtTime> component displays time in a locale-friendly format with server-client consistency.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-time.vue
    size: xs
---

::important
This component is available in Nuxt v3.17+.
::

The `<NuxtTime>` component lets you display dates and times in a locale-friendly format with proper `<time>` HTML semantics. It ensures consistent rendering between server and client without hydration mismatches.

## Usage

You can use the `<NuxtTime>` component anywhere in your app:

```vue
<template>
  <NuxtTime :datetime="Date.now()" />
</template>
```

## Props

### `datetime`

- Type: `Date | number | string`
- Required: `true`

The date and time value to display. You can provide:
- A `Date` object
- A timestamp (number)
- An ISO-formatted date string

```vue
<template>
  <NuxtTime :datetime="Date.now()" />
  <NuxtTime :datetime="new Date()" />
  <NuxtTime datetime="2023-06-15T09:30:00.000Z" />
</template>
```

### `locale`

- Type: `string`
- Required: `false`
- Default: Uses the browser or server's default locale

The [BCP 47 language tag](https://datatracker.ietf.org/doc/html/rfc5646) for formatting (e.g., 'en-US', 'fr-FR', 'ja-JP'):

```vue
<template>
  <NuxtTime
    :datetime="Date.now()"
    locale="fr-FR"
  />
</template>
```

### Formatting Props

The component accepts any property from the [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat) options:

```vue
<template>
  <NuxtTime
    :datetime="Date.now()"
    year="numeric"
    month="long"
    day="numeric"
    hour="2-digit"
    minute="2-digit"
  />
</template>
```

This would output something like: "April 22, 2025, 08:30 AM"

### `relative`

- Type: `boolean`
- Required: `false`
- Default: `false`

Enables relative time formatting using the Intl.RelativeTimeFormat API:

```vue
<template>
  <!-- Shows something like "5 minutes ago" -->
  <NuxtTime
    :datetime="Date.now() - 5 * 60 * 1000"
    relative
  />
</template>
```

### Relative Time Formatting Props

When `relative` is set to `true`, the component also accepts properties from [Intl.RelativeTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat):

::warning
Due to `style` being a reserved prop, `relativeStyle` prop is used instead.
::

```vue
<template>
  <NuxtTime
    :datetime="Date.now() - 3 * 24 * 60 * 60 * 1000"
    relative
    numeric="auto"
    relative-style="long"
  />
</template>
```

This would output something like: "3 days ago" or "last Friday" depending on the `numeric` setting.

## Examples

### Basic Usage

```vue
<template>
  <NuxtTime :datetime="Date.now()" />
</template>
```

### Custom Formatting

```vue
<template>
  <NuxtTime
    :datetime="Date.now()"
    weekday="long"
    year="numeric"
    month="short"
    day="numeric"
    hour="numeric"
    minute="numeric"
    second="numeric"
    time-zone-name="short"
  />
</template>
```

### Relative Time

```vue
<template>
  <div>
    <p>
      <NuxtTime
        :datetime="Date.now() - 30 * 1000"
        relative
      />
      <!-- 30 seconds ago -->
    </p>
    <p>
      <NuxtTime
        :datetime="Date.now() - 45 * 60 * 1000"
        relative
      />
      <!-- 45 minutes ago -->
    </p>
    <p>
      <NuxtTime
        :datetime="Date.now() + 2 * 24 * 60 * 60 * 1000"
        relative
      />
      <!-- in 2 days -->
    </p>
  </div>
</template>
```

### With Custom Locale

```vue
<template>
  <div>
    <NuxtTime
      :datetime="Date.now()"
      locale="en-US"
      weekday="long"
    />
    <NuxtTime
      :datetime="Date.now()"
      locale="fr-FR"
      weekday="long"
    />
    <NuxtTime
      :datetime="Date.now()"
      locale="ja-JP"
      weekday="long"
    />
  </div>
</template>
```
</file>

<file path="docs/4.api/1.components/2.nuxt-page.md">
---
title: "<NuxtPage>"
description: The <NuxtPage> component is required to display pages located in the pages/ directory.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/pages/runtime/page.ts
    size: xs
---

`<NuxtPage>` is a built-in component that comes with Nuxt. It lets you display top-level or nested pages located in the [`app/pages/`](/docs/4.x/directory-structure/app/pages) directory.

::note
`<NuxtPage>` is a wrapper around [`<RouterView>`](https://router.vuejs.org/api/interfaces/routerviewprops) from Vue Router. It should be used instead of `<RouterView>` because the former takes additional care of internal states. Otherwise, `useRoute()` may return incorrect paths.
::

`<NuxtPage>` includes the following components:

```vue
<template>
  <RouterView v-slot="{ Component }">
    <!-- Optional, when using transitions -->
    <Transition>
      <!-- Optional, when using keep-alive -->
      <KeepAlive>
        <Suspense>
          <component :is="Component" />
        </Suspense>
      </KeepAlive>
    </Transition>
  </RouterView>
</template>
```

By default, Nuxt does not enable `<Transition>` and `<KeepAlive>`. You can enable them in the nuxt.config file or by setting the `transition` and `keepalive` properties on `<NuxtPage>`. If you want to define a specific page, you can set it in `definePageMeta` in the page component.

::warning
If you enable `<Transition>` in your page component, ensure that the page has a single root element.
::

Since `<NuxtPage>` uses `<Suspense>` under the hood, the component lifecycle behavior during page changes differs from that of a typical Vue application.

In a typical Vue application, a new page component is mounted **only after** the previous one has been fully unmounted. However, in Nuxt, due to how Vue `<Suspense>` is implemented, the new page component is mounted **before** the previous one is unmounted.  

## Props

- `name`: tells `<RouterView>` to render the component with the corresponding name in the matched route record's components option.
  - type: `string`
- `route`: route location that has all of its components resolved.
  - type: `RouteLocationNormalized`
- `pageKey`: control when the `NuxtPage` component is re-rendered.
  - type: `string` or `function`
- `transition`: define global transitions for all pages rendered with the `NuxtPage` component.
  - type: `boolean` or [`TransitionProps`](https://vuejs.org/api/built-in-components#transition)
- `keepalive`: control state preservation of pages rendered with the `NuxtPage` component.
  - type: `boolean` or [`KeepAliveProps`](https://vuejs.org/api/built-in-components#keepalive)

::tip
Nuxt automatically resolves the `name` and `route` by scanning and rendering all Vue component files found in the `/pages` directory.
::

## Example

For example, if you pass a key that never changes, the `<NuxtPage>` component will be rendered only once - when it is first mounted.

```vue [app/app.vue]
<template>
  <NuxtPage page-key="static" />
</template>
```

You can also use a dynamic key based on the current route:

```html
<NuxtPage :page-key="route => route.fullPath" />
```

::warning
Don't use `$route` object here as it can cause problems with how `<NuxtPage>` renders pages with `<Suspense>`.
::

Alternatively, `pageKey` can be passed as a `key` value via [`definePageMeta`](/docs/4.x/api/utils/define-page-meta) from the `<script>` section of your Vue component in the `/pages` directory.

```vue [app/pages/my-page.vue]
<script setup lang="ts">
definePageMeta({
  key: route => route.fullPath,
})
</script>
```

:link-example{to="/docs/4.x/examples/routing/pages"}

## Page's Ref

To get the `ref` of a page component, access it through `ref.value.pageRef`

````vue [app/app.vue]
<script setup lang="ts">
const page = ref()

function logFoo () {
  page.value.pageRef.foo()
}
</script>

<template>
  <NuxtPage ref="page" />
</template>
````

````vue [my-page.vue]
<script setup lang="ts">
const foo = () => {
  console.log('foo method called')
}

defineExpose({
  foo,
})
</script>
````

## Custom Props

`<NuxtPage>` also accepts custom props that you may need to pass further down the hierarchy.

For example, in the below example, the value of `foobar` will be passed to the `NuxtPage` component and then to the page components.

```vue [app/app.vue]
<template>
  <NuxtPage :foobar="123" />
</template>
```

We can access the `foobar` prop in the page component:

```vue [app/pages/page.vue]
<script setup lang="ts">
const props = defineProps<{ foobar: number }>()

console.log(props.foobar) // Outputs: 123
```

If you have not defined the prop with `defineProps`, any props passed down to `NuxtPage` can still be accessed directly from the page `attrs`:

```vue [app/pages/page.vue]
<script setup lang="ts">
const attrs = useAttrs()
console.log(attrs.foobar) // Outputs: 123
</script>
```

:read-more{to="/docs/4.x/directory-structure/app/pages"}
</file>

<file path="docs/4.api/1.components/3.nuxt-layout.md">
---
title: "<NuxtLayout>"
description: "Nuxt provides the <NuxtLayout> component to show layouts on pages and error pages."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-layout.ts
    size: xs
---

You can use `<NuxtLayout />` component to activate the `default` layout on `app.vue` or `error.vue`.

```vue [app/app.vue]
<template>
  <NuxtLayout>
    some page content
  </NuxtLayout>
</template>
```

:read-more{to="/docs/4.x/directory-structure/app/layouts"}

## Props

- `name`: Specify a layout name to be rendered, can be a string, reactive reference or a computed property. It **must** match the name of the corresponding layout file in the [`app/layouts/`](/docs/4.x/directory-structure/app/layouts) directory.
  - **type**: `string`
  - **default**: `default`

```vue [app/pages/index.vue]
<script setup lang="ts">
// layouts/custom.vue
const layout = 'custom'
</script>

<template>
  <NuxtLayout :name="layout">
    <NuxtPage />
  </NuxtLayout>
</template>
```

::note
Please note the layout name is normalized to kebab-case, so if your layout file is named `errorLayout.vue`, it will become `error-layout` when passed as a `name` property to `<NuxtLayout />`.
::

```vue [error.vue]
<template>
  <NuxtLayout name="error-layout">
    <NuxtPage />
  </NuxtLayout>
</template>
```

::read-more{to="/docs/4.x/directory-structure/app/layouts"}
Read more about dynamic layouts.
::

- `fallback`: If an invalid layout is passed to the `name` prop, no layout will be rendered. Specify a `fallback` layout to be rendered in this scenario. It **must** match the name of the corresponding layout file in the [`app/layouts/`](/docs/4.x/directory-structure/app/layouts) directory.
  - **type**: `string`
  - **default**: `null`

## Additional Props

`NuxtLayout` also accepts any additional props that you may need to pass to the layout. These custom props are then made accessible as attributes.

```vue [app/pages/some-page.vue]
<template>
  <div>
    <NuxtLayout
      name="custom"
      title="I am a custom layout"
    >
      <!-- ... -->
    </NuxtLayout>
  </div>
</template>
```

In the above example, the value of `title` will be available using `$attrs.title` in the template or `useAttrs().title` in `<script setup>` at custom.vue.

```vue [app/layouts/custom.vue]
<script setup lang="ts">
const layoutCustomProps = useAttrs()

console.log(layoutCustomProps.title) // I am a custom layout
</script>
```

## Transitions

`<NuxtLayout />` renders incoming content via `<slot />`, which is then wrapped around Vue’s `<Transition />` component to activate layout transition. For this to work as expected, it is recommended that `<NuxtLayout />` is **not** the root element of the page component.

::code-group

```vue [app/pages/index.vue]
<template>
  <div>
    <NuxtLayout name="custom">
      <template #header>
        Some header template content.
      </template>
    </NuxtLayout>
  </div>
</template>
```

```vue [app/layouts/custom.vue]
<template>
  <div>
    <!-- named slot -->
    <slot name="header" />
    <slot />
  </div>
</template>
```

::

:read-more{to="/docs/4.x/getting-started/transitions"}

## Layout's Ref

To get the ref of a layout component, access it through `ref.value.layoutRef`.

::code-group

```vue [app/app.vue]
<script setup lang="ts">
const layout = ref()

function logFoo () {
  layout.value.layoutRef.foo()
}
</script>

<template>
  <NuxtLayout ref="layout">
    default layout
  </NuxtLayout>
</template>
```

```vue [app/layouts/default.vue]
<script setup lang="ts">
const foo = () => console.log('foo')
defineExpose({
  foo,
})
</script>

<template>
  <div>
    default layout
    <slot />
  </div>
</template>
```

::

:read-more{to="/docs/4.x/directory-structure/app/layouts"}
</file>

<file path="docs/4.api/1.components/4.nuxt-link.md">
---
title: "<NuxtLink>"
description: "Nuxt provides <NuxtLink> component to handle any kind of links within your application."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts
    size: xs
---

::note
`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is _internal_ or _external_ and renders it accordingly with available optimizations (prefetching, default attributes, etc.)
::

## Internal Routing

In this example, we use `<NuxtLink>` component to link to another page of the application.

::code-group
```vue [app/pages/index.vue]
<template>
  <NuxtLink to="/about">About page</NuxtLink>
</template>
```

```html [(Renders as) index.html]
<!-- (Vue Router & Smart Prefetching) -->
<a href="/about">About page</a>
```
::

### Passing Params to Dynamic Routes

In this example, we pass the `id` param to link to the route `~/pages/posts/[id].vue`.

::code-group
```vue [app/pages/index.vue]
<template>
  <NuxtLink :to="{ name: 'posts-id', params: { id: 123 } }">
    Post 123
  </NuxtLink>
</template>
```

```html [(Renders as) index.html]
<a href="/posts/123">Post 123</a>
```
::

::tip
Check out the Pages panel in Nuxt DevTools to see the route name and the params it might take.
::

::tip
When you pass an object into the `to` prop, `<NuxtLink>` will inherit Vue Router’s handling of query parameters. Keys and values will be automatically encoded, so you don’t need to call `encodeURI` or `encodeURIComponent` manually.
::

### Handling Static File and Cross-App Links

By default, `<NuxtLink>` uses Vue Router's client side navigation for relative route. When linking to static files in the `/public` directory or to another application hosted on the same domain, it might result in unexpected 404 errors because they are not part of the client routes. In such cases, you can use the `external` prop with `<NuxtLink>` to bypass Vue Router's internal routing mechanism.

The `external` prop explicitly indicates that the link is external. `<NuxtLink>` will render the link as a standard HTML `<a>` tag. This ensures the link behaves correctly, bypassing Vue Router’s logic and directly pointing to the resource.

#### Linking to Static Files

For static files in the `/public` directory, such as PDFs or images, use the `external` prop to ensure the link resolves correctly.

```vue [app/pages/index.vue]
<template>
  <NuxtLink
    to="/example-report.pdf"
    external
  >
    Download Report
  </NuxtLink>
</template>
```

#### Linking to a Cross-App URL

When pointing to a different application on the same domain, using the `external` prop ensures the correct behavior.

```vue [app/pages/index.vue]
<template>
  <NuxtLink
    to="/another-app"
    external
  >
    Go to Another App
  </NuxtLink>
</template>
```

Using the `external` prop or relying on automatic handling ensures proper navigation, avoids unexpected routing issues, and improves compatibility with static resources or cross-application scenarios.

## External Routing

In this example, we use `<NuxtLink>` component to link to a website.

```vue [app/app.vue]
<template>
  <NuxtLink to="https://nuxtjs.org">
    Nuxt website
  </NuxtLink>
  <!-- <a href="https://nuxtjs.org" rel="noopener noreferrer">...</a> -->
</template>
```

## `rel` and `noRel` Attributes

A `rel` attribute of `noopener noreferrer` is applied by default to links with a `target` attribute or to absolute links (e.g., links starting with `http://`, `https://`, or `//`).
- `noopener` solves a [security bug](https://mathiasbynens.github.io/rel-noopener/) in older browsers.
- `noreferrer` improves privacy for your users by not sending the `Referer` header to the linked site.

These defaults have no negative impact on SEO and are considered [best practice](https://developer.chrome.com/docs/lighthouse/best-practices/external-anchors-use-rel-noopener).

When you need to overwrite this behavior you can use the `rel` or `noRel` props.

```vue [app/app.vue]
<template>
  <NuxtLink to="https://twitter.com/nuxt_js">
    Nuxt Twitter
  </NuxtLink>
  <!-- <a href="https://twitter.com/nuxt_js" rel="noopener noreferrer">...</a> -->

  <NuxtLink
    to="https://discord.nuxtjs.org"
    rel="noopener"
  >
    Nuxt Discord
  </NuxtLink>
  <!-- <a href="https://discord.nuxtjs.org" rel="noopener">...</a> -->

  <NuxtLink
    to="/about"
    target="_blank"
  >About page</NuxtLink>
  <!-- <a href="/about" target="_blank" rel="noopener noreferrer">...</a> -->
</template>
```

A `noRel` prop can be used to prevent the default `rel` attribute from being added to the absolute links.

```vue [app/app.vue]
<template>
  <NuxtLink
    to="https://github.com/nuxt"
    no-rel
  >
    Nuxt GitHub
  </NuxtLink>
  <!-- <a href="https://github.com/nuxt">...</a> -->
</template>
```

::note
`noRel` and `rel` cannot be used together. `rel` will be ignored.
::

## Prefetch Links

Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link. Nuxt only loads the resources when the browser isn't busy and skips prefetching if your connection is offline or if you only have 2g connection.

```vue [app/pages/index.vue]
<NuxtLink to="/about" no-prefetch>
About page not pre-fetched
</NuxtLink>

<NuxtLink to="/about" :prefetch="false">
About page not pre-fetched
</NuxtLink>
```

### Custom Prefetch Triggers

We now support custom prefetch triggers for `<NuxtLink>` after `v3.13.0`. You can use the `prefetchOn` prop to control when to prefetch links.

```vue
<template>
  <NuxtLink prefetch-on="visibility">
    This will prefetch when it becomes visible (default)
  </NuxtLink>

  <NuxtLink prefetch-on="interaction">
    This will prefetch when hovered or when it gains focus
  </NuxtLink>
</template>
```

- `visibility`: Prefetches when the link becomes visible in the viewport. Monitors the element's intersection with the viewport using the [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API). Prefetching is triggered when the element is scrolled into view.
- `interaction`: Prefetches when the link is hovered or focused. This approach listens for `pointerenter` and `focus` events, proactively prefetching resources when the user indicates intent to interact.

You can also use an object to configure `prefetchOn`:

```vue
<template>
  <NuxtLink :prefetch-on="{ interaction: true }">
    This will prefetch when hovered or when it gains focus
  </NuxtLink>
</template>
```

That you probably don't want both enabled!

```vue
<template>
  <NuxtLink :prefetch-on="{ visibility: true, interaction: true }">
    This will prefetch when hovered/focus - or when it becomes visible
  </NuxtLink>
</template>
```

This configuration will observe when the element enters the viewport and also listen for `pointerenter` and `focus` events. This may result in unnecessary resource usage or redundant prefetching, as both triggers can prefetch the same resource under different conditions.

### Enable Cross-origin Prefetch

To enable cross-origin prefetching, you can set the `crossOriginPrefetch` option in your `nuxt.config`. This will enable cross-origin prefetching using the [Speculation Rules API](https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API).

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    crossOriginPrefetch: true,
  },
})
```

### Disable prefetch globally

It's also possible to enable/disable prefetching all links globally for your app.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        prefetch: false,
      },
    },
  },
})
```

## Props

### RouterLink

When not using `external`, `<NuxtLink>` supports all Vue Router's [`RouterLink` props](https://router.vuejs.org/api/interfaces/routerlinkprops)

- `to`: Any URL or a [route location object](https://router.vuejs.org/api/type-aliases/routelocation) from Vue Router
- `custom`: Whether `<NuxtLink>` should wrap its content in an `<a>` element. It allows taking full control of how a link is rendered and how navigation works when it is clicked. Works the same as [Vue Router's `custom` prop](https://router.vuejs.org/api/interfaces/routerlinkprops#custom-)
- `exactActiveClass`: A class to apply on exact active links. Works the same as [Vue Router's `exactActiveClass` prop](https://router.vuejs.org/api/interfaces/routerlinkprops#exactActiveClass-) on internal links. Defaults to Vue Router's default (`"router-link-exact-active"`)
- `activeClass`: A class to apply on active links. Works the same as [Vue Router's `activeClass` prop](https://router.vuejs.org/api/interfaces/routerlinkprops#activeClass-) on internal links. Defaults to Vue Router's default (`"router-link-active"`)
- `replace`: Works the same as [Vue Router's `replace` prop](https://router.vuejs.org/api/interfaces/routelocationoptions#replace-) on internal links
- `ariaCurrentValue`: An `aria-current` attribute value to apply on exact active links. Works the same as [Vue Router's `ariaCurrentValue` prop](https://router.vuejs.org/api/interfaces/routerlinkprops#ariaCurrentValue-) on internal links

### NuxtLink

- `href`: An alias for `to`. If used with `to`, `href` will be ignored
- `noRel`: If set to `true`, no `rel` attribute will be added to the external link
- `external`: Forces the link to be rendered as an `<a>` tag instead of a Vue Router `RouterLink`.
- `prefetch`: When enabled will prefetch middleware, layouts and payloads (when using [payloadExtraction](/docs/4.x/guide/going-further/experimental-features#payloadextraction)) of links in the viewport. Used by the experimental [crossOriginPrefetch](/docs/4.x/guide/going-further/experimental-features#crossoriginprefetch) config.
- `prefetchOn`: Allows custom control of when to prefetch links. Possible options are `interaction` and `visibility` (default). You can also pass an object for full control, for example: `{ interaction: true, visibility: true }`. This prop is only used when `prefetch` is enabled (default) and `noPrefetch` is not set.
- `noPrefetch`: Disables prefetching.
- `prefetchedClass`: A class to apply to links that have been prefetched.

### Anchor

- `target`: A `target` attribute value to apply on the link
- `rel`: A `rel` attribute value to apply on the link. Defaults to `"noopener noreferrer"` for external links.

::tip
Defaults can be overwritten, see [overwriting defaults](/docs/4.x/api/components/nuxt-link#overwriting-defaults) if you want to change them.
::

## Overwriting Defaults

### In Nuxt Config

You can overwrite some `<NuxtLink>` defaults in your [`nuxt.config`](/docs/4.x/guide/going-further/experimental-features#defaults)

::important
These options will likely be moved elsewhere in the future, such as into `app.config` or into the `app/` directory.
::

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    defaults: {
      nuxtLink: {
        // default values
        componentName: 'NuxtLink',
        externalRelAttribute: 'noopener noreferrer',
        activeClass: 'router-link-active',
        exactActiveClass: 'router-link-exact-active',
        prefetchedClass: undefined, // can be any valid string class name
        trailingSlash: undefined, // can be 'append' or 'remove'
        prefetch: true,
        prefetchOn: { visibility: true },
      },
    },
  },
})
```

### Custom Link Component

You can overwrite `<NuxtLink>` defaults by creating your own link component using `defineNuxtLink`.

```ts [app/components/MyNuxtLink.ts]
export default defineNuxtLink({
  componentName: 'MyNuxtLink',
  /* see signature below for more */
})
```

You can then use `<MyNuxtLink />` component as usual with your new defaults.

### `defineNuxtLink` Signature

```ts
interface NuxtLinkOptions {
  componentName?: string
  externalRelAttribute?: string
  activeClass?: string
  exactActiveClass?: string
  trailingSlash?: 'append' | 'remove'
  prefetch?: boolean
  prefetchedClass?: string
  prefetchOn?: Partial<{
    visibility: boolean
    interaction: boolean
  }>
}
function defineNuxtLink (options: NuxtLinkOptions): Component {}
```

- `componentName`: A name for the component. Default is `NuxtLink`.
- `externalRelAttribute`: A default `rel` attribute value applied on external links. Defaults to `"noopener noreferrer"`. Set it to `""` to disable
- `activeClass`: A default class to apply on active links. Works the same as [Vue Router's `linkActiveClass` option](https://router.vuejs.org/api/interfaces/routeroptions#linkActiveClass-). Defaults to Vue Router's default (`"router-link-active"`)
- `exactActiveClass`: A default class to apply on exact active links. Works the same as [Vue Router's `linkExactActiveClass` option](https://router.vuejs.org/api/interfaces/routeroptions#linkExactActiveClass-). Defaults to Vue Router's default (`"router-link-exact-active"`)
- `trailingSlash`: An option to either add or remove trailing slashes in the `href`. If unset or not matching the valid values `append` or `remove`, it will be ignored.
- `prefetch`: Whether or not to prefetch links by default.
- `prefetchOn`: Granular control of which prefetch strategies to apply by default.
- `prefetchedClass`: A default class to apply to links that have been prefetched.

:link-example{to="/docs/4.x/examples/routing/pages"}
</file>

<file path="docs/4.api/1.components/5.nuxt-loading-indicator.md">
---
title: '<NuxtLoadingIndicator>'
description: 'Display a progress bar between page navigations.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-loading-indicator.ts
    size: xs
---

## Usage

Add `<NuxtLoadingIndicator/>` in your [`app.vue`](/docs/4.x/directory-structure/app/app) or [`app/layouts/`](/docs/4.x/directory-structure/app/layouts).

```vue [app/app.vue]
<template>
  <NuxtLoadingIndicator />
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
```

:link-example{to="/docs/4.x/examples/routing/pages"}

## Slots

You can pass custom HTML or components through the loading indicator's default slot.

## Props

- `color`: The color of the loading bar. It can be set to `false` to turn off explicit color styling.
- `errorColor`: The color of the loading bar when `error` is set to `true`.
- `height`: Height of the loading bar, in pixels (default `3`).
- `duration`: Duration of the loading bar, in milliseconds (default `2000`).
- `throttle`: Throttle the appearing and hiding, in milliseconds (default `200`).
- `estimatedProgress`: By default Nuxt will back off as it approaches 100%. You can provide a custom function to customize the progress estimation, which is a function that receives the duration of the loading bar (above) and the elapsed time. It should return a value between 0 and 100.

::note
This component is optional. :br
To achieve full customization, you can implement your own one based on [its source code](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-loading-indicator.ts).
::

::note
You can hook into the underlying indicator instance using [the `useLoadingIndicator` composable](/docs/4.x/api/composables/use-loading-indicator), which will allow you to trigger start/finish events yourself.
::

::tip
The loading indicator's speed gradually decreases after reaching a specific point controlled by `estimatedProgress`. This adjustment provides a more accurate reflection of longer page loading times and prevents the indicator from prematurely showing 100% completion.
::
</file>

<file path="docs/4.api/1.components/6.nuxt-error-boundary.md">
---
title: "<NuxtErrorBoundary>"
description: The <NuxtErrorBoundary> component handles client-side errors happening in its default slot.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-error-boundary.vue
    size: xs
---

::tip
The `<NuxtErrorBoundary>` uses Vue's [`onErrorCaptured`](https://vuejs.org/api/composition-api-lifecycle#onerrorcaptured) hook under the hood.
::

## Events

- `@error`: Event emitted when the default slot of the component throws an error.

  ```vue
  <template>
    <NuxtErrorBoundary @error="logSomeError">
      <!-- ... -->
    </NuxtErrorBoundary>
  </template>
  ```

## Slots

- `#error`: Specify a fallback content to display in case of error.

  ```vue
  <template>
    <NuxtErrorBoundary>
      <!-- ... -->
      <template #error="{ error, clearError }">
        <p>An error occurred: {{ error }}</p>

        <button @click="clearError">
          Clear error
        </button>
      </template>
    </NuxtErrorBoundary>
  </template>
  ```

:read-more{to="/docs/4.x/getting-started/error-handling"}

## Examples

### Accessing `error` and `clearError` in script

You can access `error` and `clearError` properties within the component's script as below:

```vue
<template>
  <NuxtErrorBoundary ref="errorBoundary">
    <!-- ... -->
  </NuxtErrorBoundary>
</template>

<script setup lang="ts">
const errorBoundary = useTemplateRef('errorBoundary')

// errorBoundary.value?.error
// errorBoundary.value?.clearError()
</script>
```
</file>

<file path="docs/4.api/1.components/7.nuxt-welcome.md">
---
title: '<NuxtWelcome>'
description: The <NuxtWelcome> component greets users in new projects made from the starter template.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/ui-templates/templates/welcome/index.html
    size: xs
---

It includes links to the Nuxt documentation, source code, and social media accounts.

```vue [app/app.vue]
<template>
  <NuxtWelcome />
</template>
```

::read-more{to="https://templates.ui.nuxtjs.org/templates/welcome" target="_blank"}
Preview the `<NuxtWelcome />` component.
::

::tip
This component is part of [`@nuxt/ui-templates`](https://github.com/nuxt/nuxt/tree/main/packages/ui-templates) package.
::
</file>

<file path="docs/4.api/1.components/8.nuxt-island.md">
---
title: "<NuxtIsland>"
description: "Nuxt provides the <NuxtIsland> component to render a non-interactive component without any client JS."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-island.ts
    size: xs
---

When rendering an island component, the content of the island component is static, thus no JS is downloaded client-side.

Changing the island component props triggers a refetch of the island component to re-render it again.

::note
Global styles of your application are sent with the response.
::

::tip
Server only components use `<NuxtIsland>` under the hood
::

## Props

- `name` : Name of the component to render.
  - **type**: `string`
  - **required**
- `lazy`: Make the component non-blocking.
  - **type**: `boolean`
  - **default**: `false`
- `props`: Props to send to the component to render.
  - **type**: `Record<string, any>`
- `source`: Remote source to call the island to render.
  - **type**: `string`
- **dangerouslyLoadClientComponents**: Required to load components from a remote source.
  - **type**: `boolean`
  - **default**: `false`

::note
Remote islands need `experimental.componentIslands` to be `'local+remote'` in your `nuxt.config`.
It is strongly discouraged to enable `dangerouslyLoadClientComponents` as you can't trust a remote server's javascript.
::

::note
By default, component islands are scanned from the `~/components/islands/` directory. So the `~/components/islands/MyIsland.vue` component could be rendered with `<NuxtIsland name="MyIsland" />`.
::

## Slots

Slots can be passed to an island component if declared.

Every slot is interactive since the parent component is the one providing it.

Some slots are reserved to `NuxtIsland` for special cases.

- `#fallback`: Specify the content to be rendered before the island loads (if the component is lazy) or if `NuxtIsland` fails to fetch the component.

## Ref

- `refresh()`
  - **type**: `() => Promise<void>`
  - **description**: force refetch the server component by refetching it.

## Events

- `error`
  - **parameters**:
    - **error**:
      - **type**: `unknown`
  - **description**: emitted when when `NuxtIsland` fails to fetch the new island.
</file>

<file path="docs/4.api/1.components/9.nuxt-img.md">
---
title: "<NuxtImg>"
description: "Nuxt provides a <NuxtImg> component to handle automatic image optimization."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/image/blob/main/src/runtime/components/NuxtImg.vue
    size: xs
---

`<NuxtImg>` is a drop-in replacement for the native `<img>` tag.

- Uses built-in provider to optimize local and remote images
- Converts `src` to provider-optimized URLs
- Automatically resizes images based on `width` and `height`
- Generates responsive sizes when providing `sizes` option
- Supports native lazy loading as well as other `<img>` attributes

## Setup

In order to use `<NuxtImg>` you should install and enable the Nuxt Image module:

```bash [Terminal]
npx nuxt module add image
```

## Usage

`<NuxtImg>` outputs a native `img` tag directly (without any wrapper around it). Use it like you would use the `<img>` tag:

```html
<NuxtImg src="/nuxt-icon.png" />
```

Will result in:

```html
<img src="/nuxt-icon.png" />
```

::read-more{to="https://image.nuxt.com/usage/nuxt-img" target="_blank"}
Read more about the `<NuxtImg>` component.
::
</file>

<file path="docs/4.api/2.composables/.navigation.yml">
title: 'Composables'
titleTemplate: '%s · Nuxt Composables'
icon: i-lucide-arrow-left-right
</file>

<file path="docs/4.api/2.composables/on-prehydrate.md">
---
title: "onPrehydrate"
description: "Use onPrehydrate to run a callback on the client immediately before Nuxt hydrates the page."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/ssr.ts
    size: xs
---

::important
This composable is available in Nuxt v3.12+.
::

`onPrehydrate` is a composable lifecycle hook that allows you to run a callback on the client immediately before Nuxt hydrates the page.
::note
This is an advanced utility and should be used with care. For example, [`nuxt-time`](https://github.com/danielroe/nuxt-time/pull/251) and [`@nuxtjs/color-mode`](https://github.com/nuxt-modules/color-mode/blob/main/src/script.js) manipulate the DOM to avoid hydration mismatches.
::

## Usage

Call `onPrehydrate` in the setup function of a Vue component (e.g., in `<script setup>`) or in a plugin. It only has an effect when called on the server and will not be included in your client build.

## Type

```ts [Signature]
export function onPrehydrate (callback: (el: HTMLElement) => void): void
export function onPrehydrate (callback: string | ((el: HTMLElement) => void), key?: string): undefined | string
```

## Parameters

| Parameter | Type | Required | Description |
| ---- | --- | --- | --- |
| `callback` | `((el: HTMLElement) => void) \| string` | Yes | A function (or stringified function) to run before Nuxt hydrates. It will be stringified and inlined in the HTML. Should not have external dependencies or reference variables outside the callback. Runs before Nuxt runtime initializes, so it should not rely on Nuxt or Vue context. |
| `key` | `string` | No | (Advanced) A unique key to identify the prehydrate script, useful for advanced scenarios like multiple root nodes. |

## Return Values

- Returns `undefined` when called with only a callback function.
- Returns a string (the prehydrate id) when called with a callback and a key, which can be used to set or access the `data-prehydrate-id` attribute for advanced use cases.

## Example

```vue twoslash [app/app.vue]
<script setup lang="ts">
declare const window: Window
// ---cut---
// Run code before Nuxt hydrates
onPrehydrate(() => {
  console.log(window)
})

// Access the root element
onPrehydrate((el) => {
  console.log(el.outerHTML)
  // <div data-v-inspector="app.vue:15:3" data-prehydrate-id=":b3qlvSiBeH:"> Hi there </div>
})

// Advanced: access/set `data-prehydrate-id` yourself
const prehydrateId = onPrehydrate((el) => {})
</script>

<template>
  <div>
    Hi there
  </div>
</template>
```
</file>

<file path="docs/4.api/2.composables/use-app-config.md">
---
title: 'useAppConfig'
description: 'Access the reactive app config defined in the project.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/config.ts
    size: xs
---

## Usage

```ts
const appConfig = useAppConfig()

console.log(appConfig)
```

:read-more{to="/docs/4.x/directory-structure/app/app-config"}
</file>

<file path="docs/4.api/2.composables/use-async-data.md">
---
title: 'useAsyncData'
description: useAsyncData provides access to data that resolves asynchronously in an SSR-friendly composable.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/asyncData.ts
    size: xs
---

Within your pages, components, and plugins you can use useAsyncData to get access to data that resolves asynchronously.

::note
[`useAsyncData`](/docs/4.x/api/composables/use-async-data) is a composable meant to be called directly in the [Nuxt context](/docs/4.x/guide/going-further/nuxt-app#the-nuxt-context). It returns reactive composables and handles adding responses to the Nuxt payload so they can be passed from server to client **without re-fetching the data on client side** when the page hydrates.
::

## Usage

```vue [app/pages/index.vue]
<script setup lang="ts">
const { data, status, pending, error, refresh, clear } = await useAsyncData(
  'mountains',
  (_nuxtApp, { signal }) => $fetch('https://api.nuxtjs.dev/mountains', { signal }),
)
</script>
```

::warning
If you're using a custom useAsyncData wrapper, do not await it in the composable, as that can cause unexpected behavior. Please follow [this recipe](/docs/4.x/guide/recipes/custom-usefetch#custom-usefetchuseasyncdata) for more information on how to make a custom async data fetcher.
::

::note
`data`, `status`, `pending` and `error` are Vue refs and they should be accessed with `.value` when used within the `<script setup>`, while `refresh`/`execute` and `clear` are plain functions.
::

### Watch Params

The built-in `watch` option allows automatically rerunning the fetcher function when any changes are detected.

```vue [app/pages/index.vue]
<script setup lang="ts">
const page = ref(1)
const { data: posts } = await useAsyncData(
  'posts',
  (_nuxtApp, { signal }) => $fetch('https://fakeApi.com/posts', {
    params: {
      page: page.value,
    },
    signal,
  }), {
    watch: [page],
  },
)
</script>
```

### Reactive Keys

You can use a computed ref, plain ref or a getter function as the key, allowing for dynamic data fetching that automatically updates when the key changes:

```vue [app/pages/[id\\].vue]
<script setup lang="ts">
const route = useRoute()
const userId = computed(() => `user-${route.params.id}`)

// When the route changes and userId updates, the data will be automatically refetched
const { data: user } = useAsyncData(
  userId,
  () => fetchUserById(route.params.id),
)
</script>
```

### Make your `handler` abortable

You can make your `handler` function abortable by using the `signal` provided in the second argument. This is useful for cancelling requests when they are no longer needed, such as when a user navigates away from a page. `$fetch` natively supports abort signals.

```ts
const { data, error } = await useAsyncData(
  'users',
  (_nuxtApp, { signal }) => $fetch('/api/users', { signal }),
)

refresh() // will actually cancel the $fetch request (if dedupe: cancel)
refresh() // will actually cancel the $fetch request (if dedupe: cancel)
refresh()

clear() // will cancel the latest pending handler
```

You can also pass an `AbortSignal` to the `refresh`/`execute` function to cancel individual requests manually.

```ts
const { refresh } = await useAsyncData(
  'users',
  (_nuxtApp, { signal }) => $fetch('/api/users', { signal }),
)
let abortController: AbortController | undefined

function handleUserAction () {
  abortController = new AbortController()
  refresh({ signal: abortController.signal })
}

function handleCancel () {
  abortController?.abort() // aborts the ongoing refresh request
}
```

If your `handler` function does not support abort signals, you can implement your own abort logic using the `signal` provided.

```ts
const { data, error } = await useAsyncData(
  'users',
  (_nuxtApp, { signal }) => {
    return new Promise((resolve, reject) => {
      signal?.addEventListener('abort', () => {
        reject(new Error('Request aborted'))
      })
      return Promise.resolve(callback.call(this, yourHandler)).then(resolve, reject)
    })
  },
)
```

The handler signal will be aborted when:

- A new request is made with `dedupe: 'cancel'`
- The `clear` function is called
- The `options.timeout` duration is exceeded

::warning
[`useAsyncData`](/docs/4.x/api/composables/use-async-data) is a reserved function name transformed by the compiler, so you should not name your own function [`useAsyncData`](/docs/4.x/api/composables/use-async-data).
::

:read-more{to="/docs/4.x/getting-started/data-fetching#useasyncdata"}

## Params

- `key`: a unique key to ensure that data fetching can be properly de-duplicated across requests. If you do not provide a key, then a key that is unique to the file name and line number of the instance of `useAsyncData` will be generated for you.
- `handler`: an asynchronous function that must return a truthy value (for example, it should not be `undefined` or `null`) or the request may be duplicated on the client side.
::warning
The `handler` function should be **side-effect free** to ensure predictable behavior during SSR and CSR hydration. If you need to trigger side effects, use the [`callOnce`](/docs/4.x/api/utils/call-once) utility to do so.
::
- `options`:
  - `server`: whether to fetch the data on the server (defaults to `true`)
  - `lazy`: whether to resolve the async function after loading the route, instead of blocking client-side navigation (defaults to `false`)
  - `immediate`: when set to `false`, will prevent the request from firing immediately. (defaults to `true`)
  - `default`: a factory function to set the default value of the `data`, before the async function resolves - useful with the `lazy: true` or `immediate: false` option
  - `transform`: a function that can be used to alter `handler` function result after resolving
  - `getCachedData`: Provide a function which returns cached data. A `null` or `undefined` return value will trigger a fetch. By default, this is:
    ```ts
    const getDefaultCachedData = (key, nuxtApp, ctx) => nuxtApp.isHydrating
      ? nuxtApp.payload.data[key]
      : nuxtApp.static.data[key]
    ```
    Which only caches data when `experimental.payloadExtraction` of `nuxt.config` is enabled.
  - `pick`: only pick specified keys in this array from the `handler` function result
  - `watch`: watch reactive sources to auto-refresh
  - `deep`: return data in a deep ref object. It is `false` by default to return data in a shallow ref object, which can improve performance if your data does not need to be deeply reactive.
  - `dedupe`: avoid fetching same key more than once at a time (defaults to `cancel`). Possible options:
    - `cancel` - cancels existing requests when a new one is made
    - `defer` - does not make new requests at all if there is a pending request
  - `timeout` - a number in milliseconds to wait before timing out the request (defaults to `undefined`, which means no timeout)

::note
Under the hood, `lazy: false` uses `<Suspense>` to block the loading of the route before the data has been fetched. Consider using `lazy: true` and implementing a loading state instead for a snappier user experience.
::

::read-more{to="/docs/4.x/api/composables/use-lazy-async-data"}
You can use `useLazyAsyncData` to have the same behavior as `lazy: true` with `useAsyncData`.
::

:video-accordion{title="Watch a video from Alexander Lichter about client-side caching with getCachedData" videoId="aQPR0xn-MMk"}

### Shared State and Option Consistency

When using the same key for multiple `useAsyncData` calls, they will share the same `data`, `error`, `status` and `pending` refs. This ensures consistency across components but requires option consistency.

The following options **must be consistent** across all calls with the same key:
- `handler` function
- `deep` option
- `transform` function
- `pick` array
- `getCachedData` function
- `default` value

The following options **can differ** without triggering warnings:
- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ❌ This will trigger a development warning
const { data: users1 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { deep: false })
const { data: users2 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { deep: true })

// ✅ This is allowed
const { data: users1 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { immediate: true })
const { data: users2 } = useAsyncData('users', (_nuxtApp, { signal }) => $fetch('/api/users', { signal }), { immediate: false })
```

::tip
Keyed state created using `useAsyncData` can be retrieved across your Nuxt application using [`useNuxtData`](/docs/4.x/api/composables/use-nuxt-data).
::

## Return Values

- `data`: the result of the asynchronous function that is passed in.
- `refresh`/`execute`: a function that can be used to refresh the data returned by the `handler` function.
- `error`: an error object if the data fetching failed.
- `status`: a string indicating the status of the data request:
  - `idle`: when the request has not started, such as:
    - when `execute` has not yet been called and `{ immediate: false }` is set
    - when rendering HTML on the server and `{ server: false }` is set
  - `pending`: the request is in progress
  - `success`: the request has completed successfully
  - `error`: the request has failed
- `pending`: a `Ref<boolean>` that is `true` while the request is in progress (that is, while `status.value === 'pending'`).
- `clear`: a function that can be used to set `data` to `undefined` (or the value of `options.default()` if provided), set `error` to `undefined`, set `status` to `idle`, and mark any currently pending requests as cancelled.

By default, Nuxt waits until a `refresh` is finished before it can be executed again.

::note
If you have not fetched data on the server (for example, with `server: false`), then the data _will not_ be fetched until hydration completes. This means even if you await [`useAsyncData`](/docs/4.x/api/composables/use-async-data) on the client side, `data` will remain `undefined` within `<script setup>`.
::

## Type

```ts [Signature]
export type AsyncDataHandler<ResT> = (nuxtApp: NuxtApp, options: { signal: AbortSignal }) => Promise<ResT>

export function useAsyncData<DataT, DataE> (
  handler: AsyncDataHandler<DataT>,
  options?: AsyncDataOptions<DataT>,
): AsyncData<DataT, DataE>
export function useAsyncData<DataT, DataE> (
  key: MaybeRefOrGetter<string>,
  handler: AsyncDataHandler<DataT>,
  options?: AsyncDataOptions<DataT>,
): Promise<AsyncData<DataT, DataE>>

type AsyncDataOptions<DataT> = {
  server?: boolean
  lazy?: boolean
  immediate?: boolean
  deep?: boolean
  dedupe?: 'cancel' | 'defer'
  default?: () => DataT | Ref<DataT> | null
  transform?: (input: DataT) => DataT | Promise<DataT>
  pick?: string[]
  watch?: MultiWatchSources | false
  getCachedData?: (key: string, nuxtApp: NuxtApp, ctx: AsyncDataRequestContext) => DataT | undefined
  timeout?: number
}

type AsyncDataRequestContext = {
  /** The reason for this data request */
  cause: 'initial' | 'refresh:manual' | 'refresh:hook' | 'watch'
}

type AsyncData<DataT, ErrorT> = {
  data: Ref<DataT | undefined>
  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>
  execute: (opts?: AsyncDataExecuteOptions) => Promise<void>
  clear: () => void
  error: Ref<ErrorT | undefined>
  status: Ref<AsyncDataRequestStatus>
  pending: Ref<boolean>
}

interface AsyncDataExecuteOptions {
  dedupe?: 'cancel' | 'defer'
  timeout?: number
  signal?: AbortSignal
}

type AsyncDataRequestStatus = 'idle' | 'pending' | 'success' | 'error'
```

:read-more{to="/docs/4.x/getting-started/data-fetching"}
</file>

<file path="docs/4.api/2.composables/use-cookie.md">
---
title: 'useCookie'
description: useCookie is an SSR-friendly composable to read and write cookies.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/cookie.ts
    size: xs
---

## Usage

Within your pages, components, and plugins, you can use `useCookie` to read and write cookies in an SSR-friendly way.

```ts
const cookie = useCookie(name, options)
```

::note
`useCookie` only works in the [Nuxt context](/docs/4.x/guide/going-further/nuxt-app#the-nuxt-context).
::

::tip
The returned ref will automatically serialize and deserialize cookie values to JSON.
::

## Type

```ts [Signature]
import type { Ref } from 'vue'
import type { CookieParseOptions, CookieSerializeOptions } from 'cookie-es'

export interface CookieOptions<T = any> extends Omit<CookieSerializeOptions & CookieParseOptions, 'decode' | 'encode'> {
  decode?(value: string): T
  encode?(value: T): string
  default?: () => T | Ref<T>
  watch?: boolean | 'shallow'
  readonly?: boolean
}

export interface CookieRef<T> extends Ref<T> {}

export function useCookie<T = string | null | undefined> (
  name: string,
  options?: CookieOptions<T>,
): CookieRef<T>
```

## Parameters

`name`: The name of the cookie.

`options`: Options to control cookie behavior. The object can have the following properties:

Most of the options will be directly passed to the [cookie](https://github.com/jshttp/cookie) package.

| Property      | Type                   | Default                                                        | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|---------------|------------------------|----------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `decode`      | `(value: string) => T` | `decodeURIComponent` + [destr](https://github.com/unjs/destr). | Custom function to decode the cookie value.  Since the value of a cookie has a limited character set (and must be a simple string), this function can be used to decode a previously encoded cookie value into a JavaScript string or other object. <br/> **Note:** If an error is thrown from this function, the original, non-decoded cookie value will be returned as the cookie's value.                                                                                                                                                                                                                                                       |
| `encode`      | `(value: T) => string` | `JSON.stringify` + `encodeURIComponent`                        | Custom function to encode the cookie value. Since the value of a cookie has a limited character set (and must be a simple string), this function can be used to encode a value into a string suited for a cookie's value.                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `default`     | `() => T \| Ref<T>`    | `undefined`                                                    | Function returning the default value if the cookie does not exist.  The function can also return a `Ref`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `watch`       | `boolean \| 'shallow'` | `true`                                                         | Whether to watch for changes and update the cookie. `true` for deep watch, `'shallow'` for shallow watch, i.e. data changes for only top level properties, `false` to disable. <br/> **Note:** Refresh `useCookie` values manually when a cookie has changed with [`refreshCookie`](/docs/4.x/api/utils/refresh-cookie).                                                                                                                                                                                                                                                                                                                           |
| `readonly`    | `boolean`              | `false`                                                        | If `true`, disables writing to the cookie.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `maxAge`      | `number`               | `undefined`                                                    | Max age in seconds for the cookie, i.e. the value for the [`Max-Age` `Set-Cookie` attribute](https://datatracker.ietf.org/doc/html/rfc6265#section-5.2.2). The given number will be converted to an integer by rounding down. By default, no maximum age is set.                                                                                                                                                                                                                                                                                                                                                                                   |
| `expires`     | `Date`                 | `undefined`                                                    | Expiration date for the cookie. By default, no expiration is set. Most clients will consider this a "non-persistent cookie" and will delete it on a condition like exiting a web browser application. <br/> **Note:** The [cookie storage model specification](https://datatracker.ietf.org/doc/html/rfc6265#section-5.3) states that if both `expires` and `maxAge` is set, then `maxAge` takes precedence, but not all clients may obey this, so if both are set, they should point to the same date and time! <br/>If neither of `expires` and `maxAge` is set, the cookie will be session-only and removed when the user closes their browser. |
| `httpOnly`    | `boolean`              | `false`                                                        | Sets the HttpOnly attribute. <br/> **Note:** Be careful when setting this to `true`, as compliant clients will not allow client-side JavaScript to see the cookie in `document.cookie`.                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `secure`      | `boolean`              | `false`                                                        | Sets the [`Secure` `Set-Cookie` attribute](https://datatracker.ietf.org/doc/html/rfc6265#section-5.2.5). <br/>**Note:** Be careful when setting this to `true`, as compliant clients will not send the cookie back to the server in the future if the browser does not have an HTTPS connection. This can lead to hydration errors.                                                                                                                                                                                                                                                                                                                |
| `partitioned` | `boolean`              | `false`                                                        | Sets the [`Partitioned` `Set-Cookie` attribute](https://datatracker.ietf.org/doc/html/draft-cutler-httpbis-partitioned-cookies#section-2.1). <br/>**Note:** This is an attribute that has not yet been fully standardized, and may change in the future. <br/>This also means many clients may ignore this attribute until they understand it.<br/>More information can be found in the [proposal](https://github.com/privacycg/CHIPS).                                                                                                                                                                                                            |
| `domain`      | `string`               | `undefined`                                                    | Sets the [`Domain` `Set-Cookie` attribute](https://datatracker.ietf.org/doc/html/rfc6265#section-5.2.3). By default, no domain is set, and most clients will consider applying the cookie only to the current domain.                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `path`        | `string`               | `'/'`                                                          | Sets the [`Path` `Set-Cookie` attribute](https://datatracker.ietf.org/doc/html/rfc6265#section-5.2.4). By default, the path is considered the ["default path"](https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.4).                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `sameSite`    | `boolean \| string`    | `undefined`                                                    | Sets the [`SameSite` `Set-Cookie` attribute](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7). <br/>- `true` will set the `SameSite` attribute to `Strict` for strict same-site enforcement.<br/>- `false` will not set the `SameSite` attribute.<br/>- `'lax'` will set the `SameSite` attribute to `Lax` for lax same-site enforcement.<br/>- `'none'` will set the `SameSite` attribute to `None` for an explicit cross-site cookie.<br/>- `'strict'` will set the `SameSite` attribute to `Strict` for strict same-site enforcement.                                                                    |

## Return Values

Returns a Vue `Ref<T>` representing the cookie value. Updating the ref will update the cookie (unless `readonly` is set). The ref is SSR-friendly and will work on both client and server.

## Examples

### Basic Usage

The example below creates a cookie called `counter`. If the cookie doesn't exist, it is initially set to a random value. Whenever we update the `counter` variable, the cookie will be updated accordingly.

```vue [app/app.vue]
<script setup lang="ts">
const counter = useCookie('counter')

counter.value ||= Math.round(Math.random() * 1000)
</script>

<template>
  <div>
    <h1>Counter: {{ counter || '-' }}</h1>
    <button @click="counter = null">
      reset
    </button>
    <button @click="counter--">
      -
    </button>
    <button @click="counter++">
      +
    </button>
  </div>
</template>
```

### Readonly Cookies

```vue
<script setup lang="ts">
const user = useCookie(
  'userInfo',
  {
    default: () => ({ score: -1 }),
    watch: false,
  },
)

if (user.value) {
  // the actual `userInfo` cookie will not be updated
  user.value.score++
}
</script>

<template>
  <div>User score: {{ user?.score }}</div>
</template>
```

### Writable Cookies

```vue
<script setup lang="ts">
const list = useCookie(
  'list',
  {
    default: () => [],
    watch: 'shallow',
  },
)

function add () {
  list.value?.push(Math.round(Math.random() * 1000))
  // list cookie won't be updated with this change
}

function save () {
  // the actual `list` cookie will be updated
  list.value &&= [...list.value]
}
</script>

<template>
  <div>
    <h1>List</h1>
    <pre>{{ list }}</pre>
    <button @click="add">
      Add
    </button>
    <button @click="save">
      Save
    </button>
  </div>
</template>
```

### Cookies in API Routes

You can use `getCookie` and `setCookie` from [`h3`](https://github.com/h3js/h3) package to set cookies in server API routes.

```ts [server/api/counter.ts]
export default defineEventHandler((event) => {
  // Read counter cookie
  let counter = getCookie(event, 'counter') || 0

  // Increase counter cookie by 1
  setCookie(event, 'counter', ++counter)

  // Send JSON response
  return { counter }
})
```

:link-example{to="/docs/4.x/examples/advanced/use-cookie"}
</file>

<file path="docs/4.api/2.composables/use-error.md">
---
title: "useError"
description: useError composable returns the global Nuxt error that is being handled.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/error.ts
    size: xs
---

## Usage

The `useError` composable returns the global Nuxt error that is being handled and is available on both client and server. It provides a reactive, SSR-friendly error state across your app.

```ts
const error = useError()
```

You can use this composable in your components, pages, or plugins to access or react to the current Nuxt error.

## Type

```ts
interface NuxtError<DataT = unknown> {
  status: number
  statusText: string
  message: string
  data?: DataT
  error?: true
}

export const useError: () => Ref<NuxtError | undefined>
```

## Parameters

This composable does not take any parameters.

## Return Values

Returns a `Ref` containing the current Nuxt error (or `undefined` if there is no error). The error object is reactive and will update automatically when the error state changes.

## Example

```vue
<script setup lang="ts">
const error = useError()

if (error.value) {
  console.error('Nuxt error:', error.value)
}
</script>
```

:read-more{to="/docs/4.x/getting-started/error-handling"}
</file>

<file path="docs/4.api/2.composables/use-fetch.md">
---
title: 'useFetch'
description: 'Fetch data from an API endpoint with an SSR-friendly composable.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/fetch.ts
    size: xs
---

This composable provides a convenient wrapper around [`useAsyncData`](/docs/4.x/api/composables/use-async-data) and [`$fetch`](/docs/4.x/api/utils/dollarfetch).
It automatically generates a key based on URL and fetch options, provides type hints for request url based on server routes, and infers API response type.

::note
`useFetch` is a composable meant to be called directly in a setup function, plugin, or route middleware. It returns reactive composables and handles adding responses to the Nuxt payload so they can be passed from server to client without re-fetching the data on client side when the page hydrates.
::

## Usage

```vue [app/pages/modules.vue]
<script setup lang="ts">
const { data, status, error, refresh, clear } = await useFetch('/api/modules', {
  pick: ['title'],
})
</script>
```

::warning
If you're using a custom useFetch wrapper, do not await it in the composable, as that can cause unexpected behavior. Please follow [this recipe](/docs/4.x/guide/recipes/custom-usefetch#custom-usefetchuseasyncdata) for more information on how to make a custom async data fetcher.
::

::note
`data`, `status`, and `error` are Vue refs, and they should be accessed with `.value` when used within the `<script setup>`, while `refresh`/`execute` and `clear` are plain functions.
::

Using the `query` option, you can add search parameters to your query. This option is extended from [unjs/ofetch](https://github.com/unjs/ofetch) and is using [unjs/ufo](https://github.com/unjs/ufo) to create the URL. Objects are automatically stringified.

```ts
const param1 = ref('value1')
const { data, status, error, refresh } = await useFetch('/api/modules', {
  query: { param1, param2: 'value2' },
})
```

The above example results in `https://api.nuxt.com/modules?param1=value1&param2=value2`.

You can also use [interceptors](https://github.com/unjs/ofetch#%EF%B8%8F-interceptors):

```ts
const { data, status, error, refresh, clear } = await useFetch('/api/auth/login', {
  onRequest ({ request, options }) {
    // Set the request headers
    // note that this relies on ofetch >= 1.4.0 - you may need to refresh your lockfile
    options.headers.set('Authorization', '...')
  },
  onRequestError ({ request, options, error }) {
    // Handle the request errors
  },
  onResponse ({ request, response, options }) {
    // Process the response data
    localStorage.setItem('token', response._data.token)
  },
  onResponseError ({ request, response, options }) {
    // Handle the response errors
  },
})
```

### Reactive Keys and Shared State

You can use a computed ref or a plain ref as the URL, allowing for dynamic data fetching that automatically updates when the URL changes:

```vue [app/pages/[id\\].vue]
<script setup lang="ts">
const route = useRoute()
const id = computed(() => route.params.id)

// When the route changes and id updates, the data will be automatically refetched
const { data: post } = await useFetch(() => `/api/posts/${id.value}`)
</script>
```

When using `useFetch` with the same URL and options in multiple components, they will share the same `data`, `error` and `status` refs. This ensures consistency across components.

::tip
Keyed state created using `useFetch` can be retrieved across your Nuxt application using [`useNuxtData`](/docs/4.x/api/composables/use-nuxt-data).
::

::warning
`useFetch` is a reserved function name transformed by the compiler, so you should not name your own function `useFetch`.
::

::warning
If you encounter the `data` variable destructured from a `useFetch` returns a string and not a JSON parsed object then make sure your component doesn't include an import statement like `import { useFetch } from '@vueuse/core`.
::

:video-accordion{title="Watch the video from Alexander Lichter to avoid using useFetch the wrong way" videoId="njsGVmcWviY"}

:read-more{to="/docs/4.x/getting-started/data-fetching"}

### Reactive Fetch Options

Fetch options can be provided as reactive, supporting `computed`, `ref` and [computed getters](https://vuejs.org/guide/essentials/computed). When a reactive fetch option is updated it will trigger a refetch using the updated resolved reactive value.

```ts
const searchQuery = ref('initial')
const { data } = await useFetch('/api/search', {
  query: { q: searchQuery },
})
// triggers a refetch: /api/search?q=new%20search
searchQuery.value = 'new search'
```

If needed, you can opt out of this behavior using `watch: false`:

```ts
const searchQuery = ref('initial')
const { data } = await useFetch('/api/search', {
  query: { q: searchQuery },
  watch: false,
})
// does not trigger a refetch
searchQuery.value = 'new search'
```

## Type

```ts [Signature]
export function useFetch<DataT, ErrorT> (
  url: string | Request | Ref<string | Request> | (() => string | Request),
  options?: UseFetchOptions<DataT>,
): Promise<AsyncData<DataT, ErrorT>>

type UseFetchOptions<DataT> = {
  key?: MaybeRefOrGetter<string>
  method?: MaybeRefOrGetter<string>
  query?: MaybeRefOrGetter<SearchParams>
  params?: MaybeRefOrGetter<SearchParams>
  body?: MaybeRefOrGetter<RequestInit['body'] | Record<string, any>>
  headers?: MaybeRefOrGetter<Record<string, string> | [key: string, value: string][] | Headers>
  baseURL?: MaybeRefOrGetter<string>
  server?: boolean
  lazy?: boolean
  immediate?: boolean
  getCachedData?: (key: string, nuxtApp: NuxtApp, ctx: AsyncDataRequestContext) => DataT | undefined
  deep?: boolean
  dedupe?: 'cancel' | 'defer'
  timeout?: number
  default?: () => DataT
  transform?: (input: DataT) => DataT | Promise<DataT>
  pick?: string[]
  $fetch?: typeof globalThis.$fetch
  watch?: MultiWatchSources | false
  timeout?: MaybeRefOrGetter<number>
}

type AsyncDataRequestContext = {
  /** The reason for this data request */
  cause: 'initial' | 'refresh:manual' | 'refresh:hook' | 'watch'
}

type AsyncData<DataT, ErrorT> = {
  data: Ref<DataT | undefined>
  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>
  execute: (opts?: AsyncDataExecuteOptions) => Promise<void>
  clear: () => void
  error: Ref<ErrorT | undefined>
  status: Ref<AsyncDataRequestStatus>
}

interface AsyncDataExecuteOptions {
  dedupe?: 'cancel' | 'defer'
  timeout?: number
  signal?: AbortSignal
}

type AsyncDataRequestStatus = 'idle' | 'pending' | 'success' | 'error'
```

## Parameters

- `URL` (`string | Request | Ref<string | Request> | () => string | Request`): The URL or request to fetch. Can be a string, a Request object, a Vue ref, or a function returning a string/Request. Supports reactivity for dynamic endpoints.

- `options` (object): Configuration for the fetch request. Extends [unjs/ofetch](https://github.com/unjs/ofetch) options and [`AsyncDataOptions`](/docs/4.x/api/composables/use-async-data#params). All options can be a static value, a `ref`, or a computed value.

| Option          | Type                                                                    | Default    | Description                                                                                                      |
|-----------------|-------------------------------------------------------------------------|------------|------------------------------------------------------------------------------------------------------------------|
| `key`           | `MaybeRefOrGetter<string>`                                              | auto-gen   | Unique key for de-duplication. If not provided, generated from URL and options.                                  |
| `method`        | `MaybeRefOrGetter<string>`                                              | `'GET'`    | HTTP request method.                                                                                             |
| `query`         | `MaybeRefOrGetter<SearchParams>`                                        | -          | Query/search params to append to the URL. Alias: `params`.                                                       |
| `params`        | `MaybeRefOrGetter<SearchParams>`                                        | -          | Alias for `query`.                                                                                               |
| `body`          | `MaybeRefOrGetter<RequestInit['body'] \| Record<string, any>>`          | -          | Request body. Objects are automatically stringified.                                                             |
| `headers`       | `MaybeRefOrGetter<Record<string, string> \| [key, value][] \| Headers>` | -          | Request headers.                                                                                                 |
| `baseURL`       | `MaybeRefOrGetter<string>`                                              | -          | Base URL for the request.                                                                                        |
| `timeout`       | `MaybeRefOrGetter<number>`                                              | -          | Timeout in milliseconds to abort the request.                                                                    |
| `cache`         | `boolean \| string`                                                     | -          | Cache control. Boolean disables cache, or use Fetch API values: `default`, `no-store`, etc.                      |
| `server`        | `boolean`                                                               | `true`     | Whether to fetch on the server.                                                                                  |
| `lazy`          | `boolean`                                                               | `false`    | If true, resolves after route loads (does not block navigation).                                                 |
| `immediate`     | `boolean`                                                               | `true`     | If false, prevents request from firing immediately.                                                              |
| `default`       | `() => DataT`                                                           | -          | Factory for default value of `data` before async resolves.                                                       |
| `timeout`       | `number`                                                                | -          | A number in milliseconds to wait before timing out the request (defaults to `undefined`, which means no timeout) |
| `transform`     | `(input: DataT) => DataT \| Promise<DataT>`                             | -          | Function to transform the result after resolving.                                                                |
| `getCachedData` | `(key, nuxtApp, ctx) => DataT \| undefined`                             | -          | Function to return cached data. See below for default.                                                           |
| `pick`          | `string[]`                                                              | -          | Only pick specified keys from the result.                                                                        |
| `watch`         | `MultiWatchSources \| false`                                            | -          | Array of reactive sources to watch and auto-refresh. `false` disables watching.                                  |
| `deep`          | `boolean`                                                               | `false`    | Return data in a deep ref object.                                                                                |
| `dedupe`        | `'cancel' \| 'defer'`                                                   | `'cancel'` | Avoid fetching same key more than once at a time.                                                                |
| `$fetch`        | `typeof globalThis.$fetch`                                              | -          | Custom $fetch implementation. See [Custom useFetch in Nuxt](/docs/4.x/guide/recipes/custom-usefetch)             |

::note
All fetch options can be given a `computed` or `ref` value. These will be watched and new requests made automatically with any new values if they are updated.
::

**getCachedData default:**

```ts
const getDefaultCachedData = (key, nuxtApp, ctx) => nuxtApp.isHydrating
  ? nuxtApp.payload.data[key]
  : nuxtApp.static.data[key]
```
This only caches data when `experimental.payloadExtraction` in `nuxt.config` is enabled.

## Return Values

| Name      | Type                                                | Description                                                                                                                                                       |
|-----------|-----------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `data`    | `Ref<DataT \| undefined>`                           | The result of the asynchronous fetch.                                                                                                                             |
| `refresh` | `(opts?: AsyncDataExecuteOptions) => Promise<void>` | Function to manually refresh the data. By default, Nuxt waits until a `refresh` is finished before it can be executed again.                                      |
| `execute` | `(opts?: AsyncDataExecuteOptions) => Promise<void>` | Alias for `refresh`.                                                                                                                                              |
| `error`   | `Ref<ErrorT \| undefined>`                          | Error object if the data fetching failed.                                                                                                                         |
| `status`  | `Ref<'idle' \| 'pending' \| 'success' \| 'error'>`  | Status of the data request. See below for possible values.                                                                                                        |
| `clear`   | `() => void`                                        | Resets `data` to `undefined` (or the value of `options.default()` if provided), `error` to `undefined`, set `status` to `idle`, and cancels any pending requests. |

### Status values

- `idle`: Request has not started (e.g. `{ immediate: false }` or `{ server: false }` on server render)
- `pending`: Request is in progress
- `success`: Request completed successfully
- `error`: Request failed

::note
If you have not fetched data on the server (for example, with `server: false`), then the data _will not_ be fetched until hydration completes. This means even if you await `useFetch` on client-side, `data` will remain null within `<script setup>`.
::

### Examples

:link-example{to="/docs/4.x/examples/advanced/use-custom-fetch-composable"}

:link-example{to="/docs/4.x/examples/features/data-fetching"}
</file>

<file path="docs/4.api/2.composables/use-head-safe.md">
---
title: useHeadSafe
description: The recommended way to provide head data with user input.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/unjs/unhead/blob/main/packages/vue/src/composables.ts
    size: xs
---

## Usage

The `useHeadSafe` composable is a wrapper around the [`useHead`](/docs/4.x/api/composables/use-head) composable that restricts the input to only allow safe values. This is the recommended way to manage head data when working with user input, as it prevents XSS attacks by sanitizing potentially dangerous attributes.

::warning
When using `useHeadSafe`, potentially dangerous attributes like `innerHTML` in scripts or `http-equiv` in meta tags are automatically stripped out to prevent XSS attacks. Use this composable whenever you're working with user-generated content.
::

## Type

```ts [Signature]
export function useHeadSafe (input: MaybeComputedRef<HeadSafe>): void
```

### Allowed Attributes

The following attributes are whitelisted for each head element type:

```ts
const WhitelistAttributes = {
  htmlAttrs: ['class', 'style', 'lang', 'dir'],
  bodyAttrs: ['class', 'style'],
  meta: ['name', 'property', 'charset', 'content', 'media'],
  noscript: ['textContent'],
  style: ['media', 'textContent', 'nonce', 'title', 'blocking'],
  script: ['type', 'textContent', 'nonce', 'blocking'],
  link: ['color', 'crossorigin', 'fetchpriority', 'href', 'hreflang', 'imagesrcset', 'imagesizes', 'integrity', 'media', 'referrerpolicy', 'rel', 'sizes', 'type'],
}
```

See [@unhead/vue](https://github.com/unjs/unhead/blob/main/packages/vue/src/types/safeSchema.ts) for more detailed types.

## Parameters

`input`: A `MaybeComputedRef<HeadSafe>` object containing head data. You can pass all the same values as [`useHead`](/docs/4.x/api/composables/use-head), but only safe attributes will be rendered.

## Return Values

This composable does not return any value.

## Example

```vue [app/pages/user-profile.vue]
<script setup lang="ts">
// User-generated content that might contain malicious code
const userBio = ref('<script>alert("xss")<' + '/script>')

useHeadSafe({
  title: `User Profile`,
  meta: [
    {
      name: 'description',
      content: userBio.value, // Safely sanitized
    },
  ],
})
</script>
```

::read-more{to="https://unhead.unjs.io/docs/typescript/head/api/composables/use-head-safe" target="_blank"}
Read more on the `Unhead` documentation.
::
</file>

<file path="docs/4.api/2.composables/use-head.md">
---
title: useHead
description: useHead customizes the head properties of individual pages of your Nuxt app.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/unjs/unhead/blob/main/packages/vue/src/composables.ts
    size: xs
---

## Usage

The `useHead` composable allows you to manage your head tags in a programmatic and reactive way, powered by [Unhead](https://unhead.unjs.io). It lets you customize the meta tags, links, scripts, and other elements in the `<head>` section of your HTML document.

```vue [app/app.vue]
<script setup lang="ts">
useHead({
  title: 'My App',
  meta: [
    { name: 'description', content: 'My amazing site.' },
  ],
  bodyAttrs: {
    class: 'test',
  },
  script: [{ innerHTML: 'console.log(\'Hello world\')' }],
})
</script>
```

::warning
If the data comes from a user or other untrusted source, we recommend you check out [`useHeadSafe`](/docs/4.x/api/composables/use-head-safe).
::

::note
The properties of `useHead` can be dynamic, accepting `ref`, `computed` and `reactive` properties. The `meta` parameter can also accept a function returning an object to make the entire object reactive.
::

## Type

```ts [Signature]
export function useHead (meta: MaybeComputedRef<MetaObject>): ActiveHeadEntry<UseHeadInput>

interface MetaObject {
  title?: string
  titleTemplate?: string | ((title?: string) => string)
  base?: Base
  link?: Link[]
  meta?: Meta[]
  style?: Style[]
  script?: Script[]
  noscript?: Noscript[]
  htmlAttrs?: HtmlAttributes
  bodyAttrs?: BodyAttributes
}

interface ActiveHeadEntry<Input> {
  /**
   * Updates the entry with new input.
   *
   * Will first clear any side effects for previous input.
   */
  patch: (input: Input) => void
  /**
   * Dispose the entry, removing it from the active head.
   *
   * Will queue side effects for removal.
   */
  dispose: () => void
}
```

See [@unhead/schema](https://github.com/unjs/unhead/blob/main/packages/vue/src/types/schema.ts) for more detailed types.

## Parameters

`meta`: An object accepting head metadata properties to customize the page's `<head>` section. All properties support reactive values (`ref`, `computed`, `reactive`) or can be a function returning the metadata object.

| Property | Type | Description |
| --- | --- | --- |
| `title` | `string` | Sets the page title. |
| `titleTemplate` | `string \| ((title?: string) => string)` | Configures a dynamic template to customize the page title. Can be a string with `%s` placeholder or a function. |
| `base` | `Base` | Sets the `<base>` tag for the document. |
| `link` | `Link[]` | Array of link objects. Each element is mapped to a `<link>` tag, where object properties correspond to HTML attributes. |
| `meta` | `Meta[]` | Array of meta objects. Each element is mapped to a `<meta>` tag, where object properties correspond to HTML attributes. |
| `style` | `Style[]` | Array of style objects. Each element is mapped to a `<style>` tag, where object properties correspond to HTML attributes. |
| `script` | `Script[]` | Array of script objects. Each element is mapped to a `<script>` tag, where object properties correspond to HTML attributes. |
| `noscript` | `Noscript[]` | Array of noscript objects. Each element is mapped to a `<noscript>` tag, where object properties correspond to HTML attributes. |
| `htmlAttrs` | `HtmlAttributes` | Sets attributes of the `<html>` tag. Each object property is mapped to the corresponding attribute. |
| `bodyAttrs` | `BodyAttributes` | Sets attributes of the `<body>` tag. Each object property is mapped to the corresponding attribute. |

## Return Values

This composable does not return any value. It registers the head metadata with Unhead, which manages the actual DOM updates.

## Examples

### Basic Meta Tags

```vue [app/pages/about.vue]
<script setup lang="ts">
useHead({
  title: 'About Us',
  meta: [
    { name: 'description', content: 'Learn more about our company' },
    { property: 'og:title', content: 'About Us' },
    { property: 'og:description', content: 'Learn more about our company' },
  ],
})
</script>
```

### Reactive Meta Tags

```vue [app/pages/profile.vue]
<script setup lang="ts">
const profile = ref({ name: 'John Doe' })

useHead({
  title: computed(() => profile.value.name),
  meta: [
    {
      name: 'description',
      content: computed(() => `Profile page for ${profile.value.name}`),
    },
  ],
})
</script>
```

### Using a Function for Full Reactivity

```vue [app/pages/dynamic.vue]
<script setup lang="ts">
const count = ref(0)

useHead(() => ({
  title: `Count: ${count.value}`,
  meta: [
    { name: 'description', content: `Current count is ${count.value}` },
  ],
}))
</script>
```

### Adding External Scripts and Styles

```vue [app/pages/external.vue]
<script setup lang="ts">
useHead({
  link: [
    {
      rel: 'stylesheet',
      href: 'https://cdn.example.com/styles.css',
    },
  ],
  script: [
    {
      src: 'https://cdn.example.com/script.js',
      async: true,
    },
  ],
})
</script>
```

### Body and HTML Attributes

```vue [app/pages/themed.vue]
<script setup lang="ts">
const isDark = ref(true)

useHead({
  htmlAttrs: {
    lang: 'en',
    class: computed(() => isDark.value ? 'dark' : 'light'),
  },
  bodyAttrs: {
    class: 'themed-page',
  },
})
</script>
```

:read-more{to="/docs/4.x/getting-started/seo-meta"}
</file>

<file path="docs/4.api/2.composables/use-hydration.md">
---
title: 'useHydration'
description: 'Allows full control of the hydration cycle to set and receive data from the server.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/hydrate.ts
    size: xs
---

`useHydration` is a built-in composable that provides a way to set data on the server side every time a new HTTP request is made and receive that data on the client side. This way `useHydration` allows you to take full control of the hydration cycle.

::note
This is an advanced composable, primarily designed for use within plugins, mostly used by Nuxt modules.
::

::note
`useHydration` is designed to **ensure state synchronization and restoration during SSR**. If you need to create a globally reactive state that is SSR-friendly in Nuxt, [`useState`](/docs/4.x/api/composables/use-state) is the recommended choice.
::

## Usage

The data returned from the `get` function on the server is stored in `nuxtApp.payload` under the unique key provided as the first parameter to `useHydration`. During hydration, this data is then retrieved on the client, preventing redundant computations or API calls.

::code-group

```ts [With useHydration]
export default defineNuxtPlugin((nuxtApp) => {
  const myStore = new MyStore()

  useHydration(
    'myStoreState',
    () => myStore.getState(),
    data => myStore.setState(data),
  )
})
```

```ts [Without useHydration]
export default defineNuxtPlugin((nuxtApp) => {
  const myStore = new MyStore()

  if (import.meta.server) {
    nuxt.hooks.hook('app:rendered', () => {
      nuxtApp.payload.myStoreState = myStore.getState()
    })
  }

  if (import.meta.client) {
    nuxt.hooks.hook('app:created', () => {
      myStore.setState(nuxtApp.payload.myStoreState)
    })
  }
})
```
::

## Type

```ts [Signature]
export function useHydration<T> (key: string, get: () => T, set: (value: T) => void): void
```

## Parameters

| Parameter | Type | Description |
| --- | --- | --- |
| `key` | `string` | A unique key that identifies the data in your Nuxt application. |
| `get` | `() => T` | A function executed **only on the server** (called when SSR rendering is done) to set the initial value. |
| `set` | `(value: T) => void` | A function executed **only on the client** (called when initial Vue instance is created) to receive the data. |

## Return Values

This composable does not return any value.
</file>

<file path="docs/4.api/2.composables/use-lazy-async-data.md">
---
title: useLazyAsyncData
description: This wrapper around useAsyncData triggers navigation immediately.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/asyncData.ts
    size: xs
---

`useLazyAsyncData` provides a wrapper around [`useAsyncData`](/docs/4.x/api/composables/use-async-data) that triggers navigation before the handler is resolved by setting the `lazy` option to `true`.

::note
By default, [`useAsyncData`](/docs/4.x/api/composables/use-async-data) blocks navigation until its async handler is resolved. `useLazyAsyncData` allows navigation to occur immediately while data fetching continues in the background.
::

## Usage

```vue [app/pages/index.vue]
<script setup lang="ts">
const { status, data: posts } = await useLazyAsyncData('posts', () => $fetch('/api/posts'))
</script>

<template>
  <div>
    <div v-if="status === 'pending'">
      Loading...
    </div>
    <div v-else-if="status === 'error'">
      Error loading posts
    </div>
    <div v-else>
      {{ posts }}
    </div>
  </div>
</template>
```

When using `useLazyAsyncData`, navigation will occur before fetching is complete. This means you must handle `pending` and `error` states directly within your component's template.

::warning
`useLazyAsyncData` is a reserved function name transformed by the compiler, so you should not name your own function `useLazyAsyncData`.
::

## Type

```ts [Signature]
export function useLazyAsyncData<DataT, ErrorT> (
  handler: (ctx?: NuxtApp) => Promise<DataT>,
  options?: AsyncDataOptions<DataT>,
): AsyncData<DataT, ErrorT>

export function useLazyAsyncData<DataT, ErrorT> (
  key: string,
  handler: (ctx?: NuxtApp) => Promise<DataT>,
  options?: AsyncDataOptions<DataT>,
): AsyncData<DataT, ErrorT>
```

`useLazyAsyncData` has the same signature as [`useAsyncData`](/docs/4.x/api/composables/use-async-data).

## Parameters

`useLazyAsyncData` accepts the same parameters as [`useAsyncData`](/docs/4.x/api/composables/use-async-data), with the `lazy` option automatically set to `true`.

:read-more{to="/docs/4.x/api/composables/use-async-data#parameters"}

## Return Values

`useLazyAsyncData` returns the same values as [`useAsyncData`](/docs/4.x/api/composables/use-async-data).

:read-more{to="/docs/4.x/api/composables/use-async-data#return-values"}

## Example

```vue [app/pages/index.vue]
<script setup lang="ts">
/* Navigation will occur before fetching is complete.
  Handle 'pending' and 'error' states directly within your component's template
*/
const { status, data: count } = await useLazyAsyncData('count', () => $fetch('/api/count'))

watch(count, (newCount) => {
  // Because count might start out null, you won't have access
  // to its contents immediately, but you can watch it.
})
</script>

<template>
  <div>
    {{ status === 'pending' ? 'Loading' : count }}
  </div>
</template>
```

:read-more{to="/docs/4.x/getting-started/data-fetching"}
</file>

<file path="docs/4.api/2.composables/use-lazy-fetch.md">
---
title: 'useLazyFetch'
description: This wrapper around useFetch triggers navigation immediately.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/fetch.ts
    size: xs
---

`useLazyFetch` provides a wrapper around [`useFetch`](/docs/4.x/api/composables/use-fetch) that triggers navigation before the handler is resolved by setting the `lazy` option to `true`.

## Usage

By default, [`useFetch`](/docs/4.x/api/composables/use-fetch) blocks navigation until its async handler is resolved. `useLazyFetch` allows navigation to proceed immediately, with data being fetched in the background.

```vue [app/pages/index.vue]
<script setup lang="ts">
const { status, data: posts } = await useLazyFetch('/api/posts')
</script>

<template>
  <div v-if="status === 'pending'">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

::note
`useLazyFetch` has the same signature as [`useFetch`](/docs/4.x/api/composables/use-fetch).
::

::warning
Awaiting `useLazyFetch` only ensures the call is initialized. On client-side navigation, data may not be immediately available, and you must handle the `pending` state in your component's template.
::

::warning
`useLazyFetch` is a reserved function name transformed by the compiler, so you should not name your own function `useLazyFetch`.
::

## Type

```ts [Signature]
export function useLazyFetch<DataT, ErrorT> (
  url: string | Request | Ref<string | Request> | (() => string | Request),
  options?: UseFetchOptions<DataT>,
): Promise<AsyncData<DataT, ErrorT>>
```

::note
`useLazyFetch` is equivalent to `useFetch` with `lazy: true` option set. See [`useFetch`](/docs/4.x/api/composables/use-fetch) for full type definitions.
::

## Parameters

`useLazyFetch` accepts the same parameters as [`useFetch`](/docs/4.x/api/composables/use-fetch):

- `URL` (`string | Request | Ref<string | Request> | () => string | Request`): The URL or request to fetch.
- `options` (object): Same as [`useFetch` options](/docs/4.x/api/composables/use-fetch#parameters), with `lazy` automatically set to `true`.

:read-more{to="/docs/4.x/api/composables/use-fetch#parameters"}

## Return Values

Returns the same `AsyncData` object as [`useFetch`](/docs/4.x/api/composables/use-fetch):

| Name      | Type                                                | Description                                                                                                      |
|-----------|-----------------------------------------------------|------------------------------------------------------------------------------------------------------------------|
| `data`    | `Ref<DataT \| undefined>`                           | The result of the asynchronous fetch.                                                                            |
| `refresh` | `(opts?: AsyncDataExecuteOptions) => Promise<void>` | Function to manually refresh the data.                                                                           |
| `execute` | `(opts?: AsyncDataExecuteOptions) => Promise<void>` | Alias for `refresh`.                                                                                             |
| `error`   | `Ref<ErrorT \| undefined>`                          | Error object if the data fetching failed.                                                                        |
| `status`  | `Ref<'idle' \| 'pending' \| 'success' \| 'error'>`  | Status of the data request.                                                                                      |
| `clear`   | `() => void`                                        | Resets `data` to `undefined`, `error` to `undefined`, sets `status` to `idle`, and cancels any pending requests. |

:read-more{to="/docs/4.x/api/composables/use-fetch#return-values"}

## Examples

### Handling Pending State

```vue [app/pages/index.vue]
<script setup lang="ts">
/* Navigation will occur before fetching is complete.
 * Handle 'pending' and 'error' states directly within your component's template
 */
const { status, data: posts } = await useLazyFetch('/api/posts')
watch(posts, (newPosts) => {
  // Because posts might start out null, you won't have access
  // to its contents immediately, but you can watch it.
})
</script>

<template>
  <div v-if="status === 'pending'">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

:read-more{to="/docs/4.x/getting-started/data-fetching"}
</file>

<file path="docs/4.api/2.composables/use-loading-indicator.md">
---
title: 'useLoadingIndicator'
description: This composable gives you access to the loading state of the app page.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/loading-indicator.ts
    size: xs
---

## Description

A composable which returns the loading state of the page. Used by [`<NuxtLoadingIndicator>`](/docs/4.x/api/components/nuxt-loading-indicator) and controllable.
It hooks into [`page:loading:start`](/docs/4.x/api/advanced/hooks#app-hooks-runtime) and [`page:loading:end`](/docs/4.x/api/advanced/hooks#app-hooks-runtime) to change its state.

## Parameters

- `duration`: Duration of the loading bar, in milliseconds (default `2000`).
- `throttle`: Throttle the appearing and hiding, in milliseconds (default `200`).
- `estimatedProgress`: By default Nuxt will back off as it approaches 100%. You can provide a custom function to customize the progress estimation, which is a function that receives the duration of the loading bar (above) and the elapsed time. It should return a value between 0 and 100.

## Properties

### `isLoading`

- **type**: `Ref<boolean>`
- **description**: The loading state

### `error`

- **type**: `Ref<boolean>`
- **description**: The error state

### `progress`

- **type**: `Ref<number>`
- **description**: The progress state. From `0` to `100`.

## Methods

### `start()`

Set `isLoading` to true and start to increase the `progress` value. `start` accepts a `{ force: true }` option to skip the interval and show the loading state immediately.

### `set()`

Set the `progress` value to a specific value. `set` accepts a `{ force: true }` option to skip the interval and show the loading state immediately.

### `finish()`

Set the `progress` value to `100`, stop all timers and intervals then reset the loading state `500` ms later. `finish` accepts a `{ force: true }` option to skip the interval before the state is reset, and `{ error: true }` to change the loading bar color and set the error property to true.

### `clear()`

Used by `finish()`. Clear all timers and intervals used by the composable.

## Example

```vue
<script setup lang="ts">
const { progress, isLoading, start, finish, clear } = useLoadingIndicator({
  duration: 2000,
  throttle: 200,
  // This is how progress is calculated by default
  estimatedProgress: (duration, elapsed) => (2 / Math.PI * 100) * Math.atan(elapsed / duration * 100 / 50),
})
</script>
```

```vue
<script setup lang="ts">
const { start, set } = useLoadingIndicator()
// same as set(0, { force: true })
// set the progress to 0, and show loading immediately
start({ force: true })
</script>
```
</file>

<file path="docs/4.api/2.composables/use-nuxt-app.md">
---
title: 'useNuxtApp'
description: 'Access the shared runtime context of the Nuxt Application.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts
    size: xs
---

`useNuxtApp` is a built-in composable that provides a way to access shared runtime context of Nuxt, also known as the [Nuxt context](/docs/4.x/guide/going-further/nuxt-app#the-nuxt-context), which is available on both client and server side (but not within Nitro routes). It helps you access the Vue app instance, runtime hooks, runtime config variables and internal states, such as `ssrContext` and `payload`.

```vue [app/app.vue]
<script setup lang="ts">
const nuxtApp = useNuxtApp()
</script>
```

If runtime context is unavailable in your scope, `useNuxtApp` will throw an exception when called. You can use [`tryUseNuxtApp`](/docs/4.x/api/composables/use-nuxt-app#tryusenuxtapp) instead for composables that do not require `nuxtApp`, or to simply check if context is available or not without an exception.

<!--
note
By default, the shared runtime context of Nuxt is namespaced under the [`buildId`](/docs/4.x/api/nuxt-config#buildid) option. It allows the support of multiple runtime contexts.

## Params

- `appName`: an optional application name. If you do not provide it, the Nuxt `buildId` option is used. Otherwise, it must match with an existing `buildId`. -->

## Methods

### `provide (name, value)`

`nuxtApp` is a runtime context that you can extend using [Nuxt plugins](/docs/4.x/directory-structure/app/plugins). Use the `provide` function to create Nuxt plugins to make values and helper methods available in your Nuxt application across all composables and components.

`provide` function accepts `name` and `value` parameters.

```ts
const nuxtApp = useNuxtApp()
nuxtApp.provide('hello', name => `Hello ${name}!`)

// Prints "Hello name!"
console.log(nuxtApp.$hello('name'))
```

As you can see in the example above, `$hello` has become the new and custom part of `nuxtApp` context and it is available in all places where `nuxtApp` is accessible.

### `hook(name, cb)`

Hooks available in `nuxtApp` allows you to customize the runtime aspects of your Nuxt application. You can use runtime hooks in Vue.js composables and [Nuxt plugins](/docs/4.x/directory-structure/app/plugins) to hook into the rendering lifecycle.

`hook` function is useful for adding custom logic by hooking into the rendering lifecycle at a specific point. `hook` function is mostly used when creating Nuxt plugins.

See [Runtime Hooks](/docs/4.x/api/advanced/hooks#app-hooks-runtime) for available runtime hooks called by Nuxt.

```ts [app/plugins/test.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.hook('page:start', () => {
    /* your code goes here */
  })
  nuxtApp.hook('vue:error', (..._args) => {
    console.log('vue:error')
    // if (import.meta.client) {
    //   console.log(..._args)
    // }
  })
})
```

### `callHook(name, ...args)`

`callHook` returns a promise when called with any of the existing hooks.

```ts
await nuxtApp.callHook('my-plugin:init')
```

## Properties

`useNuxtApp()` exposes the following properties that you can use to extend and customize your app and share state, data and variables.

### `vueApp`

`vueApp` is the global Vue.js [application instance](https://vuejs.org/api/application#application-api) that you can access through `nuxtApp`.

Some useful methods:
- [`component()`](https://vuejs.org/api/application#app-component) - Registers a global component if passing both a name string and a component definition, or retrieves an already registered one if only the name is passed.
- [`directive()`](https://vuejs.org/api/application#app-directive) - Registers a global custom directive if passing both a name string and a directive definition, or retrieves an already registered one if only the name is passed[(example)](/docs/4.x/directory-structure/app/plugins#vue-directives).
- [`use()`](https://vuejs.org/api/application#app-use) - Installs a **[Vue.js Plugin](https://vuejs.org/guide/reusability/plugins)** [(example)](/docs/4.x/directory-structure/app/plugins#vue-plugins).

:read-more{icon="i-simple-icons-vuedotjs" to="https://vuejs.org/api/application.html#application-api"}

### `ssrContext`

`ssrContext` is generated during server-side rendering and it is only available on the server side.

Nuxt exposes the following properties through `ssrContext`:
- `url` (string) -  Current request url.
- `event` ([h3js/h3](https://github.com/h3js/h3) request event) - Access the request & response of the current route.
- `payload` (object) - NuxtApp payload object.

### `payload`

`payload` exposes data and state variables from server side to client side. The following keys will be available on the client after they have been passed from the server side:

- `serverRendered` (boolean) - Indicates if response is server-side-rendered.
- `data` (object) - When you fetch the data from an API endpoint using either [`useFetch`](/docs/4.x/api/composables/use-fetch) or [`useAsyncData`](/docs/4.x/api/composables/use-async-data) , resulting payload can be accessed from the `payload.data`. This data is cached and helps you prevent fetching the same data in case an identical request is made more than once.

  ::code-group
  ```vue [app/app.vue]
  <script setup lang="ts">
  const { data } = await useAsyncData('count', (_nuxtApp, { signal }) => $fetch('/api/count', { signal }))
  </script>
  ```
  ```ts [server/api/count.ts]
  export default defineEventHandler((event) => {
    return { count: 1 }
  })
  ```
  ::

  After fetching the value of `count` using [`useAsyncData`](/docs/4.x/api/composables/use-async-data) in the example above, if you access `payload.data`, you will see `{ count: 1 }` recorded there.

  When accessing the same `payload.data` from [`ssrcontext`](/docs/4.x/api/composables/use-nuxt-app#ssrcontext), you can access the same value on the server side as well.

- `state` (object) - When you use [`useState`](/docs/4.x/api/composables/use-state) composable in Nuxt to set shared state, this state data is accessed through `payload.state.[name-of-your-state]`.

  ```ts [app/plugins/my-plugin.ts]
  export const useColor = () => useState<string>('color', () => 'pink')

  export default defineNuxtPlugin((nuxtApp) => {
    if (import.meta.server) {
      const color = useColor()
    }
  })
  ```

  It is also possible to use more advanced types, such as `ref`, `reactive`, `shallowRef`, `shallowReactive` and `NuxtError`.

  Since [Nuxt v3.4](https://nuxt.com/blog/v3-4#payload-enhancements), it is possible to define your own reducer/reviver for types that are not supported by Nuxt.

  :video-accordion{title="Watch a video from Alexander Lichter about serializing payloads, especially with regards to classes" videoId="8w6ffRBs8a4"}

  In the example below, we define a reducer (or a serializer) and a reviver (or deserializer) for the [Luxon](https://moment.github.io/luxon/#/) DateTime class, using a payload plugin.

  ```ts [app/plugins/date-time-payload.ts]
  /**
   * This kind of plugin runs very early in the Nuxt lifecycle, before we revive the payload.
   * You will not have access to the router or other Nuxt-injected properties.
   *
   * Note that the "DateTime" string is the type identifier and must
   * be the same on both the reducer and the reviver.
   */
  export default definePayloadPlugin((nuxtApp) => {
    definePayloadReducer('DateTime', (value) => {
      return value instanceof DateTime && value.toJSON()
    })
    definePayloadReviver('DateTime', (value) => {
      return DateTime.fromISO(value)
    })
  })
  ```

### `isHydrating`

Use `nuxtApp.isHydrating` (boolean) to check if the Nuxt app is hydrating on the client side.

```ts [app/components/nuxt-error-boundary.ts]
export default defineComponent({
  setup (_props, { slots, emit }) {
    const nuxtApp = useNuxtApp()
    onErrorCaptured((err) => {
      if (import.meta.client && !nuxtApp.isHydrating) {
        // ...
      }
    })
  },
})
```

### `runWithContext`

::note
You are likely here because you got a "Nuxt instance unavailable" message. Please use this method sparingly, and report examples that are causing issues, so that it can ultimately be solved at the framework level.
::

The `runWithContext` method is meant to be used to call a function and give it an explicit Nuxt context. Typically, the Nuxt context is passed around implicitly and you do not need to worry about this. However, when working with complex `async`/`await` scenarios in middleware/plugins, you can run into instances where the current instance has been unset after an async call.

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware(async (to, from) => {
  const nuxtApp = useNuxtApp()
  let user
  try {
    user = await fetchUser()
    // the Vue/Nuxt compiler loses context here because of the try/catch block.
  } catch (e) {
    user = null
  }
  if (!user) {
    // apply the correct Nuxt context to our `navigateTo` call.
    return nuxtApp.runWithContext(() => navigateTo('/auth'))
  }
})
```

#### Usage

```ts
const result = nuxtApp.runWithContext(() => functionWithContext())
```

- `functionWithContext`: Any function that requires the context of the current Nuxt application. This context will be correctly applied automatically.

`runWithContext` will return whatever is returned by `functionWithContext`.

#### A Deeper Explanation of Context

Vue.js Composition API (and Nuxt composables similarly) work by depending on an implicit context. During the lifecycle, Vue sets the temporary instance of the current component (and Nuxt temporary instance of nuxtApp) to a global variable and unsets it in same tick. When rendering on the server side, there are multiple requests from different users and nuxtApp running in a same global context. Because of this, Nuxt and Vue immediately unset this global instance to avoid leaking a shared reference between two users or components.

What it does mean? The Composition API and Nuxt Composables are only available during lifecycle and in same tick before any async operation:

```ts
// --- Vue internal ---
const _vueInstance = null
const getCurrentInstance = () => _vueInstance
// ---

// Vue / Nuxt sets a global variable referencing to current component in _vueInstance when calling setup()
async function setup () {
  getCurrentInstance() // Works
  await someAsyncOperation() // Vue unsets the context in same tick before async operation!
  getCurrentInstance() // null
}
```

The classic solution to this, is caching the current instance on first call to a local variable like `const instance = getCurrentInstance()` and use it in the next composable call but the issue is that any nested composable calls now needs to explicitly accept the instance as an argument and not depend on the implicit context of composition-api. This is design limitation with composables and not an issue per-se.

To overcome this limitation, Vue does some behind the scenes work when compiling our application code and restores context after each call for `<script setup>`:

```ts
const __instance = getCurrentInstance() // Generated by Vue compiler
getCurrentInstance() // Works!
await someAsyncOperation() // Vue unsets the context
__restoreInstance(__instance) // Generated by Vue compiler
getCurrentInstance() // Still works!
```

For a better description of what Vue actually does, see [unjs/unctx#2 (comment)](https://github.com/unjs/unctx/issues/2#issuecomment-942193723).

#### Solution

This is where `runWithContext` can be used to restore context, similarly to how `<script setup>` works.

Nuxt internally uses [unjs/unctx](https://github.com/unjs/unctx) to support composables similar to Vue for plugins and middleware. This enables composables like `navigateTo()` to work without directly passing `nuxtApp` to them - bringing the DX and performance benefits of Composition API to the whole Nuxt framework.

Nuxt composables have the same design as the Vue Composition API and therefore need a similar solution to magically do this transform. Check out [unjs/unctx#2](https://github.com/unjs/unctx/issues/2) (proposal), [unjs/unctx#4](https://github.com/unjs/unctx/pull/4) (transform implementation), and [nuxt/framework#3884](https://github.com/nuxt/framework/pull/3884) (Integration to Nuxt).

Vue currently only supports async context restoration for `<script setup>` for async/await usage. In Nuxt, the transform support for `defineNuxtPlugin()` and `defineNuxtRouteMiddleware()` was added, which means when you use them Nuxt automatically transforms them with context restoration.

#### Remaining Issues

The `unjs/unctx` transformation to automatically restore context seems buggy with `try/catch` statements containing `await` which ultimately needs to be solved in order to remove the requirement of the workaround suggested above.

#### Native Async Context

Using a new experimental feature, it is possible to enable native async context support using [Node.js `AsyncLocalStorage`](https://nodejs.org/api/async_context.html#class-asynclocalstorage) and new unctx support to make async context available **natively** to **any nested async composable** without needing a transform or manual passing/calling with context.

::tip
Native async context support works currently in Bun and Node.
::

:read-more{to="/docs/4.x/guide/going-further/experimental-features#asynccontext"}

## tryUseNuxtApp

This function works exactly the same as `useNuxtApp`, but returns `null` if context is unavailable instead of throwing an exception.

You can use it for composables that do not require `nuxtApp`, or to simply check if context is available or not without an exception.

Example usage:

```ts [composable.ts]
export function useStandType () {
  // Always works on the client
  if (tryUseNuxtApp()) {
    return useRuntimeConfig().public.STAND_TYPE
  } else {
    return process.env.STAND_TYPE
  }
}
```

<!-- ### Params

- `appName`: an optional application name. If you do not provide it, the Nuxt `buildId` option is used. Otherwise, it must match with an existing `buildId`. -->
</file>

<file path="docs/4.api/2.composables/use-nuxt-data.md">
---
title: 'useNuxtData'
description: 'Access the current cached value of data fetching composables.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/asyncData.ts
    size: xs
---

::note
`useNuxtData` gives you access to the current cached value of [`useAsyncData`](/docs/4.x/api/composables/use-async-data) , [`useLazyAsyncData`](/docs/4.x/api/composables/use-lazy-async-data), [`useFetch`](/docs/4.x/api/composables/use-fetch) and [`useLazyFetch`](/docs/4.x/api/composables/use-lazy-fetch) with explicitly provided key.
::

## Usage

The `useNuxtData` composable is used to access the current cached value of data-fetching composables such as `useAsyncData`, `useLazyAsyncData`, `useFetch`, and `useLazyFetch`. By providing the key used during the data fetch, you can retrieve the cached data and use it as needed.

This is particularly useful for optimizing performance by reusing already-fetched data or implementing features like Optimistic Updates or cascading data updates.

To use `useNuxtData`, ensure that the data-fetching composable (`useFetch`, `useAsyncData`, etc.) has been called with an explicitly provided key.

:video-accordion{title="Watch a video from LearnVue about useNuxtData" videoId="e-_u6swXRWk"}

## Params

- `key`: The unique key that identifies the cached data. This key should match the one used during the original data fetch.

## Return Values

- `data`: A reactive reference to the cached data associated with the provided key. If no cached data exists, the value will be `null`. This `Ref` automatically updates if the cached data changes, allowing seamless reactivity in your components.

## Example

The example below shows how you can use cached data as a placeholder while the most recent data is being fetched from the server.

```vue [app/pages/posts.vue]
<script setup lang="ts">
// We can access same data later using 'posts' key
const { data } = await useFetch('/api/posts', { key: 'posts' })
</script>
```

```vue [app/pages/posts/[id\\].vue]
<script setup lang="ts">
// Access to the cached value of useFetch in posts.vue (parent route)
const { data: posts } = useNuxtData('posts')

const route = useRoute()

const { data } = useLazyFetch(`/api/posts/${route.params.id}`, {
  key: `post-${route.params.id}`,
  default () {
    // Find the individual post from the cache and set it as the default value.
    return posts.value.find(post => post.id === route.params.id)
  },
})
</script>
```

## Optimistic Updates

The example below shows how implementing Optimistic Updates can be achieved using useNuxtData.

Optimistic Updates is a technique where the user interface is updated immediately, assuming a server operation will succeed. If the operation eventually fails, the UI is rolled back to its previous state.

```vue [app/pages/todos.vue]
<script setup lang="ts">
// We can access same data later using 'todos' key
const { data } = await useAsyncData('todos', (_nuxtApp, { signal }) => $fetch('/api/todos', { signal }))
</script>
```

```vue [app/components/NewTodo.vue]
<script setup lang="ts">
const newTodo = ref('')
let previousTodos = []

// Access to the cached value of useAsyncData in todos.vue
const { data: todos } = useNuxtData('todos')

async function addTodo () {
  await $fetch('/api/addTodo', {
    method: 'post',
    body: {
      todo: newTodo.value,
    },
    onRequest () {
      // Store the previously cached value to restore if fetch fails.
      previousTodos = todos.value

      // Optimistically update the todos.
      todos.value = [...todos.value, newTodo.value]
    },
    onResponseError () {
      // Rollback the data if the request failed.
      todos.value = previousTodos
    },
    async onResponse () {
      // Invalidate todos in the background if the request succeeded.
      await refreshNuxtData('todos')
    },
  })
}
</script>
```

## Type

```ts [Signature]
export function useNuxtData<DataT = any> (key: string): { data: Ref<DataT | undefined> }
```
</file>

<file path="docs/4.api/2.composables/use-preview-mode.md">
---
title: "usePreviewMode"
description: "Use usePreviewMode to check and control preview mode in Nuxt"
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/preview.ts
    size: xs
---

# `usePreviewMode`

Preview mode allows you to see how your changes would be displayed on a live site without revealing them to users.

You can use the built-in `usePreviewMode` composable to access and control preview state in Nuxt. If the composable detects preview mode it will automatically force any updates necessary for [`useAsyncData`](/docs/4.x/api/composables/use-async-data) and [`useFetch`](/docs/4.x/api/composables/use-fetch) to rerender preview content.

```ts
const { enabled, state } = usePreviewMode()
```

## Options

### Custom `enable` check

You can specify a custom way to enable preview mode. By default the `usePreviewMode` composable will enable preview mode if there is a `preview` param in url that is equal to `true` (for example, `http://localhost:3000?preview=true`). You can wrap the `usePreviewMode` into custom composable, to keep options consistent across usages and prevent any errors.

```ts
export function useMyPreviewMode () {
  const route = useRoute()
  return usePreviewMode({
    shouldEnable: () => {
      return !!route.query.customPreview
    },
  })
}
```

### Modify default state

`usePreviewMode` will try to store the value of a `token` param from url in state. You can modify this state and it will be available for all [`usePreviewMode`](/docs/4.x/api/composables/use-preview-mode) calls.

```ts
const data1 = ref('data1')

const { enabled, state } = usePreviewMode({
  getState: (currentState) => {
    return { data1, data2: 'data2' }
  },
})
```

::note
The `getState` function will append returned values to current state, so be careful not to accidentally overwrite important state.
::

### Customize the `onEnable` and `onDisable` callbacks

By default, when `usePreviewMode` is enabled, it will call `refreshNuxtData()` to re-fetch all data from the server.

When preview mode is disabled, the composable will attach a callback to call `refreshNuxtData()` to run after a subsequent router navigation.

You can specify custom callbacks to be triggered by providing your own functions for the `onEnable` and `onDisable` options.

```ts
const { enabled, state } = usePreviewMode({
  onEnable: () => {
    console.log('preview mode has been enabled')
  },
  onDisable: () => {
    console.log('preview mode has been disabled')
  },
})
```

## Example

The example below creates a page where part of a content is rendered only in preview mode.

```vue [app/pages/some-page.vue]
<script setup>
const { enabled, state } = usePreviewMode()

const { data } = await useFetch('/api/preview', {
  query: {
    apiKey: state.token,
  },
})
</script>

<template>
  <div>
    Some base content
    <p v-if="enabled">
      Only preview content: {{ state.token }}
      <br>
      <button @click="enabled = false">
        disable preview mode
      </button>
    </p>
  </div>
</template>
```

Now you can generate your site and serve it:

```bash [Terminal]
npx nuxt generate
npx nuxt preview
```

Then you can see your preview page by adding the query param `preview` to the end of the page you want to see once, for example `http://localhost:3000/?preview=true`.

::note
`usePreviewMode` should be tested locally with `nuxt generate` and then `nuxt preview` rather than `nuxt dev`. (The [preview command](/docs/4.x/api/commands/preview) is not related to preview mode.)
::
</file>

<file path="docs/4.api/2.composables/use-request-event.md">
---
title: 'useRequestEvent'
description: 'Access the incoming request event with the useRequestEvent composable.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/ssr.ts
    size: xs
---

Within the [Nuxt context](/docs/4.x/guide/going-further/nuxt-app#the-nuxt-context) you can use `useRequestEvent` to access the incoming request.

```ts
// Get underlying request event
const event = useRequestEvent()

// Get the URL
const url = event?.path
```

::tip
In the browser, `useRequestEvent` will return `undefined`.
::
</file>

<file path="docs/4.api/2.composables/use-request-fetch.md">
---
title: 'useRequestFetch'
description: 'Forward the request context and headers for server-side fetch requests with the useRequestFetch composable.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/ssr.ts
    size: xs
---

You can use `useRequestFetch` to forward the request context and headers when making server-side fetch requests.

When making a client-side fetch request, the browser automatically sends the necessary headers.
However, when making a request during server-side rendering, due to security considerations, we need to forward the headers manually.

::note
Headers that are **not meant to be forwarded** will **not be included** in the request. These headers include, for example:
`transfer-encoding`, `connection`, `keep-alive`, `upgrade`, `expect`, `host`, `accept`
::

::tip
The [`useFetch`](/docs/4.x/api/composables/use-fetch) composable uses `useRequestFetch` under the hood to automatically forward the request context and headers.
::

::code-group

```vue [app/pages/index.vue]
<script setup lang="ts">
// This will forward the user's headers to the `/api/cookies` event handler
// Result: { cookies: { foo: 'bar' } }
const requestFetch = useRequestFetch()
const { data: forwarded } = await useAsyncData(() => requestFetch('/api/cookies'))

// This will NOT forward anything
// Result: { cookies: {} }
const { data: notForwarded } = await useAsyncData((_nuxtApp, { signal }) => $fetch('/api/cookies', { signal }))
</script>
```

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const cookies = parseCookies(event)

  return { cookies }
})
```

::

::tip
In the browser during client-side navigation, `useRequestFetch` will behave just like regular [`$fetch`](/docs/4.x/api/utils/dollarfetch).
::
</file>

<file path="docs/4.api/2.composables/use-request-header.md">
---
title: "useRequestHeader"
description: "Use useRequestHeader to access a certain incoming request header."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/ssr.ts
    size: xs
---

You can use the built-in [`useRequestHeader`](/docs/4.x/api/composables/use-request-header) composable to access any incoming request header within your pages, components, and plugins.

```ts
// Get the authorization request header
const authorization = useRequestHeader('authorization')
```

::tip
In the browser, `useRequestHeader` will return `undefined`.
::

## Example

We can use `useRequestHeader` to easily figure out if a user is authorized or not.

The example below reads the `authorization` request header to find out if a person can access a restricted resource.

```ts [app/middleware/authorized-only.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  if (!useRequestHeader('authorization')) {
    return navigateTo('/not-authorized')
  }
})
```
</file>

<file path="docs/4.api/2.composables/use-request-headers.md">
---
title: "useRequestHeaders"
description: "Use useRequestHeaders to access the incoming request headers."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/ssr.ts
    size: xs
---

You can use built-in [`useRequestHeaders`](/docs/4.x/api/composables/use-request-headers) composable to access the incoming request headers within your pages, components, and plugins.

```ts
// Get all request headers
const headers = useRequestHeaders()

// Get only cookie request header
const { cookie } = useRequestHeaders(['cookie'])
```

::tip
In the browser, `useRequestHeaders` will return an empty object.
::

## Example

We can use `useRequestHeaders` to access and proxy the initial request's `authorization` header to any future internal requests during SSR.

The example below adds the `authorization` request header to an isomorphic `$fetch` call.

```vue [app/pages/some-page.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/confidential', {
  headers: useRequestHeaders(['authorization']),
})
</script>
```
</file>

<file path="docs/4.api/2.composables/use-request-url.md">
---
title: 'useRequestURL'
description: 'Access the incoming request URL with the useRequestURL composable.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/url.ts
    size: xs
---

`useRequestURL` is a helper function that returns an [URL object](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) working on both server-side and client-side.

::important
When utilizing [Hybrid Rendering](/docs/4.x/guide/concepts/rendering#hybrid-rendering) with cache strategies, all incoming request headers are dropped when handling the cached responses via the [Nitro caching layer](https://nitro.build/guide/cache) (meaning `useRequestURL` will return `localhost` for the `host`).

You can define the [`cache.varies` option](https://nitro.build/guide/cache#options) to specify headers that will be considered when caching and serving the responses, such as `host` and `x-forwarded-host` for multi-tenant environments.
::

::code-group

```vue [app/pages/about.vue]
<script setup lang="ts">
const url = useRequestURL()
</script>

<template>
  <p>URL is: {{ url }}</p>
  <p>Path is: {{ url.pathname }}</p>
</template>
```

```html [Result in development]
<p>URL is: http://localhost:3000/about</p>
<p>Path is: /about</p>
```

::

::tip{icon="i-simple-icons-mdnwebdocs" to="https://developer.mozilla.org/en-US/docs/Web/API/URL#instance_properties" target="_blank"}
Read about the URL instance properties on the MDN documentation.
::
</file>

<file path="docs/4.api/2.composables/use-response-header.md">
---
title: "useResponseHeader"
description: "Use useResponseHeader to set a server response header."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/ssr.ts
    size: xs
---

::important
This composable is available in Nuxt v3.14+.
::

You can use the built-in [`useResponseHeader`](/docs/4.x/api/composables/use-response-header) composable to set any server response header within your pages, components, and plugins.

```ts
// Set a custom response header
const header = useResponseHeader('X-My-Header')
header.value = 'my-value'
```

## Example

We can use `useResponseHeader` to easily set a response header on a per-page basis.

```vue [app/pages/test.vue]
<script setup>
// pages/test.vue
const header = useResponseHeader('X-My-Header')
header.value = 'my-value'
</script>

<template>
  <h1>Test page with custom header</h1>
  <p>The response from the server for this "/test" page will have a custom "X-My-Header" header.</p>
</template>
```

We can use `useResponseHeader` for example in Nuxt [middleware](/docs/4.x/directory-structure/app/middleware) to set a response header for all pages.

```ts [app/middleware/my-header-middleware.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const header = useResponseHeader('X-My-Always-Header')
  header.value = `I'm Always here!`
})
```
</file>

<file path="docs/4.api/2.composables/use-route-announcer.md">
---
title: 'useRouteAnnouncer'
description: This composable observes the page title changes and updates the announcer message accordingly.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/route-announcer.ts
    size: xs
---

::important
This composable is available in Nuxt v3.12+.
::

## Description

A composable which observes the page title changes and updates the announcer message accordingly. Used by [`<NuxtRouteAnnouncer>`](/docs/4.x/api/components/nuxt-route-announcer) and controllable.
It hooks into Unhead's [`dom:rendered`](https://unhead.unjs.io/docs/typescript/head/api/hooks/dom-rendered) to read the page's title and set it as the announcer message.

## Parameters

- `politeness`: Sets the urgency for screen reader announcements: `off` (disable the announcement), `polite` (waits for silence), or `assertive` (interrupts immediately).  (default `polite`).

## Properties

### `message`

- **type**: `Ref<string>`
- **description**: The message to announce

### `politeness`

- **type**: `Ref<string>`
- **description**: Screen reader announcement urgency level `off`, `polite`, or `assertive`

## Methods

### `set(message, politeness = "polite")`

Sets the message to announce with its urgency level.

### `polite(message)`

Sets the message with `politeness = "polite"`

### `assertive(message)`

Sets the message with `politeness = "assertive"`

## Example

```vue [app/pages/index.vue]
<script setup lang="ts">
const { message, politeness, set, polite, assertive } = useRouteAnnouncer({
  politeness: 'assertive',
})
</script>
```
</file>

<file path="docs/4.api/2.composables/use-route.md">
---
title: "useRoute"
description: The useRoute composable returns the current route.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/router.ts
    size: xs
---

::note
Within the template of a Vue component, you can access the route using `$route`.
::

The `useRoute` composable is a wrapper around the identically named composable from `vue-router`, providing access to the current route in a Nuxt application.

The key difference is that in Nuxt, the composable ensures that the route is updated **only after** the page content has changed after navigation.
In contrast, the `vue-router` version updates the route **immediately**, which can lead to synchronization issues between different parts of the template
that rely on the route metadata, for example.

## Example

In the following example, we call an API via [`useFetch`](/docs/4.x/api/composables/use-fetch) using a dynamic page parameter - `slug` - as part of the URL.

```html [~/pages/[slug\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data: mountain } = await useFetch(`/api/mountains/${route.params.slug}`)
</script>

<template>
  <div>
    <h1>{{ mountain.title }}</h1>
    <p>{{ mountain.description }}</p>
  </div>
</template>
```

If you need to access the route query parameters (for example `example` in the path `/test?example=true`), then you can use `useRoute().query` instead of `useRoute().params`.

## API

Apart from dynamic parameters and query parameters, `useRoute()` also provides the following computed references related to the current route:

- `fullPath`: encoded URL associated with the current route that contains path, query and hash
- `hash`: decoded hash section of the URL that starts with a #
- `query`: access route query parameters
- `matched`: array of normalized matched routes with current route location
- `meta`: custom data attached to the record
- `name`: unique name for the route record
- `path`: encoded pathname section of the URL
- `redirectedFrom`: route location that was attempted to access before ending up on the current route location

## Common Pitfalls

### Route Synchronization Issues

It’s important to use the `useRoute()` composable from Nuxt rather than the one from `vue-router` to avoid synchronization issues during page navigation.
Importing `useRoute` directly from `vue-router` bypasses Nuxt's implementation.

```ts twoslash
// ❌ do not use `useRoute` from `vue-router`
// @errors: 2300
import { useRoute } from 'vue-router'
// ✅ use Nuxt's `useRoute` composable
import { useRoute } from '#app'
```

### Calling `useRoute` in Middleware

Using `useRoute` in middleware is not recommended because it can lead to unexpected behavior.
There is no concept of a "current route" in middleware.
The `useRoute()` composable should only be used in the setup function of a Vue component or in a Nuxt plugin.

::warning
This applies to any composable that uses `useRoute()` internally too.
::

::read-more{to="/docs/4.x/directory-structure/app/middleware"}
Read more about accessing the route in the middleware section.
::

### Hydration Issues with `route.fullPath`

Browsers don't send [URL fragments](https://url.spec.whatwg.org/#concept-url-fragment) (for example `#foo`) when making requests. So using `route.fullPath` to affect the template can trigger hydration issues because this will include the fragment on client but not the server.

:read-more{icon="i-simple-icons-vuedotjs" to="https://router.vuejs.org/api/type-aliases/routelocationnormalizedloaded"}
</file>

<file path="docs/4.api/2.composables/use-router.md">
---
title: "useRouter"
description: "The useRouter composable returns the router instance."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/router.ts
    size: xs
---

```vue [app/pages/index.vue]
<script setup lang="ts">
const router = useRouter()
</script>
```

If you only need the router instance within your template, use `$router`:

```vue [app/pages/index.vue]
<template>
  <button @click="$router.back()">
    Back
  </button>
</template>
```

If you have a `app/pages/` directory, `useRouter` is identical in behavior to the one provided by `vue-router`.

::read-more{icon="i-simple-icons-vuedotjs" to="https://router.vuejs.org/api/interfaces/router#Properties-currentRoute-" target="_blank"}
Read `vue-router` documentation about the `Router` interface.
::

## Basic Manipulation

- [`addRoute()`](https://router.vuejs.org/api/interfaces/router#addRoute-): Add a new route to the router instance. `parentName` can be provided to add new route as the child of an existing route.
- [`removeRoute()`](https://router.vuejs.org/api/interfaces/router#removeRoute-): Remove an existing route by its name.
- [`getRoutes()`](https://router.vuejs.org/api/interfaces/router#getRoutes-): Get a full list of all the route records.
- [`hasRoute()`](https://router.vuejs.org/api/interfaces/router#hasRoute-): Checks if a route with a given name exists.
- [`resolve()`](https://router.vuejs.org/api/interfaces/router#resolve-): Returns the normalized version of a route location. Also includes an `href` property that includes any existing base.

```ts [Example]
const router = useRouter()

router.addRoute({ name: 'home', path: '/home', component: Home })
router.removeRoute('home')
router.getRoutes()
router.hasRoute('home')
router.resolve({ name: 'home' })
```

::note
`router.addRoute()` adds route details into an array of routes and it is useful while building [Nuxt plugins](/docs/4.x/directory-structure/app/plugins) while `router.push()` on the other hand, triggers a new navigation immediately and it is useful in pages, Vue components and composable.
::

## Based on History API

- [`back()`](https://router.vuejs.org/api/interfaces/router#back-): Go back in history if possible, same as `router.go(-1)`.
- [`forward()`](https://router.vuejs.org/api/interfaces/router#forward-): Go forward in history if possible, same as `router.go(1)`.
- [`go()`](https://router.vuejs.org/api/interfaces/router#go-): Move forward or backward through the history without the hierarchical restrictions enforced in `router.back()` and `router.forward()`.
- [`push()`](https://router.vuejs.org/api/interfaces/router#push-): Programmatically navigate to a new URL by pushing an entry in the history stack. **It is recommended to use [`navigateTo`](/docs/4.x/api/utils/navigate-to) instead.**
- [`replace()`](https://router.vuejs.org/api/interfaces/router#replace-): Programmatically navigate to a new URL by replacing the current entry in the routes history stack. **It is recommended to use [`navigateTo`](/docs/4.x/api/utils/navigate-to) instead.**

```ts [Example]
const router = useRouter()

router.back()
router.forward()
router.go(3)
router.push({ path: '/home' })
router.replace({ hash: '#bio' })
```

::read-more{icon="i-simple-icons-mdnwebdocs" to="https://developer.mozilla.org/en-US/docs/Web/API/History" target="_blank"}
Read more about the browser's History API.
::

## Navigation Guards

`useRouter` composable provides `afterEach`, `beforeEach` and `beforeResolve` helper methods that acts as navigation guards.

However, Nuxt has a concept of **route middleware** that simplifies the implementation of navigation guards and provides a better developer experience.

:read-more{to="/docs/4.x/directory-structure/app/middleware"}

## Promise and Error Handling

- [`isReady()`](https://router.vuejs.org/api/interfaces/router#isReady-): Returns a Promise that resolves when the router has completed the initial navigation.
- [`onError`](https://router.vuejs.org/api/interfaces/router#onError-): Adds an error handler that is called every time a non caught error happens during navigation.

:read-more{icon="i-simple-icons-vuedotjs" to="https://router.vuejs.org/api/interfaces/router#Methods-" title="Vue Router Docs" target="_blank"}

## Universal Router Instance

If you do not have a `app/pages/` folder, then [`useRouter`](/docs/4.x/api/composables/use-router)  will return a universal router instance with similar helper methods, but be aware that not all features may be supported or behave in exactly the same way as with `vue-router`.
</file>

<file path="docs/4.api/2.composables/use-runtime-config.md">
---
title: 'useRuntimeConfig'
description: 'Access runtime config variables with the useRuntimeConfig composable.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts
    size: xs
---

## Usage

```vue [app/app.vue]
<script setup lang="ts">
const config = useRuntimeConfig()
</script>
```

```ts [server/api/foo.ts]
export default defineEventHandler((event) => {
  const config = useRuntimeConfig(event)
})
```

:read-more{to="/docs/4.x/guide/going-further/runtime-config"}

## Define Runtime Config

The example below shows how to set a public API base URL and a secret API token that is only accessible on the server.

We should always define `runtimeConfig` variables inside `nuxt.config`.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    // Private keys are only available on the server
    apiSecret: '123',

    // Public keys that are exposed to the client
    public: {
      apiBase: process.env.NUXT_PUBLIC_API_BASE || '/api',
    },
  },
})
```

::note
Variables that need to be accessible on the server are added directly inside `runtimeConfig`. Variables that need to be accessible on both the client and the server are defined in `runtimeConfig.public`.
::

:read-more{to="/docs/4.x/guide/going-further/runtime-config"}

## Access Runtime Config

To access runtime config, we can use `useRuntimeConfig()` composable:

```ts [server/api/test.ts]
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig(event)

  // Access public variables
  const result = await $fetch(`/test`, {
    baseURL: config.public.apiBase,
    headers: {
      // Access a private variable (only available on the server)
      Authorization: `Bearer ${config.apiSecret}`,
    },
  })
  return result
})
```

In this example, since `apiBase` is defined within the `public` namespace, it is universally accessible on both server and client-side, while `apiSecret` **is only accessible on the server-side**.

## Environment Variables

It is possible to update runtime config values using a matching environment variable name prefixed with `NUXT_`.

:read-more{to="/docs/4.x/guide/going-further/runtime-config"}

### Using the `.env` File

We can set the environment variables inside the `.env` file to make them accessible during **development** and **build/generate**.

```ini [.env]
NUXT_PUBLIC_API_BASE = "https://api.localhost:5555"
NUXT_API_SECRET = "123"
```

::note
Any environment variables set within `.env` file are accessed using `process.env` in the Nuxt app during **development** and **build/generate**.
::

::warning
In **production runtime**, you should use platform environment variables and `.env` is not used.
::

:read-more{to="/docs/4.x/directory-structure/env"}

## `app` namespace

Nuxt uses `app` namespace in runtime-config with keys including `baseURL` and `cdnURL`. You can customize their values at runtime by setting environment variables.

::note
This is a reserved namespace. You should not introduce additional keys inside `app`.
::

### `app.baseURL`

By default, the `baseURL` is set to `'/'`.

However, the `baseURL` can be updated at runtime by setting the `NUXT_APP_BASE_URL` as an environment variable.

Then, you can access this new base URL using `config.app.baseURL`:

```ts [/plugins/my-plugin.ts]
export default defineNuxtPlugin((NuxtApp) => {
  const config = useRuntimeConfig()

  // Access baseURL universally
  const baseURL = config.app.baseURL
})
```

### `app.cdnURL`

This example shows how to set a custom CDN url and access them using `useRuntimeConfig()`.

You can use a custom CDN for serving static assets inside `.output/public` using the `NUXT_APP_CDN_URL` environment variable.

And then access the new CDN url using `config.app.cdnURL`.

```ts [server/api/foo.ts]
export default defineEventHandler((event) => {
  const config = useRuntimeConfig(event)

  // Access cdnURL universally
  const cdnURL = config.app.cdnURL
})
```

:read-more{to="/docs/4.x/guide/going-further/runtime-config"}
</file>

<file path="docs/4.api/2.composables/use-runtime-hook.md">
---
title: useRuntimeHook
description: Registers a runtime hook in a Nuxt application and ensures it is properly disposed of when the scope is destroyed.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/runtime-hook.ts
    size: xs
---

::important
This composable is available in Nuxt v3.14+.
::

```ts [signature]
function useRuntimeHook<THookName extends keyof RuntimeNuxtHooks> (
  name: THookName,
  fn: RuntimeNuxtHooks[THookName] extends HookCallback ? RuntimeNuxtHooks[THookName] : never,
): void
```

## Usage

### Parameters

- `name`: The name of the runtime hook to register. You can see the full list of [runtime Nuxt hooks here](/docs/4.x/api/advanced/hooks#app-hooks-runtime).
- `fn`: The callback function to execute when the hook is triggered. The function signature varies based on the hook name.

### Returns

The composable doesn't return a value, but it automatically unregisters the hook when the component's scope is destroyed.

## Example

```vue twoslash [pages/index.vue]
<script setup lang="ts">
// Register a hook that runs every time a link is prefetched, but which will be
// automatically cleaned up (and not called again) when the component is unmounted
useRuntimeHook('link:prefetch', (link) => {
  console.log('Prefetching', link)
})
</script>
```
</file>

<file path="docs/4.api/2.composables/use-seo-meta.md">
---
title: 'useSeoMeta'
description: The useSeoMeta composable lets you define your site's SEO meta tags as a flat object with full TypeScript support.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/unjs/unhead/blob/main/packages/vue/src/composables.ts
    size: xs
---

This helps you avoid common mistakes, such as using `name` instead of `property`, as well as typos - with over 100+ meta tags fully typed.

::important
This is the recommended way to add meta tags to your site as it is XSS safe and has full TypeScript support.
::

:read-more{to="/docs/4.x/getting-started/seo-meta"}

## Usage

```vue [app/app.vue]
<script setup lang="ts">
useSeoMeta({
  title: 'My Amazing Site',
  ogTitle: 'My Amazing Site',
  description: 'This is my amazing site, let me tell you all about it.',
  ogDescription: 'This is my amazing site, let me tell you all about it.',
  ogImage: 'https://example.com/image.png',
  twitterCard: 'summary_large_image',
})
</script>
```

When inserting tags that are reactive, you should use the computed getter syntax (`() => value`):

```vue [app/app.vue]
<script setup lang="ts">
const title = ref('My title')

useSeoMeta({
  title,
  description: () => `This is a description for the ${title.value} page`,
})
</script>
```

## Parameters

There are over 100 parameters. See the [full list of parameters in the source code](https://github.com/harlan-zw/zhead/blob/main/packages/zhead/src/metaFlat.ts#L1035).

:read-more{to="/docs/4.x/getting-started/seo-meta"}

## Performance

In most instances, SEO meta tags don't need to be reactive as search engine robots primarily scan the initial page load.

For better performance, you can wrap your `useSeoMeta` calls in a server-only condition when the meta tags don't need to be reactive:

```vue [app/app.vue]
<script setup lang="ts">
if (import.meta.server) {
  // These meta tags will only be added during server-side rendering
  useSeoMeta({
    robots: 'index, follow',
    description: 'Static description that does not need reactivity',
    ogImage: 'https://example.com/image.png',
    // other static meta tags...
  })
}

const dynamicTitle = ref('My title')
// Only use reactive meta tags outside the condition when necessary
useSeoMeta({
  title: () => dynamicTitle.value,
  ogTitle: () => dynamicTitle.value,
})
</script>
```

This previously used the [`useServerSeoMeta`](/docs/4.x/api/composables/use-server-seo-meta) composable, but it has been deprecated in favor of this approach.
</file>

<file path="docs/4.api/2.composables/use-server-seo-meta.md">
---
title: 'useServerSeoMeta'
description: The useServerSeoMeta composable lets you define your site's SEO meta tags as a flat object with full TypeScript support.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/unjs/unhead/blob/main/packages/vue/src/composables.ts
    size: xs
---

Just like [`useSeoMeta`](/docs/4.x/api/composables/use-seo-meta), `useServerSeoMeta` composable lets you define your site's SEO meta tags as a flat object with full TypeScript support.

:read-more{to="/docs/4.x/api/composables/use-seo-meta"}

In most instances, the meta doesn't need to be reactive as robots will only scan the initial load. So we recommend using [`useServerSeoMeta`](/docs/4.x/api/composables/use-server-seo-meta) as a performance-focused utility that will not do anything (or return a `head` object) on the client.

```vue [app/app.vue]
<script setup lang="ts">
useServerSeoMeta({
  robots: 'index, follow',
})
</script>
```

Parameters are exactly the same as with [`useSeoMeta`](/docs/4.x/api/composables/use-seo-meta)

:read-more{to="/docs/4.x/getting-started/seo-meta"}
</file>

<file path="docs/4.api/2.composables/use-state.md">
---
title: "useState"
description: The useState composable creates a reactive and SSR-friendly shared state.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/state.ts
    size: xs
---

## Usage

```ts
// Create a reactive state and set default value
const count = useState('counter', () => Math.round(Math.random() * 100))
```

:read-more{to="/docs/4.x/getting-started/state-management"}

::important
Because the data inside `useState` will be serialized to JSON, it is important that it does not contain anything that cannot be serialized, such as classes, functions or symbols.
::

::warning
`useState` is a reserved function name transformed by the compiler, so you should not name your own function `useState`.
::

:video-accordion{title="Watch a video from Alexander Lichter about why and when to use useState" videoId="mv0WcBABcIk"}

## Using `shallowRef`

If you don't need your state to be deeply reactive, you can combine `useState` with [`shallowRef`](https://vuejs.org/api/reactivity-advanced#shallowref). This can improve performance when your state contains large objects and arrays.

```ts
const state = useState('my-shallow-state', () => shallowRef({ deep: 'not reactive' }))
// isShallow(state) === true
```

## Type

```ts [Signature]
export function useState<T> (init?: () => T | Ref<T>): Ref<T>
export function useState<T> (key: string, init?: () => T | Ref<T>): Ref<T>
```

- `key`: A unique key ensuring that data fetching is properly de-duplicated across requests. If you do not provide a key, then a key that is unique to the file and line number of the instance of [`useState`](/docs/4.x/api/composables/use-state) will be generated for you.
- `init`: A function that provides initial value for the state when not initiated. This function can also return a `Ref`.
- `T`: (typescript only) Specify the type of state
</file>

<file path="docs/4.api/3.utils/.navigation.yml">
title: 'Utils'
titleTemplate: '%s · Nuxt Utils'
navigation.icon: i-lucide-square-function
</file>

<file path="docs/4.api/3.utils/$fetch.md">
---
title: "$fetch"
description: Nuxt uses ofetch to expose globally the $fetch helper for making HTTP requests.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/entry.ts
    size: xs
---

Nuxt uses [ofetch](https://github.com/unjs/ofetch) to expose globally the `$fetch` helper for making HTTP requests within your Vue app or API routes.

::tip{icon="i-lucide-rocket"}
During server-side rendering, calling `$fetch` to fetch your internal [API routes](/docs/4.x/directory-structure/server) will directly call the relevant function (emulating the request), **saving an additional API call**.
::

::note{color="blue" icon="i-lucide-info"}
Using `$fetch` in components without wrapping it with [`useAsyncData`](/docs/4.x/api/composables/use-async-data) causes fetching the data twice: initially on the server, then again on the client-side during hydration, because `$fetch` does not transfer state from the server to the client. Thus, the fetch will be executed on both sides because the client has to get the data again.
::

## Usage

We recommend using [`useFetch`](/docs/4.x/api/composables/use-fetch) or [`useAsyncData`](/docs/4.x/api/composables/use-async-data) + `$fetch` to prevent double data fetching when fetching the component data.

```vue [app/app.vue]
<script setup lang="ts">
// During SSR data is fetched twice, once on the server and once on the client.
const dataTwice = await $fetch('/api/item')

// During SSR data is fetched only on the server side and transferred to the client.
const { data } = await useAsyncData('item', () => $fetch('/api/item'))

// You can also useFetch as shortcut of useAsyncData + $fetch
const { data } = await useFetch('/api/item')
</script>
```

:read-more{to="/docs/4.x/getting-started/data-fetching"}

You can use `$fetch` in any methods that are executed only on client-side.

```vue [app/pages/contact.vue]
<script setup lang="ts">
async function contactForm () {
  await $fetch('/api/contact', {
    method: 'POST',
    body: { hello: 'world' },
  })
}
</script>

<template>
  <button @click="contactForm">
    Contact
  </button>
</template>
```

::tip
`$fetch` is the preferred way to make HTTP calls in Nuxt instead of [@nuxt/http](https://github.com/nuxt/http) and [@nuxtjs/axios](https://github.com/nuxt-community/axios-module) that are made for Nuxt 2.
::

::note
If you use `$fetch` to call an (external) HTTPS URL with a self-signed certificate in development, you will need to set `NODE_TLS_REJECT_UNAUTHORIZED=0` in your environment.
::

### Passing Headers and Cookies

When we call `$fetch` in the browser, user headers like `cookie` will be directly sent to the API.

However, during Server-Side Rendering, due to security risks such as **Server-Side Request Forgery (SSRF)** or **Authentication Misuse**, the `$fetch` wouldn't include the user's browser cookies, nor pass on cookies from the fetch response.

::code-group

```vue [app/pages/index.vue]
<script setup lang="ts">
// This will NOT forward headers or cookies during SSR
const { data } = await useAsyncData(() => $fetch('/api/cookies'))
</script>
```

```ts [server/api/cookies.ts]
export default defineEventHandler((event) => {
  const foo = getCookie(event, 'foo')
  // ... Do something with the cookie
})
```
::

If you need to forward headers and cookies on the server, you must manually pass them:

```vue [app/pages/index.vue]
<script setup lang="ts">
// This will forward the user's headers and cookies to `/api/cookies`
const requestFetch = useRequestFetch()
const { data } = await useAsyncData(() => requestFetch('/api/cookies'))
</script>
```

However, when calling `useFetch` with a relative URL on the server, Nuxt will use [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) to proxy headers and cookies (with the exception of headers not meant to be forwarded, like `host`).
</file>

<file path="docs/4.api/3.utils/abort-navigation.md">
---
title: 'abortNavigation'
description: 'abortNavigation is a helper function that prevents navigation from taking place and throws an error if one is set as a parameter.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/router.ts
    size: xs
---

::warning
`abortNavigation` is only usable inside a [route middleware handler](/docs/4.x/directory-structure/app/middleware).
::

## Type

```ts [Signature]
export function abortNavigation (err?: Error | string): false
```

## Parameters

### `err`

- **Type**: [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) | `string`

  Optional error to be thrown by `abortNavigation`.

## Examples

The example below shows how you can use `abortNavigation` in a route middleware to prevent unauthorized route access:

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const user = useState('user')

  if (!user.value.isAuthorized) {
    return abortNavigation()
  }

  if (to.path !== '/edit-post') {
    return navigateTo('/edit-post')
  }
})
```

### `err` as a String

You can pass the error as a string:

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const user = useState('user')

  if (!user.value.isAuthorized) {
    return abortNavigation('Insufficient permissions.')
  }
})
```

### `err` as an Error Object

You can pass the error as an [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object, e.g. caught by the `catch`-block:

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  try {
    /* code that might throw an error */
  } catch (err) {
    return abortNavigation(err)
  }
})
```
</file>

<file path="docs/4.api/3.utils/add-route-middleware.md">
---
title: 'addRouteMiddleware'
description: 'addRouteMiddleware() is a helper function to dynamically add middleware in your application.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/router.ts
    size: xs
---

::note
Route middleware are navigation guards stored in the [`app/middleware/`](/docs/4.x/directory-structure/app/middleware) directory of your Nuxt application (unless [set otherwise](/docs/4.x/api/nuxt-config#middleware)).
::

## Type

```ts
function addRouteMiddleware (name: string, middleware: RouteMiddleware, options?: AddRouteMiddlewareOptions): void
function addRouteMiddleware (middleware: RouteMiddleware): void

interface AddRouteMiddlewareOptions {
  global?: boolean
}
```

## Parameters

### `name`

- **Type:** `string` | `RouteMiddleware`

Can be either a string or a function of type `RouteMiddleware`. Function takes the next route `to` as the first argument and the current route `from` as the second argument, both of which are Vue route objects.

Learn more about available properties of [route objects](/docs/4.x/api/composables/use-route).

### `middleware`

- **Type:** `RouteMiddleware`

The second argument is a function of type `RouteMiddleware`. Same as above, it provides `to` and `from` route objects. It becomes optional if the first argument in `addRouteMiddleware()` is already passed as a function.

### `options`

- **Type:** `AddRouteMiddlewareOptions`

An optional `options` argument lets you set the value of `global` to `true` to indicate whether the router middleware is global or not (set to `false` by default).

## Examples

### Named Route Middleware

Named route middleware is defined by providing a string as the first argument and a function as the second:

```ts [app/plugins/my-plugin.ts]
export default defineNuxtPlugin(() => {
  addRouteMiddleware('named-middleware', () => {
    console.log('named middleware added in Nuxt plugin')
  })
})
```

When defined in a plugin, it overrides any existing middleware of the same name located in the `app/middleware/` directory.

### Global Route Middleware

Global route middleware can be defined in two ways:

- Pass a function directly as the first argument without a name. It will automatically be treated as global middleware and applied on every route change.

  ```ts [app/plugins/my-plugin.ts]
  export default defineNuxtPlugin(() => {
    addRouteMiddleware((to, from) => {
      console.log('anonymous global middleware that runs on every route change')
    })
  })
  ```

- Set an optional, third argument `{ global: true }` to indicate whether the route middleware is global.

  ```ts [app/plugins/my-plugin.ts]
  export default defineNuxtPlugin(() => {
    addRouteMiddleware('global-middleware', (to, from) => {
      console.log('global middleware that runs on every route change')
    },
    { global: true },
    )
  })
  ```
</file>

<file path="docs/4.api/3.utils/call-once.md">
---
title: "callOnce"
description: "Run a given function or block of code once during SSR or CSR."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/once.ts
    size: xs
---

::important
This utility is available since [Nuxt v3.9](/blog/v3-9).
::

## Purpose

The `callOnce` function is designed to execute a given function or block of code only once during:
- server-side rendering but not hydration
- client-side navigation

This is useful for code that should be executed only once, such as logging an event or setting up a global state.

## Usage

The default mode of `callOnce` is to run code only once. For example, if the code runs on the server it won't run again on the client. It also won't run again if you `callOnce` more than once on the client, for example by navigating back to this page.

```vue [app/app.vue]
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  console.log('This will only be logged once')
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
})
</script>
```

It is also possible to run on every navigation while still avoiding the initial server/client double load. For this, it is possible to use the `navigation` mode:

```vue [app/app.vue]
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  console.log('This will only be logged once and then on every client side navigation')
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
}, { mode: 'navigation' })
</script>
```

::important
`navigation` mode is available since [Nuxt v3.15](/blog/v3-15).
::

::tip{to="/docs/4.x/getting-started/state-management#usage-with-pinia"}
`callOnce` is useful in combination with the [Pinia module](/modules/pinia) to call store actions.
::

:read-more{to="/docs/4.x/getting-started/state-management"}

::warning
Note that `callOnce` doesn't return anything. You should use [`useAsyncData`](/docs/4.x/api/composables/use-async-data) or [`useFetch`](/docs/4.x/api/composables/use-fetch) if you want to do data fetching during SSR.
::

::note
`callOnce` is a composable meant to be called directly in a setup function, plugin, or route middleware, because it needs to add data to the Nuxt payload to avoid re-calling the function on the client when the page hydrates.
::

## Type

```ts [Signature]
export function callOnce (key?: string, fn?: (() => any | Promise<any>), options?: CallOnceOptions): Promise<void>
export function callOnce (fn?: (() => any | Promise<any>), options?: CallOnceOptions): Promise<void>

type CallOnceOptions = {
  /**
   * Execution mode for the callOnce function
   * @default 'render'
   */
  mode?: 'navigation' | 'render'
}
```

## Parameters

- `key`: A unique key ensuring that the code is run once. If you do not provide a key, then a key that is unique to the file and line number of the instance of `callOnce` will be generated for you.
- `fn`: The function to run once. It can be asynchronous.
- `options`: Setup the mode, either to re-execute on navigation (`navigation`) or just once for the lifetime of the app (`render`). Defaults to `render`.
  - `render`: Executes once during initial render (either SSR or CSR) - Default mode
  - `navigation`: Executes once during initial render and once per subsequent client-side navigation
</file>

<file path="docs/4.api/3.utils/clear-error.md">
---
title: "clearError"
description: "The clearError composable clears all handled errors."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/error.ts
    size: xs
---

Within your pages, components, and plugins, you can use `clearError` to clear all errors and redirect the user.

**Parameters:**

- `options?: { redirect?: string }`

You can provide an optional path to redirect to (for example, if you want to navigate to a 'safe' page).

```ts
// Without redirect
clearError()

// With redirect
clearError({ redirect: '/homepage' })
```

Errors are set in state using [`useError()`](/docs/4.x/api/composables/use-error). The `clearError` composable will reset this state and calls the `app:error:cleared` hook with the provided options.

:read-more{to="/docs/4.x/getting-started/error-handling"}
</file>

<file path="docs/4.api/3.utils/clear-nuxt-data.md">
---
title: 'clearNuxtData'
description: Delete cached data, error status and pending promises of useAsyncData and useFetch.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/asyncData.ts
    size: xs
---

::note
This method is useful if you want to invalidate the data fetching for another page.
::

## Type

```ts [Signature]
export function clearNuxtData (keys?: string | string[] | ((key: string) => boolean)): void
```

## Parameters

* `keys`: One or an array of keys that are used in [`useAsyncData`](/docs/4.x/api/composables/use-async-data) to delete their cached data. If no keys are provided, **all data** will be invalidated.
</file>

<file path="docs/4.api/3.utils/clear-nuxt-state.md">
---
title: 'clearNuxtState'
description: Delete the cached state of useState.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/state.ts
    size: xs
---

::note
This method is useful if you want to invalidate the state of `useState`.
::

## Type

```ts [Signature]
export function clearNuxtState (keys?: string | string[] | ((key: string) => boolean)): void
```

## Parameters

- `keys`: One or an array of keys that are used in [`useState`](/docs/4.x/api/composables/use-state) to delete their cached state. If no keys are provided, **all state** will be invalidated.
</file>

<file path="docs/4.api/3.utils/create-error.md">
---
title: 'createError'
description: Create an error object with additional metadata.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/error.ts
    size: xs
---

You can use this function to create an error object with additional metadata. It is usable in both the Vue and Nitro portions of your app, and is meant to be thrown.

## Parameters

- `err`: `string | { cause, data, message, name, stack, status, statusText, fatal }`

You can pass either a string or an object to the `createError` function. If you pass a string, it will be used as the error `message`, and the `status` will default to `500`. If you pass an object, you can set multiple properties of the error, such as `status`, `message`, and other error properties.

## In Vue App

If you throw an error created with `createError`:

- on server-side, it will trigger a full-screen error page which you can clear with `clearError`.
- on client-side, it will throw a non-fatal error for you to handle. If you need to trigger a full-screen error page, then you can do this by setting `fatal: true`.

### Example

```vue [app/pages/movies/[slug\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data } = await useFetch(`/api/movies/${route.params.slug}`)
if (!data.value) {
  throw createError({ status: 404, statusText: 'Page Not Found' })
}
</script>
```

## In API Routes

Use `createError` to trigger error handling in server API routes.

### Example

```ts [server/api/error.ts]
export default eventHandler(() => {
  throw createError({
    status: 404,
    statusText: 'Page Not Found',
  })
})
```

In API routes, using `createError` by passing an object with a short `statusText` is recommended because it can be accessed on the client side. Otherwise, a `message` passed to `createError` on an API route will not propagate to the client. Alternatively, you can use the `data` property to pass data back to the client. In any case, always consider avoiding to put dynamic user input to the message to avoid potential security issues.

:read-more{to="/docs/4.x/getting-started/error-handling"}
</file>

<file path="docs/4.api/3.utils/define-lazy-hydration-component.md">
---
title: 'defineLazyHydrationComponent'
description: 'Define a lazy hydration component with a specific strategy.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/components/plugins/lazy-hydration-macro-transform.ts
    size: xs
---

`defineLazyHydrationComponent` is a compiler macro that helps you create a component with a specific lazy hydration strategy. Lazy hydration defers hydration until components become visible or until the browser has completed more critical tasks. This can significantly reduce the initial performance cost, especially for non-essential components.

## Usage

### Visibility Strategy

Hydrates the component when it becomes visible in the viewport.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'visible',
  () => import('./components/MyComponent.vue'),
)
</script>

<template>
  <div>
    <!--
      Hydration will be triggered when
      the element(s) is 100px away from entering the viewport.
    -->
    <LazyHydrationMyComponent :hydrate-on-visible="{ rootMargin: '100px' }" />
  </div>
</template>
```

The `hydrateOnVisible` prop is optional. You can pass an object to customize the behavior of the `IntersectionObserver` under the hood.

::read-more{to="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver" title="IntersectionObserver options"}
Read more about the options for `hydrate-on-visible`.
::

::note
Under the hood, this uses Vue's built-in [`hydrateOnVisible` strategy](https://vuejs.org/guide/components/async#hydrate-on-visible).
::

### Idle Strategy

Hydrates the component when the browser is idle. This is suitable if you need the component to load as soon as possible, but not block the critical rendering path.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'idle',
  () => import('./components/MyComponent.vue'),
)
</script>

<template>
  <div>
    <!-- Hydration will be triggered when the browser is idle or after 2000ms. -->
    <LazyHydrationMyComponent :hydrate-on-idle="2000" />
  </div>
</template>
```

The `hydrateOnIdle` prop is optional. You can pass a positive number to specify the maximum timeout.

Idle strategy is for components that can be hydrated when the browser is idle.

::note
Under the hood, this uses Vue's built-in [`hydrateOnIdle` strategy](https://vuejs.org/guide/components/async#hydrate-on-idle).
::

### Interaction Strategy

Hydrates the component after a specified interaction (e.g., click, mouseover).

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'interaction',
  () => import('./components/MyComponent.vue'),
)
</script>

<template>
  <div>
    <!--
      Hydration will be triggered when
      the element(s) is hovered over by the pointer.
    -->
    <LazyHydrationMyComponent hydrate-on-interaction="mouseover" />
  </div>
</template>
```

The `hydrateOnInteraction` prop is optional. If you do not pass an event or a list of events, it defaults to hydrating on `pointerenter`, `click`, and `focus`.

::note
Under the hood, this uses Vue's built-in [`hydrateOnInteraction` strategy](https://vuejs.org/guide/components/async#hydrate-on-interaction).
::

### Media Query Strategy

Hydrates the component when the window matches a media query.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'mediaQuery',
  () => import('./components/MyComponent.vue'),
)
</script>

<template>
  <div>
    <!--
      Hydration will be triggered when
      the window width is greater than or equal to 768px.
    -->
    <LazyHydrationMyComponent hydrate-on-media-query="(min-width: 768px)" />
  </div>
</template>
```

::note
Under the hood, this uses Vue's built-in [`hydrateOnMediaQuery` strategy](https://vuejs.org/guide/components/async#hydrate-on-media-query).
::

### Time Strategy

Hydrates the component after a specified delay (in milliseconds).

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'time',
  () => import('./components/MyComponent.vue'),
)
</script>

<template>
  <div>
    <!-- Hydration is triggered after 1000ms. -->
    <LazyHydrationMyComponent :hydrate-after="1000" />
  </div>
</template>
```

Time strategy is for components that can wait a specific amount of time.

### If Strategy

Hydrates the component based on a boolean condition.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'if',
  () => import('./components/MyComponent.vue'),
)

const isReady = ref(false)

function myFunction () {
  // Trigger custom hydration strategy...
  isReady.value = true
}
</script>

<template>
  <div>
    <!-- Hydration is triggered when isReady becomes true. -->
    <LazyHydrationMyComponent :hydrate-when="isReady" />
  </div>
</template>
```

If strategy is best for components that might not always need to be hydrated.

### Never Hydrate

Never hydrates the component.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'never',
  () => import('./components/MyComponent.vue'),
)
</script>

<template>
  <div>
    <!-- This component will never be hydrated by Vue. -->
    <LazyHydrationMyComponent />
  </div>
</template>
```

### Listening to Hydration Events

All delayed hydration components emit a `@hydrated` event when they are hydrated.

```vue
<script setup lang="ts">
const LazyHydrationMyComponent = defineLazyHydrationComponent(
  'visible',
  () => import('./components/MyComponent.vue'),
)

function onHydrate () {
  console.log('Component has been hydrated!')
}
</script>

<template>
  <div>
    <LazyHydrationMyComponent
      :hydrate-on-visible="{ rootMargin: '100px' }"
      @hydrated="onHydrated"
    />
  </div>
</template>
```

## Parameters

::warning
To ensure that the compiler correctly recognizes this macro, avoid using external variables. The following approach will prevent the macro from being properly recognized:

```vue
<script setup lang="ts">
const strategy = 'visible'
const source = () => import('./components/MyComponent.vue')
const LazyHydrationMyComponent = defineLazyHydrationComponent(strategy, source)
</script>
```
::

### `strategy`

- **Type**: `'visible' | 'idle' | 'interaction' | 'mediaQuery' | 'if' | 'time' | 'never'`
- **Required**: `true`

| Strategy      | Description                                                    |
|---------------|----------------------------------------------------------------|
| `visible`     | Hydrates when the component becomes visible in the viewport.   |
| `idle`        | Hydrates when the browser is idle or after a delay.            |
| `interaction` | Hydrates upon user interaction (e.g., click, hover).           |
| `mediaQuery`  | Hydrates when the specified media query condition is met.      |
| `if`          | Hydrates when a specified boolean condition is met.            |
| `time`        | Hydrates after a specified time delay.                         |
| `never`       | Prevents Vue from hydrating the component.                     |

### `source`

- **Type**: `() => Promise<Component>`
- **Required**: `true`
</file>

<file path="docs/4.api/3.utils/define-nuxt-component.md">
---
title: "defineNuxtComponent"
description: defineNuxtComponent() is a helper function for defining type safe components with Options API.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/component.ts
    size: xs
---

::note
`defineNuxtComponent()` is a helper function for defining type safe Vue components using options API similar to [`defineComponent()`](https://vuejs.org/api/general#definecomponent). `defineNuxtComponent()` wrapper also adds support for `asyncData` and `head` component options.
::

::note
Using `<script setup lang="ts">` is the recommended way of declaring Vue components in Nuxt.
::

:read-more{to=/docs/getting-started/data-fetching}

## `asyncData()`

If you choose not to use `setup()` in your app, you can use the `asyncData()` method within your component definition:

```vue [app/pages/index.vue]
<script lang="ts">
export default defineNuxtComponent({
  asyncData () {
    return {
      data: {
        greetings: 'hello world!',
      },
    }
  },
})
</script>
```

## `head()`

If you choose not to use `setup()` in your app, you can use the `head()` method within your component definition:

```vue [app/pages/index.vue]
<script lang="ts">
export default defineNuxtComponent({
  head (nuxtApp) {
    return {
      title: 'My site',
    }
  },
})
</script>
```
</file>

<file path="docs/4.api/3.utils/define-nuxt-plugin.md">
---
title: "defineNuxtPlugin"
description: defineNuxtPlugin() is a helper function for creating Nuxt plugins.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts
    size: xs
---

`defineNuxtPlugin` is a helper function for creating Nuxt plugins with enhanced functionality and type safety. This utility normalizes different plugin formats into a consistent structure that works seamlessly within Nuxt's plugin system.

```ts twoslash [plugins/hello.ts]
export default defineNuxtPlugin((nuxtApp) => {
  // Doing something with nuxtApp
})
```

:read-more{to="/docs/4.x/directory-structure/app/plugins#creating-plugins"}

## Type

```ts [Signature]
export function defineNuxtPlugin<T extends Record<string, unknown>> (plugin: Plugin<T> | ObjectPlugin<T>): Plugin<T> & ObjectPlugin<T>

type Plugin<T> = (nuxt: NuxtApp) => Promise<void> | Promise<{ provide?: T }> | void | { provide?: T }

interface ObjectPlugin<T> {
  name?: string
  enforce?: 'pre' | 'default' | 'post'
  dependsOn?: string[]
  order?: number
  parallel?: boolean
  setup?: Plugin<T>
  hooks?: Partial<RuntimeNuxtHooks>
  env?: {
    islands?: boolean
  }
}
```

## Parameters

**plugin**: A plugin can be defined in two ways:
1. **Function Plugin**: A function that receives the [`NuxtApp`](/docs/4.x/guide/going-further/internals#the-nuxtapp-interface) instance and can return a promise with a potential object with a [`provide`](/docs/4.x/directory-structure/app/plugins#providing-helpers) property if you want to provide a helper on [`NuxtApp`](/docs/4.x/guide/going-further/internals#the-nuxtapp-interface) instance.
2. **Object Plugin**: An object that can include various properties to configure the plugin's behavior, such as `name`, `enforce`, `dependsOn`, `order`, `parallel`, `setup`, `hooks`, and `env`.

| Property    | Type                                   | Required | Description                                                                                                                                                         |
|-------------|----------------------------------------|----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `name`      | `string`                               | `false`  | Optional name for the plugin, useful for debugging and dependency management.                                                                                       |
| `enforce`   | `'pre'` \| `'default'` \| `'post'`     | `false`  | Controls when the plugin runs relative to other plugins.                                                                                                            |
| `dependsOn` | `string[]`                             | `false`  | Array of plugin names this plugin depends on. Ensures proper execution order.                                                                                       |
| `order`     | `number`                               | `false`  | This allows more granular control over plugin order and should only be used by advanced users. **It overrides the value of `enforce` and is used to sort plugins.** |
| `parallel`  | `boolean`                              | `false`  | Whether to execute the plugin in parallel with other parallel plugins.                                                                                              |
| `setup`     | `Plugin<T>`{lang="ts"}                 | `false`  | The main plugin function, equivalent to a function plugin.                                                                                                          |
| `hooks`     | `Partial<RuntimeNuxtHooks>`{lang="ts"} | `false`  | Nuxt app runtime hooks to register directly.                                                                                                                        |
| `env`       | `{ islands?: boolean }`{lang="ts"}     | `false`  | Set this value to `false` if you don't want the plugin to run when rendering server-only or island components.                                                      |

:video-accordion{title="Watch a video from Alexander Lichter about the Object Syntax for Nuxt plugins" videoId="2aXZyXB1QGQ"}

## Examples

### Basic Usage

The example below demonstrates a simple plugin that adds global functionality:

```ts twoslash [plugins/hello.ts]
export default defineNuxtPlugin((nuxtApp) => {
  // Add a global method
  return {
    provide: {
      hello: (name: string) => `Hello ${name}!`,
    },
  }
})
```

### Object Syntax Plugin

The example below shows the object syntax with advanced configuration:

```ts twoslash [plugins/advanced.ts]
export default defineNuxtPlugin({
  name: 'my-plugin',
  enforce: 'pre',
  async setup (nuxtApp) {
    // Plugin setup logic
    const data = await $fetch('/api/config')

    return {
      provide: {
        config: data,
      },
    }
  },
  hooks: {
    'app:created' () {
      console.log('App created!')
    },
  },
})
```
</file>

<file path="docs/4.api/3.utils/define-nuxt-route-middleware.md">
---
title: "defineNuxtRouteMiddleware"
description: "Create named route middleware using defineNuxtRouteMiddleware helper function."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/router.ts
    size: xs
---

Route middleware are stored in the [`app/middleware/`](/docs/4.x/directory-structure/app/middleware) of your Nuxt application (unless [set otherwise](/docs/4.x/api/nuxt-config#middleware)).

## Type

```ts [Signature]
export function defineNuxtRouteMiddleware (middleware: RouteMiddleware): RouteMiddleware

interface RouteMiddleware {
  (to: RouteLocationNormalized, from: RouteLocationNormalized): ReturnType<NavigationGuard>
}
```

## Parameters

### `middleware`

- **Type**: `RouteMiddleware`

A function that takes two Vue Router's route location objects as parameters: the next route `to` as the first, and the current route `from` as the second.

Learn more about available properties of `RouteLocationNormalized` in the **[Vue Router docs](https://router.vuejs.org/api/type-aliases/routelocationnormalized)**.

## Examples

### Showing Error Page

You can use route middleware to throw errors and show helpful error messages:

```ts [app/middleware/error.ts]
export default defineNuxtRouteMiddleware((to) => {
  if (to.params.id === '1') {
    throw createError({ status: 404, statusText: 'Page Not Found' })
  }
})
```

The above route middleware will redirect a user to the custom error page defined in the `~/error.vue` file, and expose the error message and code passed from the middleware.

### Redirection

Use [`useState`](/docs/4.x/api/composables/use-state) in combination with `navigateTo` helper function inside the route middleware to redirect users to different routes based on their authentication status:

```ts [app/middleware/auth.ts]
export default defineNuxtRouteMiddleware((to, from) => {
  const auth = useState('auth')

  if (!auth.value.isAuthenticated) {
    return navigateTo('/login')
  }

  if (to.path !== '/dashboard') {
    return navigateTo('/dashboard')
  }
})
```

Both [navigateTo](/docs/4.x/api/utils/navigate-to) and [abortNavigation](/docs/4.x/api/utils/abort-navigation) are globally available helper functions that you can use inside `defineNuxtRouteMiddleware`.
</file>

<file path="docs/4.api/3.utils/define-page-meta.md">
---
title: 'definePageMeta'
description: 'Define metadata for your page components.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/pages/runtime/composables.ts
    size: xs
---

`definePageMeta` is a compiler macro that you can use to set metadata for your **page** components located in the [`app/pages/`](/docs/4.x/directory-structure/app/pages) directory (unless [set otherwise](/docs/4.x/api/nuxt-config#pages)). This way you can set custom metadata for each static or dynamic route of your Nuxt application.

```vue [app/pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  layout: 'default',
})
</script>
```

:read-more{to="/docs/4.x/directory-structure/app/pages#page-metadata"}

## Type

```ts [Signature]
export function definePageMeta (meta: PageMeta): void

interface PageMeta {
  validate?: ((route: RouteLocationNormalized) => boolean | Promise<boolean> | Partial<NuxtError> | Promise<Partial<NuxtError>>)
  redirect?: RouteRecordRedirectOption
  name?: string
  path?: string
  props?: RouteRecordRaw['props']
  alias?: string | string[]
  groups?: string[]
  pageTransition?: boolean | TransitionProps
  layoutTransition?: boolean | TransitionProps
  viewTransition?: boolean | 'always'
  key?: false | string | ((route: RouteLocationNormalizedLoaded) => string)
  keepalive?: boolean | KeepAliveProps
  layout?: false | LayoutKey | Ref<LayoutKey> | ComputedRef<LayoutKey>
  middleware?: MiddlewareKey | NavigationGuard | Array<MiddlewareKey | NavigationGuard>
  scrollToTop?: boolean | ((to: RouteLocationNormalizedLoaded, from: RouteLocationNormalizedLoaded) => boolean)
  [key: string]: unknown
}
```

## Parameters

### `meta`

- **Type**: `PageMeta`

  An object accepting the following page metadata:

  **`name`**

  - **Type**: `string`

    You may define a name for this page's route. By default, name is generated based on path inside the [`app/pages/` directory](/docs/4.x/directory-structure/app/pages).

  **`path`**

  - **Type**: `string`

    You may define a [custom regular expression](/docs/4.x/api/utils/define-page-meta#using-a-custom-regular-expression) if you have a more complex pattern than can be expressed with the file name.

  **`props`**
  
  - **Type**: [`RouteRecordRaw['props']`](https://router.vuejs.org/guide/essentials/passing-props)

    Allows accessing the route `params` as props passed to the page component.

  **`alias`**

  - **Type**: `string | string[]`

    Aliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like `/users/:id` and `/u/:id`. All `alias` and `path` values must share the same params.

  **`groups`**

  - **Type**: `string[]`

    Route groups the page belongs to, based on the folder structure. Automatically populated for pages within [route groups](/docs/4.x/guide/directory-structure/app/pages#route-groups).

  **`keepalive`**

  - **Type**: `boolean` | [`KeepAliveProps`](https://vuejs.org/api/built-in-components#keepalive)

    Set to `true` when you want to preserve page state across route changes or use the [`KeepAliveProps`](https://vuejs.org/api/built-in-components#keepalive) for a fine-grained control.

  **`key`**

  - **Type**: `false` | `string` | `((route: RouteLocationNormalizedLoaded) => string)`

    Set `key` value when you need more control over when the `<NuxtPage>` component is re-rendered.

  **`layout`**

  - **Type**: `false` | `LayoutKey` | `Ref<LayoutKey>` | `ComputedRef<LayoutKey>`

    Set a static or dynamic name of the layout for each route. This can be set to `false` in case the default layout needs to be disabled.

  **`layoutTransition`**

  - **Type**: `boolean` | [`TransitionProps`](https://vuejs.org/api/built-in-components#transition)

    Set name of the transition to apply for current layout. You can also set this value to `false` to disable the layout transition.

  **`middleware`**

  - **Type**: `MiddlewareKey` | [`NavigationGuard`](https://router.vuejs.org/api/interfaces/navigationguard) | `Array<MiddlewareKey | NavigationGuard>`

    Define anonymous or named middleware directly within `definePageMeta`. Learn more about [route middleware](/docs/4.x/directory-structure/app/middleware).

  **`pageTransition`**

  - **Type**: `boolean` | [`TransitionProps`](https://vuejs.org/api/built-in-components#transition)

    Set name of the transition to apply for current page. You can also set this value to `false` to disable the page transition.

  **`viewTransition`**

  - **Type**: `boolean | 'always'`

    **Experimental feature, only available when [enabled in your nuxt.config file](/docs/4.x/getting-started/transitions#view-transitions-api-experimental)**</br>
    Enable/disable View Transitions for the current page.
    If set to true, Nuxt will not apply the transition if the users browser matches `prefers-reduced-motion: reduce` (recommended). If set to `always`, Nuxt will always apply the transition.

  **`redirect`**

  - **Type**: [`RouteRecordRedirectOption`](https://router.vuejs.org/guide/essentials/redirect-and-alias)

    Where to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.

  **`validate`**

  - **Type**: `(route: RouteLocationNormalized) => boolean | Promise<boolean> | Partial<NuxtError> | Promise<Partial<NuxtError>>`

    Validate whether a given route can validly be rendered with this page. Return true if it is valid, or false if not. If another match can't be found, this will mean a 404. You can also directly return an object with `status`/`statusText` to respond immediately with an error (other matches will not be checked).

  **`scrollToTop`**

  - **Type**: `boolean | (to: RouteLocationNormalized, from: RouteLocationNormalized) => boolean`

    Tell Nuxt to scroll to the top before rendering the page or not. If you want to overwrite the default scroll behavior of Nuxt, you can do so in `~/router.options.ts` (see [custom routing](/docs/4.x/guide/recipes/custom-routing#using-routeroptions)) for more info.

  **`[key: string]`**

  - **Type**: `any`

    Apart from the above properties, you can also set **custom** metadata. You may wish to do so in a type-safe way by [augmenting the type of the `meta` object](/docs/4.x/directory-structure/app/pages/#typing-custom-metadata).

## Examples

### Basic Usage

The example below demonstrates:

- how `key` can be a function that returns a value;
- how `keepalive` property makes sure that the `<modal>` component is not cached when switching between multiple components;
- adding `pageType` as a custom property:

```vue [app/pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  key: route => route.fullPath,

  keepalive: {
    exclude: ['modal'],
  },

  pageType: 'Checkout',
})
</script>
```

### Defining Middleware

The example below shows how the middleware can be defined using a `function` directly within the `definePageMeta` or set as a `string` that matches the middleware file name located in the `app/middleware/` directory:

```vue [app/pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  // define middleware as a function
  middleware: [
    function (to, from) {
      const auth = useState('auth')

      if (!auth.value.authenticated) {
        return navigateTo('/login')
      }

      if (to.path !== '/checkout') {
        return navigateTo('/checkout')
      }
    },
  ],

  // ... or a string
  middleware: 'auth',

  // ... or multiple strings
  middleware: ['auth', 'another-named-middleware'],
})
</script>
```

### Using a Custom Regular Expression

A custom regular expression is a good way to resolve conflicts between overlapping routes, for instance:

The two routes "/test-category" and "/1234-post" match both `[postId]-[postSlug].vue` and `[categorySlug].vue` page routes.

To make sure that we are only matching digits (`\d+`) for `postId` in the `[postId]-[postSlug]` route, we can add the following to the `[postId]-[postSlug].vue` page template:

```vue [app/pages/[postId\\]-[postSlug\\].vue]
<script setup lang="ts">
definePageMeta({
  path: '/:postId(\\d+)-:postSlug',
})
</script>
```

For more examples see [Vue Router's Matching Syntax](https://router.vuejs.org/guide/essentials/route-matching-syntax).

### Defining Layout

You can define the layout that matches the layout's file name located (by default) in the [`app/layouts/` directory](/docs/4.x/directory-structure/app/layouts). You can also disable the layout by setting the `layout` to `false`:

```vue [app/pages/some-page.vue]
<script setup lang="ts">
definePageMeta({
  // set custom layout
  layout: 'admin',

  // ... or disable a default layout
  layout: false,
})
</script>
```
</file>

<file path="docs/4.api/3.utils/define-route-rules.md">
---
title: 'defineRouteRules'
description: 'Define route rules for hybrid rendering at the page level.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/pages/runtime/composables.ts
    size: xs
---

::read-more{to="/docs/4.x/guide/going-further/experimental-features#inlinerouterules" icon="i-lucide-star"}
This feature is experimental and in order to use it you must enable the `experimental.inlineRouteRules` option in your `nuxt.config`.
::

## Usage

```vue [app/pages/index.vue]
<script setup lang="ts">
defineRouteRules({
  prerender: true,
})
</script>

<template>
  <h1>Hello world!</h1>
</template>
```

Will be translated to:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    '/': { prerender: true },
  },
})
```

::note
When running [`nuxt build`](/docs/4.x/api/commands/build), the home page will be pre-rendered in `.output/public/index.html` and statically served.
::

## Notes

- A rule defined in `~/pages/foo/bar.vue` will be applied to `/foo/bar` requests.
- A rule in `~/pages/foo/[id].vue` will be applied to `/foo/**` requests.

For more control, such as if you are using a custom `path` or `alias` set in the page's [`definePageMeta`](/docs/4.x/api/utils/define-page-meta), you should set `routeRules` directly within your `nuxt.config`.

::read-more{to="/docs/4.x/guide/concepts/rendering#hybrid-rendering" icon="i-lucide-medal"}
Read more about the `routeRules`.
::
</file>

<file path="docs/4.api/3.utils/navigate-to.md">
---
title: "navigateTo"
description: navigateTo is a helper function that programmatically navigates users.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/router.ts
    size: xs
---

## Usage

`navigateTo` is available on both server side and client side. It can be used within the [Nuxt context](/docs/4.x/guide/going-further/nuxt-app#the-nuxt-context), or directly, to perform page navigation.

::warning
Make sure to always use `await` or `return` on result of `navigateTo` when calling it.
::

::note
`navigateTo` cannot be used within Nitro routes. To perform a server-side redirect in Nitro routes, use [`sendRedirect`](https://h3.dev/utils/response#redirectlocation-status-statustext) instead.
::

### Within a Vue Component

```vue
<script setup lang="ts">
// passing 'to' as a string
await navigateTo('/search')

// ... or as a route object
await navigateTo({ path: '/search' })

// ... or as a route object with query parameters
await navigateTo({
  path: '/search',
  query: {
    page: 1,
    sort: 'asc',
  },
})
</script>
```

### Within Route Middleware

```ts
export default defineNuxtRouteMiddleware((to, from) => {
  if (to.path !== '/search') {
    // setting the redirect code to '301 Moved Permanently'
    return navigateTo('/search', { redirectCode: 301 })
  }
})
```

When using `navigateTo` within route middleware, you must **return its result** to ensure the middleware execution flow works correctly.

For example, the following implementation **will not work as expected**:

```ts
export default defineNuxtRouteMiddleware((to, from) => {
  if (to.path !== '/search') {
    // ❌ This will not work as expected
    navigateTo('/search', { redirectCode: 301 })
    return
  }
})
```

In this case, `navigateTo` will be executed but not returned, which may lead to unexpected behavior.

:read-more{to="/docs/4.x/directory-structure/app/middleware"}

### Navigating to an External URL

The `external` parameter in `navigateTo` influences how navigating to URLs is handled:

- **Without `external: true`**:
  - Internal URLs navigate as expected.
  - External URLs throw an error.

- **With `external: true`**:
  - Internal URLs navigate with a full-page reload.
  - External URLs navigate as expected.

#### Example

```vue
<script setup lang="ts">
// will throw an error;
// navigating to an external URL is not allowed by default
await navigateTo('https://nuxt.com')

// will redirect successfully with the 'external' parameter set to 'true'
await navigateTo('https://nuxt.com', {
  external: true,
})
</script>
```

### Opening a Page in a New Tab

```vue
<script setup lang="ts">
// will open 'https://nuxt.com' in a new tab
await navigateTo('https://nuxt.com', {
  open: {
    target: '_blank',
    windowFeatures: {
      width: 500,
      height: 500,
    },
  },
})
</script>
```

## Type

```ts [Signature]
export function navigateTo (
  to: RouteLocationRaw | undefined | null,
  options?: NavigateToOptions,
): Promise<void | NavigationFailure | false> | false | void | RouteLocationRaw

interface NavigateToOptions {
  replace?: boolean
  redirectCode?: number
  external?: boolean
  open?: OpenOptions
}

type OpenOptions = {
  target: string
  windowFeatures?: OpenWindowFeatures
}

type OpenWindowFeatures = {
  popup?: boolean
  noopener?: boolean
  noreferrer?: boolean
} & XOR<{ width?: number }, { innerWidth?: number }>
  & XOR<{ height?: number }, { innerHeight?: number }>
  & XOR<{ left?: number }, { screenX?: number }>
  & XOR<{ top?: number }, { screenY?: number }>
```

## Parameters

### `to`

**Type**: [`RouteLocationRaw`](https://router.vuejs.org/api/interfaces/routelocationoptions) | `undefined` | `null`

**Default**: `'/'`

`to` can be a plain string or a route object to redirect to. When passed as `undefined` or `null`, it will default to `'/'`.

#### Example

```ts
// Passing the URL directly will redirect to the '/blog' page
await navigateTo('/blog')

// Using the route object, will redirect to the route with the name 'blog'
await navigateTo({ name: 'blog' })

// Redirects to the 'product' route while passing a parameter (id = 1) using the route object.
await navigateTo({ name: 'product', params: { id: 1 } })
```

### `options` (optional)

**Type**: `NavigateToOptions`

An object accepting the following properties:

- `replace`

  - **Type**: `boolean`
  - **Default**: `false`
  - By default, `navigateTo` pushes the given route into the Vue Router's instance on the client side.

    This behavior can be changed by setting `replace` to `true`, to indicate that given route should be replaced.

- `redirectCode`

  - **Type**: `number`
  - **Default**: `302`

  - `navigateTo` redirects to the given path and sets the redirect code to [`302 Found`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/302) by default when the redirection takes place on the server side.

    This default behavior can be modified by providing different `redirectCode`. Commonly, [`301 Moved Permanently`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/301) can be used for permanent redirections.

- `external`

  - **Type**: `boolean`
  - **Default**: `false`

  - Allows navigating to an external URL when set to `true`. Otherwise, `navigateTo` will throw an error, as external navigation is not allowed by default.

- `open`

  - **Type**: `OpenOptions`
  - Allows navigating to the URL using the [open()](https://developer.mozilla.org/en-US/docs/Web/API/Window/open) method of the window. This option is only applicable on the client side and will be ignored on the server side.

    An object accepting the following properties:

  - `target`

    - **Type**: `string`
    - **Default**: `'_blank'`

    - A string, without whitespace, specifying the name of the browsing context the resource is being loaded into.

  - `windowFeatures`

    - **Type**: `OpenWindowFeatures`

    - An object accepting the following properties:

      | Property                  | Type      | Description                                                                                    |
      |---------------------------|-----------|------------------------------------------------------------------------------------------------|
      | `popup`                   | `boolean` | Requests a minimal popup window instead of a new tab, with UI features decided by the browser. |
      | `width` or `innerWidth`   | `number`  | Specifies the content area's width (minimum 100 pixels), including scrollbars.                 |
      | `height` or `innerHeight` | `number`  | Specifies the content area's height (minimum 100 pixels), including scrollbars.                |
      | `left` or `screenX`       | `number`  | Sets the horizontal position of the new window relative to the left edge of the screen.        |
      | `top` or `screenY`        | `number`  | Sets the vertical position of the new window relative to the top edge of the screen.           |
      | `noopener`                | `boolean` | Prevents the new window from accessing the originating window via `window.opener`.             |
      | `noreferrer`              | `boolean` | Prevents the Referer header from being sent and implicitly enables `noopener`.                 |

      Refer to the [documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/open#windowfeatures) for more detailed information on the **windowFeatures** properties.
</file>

<file path="docs/4.api/3.utils/on-before-route-leave.md">
---
title: "onBeforeRouteLeave"
description: The onBeforeRouteLeave composable allows registering a route guard within a component.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/router.ts
    size: xs
---

:read-more{icon="i-simple-icons-vuedotjs" to="https://router.vuejs.org/api/functions/onbeforerouteleave" title="Vue Router Docs" target="_blank"}
</file>

<file path="docs/4.api/3.utils/on-before-route-update.md">
---
title: "onBeforeRouteUpdate"
description: The onBeforeRouteUpdate composable allows registering a route guard within a component.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/router.ts
    size: xs
---

:read-more{icon="i-simple-icons-vuedotjs" to="https://router.vuejs.org/api/functions/onbeforerouteupdate" title="Vue Router Docs" target="_blank"}
</file>

<file path="docs/4.api/3.utils/on-nuxt-ready.md">
---
title: "onNuxtReady"
description: The onNuxtReady composable allows running a callback after your app has finished initializing.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/ready.ts
    size: xs
---

::important
`onNuxtReady` only runs on the client-side. :br
It is ideal for running code that should not block the initial rendering of your app.
::

```ts [app/plugins/ready.client.ts]
export default defineNuxtPlugin(() => {
  onNuxtReady(async () => {
    const myAnalyticsLibrary = await import('my-big-analytics-library')
    // do something with myAnalyticsLibrary
  })
})
```

It is 'safe' to run even after your app has initialized. In this case, then the code will be registered to run in the next idle callback.
</file>

<file path="docs/4.api/3.utils/prefetch-components.md">
---
title: 'prefetchComponents'
description: Nuxt provides utilities to give you control over prefetching components.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/preload.ts
    size: xs
---


Prefetching component downloads the code in the background, this is based on the assumption that the component will likely be used for rendering, enabling the component to load instantly if and when the user requests it. The component is downloaded and cached for anticipated future use without the user making an explicit request for it.

Use `prefetchComponents` to manually prefetch individual components that have been registered globally in your Nuxt app. By default Nuxt registers these as async components. You must use the Pascal-cased version of the component name.

```ts
await prefetchComponents('MyGlobalComponent')

await prefetchComponents(['MyGlobalComponent1', 'MyGlobalComponent2'])
```

::note
Current implementation behaves exactly the same as [`preloadComponents`](/docs/4.x/api/utils/preload-components) by preloading components instead of just prefetching we are working to improve this behavior.
::

::note
On server, `prefetchComponents` will have no effect.
::
</file>

<file path="docs/4.api/3.utils/preload-components.md">
---
title: 'preloadComponents'
description: Nuxt provides utilities to give you control over preloading components.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/preload.ts
    size: xs
---

Preloading components loads components that your page will need very soon, which you want to start loading early in rendering lifecycle. This ensures they are available earlier and are less likely to block the page's render, improving performance.

Use `preloadComponents` to manually preload individual components that have been registered globally in your Nuxt app. By default Nuxt registers these as async components. You must use the Pascal-cased version of the component name.

```ts
await preloadComponents('MyGlobalComponent')

await preloadComponents(['MyGlobalComponent1', 'MyGlobalComponent2'])
```

::note
On server, `preloadComponents` will have no effect.
::
</file>

<file path="docs/4.api/3.utils/preload-route-components.md">
---
title: 'preloadRouteComponents'
description: preloadRouteComponents allows you to manually preload individual pages in your Nuxt app.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/preload.ts
    size: xs
---

Preloading routes loads the components of a given route that the user might navigate to in future. This ensures that the components are available earlier and less likely to block the navigation, improving performance.

::tip{icon="i-lucide-rocket"}
Nuxt already automatically preloads the necessary routes if you're using the `NuxtLink` component.
::

:read-more{to="/docs/4.x/api/components/nuxt-link"}

## Example

Preload a route when using `navigateTo`.

```ts
// we don't await this async function, to avoid blocking rendering
// this component's setup function
preloadRouteComponents('/dashboard')

const submit = async () => {
  const results = await $fetch('/api/authentication')

  if (results.token) {
    await navigateTo('/dashboard')
  }
}
```

:read-more{to="/docs/4.x/api/utils/navigate-to"}

::note
On server, `preloadRouteComponents` will have no effect.
::
</file>

<file path="docs/4.api/3.utils/prerender-routes.md">
---
title: 'prerenderRoutes'
description: prerenderRoutes hints to Nitro to prerender an additional route.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/ssr.ts
    size: xs
---

When prerendering, you can hint to Nitro to prerender additional paths, even if their URLs do not show up in the HTML of the generated page.

::important
`prerenderRoutes` can only be called within the [Nuxt context](/docs/4.x/guide/going-further/nuxt-app#the-nuxt-context).
::

::note
`prerenderRoutes` has to be executed during prerendering. If the `prerenderRoutes` is used in dynamic pages/routes which are not prerendered, then it will not be executed.
::

```ts
const route = useRoute()

prerenderRoutes('/')
prerenderRoutes(['/', '/about'])
```

::note
In the browser, or if called outside prerendering, `prerenderRoutes` will have no effect.
::

You can even prerender API routes which is particularly useful for full statically generated sites (SSG) because you can then `$fetch` data as if you have an available server!

```ts
prerenderRoutes('/api/content/article/name-of-article')

// Somewhere later in App
const articleContent = await $fetch('/api/content/article/name-of-article', {
  responseType: 'json',
})
```

::warning
Prerendered API routes in production may not return the expected response headers, depending on the provider you deploy to. For example, a JSON response might be served with an `application/octet-stream` content type.
Always manually set `responseType` when fetching prerendered API routes.
::
</file>

<file path="docs/4.api/3.utils/refresh-cookie.md">
---
title: "refreshCookie"
description: "Refresh useCookie values manually when a cookie has changed"
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/cookie.ts
    size: xs
---

::important
This utility is available since [Nuxt v3.10](/blog/v3-10).
::

## Purpose

The `refreshCookie` function is designed to refresh cookie value returned by `useCookie`.

This is useful for updating the `useCookie` ref when we know the new cookie value has been set in the browser.

## Usage

```vue [app/app.vue]
<script setup lang="ts">
const tokenCookie = useCookie('token')

const login = async (username, password) => {
  const token = await $fetch('/api/token', { /** ... */ }) // Sets `token` cookie on response
  refreshCookie('token')
}

const loggedIn = computed(() => !!tokenCookie.value)
</script>
```

::note{to="/docs/4.x/guide/going-further/experimental-features#cookiestore"}
Since [Nuxt v3.12.0](https://github.com/nuxt/nuxt/releases/tag/v3.12.0), the experimental `cookieStore` option is enabled by default. It automatically refreshes the `useCookie` value when cookies change in the browser.
::

## Type

```ts [Signature]
export function refreshCookie (name: string): void
```
</file>

<file path="docs/4.api/3.utils/refresh-nuxt-data.md">
---
title: 'refreshNuxtData'
description: Refresh all or specific asyncData instances in Nuxt
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/asyncData.ts
    size: xs
---

`refreshNuxtData` is used to refetch all or specific `asyncData` instances, including those from [`useAsyncData`](/docs/4.x/api/composables/use-async-data), [`useLazyAsyncData`](/docs/4.x/api/composables/use-lazy-async-data), [`useFetch`](/docs/4.x/api/composables/use-fetch), and [`useLazyFetch`](/docs/4.x/api/composables/use-lazy-fetch).  

::note
If your component is cached by `<KeepAlive>` and enters a deactivated state, the `asyncData` inside the component will still be refetched until the component is unmounted.
::

## Type

```ts [Signature]
export function refreshNuxtData (keys?: string | string[])
```

## Parameters

* `keys`: A single string or an array of strings as `keys` that are used to fetch the data. This parameter is **optional**. All [`useAsyncData`](/docs/4.x/api/composables/use-async-data) and [`useFetch`](/docs/4.x/api/composables/use-fetch) keys are re-fetched when no `keys` are explicitly specified.

## Return Values

`refreshNuxtData` returns a promise, resolving when all or specific `asyncData` instances have been refreshed.

## Examples

### Refresh All Data

This example below refreshes all data being fetched using `useAsyncData` and `useFetch` in Nuxt application.

```vue [app/pages/some-page.vue]
<script setup lang="ts">
const refreshing = ref(false)

async function refreshAll () {
  refreshing.value = true
  try {
    await refreshNuxtData()
  } finally {
    refreshing.value = false
  }
}
</script>

<template>
  <div>
    <button
      :disabled="refreshing"
      @click="refreshAll"
    >
      Refetch All Data
    </button>
  </div>
</template>
```

### Refresh Specific Data

This example below refreshes only data where the key matches to `count` and `user`.

```vue [app/pages/some-page.vue]
<script setup lang="ts">
const refreshing = ref(false)

async function refresh () {
  refreshing.value = true
  try {
    // you could also pass an array of keys to refresh multiple data
    await refreshNuxtData(['count', 'user'])
  } finally {
    refreshing.value = false
  }
}
</script>

<template>
  <div v-if="refreshing">
    Loading
  </div>
  <button @click="refresh">
    Refresh
  </button>
</template>
```

::note
If you have access to the `asyncData` instance, it is recommended to use its `refresh` or `execute` method as the preferred way to refetch the data.
::

:read-more{to="/docs/4.x/getting-started/data-fetching"}
</file>

<file path="docs/4.api/3.utils/reload-nuxt-app.md">
---
title: 'reloadNuxtApp'
description: reloadNuxtApp will perform a hard reload of the page.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/chunk.ts
    size: xs
---

::note
`reloadNuxtApp` will perform a hard reload of your app, re-requesting a page and its dependencies from the server.
::

By default, it will also save the current `state` of your app (that is, any state you could access with `useState`).

::read-more{to="/docs/4.x/guide/going-further/experimental-features#restorestate" icon="i-lucide-star"}
You can enable experimental restoration of this state by enabling the `experimental.restoreState` option in your `nuxt.config` file.
::

## Type

```ts [Signature]
export function reloadNuxtApp (options?: ReloadNuxtAppOptions)

interface ReloadNuxtAppOptions {
  ttl?: number
  force?: boolean
  path?: string
  persistState?: boolean
}
```

### `options` (optional)

**Type**: `ReloadNuxtAppOptions`

An object accepting the following properties:

- `path` (optional)

  **Type**: `string`

  **Default**: `window.location.pathname`

  The path to reload (defaulting to the current path). If this is different from the current window location it
  will trigger a navigation and add an entry in the browser history.

- `ttl` (optional)

  **Type**: `number`

  **Default**: `10000`

  The number of milliseconds in which to ignore future reload requests. If called again within this time period,
  `reloadNuxtApp` will not reload your app to avoid reload loops.

- `force` (optional)

  **Type**: `boolean`

  **Default**: `false`

  This option allows bypassing reload loop protection entirely, forcing a reload even if one has occurred within
  the previously specified TTL.

- `persistState` (optional)

  **Type**: `boolean`

  **Default**: `false`

  Whether to dump the current Nuxt state to sessionStorage (as `nuxt:reload:state`). By default this will have no
  effect on reload unless `experimental.restoreState` is also set, or unless you handle restoring the state yourself.
</file>

<file path="docs/4.api/3.utils/set-page-layout.md">
---
title: 'setPageLayout'
description: setPageLayout allows you to dynamically change the layout of a page.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/router.ts
    size: xs
---

::important
`setPageLayout` allows you to dynamically change the layout of a page. It relies on access to the Nuxt context and therefore can only be called within the [Nuxt context](/docs/4.x/guide/going-further/nuxt-app#the-nuxt-context).
::

```ts [app/middleware/custom-layout.ts]
export default defineNuxtRouteMiddleware((to) => {
  // Set the layout on the route you are navigating _to_
  setPageLayout('other')
})
```

::note
If you choose to set the layout dynamically on the server side, you _must_ do so before the layout is rendered by Vue (that is, within a plugin or route middleware) to avoid a hydration mismatch.
::
</file>

<file path="docs/4.api/3.utils/set-response-status.md">
---
title: 'setResponseStatus'
description: setResponseStatus sets the status (and optionally the statusText) of the response.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/ssr.ts
    size: xs
---

Nuxt provides composables and utilities for first-class server-side-rendering support.

`setResponseStatus` sets the status (and optionally the statusText) of the response.

::important
`setResponseStatus` can only be called in the [Nuxt context](/docs/4.x/guide/going-further/nuxt-app#the-nuxt-context).
::

```ts
const event = useRequestEvent()

// event will be undefined in the browser
if (event) {
  // Set the status code to 404 for a custom 404 page
  setResponseStatus(event, 404)

  // Set the status message as well
  setResponseStatus(event, 404, 'Page Not Found')
}
```

::note
In the browser, `setResponseStatus` will have no effect.
::

:read-more{to="/docs/4.x/getting-started/error-handling"}
</file>

<file path="docs/4.api/3.utils/show-error.md">
---
title: 'showError'
description: Nuxt provides a quick and simple way to show a full screen error page if needed.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/composables/error.ts
    size: xs
---

Within the [Nuxt context](/docs/4.x/guide/going-further/nuxt-app#the-nuxt-context) you can use `showError` to show an error.

**Parameters:**

- `error`: `string | Error | Partial<{ cause, data, message, name, stack, status, statusText }>`

```ts
showError('😱 Oh no, an error has been thrown.')
showError({
  status: 404,
  statusText: 'Page Not Found',
})
```

The error is set in the state using [`useError()`](/docs/4.x/api/composables/use-error) to create a reactive and SSR-friendly shared error state across components.

::tip
`showError` calls the `app:error` hook.
::

:read-more{to="/docs/4.x/getting-started/error-handling"}
</file>

<file path="docs/4.api/3.utils/update-app-config.md">
---
title: 'updateAppConfig'
description: 'Update the App Config at runtime.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/config.ts
    size: xs
---

::note
Updates the [`app.config`](/docs/4.x/directory-structure/app/app-config) using deep assignment. Existing (nested) properties will be preserved.
::

## Usage

```js
import { updateAppConfig, useAppConfig } from '#imports'

const appConfig = useAppConfig() // { foo: 'bar' }

const newAppConfig = { foo: 'baz' }
updateAppConfig(newAppConfig)

console.log(appConfig) // { foo: 'baz' }
```

:read-more{to="/docs/4.x/directory-structure/app/app-config"}
</file>

<file path="docs/4.api/4.commands/.navigation.yml">
title: 'Commands'
titleTemplate: '%s · Nuxt Commands'
icon: i-lucide-square-terminal
</file>

<file path="docs/4.api/4.commands/add.md">
---
title: "nuxt add"
description: "Scaffold an entity into your Nuxt application."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/add.ts
    size: xs
---

<!--add-cmd-->
```bash [Terminal]
npx nuxt add <TEMPLATE> <NAME> [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--force]
```
<!--/add-cmd-->

## Arguments

<!--add-args-->
| Argument   | Description                                                                                                                                                                                                      |
|------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `TEMPLATE` | Specify which template to generate (options: <api\|app\|app-config\|component\|composable\|error\|layer\|layout\|middleware\|module\|page\|plugin\|server-middleware\|server-plugin\|server-route\|server-util>) |
| `NAME`     | Specify name of the generated file                                                                                                                                                                               |
<!--/add-args-->

## Options

<!--add-opts-->
| Option                               | Default | Description                              |
|--------------------------------------|---------|------------------------------------------|
| `--cwd=<directory>`                  | `.`     | Specify the working directory            |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level             |
| `--force`                            | `false` | Force override file if it already exists |
<!--/add-opts-->

**Modifiers:**

Some templates support additional modifier flags to add a suffix (like `.client` or `.get`) to their name.

```bash [Terminal]
# Generates `/plugins/sockets.client.ts`
npx nuxt add plugin sockets --client
```

## `nuxt add component`

* Modifier flags: `--mode client|server` or `--client` or `--server`

```bash [Terminal]
# Generates `app/components/TheHeader.vue`
npx nuxt add component TheHeader
```

## `nuxt add composable`

```bash [Terminal]
# Generates `app/composables/foo.ts`
npx nuxt add composable foo
```

## `nuxt add layout`

```bash [Terminal]
# Generates `app/layouts/custom.vue`
npx nuxt add layout custom
```

## `nuxt add plugin`

* Modifier flags: `--mode client|server` or `--client`or `--server`

```bash [Terminal]
# Generates `app/plugins/analytics.ts`
npx nuxt add plugin analytics
```

## `nuxt add page`

```bash [Terminal]
# Generates `app/pages/about.vue`
npx nuxt add page about
```

```bash [Terminal]
# Generates `app/pages/category/[id].vue`
npx nuxt add page "category/[id]"
```

## `nuxt add middleware`

* Modifier flags: `--global`

```bash [Terminal]
# Generates `app/middleware/auth.ts`
npx nuxt add middleware auth
```

## `nuxt add api`

* Modifier flags: `--method` (can accept `connect`, `delete`, `get`, `head`, `options`, `patch`, `post`, `put` or `trace`) or alternatively you can directly use `--get`, `--post`, etc.

```bash [Terminal]
# Generates `server/api/hello.ts`
npx nuxt add api hello
```

## `nuxt add layer`

```bash [Terminal]
# Generates `layers/subscribe/nuxt.config.ts`
npx nuxt add layer subscribe
```
</file>

<file path="docs/4.api/4.commands/analyze.md">
---
title: "nuxt analyze"
description: "Analyze the production bundle or your Nuxt application."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/analyze.ts
    size: xs
---

<!--analyze-cmd-->
```bash [Terminal]
npx nuxt analyze [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dotenv] [-e, --extends=<layer-name>] [--name=<name>] [--no-serve]
```
<!--/analyze-cmd-->

The `analyze` command builds Nuxt and analyzes the production bundle (experimental).

## Arguments

<!--analyze-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/analyze-args-->

## Options

<!--analyze-opts-->
| Option                               | Default   | Description                                                                      |
|--------------------------------------|-----------|----------------------------------------------------------------------------------|
| `--cwd=<directory>`                  |           | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
| `--logLevel=<silent\|info\|verbose>` |           | Specify build-time log level                                                     |
| `--dotenv`                           |           | Path to `.env` file to load, relative to the root directory                      |
| `-e, --extends=<layer-name>`         |           | Extend from a Nuxt layer                                                         |
| `--name=<name>`                      | `default` | Name of the analysis                                                             |
| `--no-serve`                         |           | Skip serving the analysis results                                                |
<!--/analyze-opts-->

::note
This command sets `process.env.NODE_ENV` to `production`.
::
</file>

<file path="docs/4.api/4.commands/build-module.md">
---
title: 'nuxt build-module'
description: 'Nuxt command to build your Nuxt module before publishing.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/module-builder/blob/main/src/cli.ts
    size: xs
---

<!--build-module-cmd-->
```bash [Terminal]
npx nuxt build-module [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--build] [--stub] [--sourcemap] [--prepare]
```
<!--/build-module-cmd-->

The `build-module` command runs `@nuxt/module-builder` to generate `dist` directory within your `rootDir` that contains the full build for your **nuxt-module**.

## Arguments

<!--build-module-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/build-module-args-->

## Options

<!--build-module-opts-->
| Option                               | Default | Description                                                                      |
|--------------------------------------|---------|----------------------------------------------------------------------------------|
| `--cwd=<directory>`                  |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level                                                     |
| `--build`                            | `false` | Build module for distribution                                                    |
| `--stub`                             | `false` | Stub dist instead of actually building it for development                        |
| `--sourcemap`                        | `false` | Generate sourcemaps                                                              |
| `--prepare`                          | `false` | Prepare module for local development                                             |
<!--/build-module-opts-->

::read-more{to="https://github.com/nuxt/module-builder" icon="i-simple-icons-github" target="\_blank"}
Read more about `@nuxt/module-builder`.
::
</file>

<file path="docs/4.api/4.commands/build.md">
---
title: "nuxt build"
description: "Build your Nuxt application."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/build.ts
    size: xs
---

<!--build-cmd-->
```bash [Terminal]
npx nuxt build [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--prerender] [--preset] [--dotenv] [--envName] [-e, --extends=<layer-name>]
```
<!--/build-cmd-->

The `build` command creates a `.output` directory with all your application, server and dependencies ready for production.

## Arguments

<!--build-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/build-args-->

## Options

<!--build-opts-->
| Option                               | Default | Description                                                                                                                                          |
|--------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| `--cwd=<directory>`                  |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`)                                                                     |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level                                                                                                                         |
| `--prerender`                        |         | Build Nuxt and prerender static routes                                                                                                               |
| `--preset`                           |         | Nitro server preset                                                                                                                                  |
| `--dotenv`                           |         | Path to `.env` file to load, relative to the root directory                                                                                          |
| `--envName`                          |         | The environment to use when resolving configuration overrides (default is `production` when building, and `development` when running the dev server) |
| `-e, --extends=<layer-name>`         |         | Extend from a Nuxt layer                                                                                                                             |
<!--/build-opts-->

::note
This command sets `process.env.NODE_ENV` to `production`.
::

::note
`--prerender` will always set the `preset` to `static`
::
</file>

<file path="docs/4.api/4.commands/cleanup.md">
---
title: 'nuxt cleanup'
description: 'Remove common generated Nuxt files and caches.'
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/cleanup.ts
    size: xs
---

<!--cleanup-cmd-->
```bash [Terminal]
npx nuxt cleanup [ROOTDIR] [--cwd=<directory>]
```
<!--/cleanup-cmd-->

The `cleanup` command removes common generated Nuxt files and caches, including:

- `.nuxt`
- `.output`
- `node_modules/.vite`
- `node_modules/.cache`

## Arguments

<!--cleanup-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/cleanup-args-->

## Options

<!--cleanup-opts-->
| Option              | Default | Description                                                                      |
|---------------------|---------|----------------------------------------------------------------------------------|
| `--cwd=<directory>` |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
<!--/cleanup-opts-->
</file>

<file path="docs/4.api/4.commands/dev.md">
---
title: 'nuxt dev'
description: The dev command starts a development server with hot module replacement at http://localhost:3000
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/dev.ts
    size: xs
---

<!--dev-cmd-->
```bash [Terminal]
npx nuxt dev [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dotenv] [--envName] [-e, --extends=<layer-name>] [--clear] [--no-f, --no-fork] [-p, --port] [-h, --host] [--clipboard] [-o, --open] [--https] [--publicURL] [--qr] [--public] [--tunnel] [--sslCert] [--sslKey]
```
<!--/dev-cmd-->

The `dev` command starts a development server with hot module replacement at [http://localhost:3000](https://localhost:3000)

## Arguments

<!--dev-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/dev-args-->

## Options

<!--dev-opts-->
| Option                               | Default | Description                                                                                                                                          |
|--------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| `--cwd=<directory>`                  |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`)                                                                     |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level                                                                                                                         |
| `--dotenv`                           |         | Path to `.env` file to load, relative to the root directory                                                                                          |
| `--envName`                          |         | The environment to use when resolving configuration overrides (default is `production` when building, and `development` when running the dev server) |
| `-e, --extends=<layer-name>`         |         | Extend from a Nuxt layer                                                                                                                             |
| `--clear`                            | `false` | Clear console on restart                                                                                                                             |
| `--no-f, --no-fork`                  |         | Disable forked mode                                                                                                                                  |
| `-p, --port`                         |         | Port to listen on (default: `NUXT_PORT \|\| NITRO_PORT \|\| PORT \|\| nuxtOptions.devServer.port`)                                                   |
| `-h, --host`                         |         | Host to listen on (default: `NUXT_HOST \|\| NITRO_HOST \|\| HOST \|\| nuxtOptions.devServer?.host`)                                                  |
| `--clipboard`                        | `false` | Copy the URL to the clipboard                                                                                                                        |
| `-o, --open`                         | `false` | Open the URL in the browser                                                                                                                          |
| `--https`                            |         | Enable HTTPS                                                                                                                                         |
| `--publicURL`                        |         | Displayed public URL (used for QR code)                                                                                                              |
| `--qr`                               |         | Display The QR code of public URL when available                                                                                                     |
| `--public`                           |         | Listen to all network interfaces                                                                                                                     |
| `--tunnel`                           |         | Open a tunnel using https://github.com/unjs/untun                                                                                                    |
| `--sslCert`                          |         | (DEPRECATED) Use `--https.cert` instead.                                                                                                             |
| `--sslKey`                           |         | (DEPRECATED) Use `--https.key` instead.                                                                                                              |
<!--/dev-opts-->

The port and host can also be set via NUXT_PORT, PORT, NUXT_HOST or HOST environment variables.

Additionally to the above options, `@nuxt/cli` can pass options through to `listhen`, e.g. `--no-qr` to turn off the dev server QR code. You can find the list of `listhen` options in the [unjs/listhen](https://github.com/unjs/listhen) docs.

This command sets `process.env.NODE_ENV` to `development`.

::note
If you are using a self-signed certificate in development, you will need to set `NODE_TLS_REJECT_UNAUTHORIZED=0` in your environment.
::
</file>

<file path="docs/4.api/4.commands/devtools.md">
---
title: "nuxt devtools"
description: The devtools command allows you to enable or disable Nuxt DevTools on a per-project basis.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/devtools.ts
    size: xs
---

<!--devtools-cmd-->
```bash [Terminal]
npx nuxt devtools <COMMAND> [ROOTDIR] [--cwd=<directory>]
```
<!--/devtools-cmd-->

Running `nuxt devtools enable` will install the Nuxt DevTools globally, and also enable it within the particular project you are using. It is saved as a preference in your user-level `.nuxtrc`. If you want to remove devtools support for a particular project, you can run `nuxt devtools disable`.

## Arguments

<!--devtools-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `COMMAND`     | Command to run (options: <enable\|disable>)    |
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/devtools-args-->

## Options

<!--devtools-opts-->
| Option              | Default | Description                                                                      |
|---------------------|---------|----------------------------------------------------------------------------------|
| `--cwd=<directory>` |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
<!--/devtools-opts-->

::read-more{icon="i-simple-icons-nuxtdotjs" to="https://devtools.nuxt.com" target="\_blank"}
Read more about the **Nuxt DevTools**.
::
</file>

<file path="docs/4.api/4.commands/generate.md">
---
title: "nuxt generate"
description: Pre-renders every route of the application and stores the result in plain HTML files.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/generate.ts
    size: xs
---

<!--generate-cmd-->
```bash [Terminal]
npx nuxt generate [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--preset] [--dotenv] [--envName] [-e, --extends=<layer-name>]
```
<!--/generate-cmd-->

The `generate` command pre-renders every route of your application and stores the result in plain HTML files that you can deploy on any static hosting services. The command triggers the `nuxt build` command with the `prerender` argument set to `true`

## Arguments

<!--generate-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/generate-args-->

## Options

<!--generate-opts-->
| Option                               | Default | Description                                                                                                                                          |
|--------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| `--cwd=<directory>`                  |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`)                                                                     |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level                                                                                                                         |
| `--preset`                           |         | Nitro server preset                                                                                                                                  |
| `--dotenv`                           |         | Path to `.env` file to load, relative to the root directory                                                                                          |
| `--envName`                          |         | The environment to use when resolving configuration overrides (default is `production` when building, and `development` when running the dev server) |
| `-e, --extends=<layer-name>`         |         | Extend from a Nuxt layer                                                                                                                             |
<!--/generate-opts-->

::read-more{to="/docs/4.x/getting-started/deployment#static-hosting"}
Read more about pre-rendering and static hosting.
::
</file>

<file path="docs/4.api/4.commands/info.md">
---
title: "nuxt info"
description: The info command logs information about the current or specified Nuxt project.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/info.ts
    size: xs
---

<!--info-cmd-->
```bash [Terminal]
npx nuxt info [ROOTDIR] [--cwd=<directory>]
```
<!--/info-cmd-->

The `info` command logs information about the current or specified Nuxt project.

## Arguments

<!--info-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/info-args-->

## Options

<!--info-opts-->
| Option              | Default | Description                                                                      |
|---------------------|---------|----------------------------------------------------------------------------------|
| `--cwd=<directory>` |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
<!--/info-opts-->
</file>

<file path="docs/4.api/4.commands/init.md">
---
title: "create nuxt"
description: The init command initializes a fresh Nuxt project.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/init.ts
    size: xs
---

<!--init-cmd-->
```bash [Terminal]
npm create nuxt@latest [DIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [-t, --template] [-f, --force] [--offline] [--preferOffline] [--no-install] [--gitInit] [--shell] [--packageManager] [-M, --modules] [--no-modules] [--nightly]
```
<!--/init-cmd-->

The `create-nuxt` command initializes a fresh Nuxt project using [unjs/giget](https://github.com/unjs/giget).

## Arguments

<!--init-args-->
| Argument | Description       |
|----------|-------------------|
| `DIR=""` | Project directory |
<!--/init-args-->

## Options

<!--init-opts-->
| Option                               | Default | Description                                              |
|--------------------------------------|---------|----------------------------------------------------------|
| `--cwd=<directory>`                  | `.`     | Specify the working directory                            |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level                             |
| `-t, --template`                     |         | Template name                                            |
| `-f, --force`                        |         | Override existing directory                              |
| `--offline`                          |         | Force offline mode                                       |
| `--preferOffline`                    |         | Prefer offline mode                                      |
| `--no-install`                       |         | Skip installing dependencies                             |
| `--gitInit`                          |         | Initialize git repository                                |
| `--shell`                            |         | Start shell after installation in project directory      |
| `--packageManager`                   |         | Package manager choice (npm, pnpm, yarn, bun)            |
| `-M, --modules`                      |         | Nuxt modules to install (comma separated without spaces) |
| `--no-modules`                       |         | Skip module installation prompt                          |
| `--nightly`                          |         | Use Nuxt nightly release channel (3x or latest)          |
<!--/init-opts-->

## Environment variables

- `NUXI_INIT_REGISTRY`: Set to a custom template registry. ([learn more](https://github.com/unjs/giget#custom-registry)).
  - Default registry is loaded from [nuxt/starter/templates](https://github.com/nuxt/starter/tree/templates/templates)
</file>

<file path="docs/4.api/4.commands/module.md">
---
title: "nuxt module"
description: "Search and add modules to your Nuxt application with the command line."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/tree/main/packages/nuxi/src/commands/module
    size: xs
---

Nuxt provides a few utilities to work with [Nuxt modules](/modules) seamlessly.

## nuxt module add

<!--module-add-cmd-->
```bash [Terminal]
npx nuxt module add <MODULENAME> [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--skipInstall] [--skipConfig] [--dev]
```
<!--/module-add-cmd-->

<!--module-add-args-->
| Argument     | Description                                                         |
|--------------|---------------------------------------------------------------------|
| `MODULENAME` | Specify one or more modules to install by name, separated by spaces |
<!--/module-add-args-->

<!--module-add-opts-->
| Option                               | Default | Description                         |
|--------------------------------------|---------|-------------------------------------|
| `--cwd=<directory>`                  | `.`     | Specify the working directory       |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level        |
| `--skipInstall`                      |         | Skip npm install                    |
| `--skipConfig`                       |         | Skip nuxt.config.ts update          |
| `--dev`                              |         | Install modules as dev dependencies |
<!--/module-add-opts-->

The command lets you install [Nuxt modules](/modules) in your application with no manual work.

When running the command, it will:

- install the module as a dependency using your package manager
- add it to your [package.json](/docs/4.x/directory-structure/package) file
- update your [`nuxt.config`](/docs/4.x/directory-structure/nuxt-config) file

**Example:**

Installing the [`Pinia`](/modules/pinia) module

```bash [Terminal]
npx nuxt module add pinia
```

## nuxt module search

<!--module-search-cmd-->
```bash [Terminal]
npx nuxt module search <QUERY> [--cwd=<directory>] [--nuxtVersion=<2|3>]
```
<!--/module-search-cmd-->

### Arguments

<!--module-search-args-->
| Argument | Description            |
|----------|------------------------|
| `QUERY`  | keywords to search for |
<!--/module-search-args-->

### Options

<!--module-search-opts-->
| Option                 | Default | Description                                                                        |
|------------------------|---------|------------------------------------------------------------------------------------|
| `--cwd=<directory>`    | `.`     | Specify the working directory                                                      |
| `--nuxtVersion=<2\|3>` |         | Filter by Nuxt version and list compatible modules only (auto detected by default) |
<!--/module-search-opts-->

The command searches for Nuxt modules matching your query that are compatible with your Nuxt version.

**Example:**

```bash [Terminal]
npx nuxt module search pinia
```
</file>

<file path="docs/4.api/4.commands/prepare.md">
---
title: 'nuxt prepare'
description: The prepare command creates a .nuxt directory in your application and generates types.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/prepare.ts
    size: xs
---

<!--prepare-cmd-->
```bash [Terminal]
npx nuxt prepare [ROOTDIR] [--dotenv] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--envName] [-e, --extends=<layer-name>]
```
<!--/prepare-cmd-->

The `prepare` command creates a [`.nuxt`](/docs/4.x/directory-structure/nuxt) directory in your application and generates types. This can be useful in a CI environment or as a `postinstall` command in your [`package.json`](/docs/4.x/directory-structure/package).

## Arguments

<!--prepare-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/prepare-args-->

## Options

<!--prepare-opts-->
| Option                               | Default | Description                                                                                                                                          |
|--------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| `--dotenv`                           |         | Path to `.env` file to load, relative to the root directory                                                                                          |
| `--cwd=<directory>`                  |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`)                                                                     |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level                                                                                                                         |
| `--envName`                          |         | The environment to use when resolving configuration overrides (default is `production` when building, and `development` when running the dev server) |
| `-e, --extends=<layer-name>`         |         | Extend from a Nuxt layer                                                                                                                             |
<!--/prepare-opts-->

::note
This command sets `process.env.NODE_ENV` to `production`.
::
</file>

<file path="docs/4.api/4.commands/preview.md">
---
title: "nuxt preview"
description: The preview command starts a server to preview your application after the build command.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/preview.ts
    size: xs
---

<!--preview-cmd-->
```bash [Terminal]
npx nuxt preview [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--envName] [-e, --extends=<layer-name>] [-p, --port] [--dotenv]
```
<!--/preview-cmd-->

The `preview` command starts a server to preview your Nuxt application after running the `build` command. The `start` command is an alias for `preview`. When running your application in production refer to the [Deployment section](/docs/4.x/getting-started/deployment).

## Arguments

<!--preview-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/preview-args-->

## Options

<!--preview-opts-->
| Option                               | Default | Description                                                                                                                                          |
|--------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| `--cwd=<directory>`                  |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`)                                                                     |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level                                                                                                                         |
| `--envName`                          |         | The environment to use when resolving configuration overrides (default is `production` when building, and `development` when running the dev server) |
| `-e, --extends=<layer-name>`         |         | Extend from a Nuxt layer                                                                                                                             |
| `-p, --port`                         |         | Port to listen on (use `PORT` environment variable to override)                                                                                      |
| `--dotenv`                           |         | Path to `.env` file to load, relative to the root directory                                                                                          |
<!--/preview-opts-->

This command sets `process.env.NODE_ENV` to `production`. To override, define `NODE_ENV` in a `.env` file or as command-line argument.

::note
For convenience, in preview mode, your [`.env`](/docs/4.x/directory-structure/env) file will be loaded into `process.env`. (However, in production you will need to ensure your environment variables are set yourself. For example, with Node.js 20+ you could do this by running `node --env-file .env .output/server/index.mjs` to start your server.)
::
</file>

<file path="docs/4.api/4.commands/test.md">
---
title: "nuxt test"
description: The test command runs tests using @nuxt/test-utils.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/test.ts
    size: xs
---

<!--test-cmd-->
```bash [Terminal]
npx nuxt test [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dev] [--watch]
```
<!--/test-cmd-->

The `test` command runs tests using [`@nuxt/test-utils`](/docs/getting-started/testing). This command sets `process.env.NODE_ENV` to `test` if not already set.

## Arguments

<!--test-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/test-args-->

## Options

<!--test-opts-->
| Option                               | Default | Description                                                                      |
|--------------------------------------|---------|----------------------------------------------------------------------------------|
| `--cwd=<directory>`                  |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level                                                     |
| `--dev`                              |         | Run in dev mode                                                                  |
| `--watch`                            |         | Watch mode                                                                       |
<!--/test-opts-->

::note
This command sets `process.env.NODE_ENV` to `test`.
::
</file>

<file path="docs/4.api/4.commands/typecheck.md">
---
title: "nuxt typecheck"
description: The typecheck command runs vue-tsc to check types throughout your app.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/typecheck.ts
    size: xs
---

<!--typecheck-cmd-->
```bash [Terminal]
npx nuxt typecheck [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dotenv] [-e, --extends=<layer-name>]
```
<!--/typecheck-cmd-->

The `typecheck` command runs [`vue-tsc`](https://github.com/vuejs/language-tools/tree/master/packages/tsc) to check types throughout your app.

## Arguments

<!--typecheck-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/typecheck-args-->

## Options

<!--typecheck-opts-->
| Option                               | Default | Description                                                                      |
|--------------------------------------|---------|----------------------------------------------------------------------------------|
| `--cwd=<directory>`                  |         | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
| `--logLevel=<silent\|info\|verbose>` |         | Specify build-time log level                                                     |
| `--dotenv`                           |         | Path to `.env` file to load, relative to the root directory                      |
| `-e, --extends=<layer-name>`         |         | Extend from a Nuxt layer                                                         |
<!--/typecheck-opts-->

::note
This command sets `process.env.NODE_ENV` to `production`. To override, define `NODE_ENV` in a [`.env`](/docs/4.x/directory-structure/env) file or as a command-line argument.
::

::read-more{to="/docs/4.x/guide/concepts/typescript#type-checking"}
Read more on how to enable type-checking at build or development time.
::
</file>

<file path="docs/4.api/4.commands/upgrade.md">
---
title: "nuxt upgrade"
description: The upgrade command upgrades Nuxt to the latest version.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/cli/blob/main/packages/nuxi/src/commands/upgrade.ts
    size: xs
---

<!--upgrade-cmd-->
```bash [Terminal]
npx nuxt upgrade [ROOTDIR] [--cwd=<directory>] [--logLevel=<silent|info|verbose>] [--dedupe] [-f, --force] [-ch, --channel=<stable|nightly|v3|v4|v4-nightly|v3-nightly>]
```
<!--/upgrade-cmd-->

The `upgrade` command upgrades Nuxt to the latest version.

## Arguments

<!--upgrade-args-->
| Argument      | Description                                    |
|---------------|------------------------------------------------|
| `ROOTDIR="."` | Specifies the working directory (default: `.`) |
<!--/upgrade-args-->

## Options

<!--upgrade-opts-->
| Option                                                             | Default  | Description                                                                      |
|--------------------------------------------------------------------|----------|----------------------------------------------------------------------------------|
| `--cwd=<directory>`                                                |          | Specify the working directory, this takes precedence over ROOTDIR (default: `.`) |
| `--logLevel=<silent\|info\|verbose>`                               |          | Specify build-time log level                                                     |
| `--dedupe`                                                         |          | Dedupe dependencies after upgrading                                              |
| `-f, --force`                                                      |          | Force upgrade to recreate lockfile and node_modules                              |
| `-ch, --channel=<stable\|nightly\|v3\|v4\|v4-nightly\|v3-nightly>` | `stable` | Specify a channel to install from (default: stable)                              |
<!--/upgrade-opts-->
</file>

<file path="docs/4.api/5.kit/.navigation.yml">
title: Nuxt Kit
titleTemplate: '%s · Nuxt Kit'
navigation.icon: i-lucide-package
</file>

<file path="docs/4.api/5.kit/1.modules.md">
---
title: "Modules"
description: Nuxt Kit provides a set of utilities to help you create and use modules. You can use these utilities to create your own modules or to reuse existing modules.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/tree/main/packages/kit/src/module
    size: xs
---

Modules are the building blocks of Nuxt. Kit provides a set of utilities to help you create and use modules. You can use these utilities to create your own modules or to reuse existing modules. For example, you can use the `defineNuxtModule` function to define a module and specify dependencies using the `moduleDependencies` option.

## `defineNuxtModule`

Define a Nuxt module, automatically merging defaults with user provided options, installing any hooks that are provided, and calling an optional setup function for full control.

### Usage

```ts twoslash
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  defaults: {
    enabled: true,
  },
  setup (options) {
    if (options.enabled) {
      console.log('My Nuxt module is enabled!')
    }
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { ModuleDefinition, ModuleOptions, NuxtModule } from '@nuxt/schema'
// ---cut---
export function defineNuxtModule<TOptions extends ModuleOptions> (
  definition?: ModuleDefinition<TOptions, Partial<TOptions>, false> | NuxtModule<TOptions, Partial<TOptions>, false>,
): NuxtModule<TOptions, TOptions, false>

export function defineNuxtModule<TOptions extends ModuleOptions> (): {
  with: <TOptionsDefaults extends Partial<TOptions>> (
    definition: ModuleDefinition<TOptions, TOptionsDefaults, true> | NuxtModule<TOptions, TOptionsDefaults, true>,
  ) => NuxtModule<TOptions, TOptionsDefaults, true>
}
```

### Parameters

**definition**: A module definition object or a module function. The module definition object should contain the following properties:

| Property             | Type                                                                                                              | Required | Description                                                                                                                                                                                                        |
|----------------------|-------------------------------------------------------------------------------------------------------------------|----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `meta`               | `ModuleMeta`                                                                                                      | `false`  | Metadata of the module. It defines the module name, version, config key and compatibility.                                                                                                                         |
| `defaults`           | `T \| ((nuxt: Nuxt) => T)`{lang="ts"}                                                                             | `false`  | Default options for the module. If a function is provided, it will be called with the Nuxt instance as the first argument.                                                                                         |
| `schema`             | `T`                                                                                                               | `false`  | Schema for the module options. If provided, options will be applied to the schema.                                                                                                                                 |
| `hooks`              | `Partial<NuxtHooks>`{lang="ts"}                                                                                   | `false`  | Hooks to be installed for the module. If provided, the module will install the hooks.                                                                                                                              |
| `moduleDependencies` | `Record<string, ModuleDependency> \| ((nuxt: Nuxt) => Record<string, ModuleDependency>)`{lang="ts"}               | `false`  | Dependencies on other modules with version constraints and configuration. Can be an object or a function that receives the Nuxt instance. See [example](/docs/4.x/api/kit/modules#specifying-module-dependencies). |
| `onInstall`          | `(nuxt: Nuxt) => Awaitable<void>`{lang="ts"}                                                                      | `false`  | Lifecycle hook called when the module is first installed. Requires `meta.name` and `meta.version` to be defined.                                                                                                   |
| `onUpgrade`          | `(nuxt: Nuxt, options: T, previousVersion: string) => Awaitable<void>`{lang="ts"}                                 | `false`  | Lifecycle hook called when the module is upgraded to a newer version. Requires `meta.name` and `meta.version` to be defined.                                                                                       |
| `setup`              | `(this: void, resolvedOptions: T, nuxt: Nuxt) => Awaitable<void \| false \| ModuleSetupInstallResult>`{lang="ts"} | `false`  | Setup function for the module. If provided, the module will call the setup function.                                                                                                                               |

### Examples

#### Using `configKey` to Make Your Module Configurable

When defining a Nuxt module, you can set a `configKey` to specify how users should configure the module in their `nuxt.config`.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  defaults: {
    // Module options
    enabled: true,
  },
  setup (options) {
    if (options.enabled) {
      console.log('My Nuxt module is enabled!')
    }
  },
})
```

Users can provide options for this module under the corresponding key in `nuxt.config`.

```ts
export default defineNuxtConfig({
  myModule: {
    enabled: false,
  },
})
```

#### Defining Module Compatibility Requirements

If you're developing a Nuxt module and using APIs that are only supported in specific Nuxt versions, it's highly recommended to include `compatibility.nuxt`.

```ts
export default defineNuxtModule({
  meta: {
    name: '@nuxt/icon',
    configKey: 'icon',
    compatibility: {
      // Required nuxt version in semver format.
      nuxt: '>=3.0.0', // or use '^3.0.0'
    },
  },
  setup () {
    const resolver = createResolver(import.meta.url)
    // Implement
  },
})
```

If the user tries to use your module with an incompatible Nuxt version, they will receive a warning in the console.

```terminal
 WARN  Module @nuxt/icon is disabled due to incompatibility issues:
 - [nuxt] Nuxt version ^3.1.0 is required but currently using 3.0.0
```

#### Type Safety for Resolved Options with `.with()`

When you need type safety for your resolved/merged module options, you can use the `.with()` method. This enables TypeScript to properly infer the relationship between your module's defaults and the final resolved options that your setup function receives.

```ts
import { defineNuxtModule } from '@nuxt/kit'

// Define your module options interface
interface ModuleOptions {
  apiKey: string
  baseURL: string
  timeout?: number
  retries?: number
}

export default defineNuxtModule<ModuleOptions>().with({
  meta: {
    name: '@nuxtjs/my-api',
    configKey: 'myApi',
  },
  defaults: {
    baseURL: 'https://api.example.com',
    timeout: 5000,
    retries: 3,
  },
  setup (resolvedOptions, nuxt) {
    // resolvedOptions is properly typed as:
    // {
    //   apiKey: string          // Required, no default provided
    //   baseURL: string         // Required, has default value
    //   timeout: number         // Optional, has default value
    //   retries: number         // Optional, has default value
    // }

    console.log(resolvedOptions.baseURL) // ✅ TypeScript knows this is always defined
    console.log(resolvedOptions.timeout) // ✅ TypeScript knows this is always defined
    console.log(resolvedOptions.retries) // ✅ TypeScript knows this is always defined
  },
})
```

Without using `.with()`, the `resolvedOptions` parameter would be typed as the raw `ModuleOptions` interface, where `timeout` and `retries` could be `undefined` even when defaults are provided. The `.with()` method enables TypeScript to understand that default values make those properties non-optional in the resolved options.

#### Using Lifecycle Hooks for Module Installation and Upgrade

You can define lifecycle hooks that run when your module is first installed or upgraded to a new version. These hooks are useful for performing one-time setup tasks, database migrations, or cleanup operations.

::important
For lifecycle hooks to work, you **must** provide both `meta.name` and `meta.version` in your module definition. The hooks use these values to track the module's installation state in the project's `.nuxtrc` file.
::

Lifecycle hooks run before the main `setup` function, and if a hook throws an error, it's logged but doesn't stop the build process.

**`onInstall`** runs only once when the module is first added to a project.

**`onUpgrade`** runs each time the module version increases (using semver comparison) &mdash; but only once for each version bump.

##### Example

```ts
import { defineNuxtModule } from '@nuxt/kit'
import semver from 'semver'

export default defineNuxtModule({
  meta: {
    name: 'my-awesome-module',
    version: '1.2.0', // Required for lifecycle hooks
    configKey: 'myAwesomeModule',
  },
  defaults: {
    apiKey: '',
    enabled: true,
  },

  onInstall (nuxt) {
    // This runs only when the module is first installed
    console.log('Setting up my-awesome-module for the first time!')

    // You might want to:
    // - Create initial configuration files
    // - Set up database schemas
    // - Display welcome messages
    // - Perform initial data migration
  },

  onUpgrade (nuxt, options, previousVersion) {
    // This runs when the module is upgraded to a newer version
    console.log(`Upgrading my-awesome-module from ${previousVersion} to 1.2.0`)

    // You might want to:
    // - Migrate configuration files
    // - Update database schemas
    // - Clean up deprecated files
    // - Display upgrade notes

    if (semver.lt(previousVersion, '1.1.0')) {
      console.log('⚠️  Breaking changes in 1.1.0 - please check the migration guide')
    }
  },

  setup (options, nuxt) {
    // Regular setup logic runs on every build
    if (options.enabled) {
      // Configure the module
    }
  },
})
```

#### Specifying Module Dependencies

You can use the `moduleDependencies` option to declare dependencies on other modules. This provides a robust way to ensure proper setup order, version compatibility, and configuration management.

The `moduleDependencies` option can be either an object or a function that receives the Nuxt instance:

##### Example

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
  },
  moduleDependencies: {
    '@nuxtjs/tailwindcss': {
      // Specify a version constraint (semver format)
      version: '>=6.0.0',
      // Configuration that overrides user settings
      overrides: {
        exposeConfig: true,
      },
      // Configuration that sets defaults but respects user settings
      defaults: {
        config: {
          darkMode: 'class',
        },
      },
    },
    '@nuxtjs/fontaine': {
      // Optional dependencies won't be installed but ensure that options
      // can be set if they _are_ installed
      optional: true,
      defaults: {
        fonts: [
          {
            family: 'Roboto',
            fallbacks: ['Impact'],
          },
        ],
      },
    },
  },
  setup (options, nuxt) {

  },
})
```

You can also use a function to dynamically determine dependencies based on the Nuxt configuration:

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
  },
  moduleDependencies (nuxt) {
    const dependencies: Record<string, any> = {
      '@nuxtjs/tailwindcss': {
        version: '>=6.0.0',
      },
    }

    // Conditionally add dependencies based on Nuxt config
    if (nuxt.options.experimental?.someFeature) {
      dependencies['@nuxtjs/fontaine'] = {
        optional: true,
      }
    }

    return dependencies
  },
  setup (options, nuxt) {
    // Your setup logic runs after all dependencies are initialized
  },
})
```

## `installModule`

::callout{type="warning"}
**Deprecated:** Use the [`moduleDependencies`](/docs/4.x/api/kit/modules#specifying-module-dependencies) option in `defineNuxtModule` instead. The `installModule` function will be removed (or may become non-blocking) in a future version.
::

Install specified Nuxt module programmatically. This is helpful when your module depends on other modules. You can pass the module options as an object to `inlineOptions` and they will be passed to the module's `setup` function.

### Usage

```ts twoslash
import { defineNuxtModule, installModule } from '@nuxt/kit'

export default defineNuxtModule({
  async setup () {
    // will install @nuxtjs/fontaine with Roboto font and Impact fallback
    await installModule('@nuxtjs/fontaine', {
      // module configuration
      fonts: [
        {
          family: 'Roboto',
          fallbacks: ['Impact'],
          fallbackName: 'fallback-a',
        },
      ],
    })
  },
})
```

### Type

```ts
async function installModule (moduleToInstall: string | NuxtModule, inlineOptions?: any, nuxt?: Nuxt)
```

### Parameters

| Property          | Type                              | Required | Description                                                                                   |
|-------------------|-----------------------------------|----------|-----------------------------------------------------------------------------------------------|
| `moduleToInstall` | `string \| NuxtModule`{lang="ts"} | `true`   | The module to install. Can be either a string with the module name or a module object itself. |
| `inlineOptions`   | `any`                             | `false`  | An object with the module options to be passed to the module's `setup` function.              |
| `nuxt`            | `Nuxt`                            | `false`  | Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.   |

### Examples

```ts
import { defineNuxtModule, installModule } from '@nuxt/kit'

export default defineNuxtModule({
  async setup (options, nuxt) {
    // will install @nuxtjs/fontaine with Roboto font and Impact fallback
    await installModule('@nuxtjs/fontaine', {
      // module configuration
      fonts: [
        {
          family: 'Roboto',
          fallbacks: ['Impact'],
          fallbackName: 'fallback-a',
        },
      ],
    })
  },
})
```
</file>

<file path="docs/4.api/5.kit/10.runtime-config.md">
---
title: Runtime Config
description: Nuxt Kit provides a set of utilities to help you access and modify Nuxt runtime configuration.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/runtime-config.ts
    size: xs
---

## `useRuntimeConfig`

At build-time, it is possible to access the resolved Nuxt [runtime config](/docs/4.x/guide/going-further/runtime-config).

### Type

```ts
function useRuntimeConfig (): Record<string, unknown>
```

## `updateRuntimeConfig`

It is also possible to update runtime configuration. This will be merged with the existing runtime configuration, and if Nitro has already been initialized it will trigger an HMR event to reload the Nitro runtime config.

### Type

```ts
function updateRuntimeConfig (config: Record<string, unknown>): void | Promise<void>
```
</file>

<file path="docs/4.api/5.kit/10.templates.md">
---
title: "Templates"
description: Nuxt Kit provides a set of utilities to help you work with templates. These functions allow you to generate extra files during development and build time.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/template.ts
    size: xs
---

Templates allow you to generate extra files during development and build time. These files will be available in virtual filesystem and can be used in plugins, layouts, components, etc. `addTemplate` and `addTypeTemplate` allow you to add templates to the Nuxt application. `updateTemplates` allows you to regenerate templates that match the filter.

## `addTemplate`

Renders given template during build into the virtual file system, and optionally to disk in the project `buildDir`

### Usage

```ts twoslash
import { addTemplate, defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup (options, nuxt) {
    const globalMeta = defu(nuxt.options.app.head, {
      charset: options.charset,
      viewport: options.viewport,
    })

    addTemplate({
      filename: 'meta.config.mjs',
      getContents: () => 'export default ' + JSON.stringify({ globalMeta, mixinKey: 'setup' }),
    })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { NuxtTemplate, ResolvedNuxtTemplate } from '@nuxt/schema'
// ---cut---
function addTemplate (template: NuxtTemplate | string): ResolvedNuxtTemplate
```

### Parameters

**template**: A template object or a string with the path to the template. If a string is provided, it will be converted to a template object with `src` set to the string value. If a template object is provided, it must have the following properties:

| Property      | Type                                                      | Required | Description                                                                                                                                                                      |
|---------------|-----------------------------------------------------------|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `src`         | `string`                                                  | `false`  | Path to the template. If `src` is not provided, `getContents` must be provided instead.                                                                                          |
| `filename`    | `string`                                                  | `false`  | Filename of the template. If `filename` is not provided, it will be generated from the `src` path. In this case, the `src` option is required.                                   |
| `dst`         | `string`                                                  | `false`  | Path to the destination file. If `dst` is not provided, it will be generated from the `filename` path and nuxt `buildDir` option.                                                |
| `options`     | `Options`                                                 | `false`  | Options to pass to the template.                                                                                                                                                 |
| `getContents` | `(data: Options) => string \| Promise<string>`{lang="ts"} | `false`  | A function that will be called with the `options` object. It should return a string or a promise that resolves to a string. If `src` is provided, this function will be ignored. |
| `write`       | `boolean`                                                 | `false`  | If set to `true`, the template will be written to the destination file. Otherwise, the template will be used only in virtual filesystem.                                         |

### Examples

#### Creating a Virtual File for Runtime Plugin

In this example, we merge an object inside a module and consume the result in a runtime plugin.

```ts twoslash [module.ts]
import { addTemplate, defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup (options, nuxt) {
    const globalMeta = defu(nuxt.options.app.head, {
      charset: options.charset,
      viewport: options.viewport,
    })

    addTemplate({
      filename: 'meta.config.mjs',
      getContents: () => 'export default ' + JSON.stringify({ globalMeta, mixinKey: 'setup' }),
    })
  },
})
```

In the module above, we generate a virtual file named `meta.config.mjs`. In the runtime plugin, we can import it using the `#build` alias:

```ts [runtime/plugin.ts]
import { createHead as createServerHead } from '@unhead/vue/server'
import { createHead as createClientHead } from '@unhead/vue/client'
import { defineNuxtPlugin } from '#imports'
// @ts-expect-error - virtual file
import metaConfig from '#build/meta.config.mjs'

export default defineNuxtPlugin((nuxtApp) => {
  const createHead = import.meta.server ? createServerHead : createClientHead
  const head = createHead()
  head.push(metaConfig.globalMeta)

  nuxtApp.vueApp.use(head)
})
```

## `addTypeTemplate`

Renders given template during build into the project buildDir, then registers it as types.

### Usage

```ts twoslash
import { addTypeTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addTypeTemplate({
      filename: 'types/markdown.d.ts',
      getContents: () => `declare module '*.md' {
  import type { ComponentOptions } from 'vue'
  const Component: ComponentOptions
  export default Component
}`,
    })
  },
})
```

### Type

```ts
function addTypeTemplate (template: NuxtTypeTemplate | string, context?: { nitro?: boolean, nuxt?: boolean }): ResolvedNuxtTemplate
```

### Parameters

**template**: A template object or a string with the path to the template. If a string is provided, it will be converted to a template object with `src` set to the string value. If a template object is provided, it must have the following properties:

| Property      | Type                                                      | Required | Description                                                                                                                                                                      |
|---------------|-----------------------------------------------------------|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `src`         | `string`                                                  | `false`  | Path to the template. If `src` is not provided, `getContents` must be provided instead.                                                                                          |
| `filename`    | `string`                                                  | `false`  | Filename of the template. If `filename` is not provided, it will be generated from the `src` path. In this case, the `src` option is required.                                   |
| `dst`         | `string`                                                  | `false`  | Path to the destination file. If `dst` is not provided, it will be generated from the `filename` path and nuxt `buildDir` option.                                                |
| `options`     | `Options`                                                 | `false`  | Options to pass to the template.                                                                                                                                                 |
| `getContents` | `(data: Options) => string \| Promise<string>`{lang="ts"} | `false`  | A function that will be called with the `options` object. It should return a string or a promise that resolves to a string. If `src` is provided, this function will be ignored. |

**context**: An optional context object can be passed to control where the type is added. If omitted, the type will only be added to the Nuxt context. This object supports the following properties:

| Property | Type      | Required | Description                                                    |
|----------|-----------|----------|----------------------------------------------------------------|
| `nuxt`   | `boolean` | `false`  | If set to `true`, the type will be added to the Nuxt context.  |
| `nitro`  | `boolean` | `false`  | If set to `true`, the type will be added to the Nitro context. |

### Examples

#### Adding Type Templates to the Nitro Context

By default, －－ only adds the type declarations to the Nuxt context. To also add them to the Nitro context, set nitro to true.

```ts twoslash
import { addTypeTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addTypeTemplate({
      filename: 'types/auth.d.ts',
      getContents: () => `declare module '#auth-utils' {
  interface User {
    id: string;
    name: string;
  }

}`,
    }, {
      nitro: true,
    })
  },
})
```

This allows the `#auth-utils` module to be used within the Nitro context.

```ts [server/api/auth.ts]
import type { User } from '#auth-utils'

export default eventHandler(() => {
  const user: User = {
    id: '123',
    name: 'John Doe',
  }

  // do something with the user

  return user
})
```

## `addServerTemplate`

Adds a virtual file that can be used within the Nuxt Nitro server build.

### Usage

```ts twoslash
import { addServerTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addServerTemplate({
      filename: '#my-module/test.mjs',
      getContents () {
        return 'export const test = 123'
      },
    })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { NuxtServerTemplate } from '@nuxt/schema'
// ---cut---
function addServerTemplate (template: NuxtServerTemplate): NuxtServerTemplate
```

### Parameters

**template**: A template object. It must have the following properties:

| Property      | Type                                         | Required | Description                                                                                                                 |
|---------------|----------------------------------------------|----------|-----------------------------------------------------------------------------------------------------------------------------|
| `filename`    | `string`                                     | `true`   | Filename of the template.                                                                                                   |
| `getContents` | `() => string \| Promise<string>`{lang="ts"} | `true`   | A function that will be called with the `options` object. It should return a string or a promise that resolves to a string. |

### Examples

### Creating a Virtual File for Nitro

In this example, we create a virtual file that can be used within the Nuxt Nitro server build.

```ts twoslash
import { addServerTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addServerTemplate({
      filename: '#my-module/test.mjs',
      getContents () {
        return 'export const test = 123'
      },
    })
  },
})
```

And then in a runtime file

```ts [server/api/test.ts]
import { test } from '#my-module/test.js'

export default eventHandler(() => {
  return test
})
```

## `updateTemplates`

Regenerate templates that match the filter. If no filter is provided, all templates will be regenerated.

### Usage

```ts
import { defineNuxtModule, updateTemplates } from '@nuxt/kit'
import { resolve } from 'pathe'

export default defineNuxtModule({
  setup (options, nuxt) {
    const updateTemplatePaths = [
      resolve(nuxt.options.srcDir, 'pages'),
    ]
    // watch and rebuild routes template list when one of the pages changes
    nuxt.hook('builder:watch', async (event, relativePath) => {
      if (event === 'change') {
        return
      }

      const path = resolve(nuxt.options.srcDir, relativePath)
      if (updateTemplatePaths.some(dir => path.startsWith(dir))) {
        await updateTemplates({
          filter: template => template.filename === 'routes.mjs',
        })
      }
    })
  },
})
```

### Type

```ts
async function updateTemplates (options: UpdateTemplatesOptions): void
```

### Parameters

**options**: Options to pass to the template. This object can have the following property:

| Property | Type                                                     | Required | Description                                                                                                                                                                                                  |
|----------|----------------------------------------------------------|----------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `filter` | `(template: ResolvedNuxtTemplate) => boolean`{lang="ts"} | `false`  | A function that will be called with the `template` object. It should return a boolean indicating whether the template should be regenerated. If `filter` is not provided, all templates will be regenerated. |
</file>

<file path="docs/4.api/5.kit/11.nitro.md">
---
title: "Nitro"
description: Nuxt Kit provides a set of utilities to help you work with Nitro. These functions allow you to add server handlers, plugins, and prerender routes.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/nitro.ts
    size: xs
---

Nitro is an open source TypeScript framework to build ultra-fast web servers. Nuxt uses Nitro as its server engine. You can use `useNitro` to access the Nitro instance, `addServerHandler` to add a server handler, `addDevServerHandler` to add a server handler to be used only in development mode, `addServerPlugin` to add a plugin to extend Nitro's runtime behavior, and `addPrerenderRoutes` to add routes to be prerendered by Nitro.

## `addServerHandler`

Adds a Nitro server handler. Use this if you want to create server middleware or a custom route.

### Usage

```ts twoslash
import { addServerHandler, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    const { resolve } = createResolver(import.meta.url)

    addServerHandler({
      route: '/robots.txt',
      handler: resolve('./runtime/robots.get'),
    })
  },
})
```

### Type

```ts
function addServerHandler (handler: NitroEventHandler): void
```

### Parameters

**handler**: A handler object with the following properties:

| Property     | Type      | Required | Description                                                                                                                                   |
|--------------|-----------|----------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| `handler`    | `string`  | `true`   | Path to event handler.                                                                                                                        |
| `route`      | `string`  | `false`  | Path prefix or route. If an empty string used, will be used as a middleware.                                                                  |
| `middleware` | `boolean` | `false`  | Specifies this is a middleware handler. Middleware are called on every route and should normally return nothing to pass to the next handlers. |
| `lazy`       | `boolean` | `false`  | Use lazy loading to import the handler. This is useful when you only want to load the handler on demand.                                      |
| `method`     | `string`  | `false`  | Router method matcher. If handler name contains method name, it will be used as a default value.                                              |

### Examples

#### Basic Usage

You can use `addServerHandler` to add a server handler from your module.

::code-group

```ts twoslash [module.ts]
import { addServerHandler, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    const { resolve } = createResolver(import.meta.url)

    addServerHandler({
      route: '/robots.txt',
      handler: resolve('./runtime/robots.get'),
    })
  },
})
```

```ts twoslash [runtime/robots.get.ts]
export default defineEventHandler(() => {
  return {
    body: `User-agent: *\nDisallow: /`,
  }
})
```

::

When you access `/robots.txt`, it will return the following response:

```txt
User-agent: *
Disallow: /
```

## `addDevServerHandler`

Adds a Nitro server handler to be used only in development mode. This handler will be excluded from production build.

### Usage

```ts twoslash
import { defineEventHandler } from 'h3'
import { addDevServerHandler, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addDevServerHandler({
      handler: defineEventHandler(() => {
        return {
          body: `Response generated at ${new Date().toISOString()}`,
        }
      }),
      route: '/_handler',
    })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { NitroDevEventHandler } from 'nitropack/types'
// ---cut---
function addDevServerHandler (handler: NitroDevEventHandler): void
```

### Parameters

**handler**: A handler object with the following properties:

| Property  | Type           | Required | Description                                                                  |
|-----------|----------------|----------|------------------------------------------------------------------------------|
| `handler` | `EventHandler` | `true`   | Event handler.                                                               |
| `route`   | `string`       | `false`  | Path prefix or route. If an empty string used, will be used as a middleware. |

### Examples

#### Basic Usage

In some cases, you may want to create a server handler specifically for development purposes, such as a Tailwind config viewer.

```ts
import { joinURL } from 'ufo'
import { addDevServerHandler, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  async setup (options, nuxt) {
    const route = joinURL(nuxt.options.app?.baseURL, '/_tailwind')

    // @ts-expect-error - tailwind-config-viewer does not have correct types
    const createServer = await import('tailwind-config-viewer/server/index.js').then(r => r.default || r) as any
    const viewerDevMiddleware = createServer({ tailwindConfigProvider: () => options, routerPrefix: route }).asMiddleware()

    addDevServerHandler({ route, handler: viewerDevMiddleware })
  },
})
```

## `useNitro`

Returns the Nitro instance.

::warning
You can call `useNitro()` only after `ready` hook.
::

::note
Changes to the Nitro instance configuration are not applied.
::

### Usage

```ts
import { defineNuxtModule, useNitro } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('ready', () => {
      const nitro = useNitro()
      // Do something with Nitro instance
    })
  },
})
```

### Type

```ts
function useNitro (): Nitro
```

## `addServerPlugin`

Add plugin to extend Nitro's runtime behavior.

::tip
You can read more about Nitro plugins in the [Nitro documentation](https://nitro.build/guide/plugins).
::

::warning
It is necessary to explicitly import `defineNitroPlugin` from `nitropack/runtime` within your plugin file. The same requirement applies to utilities such as `useRuntimeConfig`.
::

### Usage

```ts twoslash
import { addServerPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)
    addServerPlugin(resolve('./runtime/plugin.ts'))
  },
})
```

### Type

```ts
function addServerPlugin (plugin: string): void
```

### Parameters

| Property | Type     | Required | Description                                                                                                   |
|----------|----------|----------|---------------------------------------------------------------------------------------------------------------|
| `plugin` | `string` | `true`   | Path to the plugin. The plugin must export a default function that accepts the Nitro instance as an argument. |

### Examples

::code-group

```ts [module.ts]
import { addServerPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)
    addServerPlugin(resolve('./runtime/plugin.ts'))
  },
})
```

```ts [runtime/plugin.ts]
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook('request', (event) => {
    console.log('on request', event.path)
  })

  nitroApp.hooks.hook('beforeResponse', (event, { body }) => {
    console.log('on response', event.path, { body })
  })

  nitroApp.hooks.hook('afterResponse', (event, { body }) => {
    console.log('on after response', event.path, { body })
  })
})
```

::

## `addPrerenderRoutes`

Add routes to be prerendered to Nitro.

### Usage

```ts
import { addPrerenderRoutes, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'nuxt-sitemap',
    configKey: 'sitemap',
  },
  defaults: {
    sitemapUrl: '/sitemap.xml',
    prerender: true,
  },
  setup (options) {
    if (options.prerender) {
      addPrerenderRoutes(options.sitemapUrl)
    }
  },
})
```

### Type

```ts
function addPrerenderRoutes (routes: string | string[]): void
```

### Parameters

| Property | Type                            | Required | Description                                 |
|----------|---------------------------------|----------|---------------------------------------------|
| `routes` | `string \| string[]`{lang="ts"} | `true`   | A route or an array of routes to prerender. |

## `addServerImports`

Add imports to the server. It makes your imports available in Nitro without the need to import them manually.

### Usage

```ts twoslash
import { addServerImports, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    const names = [
      'useStoryblok',
      'useStoryblokApi',
      'useStoryblokBridge',
      'renderRichText',
      'RichTextSchema',
    ]

    names.forEach(name =>
      addServerImports({ name, as: name, from: '@storyblok/vue' }),
    )
  },
})
```

### Type

```ts
function addServerImports (dirs: Import | Import[]): void
```

### Parameters

`imports`: An object or an array of objects with the following properties:

| Property   | Type                  | Required | Description                                                                                                     |
|------------|-----------------------|----------|-----------------------------------------------------------------------------------------------------------------|
| `name`     | `string`              | `true`   | Import name to be detected.                                                                                     |
| `from`     | `string`              | `true`   | Module specifier to import from.                                                                                |
| `priority` | `number`              | `false`  | Priority of the import; if multiple imports have the same name, the one with the highest priority will be used. |
| `disabled` | `boolean`             | `false`  | If this import is disabled.                                                                                     |
| `meta`     | `Record<string, any>` | `false`  | Metadata of the import.                                                                                         |
| `type`     | `boolean`             | `false`  | If this import is a pure type import.                                                                           |
| `typeFrom` | `string`              | `false`  | Use this as the `from` value when generating type declarations.                                                 |
| `as`       | `string`              | `false`  | Import as this name.                                                                                            |

## `addServerImportsDir`

Add a directory to be scanned for auto-imports by Nitro.

### Usage

```ts twoslash
import { addServerImportsDir, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup (options) {
    const { resolve } = createResolver(import.meta.url)
    addServerImportsDir(resolve('./runtime/server/composables'))
  },
})
```

### Type

```ts
function addServerImportsDir (dirs: string | string[], opts: { prepend?: boolean }): void
```

### Parameters

| Property | Type                            | Required | Description                                                                                                         |
|----------|---------------------------------|----------|---------------------------------------------------------------------------------------------------------------------|
| `dirs`   | `string \| string[]`{lang="ts"} | `true`   | A directory or an array of directories to register to be scanned by Nitro.                                          |
| `opts`   | `{ prepend?: boolean }`         | `false`  | Options for the import directory. If `prepend` is `true`, the directory is added to the beginning of the scan list. |

### Examples

You can use `addServerImportsDir` to add a directory to be scanned by Nitro. This is useful when you want Nitro to auto-import functions from a custom server directory.

::code-group

```ts twoslash [module.ts]
import { addServerImportsDir, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup (options) {
    const { resolve } = createResolver(import.meta.url)
    addServerImportsDir(resolve('./runtime/server/composables'))
  },
})
```

```ts twoslash [runtime/server/composables/index.ts]
export function useApiSecret () {
  const { apiSecret } = useRuntimeConfig()
  return apiSecret
}
```

::

You can then use the `useApiSecret` function in your server code:

```ts twoslash [runtime/server/api/hello.ts]
const useApiSecret = (): string => ''
// ---cut---
export default defineEventHandler(() => {
  const apiSecret = useApiSecret()
  // Do something with the apiSecret
})
```

## `addServerScanDir`

Add directories to be scanned by Nitro. It will check for subdirectories, which will be registered
just like the `~/server` folder is.

::note
Only `~/server/api`, `~/server/routes`, `~/server/middleware`, and `~/server/utils` are scanned.
::

### Usage

```ts twoslash
import { addServerScanDir, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup (options) {
    const { resolve } = createResolver(import.meta.url)
    addServerScanDir(resolve('./runtime/server'))
  },
})
```

### Type

```ts
function addServerScanDir (dirs: string | string[], opts: { prepend?: boolean }): void
```

### Parameters

| Property | Type                            | Required | Description                                                                                                         |
|----------|---------------------------------|----------|---------------------------------------------------------------------------------------------------------------------|
| `dirs`   | `string \| string[]`{lang="ts"} | `true`   | A directory or an array of directories to register to be scanned for by Nitro as server dirs.                       |
| `opts`   | `{ prepend?: boolean }`         | `false`  | Options for the import directory. If `prepend` is `true`, the directory is added to the beginning of the scan list. |

### Examples

You can use `addServerScanDir` to add a directory to be scanned by Nitro. This is useful when you want to add a custom server directory.

::code-group

```ts twoslash [module.ts]
import { addServerScanDir, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  setup (options) {
    const { resolve } = createResolver(import.meta.url)
    addServerScanDir(resolve('./runtime/server'))
  },
})
```

```ts twoslash [runtime/server/utils/index.ts]
export function hello () {
  return 'Hello from server utils!'
}
```
::

You can then use the `hello` function in your server code.

```ts twoslash [runtime/server/api/hello.ts]
function hello () {
  return 'Hello from server utils!'
}
// ---cut---
export default defineEventHandler(() => {
  return hello() // Hello from server utils!
})
```
</file>

<file path="docs/4.api/5.kit/12.resolving.md">
---
title: Resolving
description: Nuxt Kit provides a set of utilities to help you resolve paths. These functions allow you to resolve paths relative to the current module, with unknown name or extension.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/resolve.ts
    size: xs
---

Sometimes you need to resolve a paths: relative to the current module, with unknown name or extension. For example, you may want to add a plugin that is located in the same directory as the module. To handle this cases, nuxt provides a set of utilities to resolve paths. `resolvePath` and `resolveAlias` are used to resolve paths relative to the current module. `findPath` is used to find first existing file in given paths. `createResolver` is used to create resolver relative to base path.

## `resolvePath`

Resolves full path to a file or directory respecting Nuxt alias and extensions options. If path could not be resolved, normalized input path will be returned.

### Usage

```ts
import { defineNuxtModule, resolvePath } from '@nuxt/kit'

export default defineNuxtModule({
  async setup () {
    const entrypoint = await resolvePath('@unhead/vue')
    console.log(`Unhead entrypoint is ${entrypoint}`)
  },
})
```

### Type

```ts
function resolvePath (path: string, options?: ResolvePathOptions): Promise<string>
```

### Parameters

**`path`**: A path to resolve.

**`options`**: Options to pass to the resolver. This object can have the following properties:

| Property             | Type                                | Required | Description                                                                                                                  |
| -------------------- | ----------------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `cwd`                | `string`                            | `false`  | Base for resolving paths from. Default is Nuxt rootDir.                                                                      |
| `alias`              | `Record<string, string>`{lang="ts"} | `false`  | An object of aliases. Default is Nuxt configured aliases.                                                                    |
| `extensions`         | `string[]`                          | `false`  | The file extensions to try. Default is Nuxt configured extensions.                                                           |
| `virtual`            | `boolean`                           | `false`  | Whether to resolve files that exist in the Nuxt VFS (for example, as a Nuxt template).                                       |
| `fallbackToOriginal` | `boolean`                           | `false`  | Whether to fallback to the original path if the resolved path does not exist instead of returning the normalized input path. |

### Examples

```ts
import { defineNuxtModule, resolvePath } from '@nuxt/kit'
import { join } from 'pathe'

const headlessComponents: ComponentGroup[] = [
  {
    relativePath: 'combobox/combobox.js',
    chunkName: 'headlessui/combobox',
    exports: [
      'Combobox',
      'ComboboxLabel',
      'ComboboxButton',
      'ComboboxInput',
      'ComboboxOptions',
      'ComboboxOption',
    ],
  },
]

export default defineNuxtModule({
  meta: {
    name: 'nuxt-headlessui',
    configKey: 'headlessui',
  },
  defaults: {
    prefix: 'Headless',
  },
  async setup (options) {
    const entrypoint = await resolvePath('@headlessui/vue')
    const root = join(entrypoint, '../components')

    for (const group of headlessComponents) {
      for (const e of group.exports) {
        addComponent(
          {
            name: e,
            export: e,
            filePath: join(root, group.relativePath),
            chunkName: group.chunkName,
            mode: 'all',
          },
        )
      }
    }
  },
})
```

## `resolveAlias`

Resolves path aliases respecting Nuxt alias options.

### Type
  
```ts
function resolveAlias (path: string, alias?: Record<string, string>): string
```

### Parameters

**`path`**: A path to resolve.

**`alias`**: An object of aliases. If not provided, it will be read from `nuxt.options.alias`.

## `findPath`

Try to resolve first existing file in given paths.

### Usage

```ts
import { defineNuxtModule, findPath } from '@nuxt/kit'
import { join } from 'pathe'

export default defineNuxtModule({
  async setup (_, nuxt) {
    // Resolve main (app.vue)
    const mainComponent = await findPath([
      join(nuxt.options.srcDir, 'App'),
      join(nuxt.options.srcDir, 'app'),
    ])
  },
})
```

### Type

```ts
function findPath (paths: string | string[], options?: ResolvePathOptions, pathType: 'file' | 'dir'): Promise<string | null>
```

### Parameters

**`paths`**: A path or an array of paths to resolve.

**`options`**: Options to pass to the resolver. This object can have the following properties:

| Property             | Type                                | Required | Description                                                                                                                  |
| -------------------- | ----------------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `cwd`                | `string`                            | `false`  | Base for resolving paths from. Default is Nuxt rootDir.                                                                      |
| `alias`              | `Record<string, string>`{lang="ts"} | `false`  | An object of aliases. Default is Nuxt configured aliases.                                                                    |
| `extensions`         | `string[]`                          | `false`  | The file extensions to try. Default is Nuxt configured extensions.                                                           |
| `virtual`            | `boolean`                           | `false`  | Whether to resolve files that exist in the Nuxt VFS (for example, as a Nuxt template).                                       |
| `fallbackToOriginal` | `boolean`                           | `false`  | Whether to fallback to the original path if the resolved path does not exist instead of returning the normalized input path. |

## `createResolver`

Creates resolver relative to base path.

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/resolving-paths-and-injecting-assets-to-the-app?friend=nuxt" target="_blank"}
Watch Vue School video about createResolver.
::

### Usage

```ts
import { createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (_, nuxt) {
    const { resolve, resolvePath } = createResolver(import.meta.url)
  },
})
```

### Type

```ts
function createResolver (basePath: string | URL): Resolver
```

### Parameters

**`basePath`**: A base path to resolve from. It can be a string or a URL.

### Return Value

The `createResolver` function returns an object with the following properties:

| Property      | Type                                                                         | Description                                                                                               |
| ------------- | ---------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| `resolve`     | `(path: string) => string`{lang="ts"}                                        | A function that resolves a path relative to the base path.                                                |
| `resolvePath` | `(path: string, options?: ResolvePathOptions) => Promise<string>`{lang="ts"} | A function that resolves a path relative to the base path and respects Nuxt alias and extensions options. |

### Examples

```ts
import { createResolver, defineNuxtModule, isNuxt2 } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('modules:done', () => {
      if (isNuxt2()) {
        addPlugin(resolver.resolve('./runtime/plugin.vue2'))
      } else {
        addPlugin(resolver.resolve('./runtime/plugin.vue3'))
      }
    })
  },
})
```
</file>

<file path="docs/4.api/5.kit/13.logging.md">
---
title: "Logging"
description: Nuxt Kit provides a set of utilities to help you work with logging. These functions allow you to log messages with extra features.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/logger.ts
    size: xs
---

Nuxt provides a logger instance that you can use to log messages with extra features. `useLogger` allows you to get a logger instance.

## `useLogger`

Returns a logger instance. It uses [consola](https://github.com/unjs/consola) under the hood.

### Usage

```ts twoslash
import { defineNuxtModule, useLogger } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const logger = useLogger('my-module')

    logger.info('Hello from my module!')
  },
})
```

### Type

```ts
function useLogger (tag?: string, options?: Partial<ConsolaOptions>): ConsolaInstance
```

### Parameters

**`tag`**: A tag to suffix all log messages with, displayed on the right near the timestamp.

**`options`**: Consola configuration options.

### Examples

```ts twoslash
import { defineNuxtModule, useLogger } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const logger = useLogger('my-module', { level: options.quiet ? 0 : 3 })

    logger.info('Hello from my module!')
  },
})
```
</file>

<file path="docs/4.api/5.kit/14.builder.md">
---
title: Builder
description: Nuxt Kit provides a set of utilities to help you work with the builder. These functions allow you to extend the Vite and webpack configurations.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/build.ts
    size: xs
---

Nuxt have builders based on [Vite](https://github.com/nuxt/nuxt/tree/main/packages/vite) and [webpack](https://github.com/nuxt/nuxt/tree/main/packages/webpack). You can extend the config passed to each one using `extendViteConfig` and `extendWebpackConfig` functions. You can also add additional plugins via `addVitePlugin`, `addWebpackPlugin` and `addBuildPlugin`.

## `extendViteConfig`

Extends the Vite configuration. Callback function can be called multiple times, when applying to both client and server builds.

::warning
This hook is now deprecated, and we recommend using a Vite plugin instead with a `config` hook, or &mdash; for environment-specific configuration &mdash; the `applyToEnvironment` hook.
::

### Usage

```ts twoslash
import { defineNuxtModule, extendViteConfig } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    extendViteConfig((config) => {
      config.optimizeDeps ||= {}
      config.optimizeDeps.include ||= []
      config.optimizeDeps.include.push('cross-fetch')
    })
  },
})
```

For environment-specific configuration in Nuxt 5+, use `addVitePlugin()` instead:

```ts twoslash
import { addVitePlugin, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    // For global configuration (affects all environments)
    addVitePlugin(() => ({
      name: 'my-global-plugin',
      config (config) {
        // This runs before environment setup
        config.optimizeDeps ||= {}
        config.optimizeDeps.include ||= []
        config.optimizeDeps.include.push('cross-fetch')
      },
    }))

    // For environment-specific configuration
    addVitePlugin(() => ({
      name: 'my-client-plugin',
      applyToEnvironment (environment) {
        return environment.name === 'client'
      },
      configEnvironment (name, config) {
        // This only affects the client environment
        config.optimizeDeps ||= {}
        config.optimizeDeps.include ||= []
        config.optimizeDeps.include.push('client-only-package')
      },
    }))
  },
})
```

::warning
**Important:** The `config` hook runs before `applyToEnvironment` and modifies the global configuration. Use `configEnvironment` for environment-specific configuration changes.
::

### Type

```ts twoslash
// @errors: 2391
import type { UserConfig as ViteConfig } from 'vite'
import type { ExtendViteConfigOptions } from '@nuxt/kit'
// ---cut---
function extendViteConfig (callback: ((config: ViteConfig) => void), options?: ExtendViteConfigOptions): void
```

::read-more{to="https://vite.dev/config/" target="_blank" icon="i-simple-icons-vite"}
Check out the Vite website for more information about its configuration.
::

### Parameters

**`callback`**: A callback function that will be called with the Vite configuration object.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                                                                                   |
|-----------|-----------|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                                                                                     |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                                                                                      |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle. **Deprecated in Nuxt 5+.** Use `addVitePlugin()` with `applyToEnvironment()` instead. |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle. **Deprecated in Nuxt 5+.** Use `addVitePlugin()` with `applyToEnvironment()` instead. |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`.                                                                  |

## `extendWebpackConfig`

Extends the webpack configuration. Callback function can be called multiple times, when applying to both client and server builds.

### Usage

```ts twoslash
import { defineNuxtModule, extendWebpackConfig } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    extendWebpackConfig((config) => {
      config.module!.rules!.push({
        test: /\.txt$/,
        use: 'raw-loader',
      })
    })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { Configuration as WebpackConfig } from 'webpack'
import type { ExtendWebpackConfigOptions } from '@nuxt/kit'
// ---cut---
function extendWebpackConfig (callback: ((config: WebpackConfig) => void), options?: ExtendWebpackConfigOptions): void
```

::read-more{to="https://webpack.js.org/configuration/" target="_blank" icon="i-simple-icons-webpack"}
Check out webpack website for more information about its configuration.
::

### Parameters

**`callback`**: A callback function that will be called with the webpack configuration object.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
|-----------|-----------|----------|--------------------------------------------------------------------------------------------------------------|
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |

## `addVitePlugin`

Append Vite plugin to the config.

::warning
In Nuxt 5+, plugins registered with `server: false` or `client: false` options will not have their `config` or `configResolved` hooks called. Instead, use the `applyToEnvironment()` method instead for environment-specific plugins.
::

### Usage

```ts twoslash
// @errors: 2307
// ---cut---
import { addVitePlugin, defineNuxtModule } from '@nuxt/kit'
import { svg4VuePlugin } from 'vite-plugin-svg4vue'

export default defineNuxtModule({
  meta: {
    name: 'nuxt-svg-icons',
    configKey: 'nuxtSvgIcons',
  },
  defaults: {
    svg4vue: {
      assetsDirName: 'assets/icons',
    },
  },
  setup (options) {
    addVitePlugin(svg4VuePlugin(options.svg4vue))

    // or, to add a vite plugin to only one environment
    addVitePlugin(() => ({
      name: 'my-client-plugin',
      applyToEnvironment (environment) {
        return environment.name === 'client'
      },
      // ... rest of your client-only plugin
    }))
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { Plugin as VitePlugin } from 'vite'
import type { ExtendViteConfigOptions } from '@nuxt/kit'
// ---cut---
function addVitePlugin (pluginOrGetter: VitePlugin | VitePlugin[] | (() => VitePlugin | VitePlugin[]), options?: ExtendViteConfigOptions): void
```

::tip
See [Vite website](https://vite.dev/guide/api-plugin) for more information about Vite plugins. You can also use [this repository](https://github.com/vitejs/awesome-vite#plugins) to find a plugin that suits your needs.
::

### Parameters

**`pluginOrGetter`**: A Vite plugin instance or an array of Vite plugin instances. If a function is provided, it must return a Vite plugin instance or an array of Vite plugin instances.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                                                            |
|-----------|-----------|----------|--------------------------------------------------------------------------------------------------------------------------------------------------------|
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                                                              |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                                                               |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle. **Deprecated in Nuxt 5+.** Use `applyToEnvironment()` instead. |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle. **Deprecated in Nuxt 5+.** Use `applyToEnvironment()` instead. |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`.                                           |

## `addWebpackPlugin`

Append webpack plugin to the config.

### Usage

```ts
import EslintWebpackPlugin from 'eslint-webpack-plugin'
import { addWebpackPlugin, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'nuxt-eslint',
    configKey: 'eslint',
  },
  defaults: nuxt => ({
    include: [`${nuxt.options.srcDir}/**/*.{js,jsx,ts,tsx,vue}`],
    lintOnStart: true,
  }),
  setup (options, nuxt) {
    const webpackOptions = {
      ...options,
      context: nuxt.options.srcDir,
      files: options.include,
      lintDirtyModulesOnly: !options.lintOnStart,
    }
    addWebpackPlugin(new EslintWebpackPlugin(webpackOptions), { server: false })
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { WebpackPluginInstance } from 'webpack'
import type { ExtendWebpackConfigOptions } from '@nuxt/kit'
// ---cut---
function addWebpackPlugin (pluginOrGetter: WebpackPluginInstance | WebpackPluginInstance[] | (() => WebpackPluginInstance | WebpackPluginInstance[]), options?: ExtendWebpackConfigOptions): void
```

::tip
See [webpack website](https://webpack.js.org/concepts/plugins/) for more information about webpack plugins. You can also use [this collection](https://webpack.js.org/awesome-webpack/#webpack-plugins) to find a plugin that suits your needs.
::

### Parameters

**`pluginOrGetter`**: A webpack plugin instance or an array of webpack plugin instances. If a function is provided, it must return a webpack plugin instance or an array of webpack plugin instances.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
|-----------|-----------|----------|--------------------------------------------------------------------------------------------------------------|
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |

## `addBuildPlugin`

Builder-agnostic version of `addVitePlugin` and `addWebpackPlugin`. It will add the plugin to both Vite and webpack configurations if they are present.

### Type

```ts twoslash
// @errors: 2391
import type { ExtendConfigOptions } from '@nuxt/kit'
import type { Plugin as VitePlugin } from 'vite'
import type { WebpackPluginInstance } from 'webpack'
import type { RspackPluginInstance } from '@rspack/core'

interface AddBuildPluginFactory {
  vite?: () => VitePlugin | VitePlugin[]
  webpack?: () => WebpackPluginInstance | WebpackPluginInstance[]
  rspack?: () => RspackPluginInstance | RspackPluginInstance[]
}
// ---cut---
function addBuildPlugin (pluginFactory: AddBuildPluginFactory, options?: ExtendConfigOptions): void
```

### Parameters

**`pluginFactory`**: A factory function that returns an object with `vite` and/or `webpack` properties. These properties must be functions that return a Vite plugin instance or an array of Vite plugin instances and/or a webpack plugin instance or an array of webpack plugin instances.

**`options`**: Options to pass to the callback function. This object can have the following properties:

| Property  | Type      | Required | Description                                                                                                  |
|-----------|-----------|----------|--------------------------------------------------------------------------------------------------------------|
| `dev`     | `boolean` | `false`  | If set to `true`, the callback function will be called when building in development mode.                    |
| `build`   | `boolean` | `false`  | If set to `true`, the callback function will be called when building in production mode.                     |
| `server`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the server bundle.                      |
| `client`  | `boolean` | `false`  | If set to `true`, the callback function will be called when building the client bundle.                      |
| `prepend` | `boolean` | `false`  | If set to `true`, the callback function will be prepended to the array with `unshift()` instead of `push()`. |
</file>

<file path="docs/4.api/5.kit/15.examples.md">
---
title: "Examples"
description: Examples of Nuxt Kit utilities in use.
---

## Accessing Nuxt Vite Config

If you are building an integration that needs access to the runtime Vite or webpack config that Nuxt uses, it is possible to extract this using Kit utilities.

Some examples of projects doing this already:

- [histoire](https://github.com/histoire-dev/histoire/blob/main/packages/histoire-plugin-nuxt/src/index.ts)
- [nuxt-vitest](https://github.com/danielroe/nuxt-vitest/blob/main/packages/nuxt-vitest/src/config.ts)
- [@storybook-vue/nuxt](https://github.com/storybook-vue/storybook-nuxt/blob/main/packages/storybook-nuxt/src/preset.ts)

Here is a brief example of how you might access the Vite config from a project; you could implement a similar approach to get the webpack configuration.

```js
import { buildNuxt, loadNuxt } from '@nuxt/kit'

// https://github.com/nuxt/nuxt/issues/14534
async function getViteConfig () {
  const nuxt = await loadNuxt({ cwd: process.cwd(), dev: false, overrides: { ssr: false } })
  return new Promise((resolve, reject) => {
    nuxt.hook('vite:extend', (config) => {
      resolve(config)
      throw new Error('_stop_')
    })
    buildNuxt(nuxt).catch((err) => {
      if (!err.toString().includes('_stop_')) {
        reject(err)
      }
    })
  }).finally(() => nuxt.close())
}

const viteConfig = await getViteConfig()
console.log(viteConfig)
```
</file>

<file path="docs/4.api/5.kit/16.layers.md">
---
title: "Layers"
description: Nuxt Kit provides utilities to help you work with layers and their directory structures.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/layers.ts
    size: xs
---

Nuxt layers provide a powerful way to share and extend functionality across projects. When working with layers in modules, you often need to access directory paths from each layer. Nuxt Kit provides the `getLayerDirectories` utility to access resolved directory paths for all layers in your Nuxt application.

## `getLayerDirectories`

Get the resolved directory paths for all layers in a Nuxt application. This function provides a structured way to access layer directories without directly accessing the private `nuxt.options._layers` property.

### Usage

```ts twoslash
import { defineNuxtModule, getLayerDirectories } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const layerDirs = getLayerDirectories()

    // Access directories from all layers
    for (const [index, layer] of layerDirs.entries()) {
      console.log(`Layer ${index}:`)
      console.log(`  Root: ${layer.root}`)
      console.log(`  App: ${layer.app}`)
      console.log(`  Server: ${layer.server}`)
      console.log(`  Pages: ${layer.appPages}`)
      // ... other directories
    }
  },
})
```

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt } from '@nuxt/schema'
// ---cut---
function getLayerDirectories (nuxt?: Nuxt): LayerDirectories[]

interface LayerDirectories {
  /** Nuxt rootDir (`/` by default) */
  readonly root: string
  /** Nitro source directory (`/server` by default) */
  readonly server: string
  /** Local modules directory (`/modules` by default) */
  readonly modules: string
  /** Shared directory (`/shared` by default) */
  readonly shared: string
  /** Public directory (`/public` by default) */
  readonly public: string
  /** Nuxt srcDir (`/app/` by default) */
  readonly app: string
  /** Layouts directory (`/app/layouts` by default) */
  readonly appLayouts: string
  /** Middleware directory (`/app/middleware` by default) */
  readonly appMiddleware: string
  /** Pages directory (`/app/pages` by default) */
  readonly appPages: string
  /** Plugins directory (`/app/plugins` by default) */
  readonly appPlugins: string
}
```

### Parameters

**`nuxt`** (optional): The Nuxt instance to get layers from. If not provided, the function will use the current Nuxt context.

### Return Value

The `getLayerDirectories` function returns an array of `LayerDirectories` objects, one for each layer in the application.

**Layer Priority Ordering**: The layers are ordered by priority, where:
- The **first layer** is the user/project layer (highest priority)
- **Earlier layers override later layers** in the array
- **Base layers appear last** in the array (lowest priority)

This ordering matches Nuxt's layer resolution system, where user-defined configurations and files take precedence over those from base layers.

**`LayerDirectories`**: An object containing the resolved directory paths for a layer.

| Property        | Type     | Description                                                  |
|-----------------|----------|--------------------------------------------------------------|
| `root`          | `string` | The root directory of the layer (equivalent to `rootDir`)    |
| `server`        | `string` | The server directory for Nitro server-side code              |
| `modules`       | `string` | The local modules directory                                  |
| `shared`        | `string` | The shared directory for code used by both client and server |
| `app`           | `string` | The source directory of the layer (equivalent to `srcDir`)   |
| `public`        | `string` | The public directory for static assets                       |
| `appLayouts`    | `string` | The layouts directory for Vue layout components              |
| `appMiddleware` | `string` | The middleware directory for route middleware                |
| `appPages`      | `string` | The pages directory for file-based routing                   |
| `appPlugins`    | `string` | The plugins directory for Nuxt plugins                       |

### Examples

**Processing files from all layers:**

```ts twoslash
// @errors: 2307
// ---cut---
import { defineNuxtModule, getLayerDirectories } from '@nuxt/kit'
import { resolve } from 'pathe'
import { globby } from 'globby'

export default defineNuxtModule({
  async setup () {
    const layerDirs = getLayerDirectories()

    // Find all component files across layers
    // Note: layerDirs[0] is the user layer (highest priority)
    // Later layers in the array have lower priority
    const componentFiles = []
    for (const [index, layer] of layerDirs.entries()) {
      const files = await globby('**/*.vue', {
        cwd: resolve(layer.app, 'components'),
        absolute: true,
      })
      console.log(`Layer ${index} (${index === 0 ? 'user' : 'base'}):`, files.length, 'components')
      componentFiles.push(...files)
    }
  },
})
```

**Adding templates from multiple layers:**

```ts twoslash
import { addTemplate, defineNuxtModule, getLayerDirectories } from '@nuxt/kit'
import { basename, resolve } from 'pathe'
import { existsSync } from 'node:fs'

export default defineNuxtModule({
  setup () {
    const layerDirs = getLayerDirectories()

    // Add a config file from each layer that has one
    for (const dirs of layerDirs) {
      const configPath = resolve(dirs.app, 'my-module.config.ts')
      if (existsSync(configPath)) {
        addTemplate({
          filename: `my-module-${basename(dirs.root)}.config.ts`,
          src: configPath,
        })
      }
    }
  },
})
```

**Respecting layer priority:**

```ts twoslash
import { defineNuxtModule, getLayerDirectories } from '@nuxt/kit'
import { resolve } from 'pathe'
import { existsSync, readFileSync } from 'node:fs'

export default defineNuxtModule({
  setup () {
    const layerDirs = getLayerDirectories()

    // Find the first (highest priority) layer that has a specific config file
    // This respects the layer priority system
    let configContent = null
    for (const dirs of layerDirs) {
      const configPath = resolve(dirs.app, 'my-config.json')
      if (existsSync(configPath)) {
        configContent = readFileSync(configPath, 'utf-8')
        console.log(`Using config from layer: ${dirs.root}`)
        break // Use the first (highest priority) config found
      }
    }

    // Alternative: Collect configs from all layers, with user layer taking precedence
    const allConfigs = {}
    for (const dirs of layerDirs.reverse()) { // Process from lowest to highest priority
      const configPath = resolve(dirs.app, 'my-config.json')
      if (existsSync(configPath)) {
        const config = JSON.parse(readFileSync(configPath, 'utf-8'))
        Object.assign(allConfigs, config) // Later assignments override earlier ones
      }
    }
  },
})
```

**Checking for layer-specific directories:**

```ts twoslash
import { defineNuxtModule, getLayerDirectories } from '@nuxt/kit'
import { existsSync } from 'node:fs'
import { resolve } from 'pathe'

export default defineNuxtModule({
  setup () {
    const layerDirs = getLayerDirectories()

    // Find layers that have a specific custom directory
    const layersWithAssets = layerDirs.filter((layer) => {
      return existsSync(resolve(layer.app, 'assets'))
    })

    console.log(`Found ${layersWithAssets.length} layers with assets directory`)
  },
})
```

::note
The `getLayerDirectories` function includes caching via a WeakMap to avoid recomputing directory paths for the same layers repeatedly, improving performance when called multiple times.
::

::note
Directory paths returned by this function always include a trailing slash for consistency.
::
</file>

<file path="docs/4.api/5.kit/2.programmatic.md">
---
title: "Programmatic Usage"
description: Nuxt Kit provides a set of utilities to help you work with Nuxt programmatically. These functions allow you to load Nuxt, build Nuxt, and load Nuxt configuration.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/tree/main/packages/kit/src/loader
    size: xs
---

Programmatic usage can be helpful when you want to use Nuxt programmatically, for example, when building a [CLI tool](https://github.com/nuxt/cli) or [test utils](https://github.com/nuxt/test-utils).

## `loadNuxt`

Load Nuxt programmatically. It will load the Nuxt configuration, instantiate and return the promise with Nuxt instance.

### Type

```ts
function loadNuxt (loadOptions?: LoadNuxtOptions): Promise<Nuxt>
```

### Parameters

**`loadOptions`**: Loading conditions for Nuxt. `loadNuxt` uses [`c12`](https://github.com/unjs/c12) under the hood, so it accepts the same options as `c12.loadConfig` with some additional options:

| Property | Type      | Required | Description                                                                                                                                                       |
| -------- | --------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `dev`    | `boolean` | `false`  | If set to `true`, Nuxt will be loaded in development mode.                                                                                                        |
| `ready`  | `boolean` | `true`   | If set to `true`, Nuxt will be ready to use after the `loadNuxt` call. If set to `false`, you will need to call `nuxt.ready()` to make sure Nuxt is ready to use. |

## `buildNuxt`

Build Nuxt programmatically. It will invoke the builder (currently [@nuxt/vite-builder](https://github.com/nuxt/nuxt/tree/main/packages/vite) or [@nuxt/webpack-builder](https://github.com/nuxt/nuxt/tree/main/packages/webpack)) to bundle the application.

### Type

```ts
function buildNuxt (nuxt: Nuxt): Promise<any>
```

### Parameters

**`nuxt`**: Nuxt instance to build. It can be retrieved from the context via `useNuxt()` call.

## `loadNuxtConfig`

Load Nuxt configuration. It will return the promise with the configuration object.

### Type

```ts
function loadNuxtConfig (options: LoadNuxtConfigOptions): Promise<NuxtOptions>
```

### Parameters

**`options`**: Options to pass in [`c12`](https://github.com/unjs/c12#options) `loadConfig` call.

## `writeTypes`

Generates `tsconfig.json` and writes it to the project buildDir.

### Type

```ts
function writeTypes (nuxt?: Nuxt): void
```

### Parameters

**`nuxt`**: Nuxt instance to build. It can be retrieved from the context via `useNuxt()` call.
</file>

<file path="docs/4.api/5.kit/3.compatibility.md">
---
title: "Compatibility"
description: Nuxt Kit provides a set of utilities to help you check the compatibility of your modules with different Nuxt versions.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/compatibility.ts
    size: xs
---

Nuxt Kit utilities can be used in Nuxt 3, Nuxt 2 with Bridge and even Nuxt 2 without Bridge. To make sure your module is compatible with all versions, you can use the `checkNuxtCompatibility`, `assertNuxtCompatibility` and `hasNuxtCompatibility` functions. They will check if the current Nuxt version meets the constraints you provide. Also you can use `isNuxt2`, `isNuxt3` and `getNuxtVersion` functions for more granular checks.

## `checkNuxtCompatibility`

Checks if constraints are met for the current Nuxt version. If not, returns an array of messages. Nuxt 2 version also checks for `bridge` support.

### Usage

```ts twoslash
import { checkNuxtCompatibility, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  async setup (_options, nuxt) {
    const issues = await checkNuxtCompatibility({ nuxt: '^2.16.0' }, nuxt)
    if (issues.length) {
      console.warn('Nuxt compatibility issues found:\n' + issues.toString())
    } else {
      // do something
    }
  },
})
```

### Type

```ts
function checkNuxtCompatibility (constraints: NuxtCompatibility, nuxt?: Nuxt): Promise<NuxtCompatibilityIssues>
```

### Parameters

**`constraints`**: Version and builder constraints to check against. It accepts the following properties:

| Property | Type                                          | Required  | Description                                                                                                                                      |
| -------- | --------------------------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| `nuxt`   | `string`                                      | `false`   | Nuxt version in semver format. Versions may be defined in Node.js way, for example: `>=2.15.0 <3.0.0`.                                           |
| `bridge` | `Record<string, string \| false>`{lang="ts"}  | `false`   | Specifies version constraints or disables compatibility for specific Nuxt builders like `vite`, `webpack`, or `rspack`. Use `false` to disable.  |

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `assertNuxtCompatibility`

Asserts that constraints are met for the current Nuxt version. If not, throws an error with the list of issues as string.

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt, NuxtCompatibility } from '@nuxt/schema'
// ---cut---
function assertNuxtCompatibility (constraints: NuxtCompatibility, nuxt?: Nuxt): Promise<true>
```

### Parameters

**`constraints`**: Version and builder constraints to check against. Refer to the [constraints table in `checkNuxtCompatibility`](/docs/4.x/api/kit/compatibility#parameters) for details.

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `hasNuxtCompatibility`

Checks if constraints are met for the current Nuxt version. Return `true` if all constraints are met, otherwise returns `false`. Nuxt 2 version also checks for `bridge` support.

### Usage

```ts twoslash
import { defineNuxtModule, hasNuxtCompatibility } from '@nuxt/kit'

export default defineNuxtModule({
  async setup (_options, nuxt) {
    const usingNewPostcss = await hasNuxtCompatibility({ nuxt: '^2.16.0' }, nuxt)
    if (usingNewPostcss) {
      // do something
    } else {
      // do something else
    }
  },
})
```

### Type

```ts
function hasNuxtCompatibility (constraints: NuxtCompatibility, nuxt?: Nuxt): Promise<boolean>
```

### Parameters

**`constraints`**: Version and builder constraints to check against. Refer to the [constraints table in `checkNuxtCompatibility`](/docs/4.x/api/kit/compatibility#parameters) for details.

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `isNuxtMajorVersion`

Check if current Nuxt instance is of specified major version

### Usage

```ts twoslash
import { defineNuxtModule, isNuxtMajorVersion } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    if (isNuxtMajorVersion(3)) {
      // do something for Nuxt 3
    } else {
      // do something else for other versions
    }
  },
})
```

### Type

```ts
function isNuxtMajorVersion (major: number, nuxt?: Nuxt): boolean
```

### Parameters

**`major`**: Major version to check against.

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `isNuxt3`

Checks if the current Nuxt version is 3.x.

::note
Use `isNuxtMajorVersion(2, nuxt)` instead. This may be removed in \@nuxt/kit v5 or a future major version.
::

### Type

```ts
function isNuxt3 (nuxt?: Nuxt): boolean
```

### Parameters

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `isNuxt2`

Checks if the current Nuxt version is 2.x.

::note
Use `isNuxtMajorVersion(2, nuxt)` instead. This may be removed in \@nuxt/kit v5 or a future major version.
::

### Type

```ts
function isNuxt2 (nuxt?: Nuxt): boolean
```

### Parameters

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.

## `getNuxtVersion`

Returns the current Nuxt version.

### Type

```ts
function getNuxtVersion (nuxt?: Nuxt): string
```

### Parameters

**`nuxt`**: Nuxt instance. If not provided, it will be retrieved from the context via `useNuxt()` call.
</file>

<file path="docs/4.api/5.kit/4.autoimports.md">
---
title: "Auto-imports"
description: Nuxt Kit provides a set of utilities to help you work with auto-imports. These functions allow you to register your own utils, composables and Vue APIs.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/imports.ts
    size: xs
---

Nuxt auto-imports helper functions, composables and Vue APIs to use across your application without explicitly importing them. Based on the directory structure, every Nuxt application can also use auto-imports for its own composables and plugins.

With Nuxt Kit you can also add your own auto-imports. `addImports` and `addImportsDir` allow you to add imports to the Nuxt application. `addImportsSources` allows you to add listed imports from 3rd party packages to the Nuxt application.

These utilities are powered by [`unimport`](https://github.com/unjs/unimport), which provides the underlying auto-import mechanism used in Nuxt.

::note
These functions are designed for registering your own utils, composables and Vue APIs. For pages, components and plugins, please refer to the specific sections: [Pages](/docs/4.x/api/kit/pages), [Components](/docs/4.x/api/kit/components), [Plugins](/docs/4.x/api/kit/plugins).
::

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/expanding-nuxt-s-auto-imports?friend=nuxt" target="_blank"}
Watch Vue School video about Auto-imports Nuxt Kit utilities.
::

## `addImports`

Add imports to the Nuxt application. It makes your imports available in the Nuxt application without the need to import them manually.

### Usage

```ts twoslash
import { addImports, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const names = [
      'useStoryblok',
      'useStoryblokApi',
      'useStoryblokBridge',
      'renderRichText',
      'RichTextSchema',
    ]

    names.forEach(name =>
      addImports({ name, as: name, from: '@storyblok/vue' }),
    )
  },
})
```

### Type

```ts
function addImports (imports: Import | Import[]): void
```

### Parameters

`imports`: An object or an array of objects with the following properties:

| Property   | Type                  | Required | Description                                                                                                     |
|------------|-----------------------|----------|-----------------------------------------------------------------------------------------------------------------|
| `name`     | `string`              | `true`   | Import name to be detected.                                                                                     |
| `from`     | `string`              | `true`   | Module specifier to import from.                                                                                |
| `priority` | `number`              | `false`  | Priority of the import; if multiple imports have the same name, the one with the highest priority will be used. |
| `disabled` | `boolean`             | `false`  | If this import is disabled.                                                                                     |
| `meta`     | `Record<string, any>` | `false`  | Metadata of the import.                                                                                         |
| `type`     | `boolean`             | `false`  | If this import is a pure type import.                                                                           |
| `typeFrom` | `string`              | `false`  | Use this as the `from` value when generating type declarations.                                                 |
| `as`       | `string`              | `false`  | Import as this name.                                                                                            |

## `addImportsDir`

Add imports from a directory to the Nuxt application. It will automatically import all files from the directory and make them available in the Nuxt application without the need to import them manually.

### Usage

```ts twoslash
import { addImportsDir, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: '@vueuse/motion',
    configKey: 'motion',
  },
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)
    addImportsDir(resolver.resolve('./runtime/composables'))
  },
})
```

### Type

```ts
function addImportsDir (dirs: string | string[], options?: { prepend?: boolean }): void
```

### Parameters

| Property  | Type                               | Required | Description                                                                                                         |
|-----------|------------------------------------|----------|---------------------------------------------------------------------------------------------------------------------|
| `dirs`    | `string \| string[]`{lang="ts"}    | `true`   | A string or an array of strings with the path to the directory to import from.                                      |
| `options` | `{ prepend?: boolean }`{lang="ts"} | `false`  | Options to pass to the import. If `prepend` is set to `true`, the imports will be prepended to the list of imports. |

## `addImportsSources`

Add listed imports to the Nuxt application.

### Usage

```ts twoslash
import { addImportsSources, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addImportsSources({
      from: 'h3',
      imports: [
        'defineEventHandler',
        'getQuery',
        'getRouterParams',
        'readBody',
        'sendRedirect',
      ],
    })
  },
})
```

### Type

```ts
function addImportsSources (importSources: ImportSource | ImportSource[]): void
```

### Parameters

**importSources**: An object or an array of objects with the following properties:

| Property  | Type                                        | Required | Description                                                                                    |
|-----------|---------------------------------------------|----------|------------------------------------------------------------------------------------------------|
| `from`    | `string`                                    | `true`   | Module specifier to import from.                                                               |
| `imports` | `PresetImport \| ImportSource[]`{lang="ts"} | `true`   | An object or an array of objects, which can be import names, import objects or import sources. |
</file>

<file path="docs/4.api/5.kit/5.components.md">
---
title: "Components"
description: Nuxt Kit provides a set of utilities to help you work with components. You can register components globally or locally, and also add directories to be scanned for components.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/components.ts
    size: xs
---

Components are the building blocks of your Nuxt application. They are reusable Vue instances that can be used to create a user interface. In Nuxt, components from the components directory are automatically imported by default. However, if you need to import components from an alternative directory or wish to selectively import them as needed, `@nuxt/kit` provides the `addComponentsDir` and `addComponent` methods. These utils allow you to customize the component configuration to better suit your needs.

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/injecting-components-and-component-directories?friend=nuxt" target="_blank"}
Watch Vue School video about injecting components.
::

## `addComponentsDir`

Register a directory to be scanned for components and imported only when used. Keep in mind, that this does not register components globally, until you specify `global: true` option.

### Usage

```ts
export default defineNuxtModule({
  meta: {
    name: '@nuxt/ui',
    configKey: 'ui',
  },
  setup () {
    addComponentsDir({
      path: resolve('./runtime/components'),
      prefix: 'U',
      pathPrefix: false,
    })
  },
})
```

### Type

```ts
function addComponentsDir (dir: ComponentsDir, opts: { prepend?: boolean } = {}): void
```

### Parameters

`dir` An object with the following properties:

| Property          | Type                                                                                     | Required | Description                                                                                                                                                                                                                                             |
|-------------------|------------------------------------------------------------------------------------------|----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `path`            | `string`                                                                                 | `true`   | Path (absolute or relative) to the directory containing your components. You can use Nuxt aliases (~ or @) to refer to directories inside project or directly use an npm package path similar to require.                                               |
| `pattern`         | `string \| string[]`{lang="ts"}                                                          | `false`  | Accept Pattern that will be run against specified path.                                                                                                                                                                                                 |
| `ignore`          | `string[]`                                                                               | `false`  | Ignore patterns that will be run against specified path.                                                                                                                                                                                                |
| `prefix`          | `string`                                                                                 | `false`  | Prefix all matched components with this string.                                                                                                                                                                                                         |
| `pathPrefix`      | `boolean`                                                                                | `false`  | Prefix component name by its path.                                                                                                                                                                                                                      |
| `prefetch`        | `boolean`                                                                                | `false`  | These properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on [webpack documentation](https://webpack.js.org/api/module-methods/#magic-comments) |
| `preload`         | `boolean`                                                                                | `false`  | These properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on [webpack documentation](https://webpack.js.org/api/module-methods/#magic-comments) |
| `isAsync`         | `boolean`                                                                                | `false`  | This flag indicates, component should be loaded async (with a separate chunk) regardless of using Lazy prefix or not.                                                                                                                                   |
| `extendComponent` | `(component: Component) => Promise<Component \| void> \| (Component \| void)`{lang="ts"} | `false`  | A function that will be called for each component found in the directory. It accepts a component object and should return a component object or a promise that resolves to a component object.                                                          |
| `global`          | `boolean`                                                                                | `false`  | If enabled, registers components to be globally available.                                                                                                                                                                                              |
| `island`          | `boolean`                                                                                | `false`  | If enabled, registers components as islands. You can read more about islands in [`<NuxtIsland/>`](/docs/4.x/api/components/nuxt-island) component description.                                                                                          |
| `watch`           | `boolean`                                                                                | `false`  | Watch specified path for changes, including file additions and file deletions.                                                                                                                                                                          |
| `extensions`      | `string[]`                                                                               | `false`  | Extensions supported by Nuxt builder.                                                                                                                                                                                                                   |
| `transpile`       | `'auto' \| boolean`{lang="ts"}                                                           | `false`  | Transpile specified path using build.transpile. If set to `'auto'`, it will set `transpile: true` if `node_modules/` is in path.                                                                                                                        |

`opts`

| Property  | Type      | Required | Description                                                                                          |
|-----------|-----------|----------|------------------------------------------------------------------------------------------------------|
| `prepend` | `boolean` | `false`  | If set to `true`, the directory will be prepended to the array with `unshift()` instead of `push()`. |

## `addComponent`

Register a component to be automatically imported.

### Usage

```ts
import { addComponent, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: '@nuxt/image',
    configKey: 'image',
  },
  setup () {
    const resolver = createResolver(import.meta.url)

    addComponent({
      name: 'NuxtImg',
      filePath: resolver.resolve('./runtime/components/NuxtImg.vue'),
    })

    addComponent({
      name: 'NuxtPicture',
      filePath: resolver.resolve('./runtime/components/NuxtPicture.vue'),
    })
  },
})
```

### Type

```ts
function addComponent (options: AddComponentOptions): void
```

### Parameters

`options`: An object with the following properties:

| Property          | Type                                       | Required | Description                                                                                                                                                                                                                                             |
|-------------------|--------------------------------------------|----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
| `name`            | `string`                                   | `true`   | Component name.                                                                                                                                                                                                                                         |
| `filePath`        | `string`                                   | `true`   | Path to the component.                                                                                                                                                                                                                                  |
| `declarationPath` | `string`                                   | `false`  | Path to component's declaration file. It is used to generate components' [type templates](/docs/4.x/api/kit/templates#addtypetemplate); if not provided, `filePath` is used instead.                                                                    |
| `pascalName`      | `string`                                   | `false`  | Pascal case component name. If not provided, it will be generated from the component name.                                                                                                                                                              |
| `kebabName`       | `string`                                   | `false`  | Kebab case component name. If not provided, it will be generated from the component name.                                                                                                                                                               |
| `export`          | `string`                                   | `false`  | Specify named or default export. If not provided, it will be set to `'default'`.                                                                                                                                                                        |
| `shortPath`       | `string`                                   | `false`  | Short path to the component. If not provided, it will be generated from the component path.                                                                                                                                                             |
| `chunkName`       | `string`                                   | `false`  | Chunk name for the component. If not provided, it will be generated from the component name.                                                                                                                                                            |
| `prefetch`        | `boolean`                                  | `false`  | These properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on [webpack documentation](https://webpack.js.org/api/module-methods/#magic-comments) |  
| `preload`         | `boolean`                                  | `false`  | These properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on [webpack documentation](https://webpack.js.org/api/module-methods/#magic-comments) |
| `global`          | `boolean`                                  | `false`  | If enabled, registers component to be globally available.                                                                                                                                                                                               |
| `island`          | `boolean`                                  | `false`  | If enabled, registers component as island. You can read more about islands in [`<NuxtIsland/>`](/docs/4.x/api/components/nuxt-island) component description.                                                                                            |
| `mode`            | `'client' \| 'server' \| 'all'`{lang="ts"} | `false`  | This options indicates if component should render on client, server or both. By default, it will render on both client and server.                                                                                                                      |
| `priority`        | `number`                                   | `false`  | Priority of the component, if multiple components have the same name, the one with the highest priority will be used.                                                                                                                                   |

### Examples

If you want to auto-import a component from an npm package, and the component is a named export (rather than the default), you can use the `export` option to specify it.

```ts
import { addComponent, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    // import { MyComponent as MyAutoImportedComponent } from 'my-npm-package'
    addComponent({
      name: 'MyAutoImportedComponent',
      export: 'MyComponent',
      filePath: 'my-npm-package',
    })
  },
})
```
</file>

<file path="docs/4.api/5.kit/6.context.md">
---
title: "Context"
description: Nuxt Kit provides a set of utilities to help you work with context.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/context.ts
    size: xs
---

Nuxt modules allow you to enhance Nuxt's capabilities. They offer a structured way to keep your code organized and modular. If you're looking to break down your module into smaller components, Nuxt offers the `useNuxt` and `tryUseNuxt` functions. These functions enable you to conveniently access the Nuxt instance from the context without having to pass it as an argument.

::note
When you're working with the `setup` function in Nuxt modules, Nuxt is already provided as the second argument. This means you can access it directly without needing to call `useNuxt()`.
::

## `useNuxt`

Get the Nuxt instance from the context. It will throw an error if Nuxt is not available.

### Usage

```ts
import { useNuxt } from '@nuxt/kit'

const setupSomeFeature = () => {
  const nuxt = useNuxt()

  // You can now use the nuxt instance
  console.log(nuxt.options)
}
```

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt } from '@nuxt/schema'
// ---cut---
function useNuxt (): Nuxt
```

### Return Value

The `useNuxt` function returns the Nuxt instance, which contains all the options and methods available in Nuxt.

| Property   | Type                                                                      | Description                                                                                               |
| ---------- | ------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| `options`  | `NuxtOptions`                                                             | The resolved Nuxt configuration.                                                                          |
| `hooks`    | `Hookable<NuxtHooks>`                                                     | The Nuxt hook system. Allows registering and listening to lifecycle events.                               |
| `hook`     | `(name: string, (...args: any[]) => Promise<void> \| void) => () => void` | Shortcut for `nuxt.hooks.hook`. Registers a single callback for a specific lifecycle hook.                |
| `callHook` | `(name: string, ...args: any[]) => Promise<any>`                          | Shortcut for `nuxt.hooks.callHook`. Triggers a lifecycle hook manually and runs all registered callbacks. |
| `addHooks` | `(configHooks: NestedHooks) => () => void`                                | Shortcut for `nuxt.hooks.addHooks`. Registers multiple hooks at once.                                     |

### Examples

::code-group

```ts twoslash [setupTranspilation.ts]
import { useNuxt } from '@nuxt/kit'

export const setupTranspilation = () => {
  const nuxt = useNuxt()

  if (nuxt.options.builder === '@nuxt/webpack-builder') {
    nuxt.options.build.transpile ||= []
    nuxt.options.build.transpile.push('xstate')
  }
}
```

```ts twoslash [module.ts]
// @module: esnext
// @filename: setupTranspilation.ts
export const setupTranspilation = () => {}
// @filename: module.ts
import { defineNuxtModule } from '@nuxt/kit'
// ---cut---
import { setupTranspilation } from './setupTranspilation'

export default defineNuxtModule({
  setup () {
    setupTranspilation()
  },
})
```

::

## `tryUseNuxt`

Get the Nuxt instance from the context. It will return `null` if Nuxt is not available.

### Usage

```ts twoslash
import { tryUseNuxt } from '@nuxt/kit'

function setupSomething () {
  const nuxt = tryUseNuxt()

  if (nuxt) {
    // You can now use the nuxt instance
    console.log(nuxt.options)
  } else {
    console.log('Nuxt is not available')
  }
}
```

### Type

```ts twoslash
// @errors: 2391
import type { Nuxt } from '@nuxt/schema'
// ---cut---
function tryUseNuxt (): Nuxt | null
```

### Return Value

The `tryUseNuxt` function returns the Nuxt instance if available, or `null` if Nuxt is not available.

The Nuxt instance as described in the `useNuxt` section.

### Examples

::code-group

```ts twoslash [requireSiteConfig.ts]
declare module 'nuxt/schema' {
  interface NuxtOptions {
    siteConfig: SiteConfig
  }
}
// ---cut---
import { tryUseNuxt } from '@nuxt/kit'

interface SiteConfig {
  title?: string
}

export const requireSiteConfig = (): SiteConfig => {
  const nuxt = tryUseNuxt()
  if (!nuxt) {
    return {}
  }
  return nuxt.options.siteConfig
}
```

```ts twoslash [module.ts]
// @module: esnext
// @filename: requireSiteConfig.ts
interface SiteConfig {
  title?: string
}
export const requireSiteConfig = (): SiteConfig => {
  return {}
}
// @filename: module.ts
// ---cut---
import { defineNuxtModule, useNuxt } from '@nuxt/kit'
import { requireSiteConfig } from './requireSiteConfig'

export default defineNuxtModule({
  setup (_, nuxt) {
    const config = requireSiteConfig()
    nuxt.options.app.head.title = config.title
  },
})
```

::
</file>

<file path="docs/4.api/5.kit/7.pages.md">
---
title: Pages
description: Nuxt Kit provides a set of utilities to help you create and use pages. You can use these utilities to manipulate the pages configuration or to define route rules.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/pages.ts
    size: xs
---

## `extendPages`

In Nuxt, routes are automatically generated based on the structure of the files in the `app/pages` directory. However, there may be scenarios where you'd want to customize these routes. For instance, you might need to add a route for a dynamic page not generated by Nuxt, remove an existing route, or modify the configuration of a route. For such customizations, Nuxt offers the `extendPages` feature, which allows you to extend and alter the pages configuration.

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/extend-and-alter-nuxt-pages?friend=nuxt" target="_blank"}
Watch Vue School video about extendPages.
::

### Usage

```ts twoslash
import { createResolver, defineNuxtModule, extendPages } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    const { resolve } = createResolver(import.meta.url)

    extendPages((pages) => {
      pages.unshift({
        name: 'prismic-preview',
        path: '/preview',
        file: resolve('runtime/preview.vue'),
      })
    })
  },
})
```

### Type

```ts
function extendPages (callback: (pages: NuxtPage[]) => void): void
```

### Parameters

**callback**: A function that will be called with the pages configuration. You can alter this array by adding, deleting, or modifying its elements. Note: You should modify the provided pages array directly, as changes made to a copied array will not be reflected in the configuration.

| Property   | Type                               | Required | Description                                                                                  |
| ---------- | ---------------------------------- | -------- | -------------------------------------------------------------------------------------------- |
| `name`     | `string`                           | `false`  | The name of the route. Useful for programmatic navigation and identifying routes.            |
| `path`     | `string`                           | `false`  | The route URL path. If not set, Nuxt will infer it from the file location.                   |
| `file`     | `string`                           | `false`  | Path to the Vue file that should be used as the component for the route.                     |
| `meta`     | `Record<string, any>`{lang="ts"}   | `false`  | Custom metadata for the route. Can be used in layouts, middlewares, or navigation guards.    |
| `alias`    | `string[] \| string`{lang="ts"}    | `false`  | One or more alias paths for the route. Useful for supporting multiple URLs.                  |
| `redirect` | `RouteLocationRaw`{lang="ts"}      | `false`  | Redirect rule for the route. Supports named routes, objects, or string paths.                |
| `children` | `NuxtPage[]`{lang="ts"}            | `false`  | Nested child routes under this route for layout or view nesting.                             |

## `extendRouteRules`

Nuxt is powered by the [Nitro](https://nitro.build/) server engine. With Nitro, you can incorporate high-level logic directly into your configuration, which is useful for actions like redirects, proxying, caching, and appending headers to routes. This configuration works by associating route patterns with specific route settings.

::tip
You can read more about Nitro route rules in the [Nitro documentation](https://nitro.build/guide/routing#route-rules).
::

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/adding-route-rules-and-route-middlewares?friend=nuxt" target="_blank"}
Watch Vue School video about adding route rules and route middelwares.
::

### Usage

```ts twoslash
import { createResolver, defineNuxtModule, extendPages, extendRouteRules } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    const { resolve } = createResolver(import.meta.url)

    extendPages((pages) => {
      pages.unshift({
        name: 'preview-new',
        path: '/preview-new',
        file: resolve('runtime/preview.vue'),
      })
    })

    extendRouteRules('/preview', {
      redirect: {
        to: '/preview-new',
        statusCode: 302,
      },
    })

    extendRouteRules('/preview-new', {
      cache: {
        maxAge: 60 * 60 * 24 * 7,
      },
    })
  },
})
```

### Type

```ts
function extendRouteRules (route: string, rule: NitroRouteConfig, options?: ExtendRouteRulesOptions): void
```

### Parameters

**route**: A route pattern to match against.\
**rule**: A route rule configuration to apply to the matched route.

::tip
About route rules configurations, you can get more detail in [Hybrid Rendering > Route Rules](/docs/4.x/guide/concepts/rendering#route-rules).
::

**options**: A object to pass to the route configuration. If `override` is set to `true`, it will override the existing route configuration.

| Name       | Type      | Default | Description                                  |
| ---------- | --------- | ------- | -------------------------------------------- |
| `override` | `boolean` | `false` | Override route rule config, default is false |

## `addRouteMiddleware`

Registers route middlewares to be available for all routes or for specific routes.

Route middlewares can be also defined in plugins via [`addRouteMiddleware`](/docs/4.x/api/utils/add-route-middleware) composable.

::tip
Read more about route middlewares in the [Route middleware documentation](/docs/4.x/getting-started/routing#route-middleware).
::

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/adding-route-rules-and-route-middlewares?friend=nuxt" target="_blank"}
Watch Vue School video about adding route rules and route middelwares.
::

### Usage

::code-group

```ts twoslash [module.ts]
import { addRouteMiddleware, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addRouteMiddleware({
      name: 'auth',
      path: resolve('runtime/auth'),
      global: true,
    }, { prepend: true })
  },
})
```

```ts twoslash [runtime/auth.ts]
function isAuthenticated (): boolean { return false }
// ---cut---
export default defineNuxtRouteMiddleware((to, from) => {
  // isAuthenticated() is an example method verifying if a user is authenticated
  if (to.path !== '/login' && isAuthenticated() === false) {
    return navigateTo('/login')
  }
})
```

::

### Type

```ts
function addRouteMiddleware (input: NuxtMiddleware | NuxtMiddleware[], options?: AddRouteMiddlewareOptions): void
```

### Parameters

**input**: A middleware object or an array of middleware objects with the following properties:

| Property | Type      | Required | Description                                         |
| -------- | --------- | -------- | --------------------------------------------------- |
| `name`   | `string`  | `true`   | The name of the middleware.                         |
| `path`   | `string`  | `true`   | The file path to the middleware.                    |
| `global` | `boolean` | `false`  | If set to `true`, applies middleware to all routes. |

**options**: An object with the following properties:

| Property   | Type      | Default | Description                                                 |
| ---------- | --------- | ------- | ----------------------------------------------------------- |
| `override` | `boolean` | `false` | If `true`, replaces middleware with the same name.          |
| `prepend`  | `boolean` | `false` | If `true`, prepends middleware before existing middlewares. |
</file>

<file path="docs/4.api/5.kit/8.layout.md">
---
title: "Layout"
description: "Nuxt Kit provides a set of utilities to help you work with layouts."
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/layout.ts
    size: xs
---

Layouts is used to be a wrapper around your pages. It can be used to wrap your pages with common components, for example, a header and a footer. Layouts can be registered using `addLayout` utility.

## `addLayout`

Register template as layout and add it to the layouts.

::note
In Nuxt 2 `error` layout can also be registered using this utility. In Nuxt 3+ `error` layout [replaced](/docs/4.x/getting-started/error-handling#error-page) with `error.vue` page in project root.
::

### Usage

```ts twoslash
import { addLayout, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addLayout({
      src: resolve('templates/custom-layout.ts'),
      filename: 'custom-layout.ts',
    }, 'custom')
  },
})
```

### Type

```ts
function addLayout (layout: NuxtTemplate | string, name: string): void
```

### Parameters

**`layout`**: A template object or a string with the path to the template. If a string is provided, it will be converted to a template object with `src` set to the string value. If a template object is provided, it must have the following properties:

| Property      | Type                                             | Required | Description                                                                                                                                                                      |
| ------------- | ------------------------------------------------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src`         | `string`                                         | `false`  | Path to the template. If `src` is not provided, `getContents` must be provided instead.                                                                                          |
| `filename`    | `string`                                         | `false`  | Filename of the template. If `filename` is not provided, it will be generated from the `src` path. In this case, the `src` option is required.                                   |
| `dst`         | `string`                                         | `false`  | Path to the destination file. If `dst` is not provided, it will be generated from the `filename` path and nuxt `buildDir` option.                                                |
| `options`     | `Record<string, any>`{lang="ts"}                 | `false`  | Options to pass to the template.                                                                                                                                                 |
| `getContents` | `(data) => string \| Promise<string>`{lang="ts"} | `false`  | A function that will be called with the `options` object. It should return a string or a promise that resolves to a string. If `src` is provided, this function will be ignored. |
| `write`       | `boolean`                                        | `false`  | If set to `true`, the template will be written to the destination file. Otherwise, the template will be used only in virtual filesystem.                                         |

**`name`**: The name to register the layout under (e.g., `default`, `custom`, etc.).

### Example

This will register a layout named `custom` that wraps pages with a header and footer.

```ts twoslash
import { addLayout, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    addLayout({
      write: true,
      filename: 'my-layout.vue',
      getContents: () => `<template>
  <div>
    <header>My Header</header>
    <slot />
    <footer>My Footer</footer>
  </div>
</template>`,
    }, 'custom')
  },
})
```

You can then use this layout in your pages:

```vue [app/pages/about.vue]
<script setup lang="ts">
definePageMeta({
  layout: 'custom',
})
</script>

<template>
  <div>About Page</div>
</template>
```

::warning
Due to the lack of support for virtual `.vue` files by `@vitejs/plugin-vue`, you can work around this limitation by passing `write: true` to the first argument of `addLayout`.
::
</file>

<file path="docs/4.api/5.kit/9.head.md">
---
title: Head
description: Nuxt Kit provides utilities to help you manage head configuration in modules.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/head.ts
    size: xs
---

## `setGlobalHead`

Sets global head configuration for your Nuxt application. This utility allows modules to programmatically configure meta tags, links, scripts, and other head elements that will be applied across all pages.

The provided head configuration will be merged with any existing head configuration using deep merging, with your provided values taking precedence.

::tip
This is particularly useful for modules that need to inject global meta tags, stylesheets, or scripts into the application head.
::

### Type

```ts twoslash
// @errors: 2391
// ---cut---
import type { SerializableHead } from '@unhead/vue/types'

interface AppHeadMetaObject extends SerializableHead {
  charset?: string
  viewport?: string
}

function setGlobalHead (head: AppHeadMetaObject): void
```

### Parameters

#### `head`

**Type**: `AppHeadMetaObject`

An object containing head configuration. All properties are optional and will be merged with existing configuration:

- `charset`: Character encoding for the document
- `viewport`: Viewport meta tag configuration
- `meta`: Array of meta tag objects
- `link`: Array of link tag objects (stylesheets, icons, etc.)
- `style`: Array of inline style tag objects
- `script`: Array of script tag objects
- `noscript`: Array of noscript tag objects
- `title`: Default page title
- `titleTemplate`: Template for formatting page titles
- `bodyAttrs`: Attributes to add to the `<body>` tag
- `htmlAttrs`: Attributes to add to the `<html>` tag

### Examples

#### Adding Global Meta Tags

```ts
import { defineNuxtModule, setGlobalHead } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    setGlobalHead({
      meta: [
        { name: 'theme-color', content: '#ffffff' },
        { name: 'author', content: 'Your Name' },
      ],
    })
  },
})
```

#### Injecting Global Stylesheets

```ts
import { defineNuxtModule, setGlobalHead } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    setGlobalHead({
      link: [
        {
          rel: 'stylesheet',
          href: 'https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap',
        },
      ],
    })
  },
})
```

#### Adding Global Scripts

```ts
import { defineNuxtModule, setGlobalHead } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    setGlobalHead({
      script: [
        {
          src: 'https://cdn.example.com/analytics.js',
          async: true,
          defer: true,
        },
      ],
    })
  },
})
```

#### Setting HTML Attributes

```ts
import { defineNuxtModule, setGlobalHead } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    setGlobalHead({
      htmlAttrs: {
        lang: 'en',
        dir: 'ltr',
      },
      bodyAttrs: {
        class: 'custom-body-class',
      },
    })
  },
})
```
</file>

<file path="docs/4.api/5.kit/9.plugins.md">
---
title: Plugins
description: Nuxt Kit provides a set of utilities to help you create and use plugins. You can add plugins or plugin templates to your module using these functions.
links:
  - label: Source
    icon: i-simple-icons-github
    to: https://github.com/nuxt/nuxt/blob/main/packages/kit/src/plugin.ts
    size: xs
---

Plugins are self-contained code that usually add app-level functionality to Vue. In Nuxt, plugins are automatically imported from the `app/plugins/` directory. However, if you need to ship a plugin with your module, Nuxt Kit provides the `addPlugin` and `addPluginTemplate` methods. These utils allow you to customize the plugin configuration to better suit your needs.

## `addPlugin`

Registers a Nuxt plugin and adds it to the plugins array.

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/injecting-plugins?friend=nuxt" target="_blank"}
Watch Vue School video about `addPlugin`.
::

### Usage

```ts twoslash
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addPlugin({
      src: resolve('runtime/plugin.js'),
      mode: 'client',
    })
  },
})
```

### Type

```ts
function addPlugin (plugin: NuxtPlugin | string, options?: AddPluginOptions): NuxtPlugin
```

### Parameters

**`plugin`**: A plugin object or a string with the path to the plugin. If a string is provided, it will be converted to a plugin object with `src` set to the string value.

If a plugin object is provided, it must have the following properties:

| Property | Type                                       | Required | Description                                                                                                                                                                                                                                                                                                                                                              |
| -------- | ------------------------------------------ | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `src`    | `string`                                   | `true`   | Path to the plugin file.                                                                                                                                                                                                                                                                                                                                                 |
| `mode`   | `'all' \| 'server' \| 'client'`{lang="ts"} | `false`  | If set to `'all'`, the plugin will be included in both client and server bundles. If set to `'server'`, the plugin will only be included in the server bundle. If set to `'client'`, the plugin will only be included in the client bundle. You can also use `.client` and `.server` modifiers when specifying `src` option to use plugin only in client or server side. |
| `order`  | `number`                                   | `false`  | Order of the plugin. This allows more granular control over plugin order and should only be used by advanced users. Lower numbers run first, and user plugins default to `0`. It's recommended to set `order` to a number between `-20` for `pre`-plugins (plugins that run before Nuxt plugins) and `20` for `post`-plugins (plugins that run after Nuxt plugins).      |

::warning
Avoid using `order` unless necessary. Use `append` if you simply need to register plugins after Nuxt defaults.
::

**`options`**: Optional object with the following properties:

| Property | Type      | Required | Description                                                                                                         |
| -------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------------- |
| `append` | `boolean` | `false`  | If `true`, the plugin will be appended to the plugins array. If `false`, it will be prepended. Defaults to `false`. |

### Examples

::code-group

```ts [module.ts]
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup () {
    const { resolve } = createResolver(import.meta.url)

    addPlugin({
      src: resolve('runtime/plugin.js'),
      mode: 'client',
    })
  },
})
```

```ts [runtime/plugin.ts]
export default defineNuxtPlugin((nuxtApp) => {
  const colorMode = useColorMode()

  nuxtApp.hook('app:mounted', () => {
    if (colorMode.preference !== 'dark') {
      colorMode.preference = 'dark'
    }
  })
})
```

::

## `addPluginTemplate`

Adds a template and registers as a nuxt plugin. This is useful for plugins that need to generate code at build time.

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/injecting-plugin-templates?friend=nuxt" target="_blank"}
Watch Vue School video about `addPluginTemplate`.
::

### Usage

```ts twoslash
import { addPluginTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options) {
    addPluginTemplate({
      filename: 'module-plugin.mjs',
      getContents: () => `import { defineNuxtPlugin } from '#app/nuxt'
export default defineNuxtPlugin({
  name: 'module-plugin',
  setup (nuxtApp) {
    ${options.log ? 'console.log("Plugin install")' : ''}
  }
})`,
    })
  },
})
```

### Type

```ts
function addPluginTemplate (pluginOptions: NuxtPluginTemplate, options?: AddPluginOptions): NuxtPlugin
```

### Parameters

**`pluginOptions`**: A plugin template object with the following properties:

| Property      | Type                                                                  | Required | Description                                                                                                                                                                                                                                                                                                                                                              |
| ------------- | --------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `src`         | `string`                                                              | `false`  | Path to the template. If `src` is not provided, `getContents` must be provided instead.                                                                                                                                                                                                                                                                                  |
| `filename`    | `string`                                                              | `false`  | Filename of the template. If `filename` is not provided, it will be generated from the `src` path. In this case, the `src` option is required.                                                                                                                                                                                                                           |
| `dst`         | `string`                                                              | `false`  | Path to the destination file. If `dst` is not provided, it will be generated from the `filename` path and nuxt `buildDir` option.                                                                                                                                                                                                                                        |
| `mode`        | `'all' \| 'server' \| 'client'`{lang="ts"}                            | `false`  | If set to `'all'`, the plugin will be included in both client and server bundles. If set to `'server'`, the plugin will only be included in the server bundle. If set to `'client'`, the plugin will only be included in the client bundle. You can also use `.client` and `.server` modifiers when specifying `src` option to use plugin only in client or server side. |
| `options`     | `Record<string, any>`{lang="ts"}                                      | `false`  | Options to pass to the template.                                                                                                                                                                                                                                                                                                                                         |
| `getContents` | `(data: Record<string, any>) => string \| Promise<string>`{lang="ts"} | `false`  | A function that will be called with the `options` object. It should return a string or a promise that resolves to a string. If `src` is provided, this function will be ignored.                                                                                                                                                                                         |
| `write`       | `boolean`                                                             | `false`  | If set to `true`, the template will be written to the destination file. Otherwise, the template will be used only in virtual filesystem.                                                                                                                                                                                                                                 |
| `order`       | `number`                                                              | `false`  | Order of the plugin. This allows more granular control over plugin order and should only be used by advanced users. Lower numbers run first, and user plugins default to `0`. It's recommended to set `order` to a number between `-20` for `pre`-plugins (plugins that run before Nuxt plugins) and `20` for `post`-plugins (plugins that run after Nuxt plugins).      |

::warning
Prefer using `getContents` for dynamic plugin generation. Avoid setting `order` unless necessary.
::

**`options`**: Optional object with the following properties:

| Property | Type      | Required | Description                                                                                                         |
| -------- | --------- | -------- | ------------------------------------------------------------------------------------------------------------------- |
| `append` | `boolean` | `false`  | If `true`, the plugin will be appended to the plugins array. If `false`, it will be prepended. Defaults to `false`. |

### Examples

#### Generate a plugin template with different options

Use `addPluginTemplate` when you need to generate plugin code dynamically at build time. This allows you to generate different plugin contents based on the options passed to it. For example, Nuxt internally uses this function to generate Vue app configurations.

```ts twoslash [module.ts]
import { addPluginTemplate, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (_, nuxt) {
    if (nuxt.options.vue.config && Object.values(nuxt.options.vue.config).some(v => v !== null && v !== undefined)) {
      addPluginTemplate({
        filename: 'vue-app-config.mjs',
        write: true,
        getContents: () => `import { defineNuxtPlugin } from '#app/nuxt'
export default defineNuxtPlugin({
  name: 'nuxt:vue-app-config',
  enforce: 'pre',
  setup (nuxtApp) {
    ${Object.keys(nuxt.options.vue.config!)
        .map(k => `nuxtApp.vueApp.config[${JSON.stringify(k)}] = ${JSON.stringify(nuxt.options.vue.config![k as 'idPrefix'])}`)
        .join('\n')
    }
  }
})`,
      })
    }
  },
})
```

This generates different plugin code depending on the provided configuration.

::code-group

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  vue: {
    config: {
      idPrefix: 'nuxt',
    },
  },
})
```

```ts [#build/vue-app-config.mjs]
import { defineNuxtPlugin } from '#app/nuxt'

export default defineNuxtPlugin({
  name: 'nuxt:vue-app-config',
  enforce: 'pre',
  setup (nuxtApp) {
    nuxtApp.vueApp.config.idPrefix = 'nuxt'
  },
})
```

::
</file>

<file path="docs/4.api/6.advanced/.navigation.yml">
icon: i-lucide-brain
</file>

<file path="docs/4.api/6.advanced/1.hooks.md">
---
title: 'Lifecycle Hooks'
description: Nuxt provides a powerful hooking system to expand almost every aspect using hooks.
---

:read-more{to="/docs/4.x/guide/going-further/hooks"}

## App Hooks (runtime)

Check the [app source code](https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts#L37) for all available hooks.

| Hook                         | Arguments           | Environment     | Description                                                                                                                                                                           |
|------------------------------|---------------------|-----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `app:created`                | `vueApp`            | Server & Client | Called when initial `vueApp` instance is created.                                                                                                                                     |
| `app:error`                  | `err`               | Server & Client | Called when a fatal error occurs.                                                                                                                                                     |
| `app:error:cleared`          | `{ redirect? }`     | Server & Client | Called when a fatal error occurs.                                                                                                                                                     |
| `vue:setup`                  | -                   | Server & Client | Called when the setup of Nuxt root is initialized. This callback must be synchronous.                                                                                                 |
| `vue:error`                  | `err, target, info` | Server & Client | Called when a vue error propagates to the root component. [Learn More](https://vuejs.org/api/composition-api-lifecycle#onerrorcaptured).                                              |
| `app:rendered`               | `renderContext`     | Server          | Called when SSR rendering is done.                                                                                                                                                    |
| `app:redirected`             | -                   | Server          | Called before SSR redirection.                                                                                                                                                        |
| `app:beforeMount`            | `vueApp`            | Client          | Called before mounting the app, called only on client side.                                                                                                                           |
| `app:mounted`                | `vueApp`            | Client          | Called when Vue app is initialized and mounted in browser.                                                                                                                            |
| `app:suspense:resolve`       | `appComponent`      | Client          | On [Suspense](https://vuejs.org/guide/built-ins/suspense#suspense) resolved event.                                                                                                    |
| `app:manifest:update`        | `{ id, timestamp }` | Client          | Called when there is a newer version of your app detected.                                                                                                                            |
| `app:data:refresh`           | `keys?`             | Client          | Called when `refreshNuxtData` is called.                                                                                                                                              |
| `link:prefetch`              | `to`                | Client          | Called when a `<NuxtLink>` is observed to be prefetched.                                                                                                                              |
| `page:start`                 | `pageComponent?`    | Client          | Called on [Suspense](https://vuejs.org/guide/built-ins/suspense#suspense) inside of `NuxtPage` pending event.                                                                         |
| `page:finish`                | `pageComponent?`    | Client          | Called on [Suspense](https://vuejs.org/guide/built-ins/suspense#suspense) inside of `NuxtPage` resolved event.                                                                        |
| `page:loading:start`         | -                   | Client          | Called when the `setup()` of the new page is running.                                                                                                                                 |
| `page:loading:end`           | -                   | Client          | Called after `page:finish`                                                                                                                                                            |
| `page:transition:finish`     | `pageComponent?`    | Client          | After page transition [onAfterLeave](https://vuejs.org/guide/built-ins/transition#javascript-hooks) event.                                                                            |
| `dev:ssr-logs`               | `logs`              | Client          | Called with an array of server-side logs that have been passed to the client (if `features.devLogs` is enabled).                                                                      |
| `page:view-transition:start` | `transition`        | Client          | Called after `document.startViewTransition` is called when [experimental viewTransition support is enabled](/docs/4.x/getting-started/transitions#view-transitions-api-experimental). |

## Nuxt Hooks (build time)

Check the [schema source code](https://github.com/nuxt/nuxt/blob/main/packages/schema/src/types/hooks.ts#L83) for all available hooks.

| Hook                        | Arguments                                                | Description                                                                                                                                                                                                                                                                                  |
|-----------------------------|----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `kit:compatibility`         | `compatibility, issues`                                  | Allows extending compatibility checks.                                                                                                                                                                                                                                                       |
| `ready`                     | `nuxt`                                                   | Called after Nuxt initialization, when the Nuxt instance is ready to work.                                                                                                                                                                                                                   |
| `close`                     | `nuxt`                                                   | Called when Nuxt instance is gracefully closing.                                                                                                                                                                                                                                             |
| `restart`                   | `{ hard?: boolean }`                                     | To be called to restart the current Nuxt instance.                                                                                                                                                                                                                                           |
| `modules:before`            | -                                                        | Called during Nuxt initialization, before installing user modules.                                                                                                                                                                                                                           |
| `modules:done`              | -                                                        | Called during Nuxt initialization, after installing user modules.                                                                                                                                                                                                                            |
| `app:resolve`               | `app`                                                    | Called after resolving the `app` instance.                                                                                                                                                                                                                                                   |
| `app:templates`             | `app`                                                    | Called during `NuxtApp` generation, to allow customizing, modifying or adding new files to the build directory (either virtually or to written to `.nuxt`).                                                                                                                                  |
| `app:templatesGenerated`    | `app`                                                    | Called after templates are compiled into the [virtual file system](/docs/4.x/directory-structure/nuxt) (vfs).                                                                                                                                                                                |
| `build:before`              | -                                                        | Called before Nuxt bundle builder.                                                                                                                                                                                                                                                           |
| `build:done`                | -                                                        | Called after Nuxt bundle builder is complete.                                                                                                                                                                                                                                                |
| `build:manifest`            | `manifest`                                               | Called during the manifest build by Vite and webpack. This allows customizing the manifest that Nitro will use to render `<script>` and `<link>` tags in the final HTML.                                                                                                                     |
| `builder:generateApp`       | `options`                                                | Called before generating the app.                                                                                                                                                                                                                                                            |
| `builder:watch`             | `event, path`                                            | Called at build time in development when the watcher spots a change to a file or directory in the project.                                                                                                                                                                                   |
| `pages:extend`              | `pages`                                                  | Called after page routes are scanned from the file system.                                                                                                                                                                                                                                   |
| `pages:resolved`            | `pages`                                                  | Called after page routes have been augmented with scanned metadata.                                                                                                                                                                                                                          |
| `pages:routerOptions`       | `{ files: Array<{ path: string, optional?: boolean }> }` | Called when resolving `router.options` files. Later items in the array override earlier ones.                                                                                                                                                                                                |
| `server:devHandler`         | `handler`                                                | Called when the dev middleware is being registered on the Nitro dev server.                                                                                                                                                                                                                  |
| `imports:sources`           | `presets`                                                | Called at setup allowing modules to extend sources.                                                                                                                                                                                                                                          |
| `imports:extend`            | `imports`                                                | Called at setup allowing modules to extend imports.                                                                                                                                                                                                                                          |
| `imports:context`           | `context`                                                | Called when the [unimport](https://github.com/unjs/unimport) context is created.                                                                                                                                                                                                             |
| `imports:dirs`              | `dirs`                                                   | Allows extending import directories.                                                                                                                                                                                                                                                         |
| `components:dirs`           | `dirs`                                                   | Called within `app:resolve` allowing to extend the directories that are scanned for auto-importable components.                                                                                                                                                                              |
| `components:extend`         | `components`                                             | Allows extending new components.                                                                                                                                                                                                                                                             |
| `nitro:config`              | `nitroConfig`                                            | Called before initializing Nitro, allowing customization of Nitro's configuration.                                                                                                                                                                                                           |
| `nitro:init`                | `nitro`                                                  | Called after Nitro is initialized, which allows registering Nitro hooks and interacting directly with Nitro.                                                                                                                                                                                 |
| `nitro:build:before`        | `nitro`                                                  | Called before building the Nitro instance.                                                                                                                                                                                                                                                   |
| `nitro:build:public-assets` | `nitro`                                                  | Called after copying public assets. Allows modifying public assets before Nitro server is built.                                                                                                                                                                                             |
| `prerender:routes`          | `ctx`                                                    | Allows extending the routes to be pre-rendered.                                                                                                                                                                                                                                              |
| `build:error`               | `error`                                                  | Called when an error occurs at build time.                                                                                                                                                                                                                                                   |
| `prepare:types`             | `options`                                                | Called before `@nuxt/cli` writes TypeScript configuration files (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, etc.) and `.nuxt/nuxt.d.ts`, allowing addition of custom references and declarations in `nuxt.d.ts`, or directly modifying the options in generated configurations |
| `listen`                    | `listenerServer, listener`                               | Called when the dev server is loading.                                                                                                                                                                                                                                                       |
| `schema:extend`             | `schemas`                                                | Allows extending default schemas.                                                                                                                                                                                                                                                            |
| `schema:resolved`           | `schema`                                                 | Allows extending resolved schema.                                                                                                                                                                                                                                                            |
| `schema:beforeWrite`        | `schema`                                                 | Called before writing the given schema.                                                                                                                                                                                                                                                      |
| `schema:written`            | -                                                        | Called after the schema is written.                                                                                                                                                                                                                                                          |
| `vite:extend`               | `viteBuildContext`                                       | Allows extending Vite default context.                                                                                                                                                                                                                                                       |
| `vite:extendConfig`         | `viteInlineConfig, env`                                  | Allows extending Vite default config. **Deprecated in Nuxt 5+.** In Nuxt 5, this operates on a shared configuration rather than separate client/server configs.                                                                                                                              |
| `vite:configResolved`       | `viteInlineConfig, env`                                  | Allows reading the resolved Vite config. **Deprecated in Nuxt 5+.** In Nuxt 5, this operates on a shared configuration rather than separate client/server configs.                                                                                                                           |
| `vite:serverCreated`        | `viteServer, env`                                        | Called when the Vite server is created.                                                                                                                                                                                                                                                      |
| `vite:compiled`             | -                                                        | Called after Vite server is compiled.                                                                                                                                                                                                                                                        |
| `webpack:config`            | `webpackConfigs`                                         | Called before configuring the webpack compiler.                                                                                                                                                                                                                                              |
| `webpack:configResolved`    | `webpackConfigs`                                         | Allows reading the resolved webpack config.                                                                                                                                                                                                                                                  |
| `webpack:compile`           | `options`                                                | Called right before compilation.                                                                                                                                                                                                                                                             |
| `webpack:compiled`          | `options`                                                | Called after resources are loaded.                                                                                                                                                                                                                                                           |
| `webpack:change`            | `shortPath`                                              | Called on `change` on WebpackBar.                                                                                                                                                                                                                                                            |
| `webpack:error`             | -                                                        | Called on `done` if has errors on WebpackBar.                                                                                                                                                                                                                                                |
| `webpack:done`              | -                                                        | Called on `allDone` on WebpackBar.                                                                                                                                                                                                                                                           |
| `webpack:progress`          | `statesArray`                                            | Called on `progress` on WebpackBar.                                                                                                                                                                                                                                                          |

## Nitro App Hooks (runtime, server-side)

See [Nitro](https://nitro.build/guide/plugins#available-hooks) for all available hooks.

| Hook              | Arguments                                  | Description                                 | Types                                                                                                                                                                                                                                                                                                                                                                                                   |
|-------------------|--------------------------------------------|---------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `dev:ssr-logs`    | `{ path, logs }`                           | Server                                      | Called at the end of a request cycle with an array of server-side logs.                                                                                                                                                                                                                                                                                                                                 |
| `render:response` | `response, { event }`                      | Called before sending the response.         | [response](https://github.com/nuxt/nuxt/blob/71ef8bd3ff207fd51c2ca18d5a8c7140476780c7/packages/nuxt/src/core/runtime/nitro/renderer.ts#L24), [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38)                                                                                                                                                         |
| `render:html`     | `html, { event }`                          | Called before constructing the HTML.        | [html](https://github.com/nuxt/nuxt/blob/71ef8bd3ff207fd51c2ca18d5a8c7140476780c7/packages/nuxt/src/core/runtime/nitro/renderer.ts#L15), [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38)                                                                                                                                                             |
| `render:island`   | `islandResponse, { event, islandContext }` | Called before constructing the island HTML. | [islandResponse](https://github.com/nuxt/nuxt/blob/e50cabfed1984c341af0d0c056a325a8aec26980/packages/nuxt/src/core/runtime/nitro/renderer.ts#L28), [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38), [islandContext](https://github.com/nuxt/nuxt/blob/e50cabfed1984c341af0d0c056a325a8aec26980/packages/nuxt/src/core/runtime/nitro/renderer.ts#L38) |
| `close`           | -                                          | Called when Nitro is closed.                | -                                                                                                                                                                                                                                                                                                                                                                                                       |
| `error`           | `error, { event? }`                        | Called when an error occurs.                | [error](https://github.com/nitrojs/nitro/blob/d20ffcbd16fc4003b774445e1a01e698c2bb078a/src/types/runtime/nitro.ts#L48), [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38)                                                                                                                                                                              |
| `request`         | `event`                                    | Called when a request is received.          | [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38)                                                                                                                                                                                                                                                                                                      |
| `beforeResponse`  | `event, { body }`                          | Called before sending the response.         | [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38), unknown                                                                                                                                                                                                                                                                                             |
| `afterResponse`   | `event, { body }`                          | Called after sending the response.          | [event](https://github.com/h3js/h3/blob/f6ceb5581043dc4d8b6eab91e9be4531e0c30f8e/src/types.ts#L38), unknown                                                                                                                                                                                                                                                                                             |
</file>

<file path="docs/4.api/6.advanced/2.import-meta.md">
---
title: 'Import meta'
description: Understand where your code is running using `import.meta`.
---

## The `import.meta` object

With ES modules you can obtain some metadata from the code that imports or compiles your ES-module.
This is done through `import.meta`, which is an object that provides your code with this information.
Throughout the Nuxt documentation you may see snippets that use this already to figure out whether the
code is currently running on the client or server side.

::read-more{to="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta"}
Read more about `import.meta`.
::

## Runtime (App) Properties

These values are statically injected and can be used for tree-shaking your runtime code.

Property | Type | Description
--- | --- | ---
`import.meta.client` | boolean | True when evaluated on the client side.
`import.meta.browser` | boolean | True when evaluated on the client side.
`import.meta.server` | boolean | True when evaluated on the server side.
`import.meta.nitro` | boolean | True when evaluated on the server side.
`import.meta.dev` | boolean | True when running the Nuxt dev server.
`import.meta.test` | boolean | True when running in a test context.
`import.meta.prerender` | boolean | True when rendering HTML on the server in the prerender stage of your build.

## Builder Properties

These values are available both in modules and in your `nuxt.config`.

Property | Type | Description
--- | --- | ---
`import.meta.env` | object | Equals `process.env`
`import.meta.url` | string | Resolvable path for the current file.

## Examples

### Using `import.meta.url` to resolve files within modules

```ts [modules/my-module/index.ts]
import { createResolver } from 'nuxt/kit'

// Resolve relative from the current file
const resolver = createResolver(import.meta.url)

export default defineNuxtModule({
  meta: { name: 'myModule' },
  setup () {
    addComponent({
      name: 'MyModuleComponent',
      // Resolves to '/modules/my-module/components/MyModuleComponent.vue'
      filePath: resolver.resolve('./components/MyModuleComponent.vue'),
    })
  },
})
```
</file>

<file path="docs/4.api/.navigation.yml">
title: API
titleTemplate: '%s · Nuxt API'
icon: i-lucide-code-xml
</file>

<file path="docs/4.api/6.nuxt-config.md">
---
title: Nuxt Configuration
titleTemplate: '%s'
description: Discover all the options you can use in your nuxt.config.ts file.
navigation.icon: i-lucide-cog
---

## alias

You can improve your DX by defining additional aliases to access custom directories within your JavaScript and CSS.

- **Type**: `object`
- **Default**
```json
{
  "~": "/<srcDir>",
  "@": "/<srcDir>",
  "~~": "/<rootDir>",
  "@@": "/<rootDir>",
  "#shared": "/<rootDir>/shared",
  "assets": "/<srcDir>/assets",
  "public": "/<rootDir>/public",
  "#build": "/<rootDir>/.nuxt",
  "#internal/nuxt/paths": "/<rootDir>/.nuxt/paths.mjs"
}
```

::callout
**Note**: Within a webpack context (image sources, CSS - but not JavaScript) you _must_ access
your alias by prefixing it with `~`.
::

::callout
<!-- @case-police-ignore tsConfig -->
**Note**: These aliases will be automatically added to the generated TypeScript configurations (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, etc.) so you can get full type support and path auto-complete. In case you need to extend options provided by the generated configurations further, make sure to add them here or within the `typescript.tsConfig` property in `nuxt.config`.
::

**Example**:
```ts
import { fileURLToPath } from 'node:url'

export default defineNuxtConfig({
  alias: {
    'images': fileURLToPath(new URL('./assets/images', import.meta.url)),
    'style': fileURLToPath(new URL('./assets/style', import.meta.url)),
    'data': fileURLToPath(new URL('./assets/other/data', import.meta.url)),
  },
})
```

```html
<template>
  <img src="~images/main-bg.jpg">
</template>

<script>
import data from 'data/test.json'
</script>

<style>
// Uncomment the below
//@import '~style/variables.scss';
//@import '~style/utils.scss';
//@import '~style/base.scss';
body {
  background-image: url('~images/main-bg.jpg');
}
</style>
```

## analyzeDir

The directory where Nuxt will store the generated files when running `nuxt analyze`.

If a relative path is specified, it will be relative to your `rootDir`.

- **Type**: `string`
- **Default:** `"/<rootDir>/.nuxt/analyze"`

## app

Nuxt App configuration.

### `baseURL`

The base path of your Nuxt application.

For example:

- **Type**: `string`
- **Default:** `"/"`

**Example**:
```ts
export default defineNuxtConfig({
  app: {
    baseURL: '/prefix/',
  },
})
```

This can also be set at runtime by setting the NUXT_APP_BASE_URL environment variable.

**Example**:
```bash
NUXT_APP_BASE_URL=/prefix/ node .output/server/index.mjs
```

### `buildAssetsDir`

The folder name for the built site assets, relative to `baseURL` (or `cdnURL` if set). This is set at build time and should not be customized at runtime.

- **Type**: `string`
- **Default:** `"/_nuxt/"`

### `cdnURL`

An absolute URL to serve the public folder from (production-only).

For example:

- **Type**: `string`
- **Default:** `""`

**Example**:
```ts
export default defineNuxtConfig({
  app: {
    cdnURL: 'https://mycdn.org/',
  },
})
```

This can be set to a different value at runtime by setting the `NUXT_APP_CDN_URL` environment variable.

**Example**:
```bash
NUXT_APP_CDN_URL=https://mycdn.org/ node .output/server/index.mjs
```

### `head`

Set default configuration for `<head>` on every page.

- **Type**: `object`
- **Default**
```json
{
  "meta": [
    {
      "name": "viewport",
      "content": "width=device-width, initial-scale=1"
    },
    {
      "charset": "utf-8"
    }
  ],
  "link": [],
  "style": [],
  "script": [],
  "noscript": []
}
```

**Example**:
```ts
export default defineNuxtConfig({
  app: {
    head: {
      meta: [
      // <meta name="viewport" content="width=device-width, initial-scale=1">
        { name: 'viewport', content: 'width=device-width, initial-scale=1' },
      ],
      script: [
      // <script src="https://myawesome-lib.js"></script>
        { src: 'https://awesome-lib.js' },
      ],
      link: [
      // <link rel="stylesheet" href="https://myawesome-lib.css">
        { rel: 'stylesheet', href: 'https://awesome-lib.css' },
      ],
      // please note that this is an area that is likely to change
      style: [
      // <style>:root { color: red }</style>
        { textContent: ':root { color: red }' },
      ],
      noscript: [
      // <noscript>JavaScript is required</noscript>
        { textContent: 'JavaScript is required' },
      ],
    },
  },
})
```

### `keepalive`

Default values for KeepAlive configuration between pages.

This can be overridden with `definePageMeta` on an individual page. Only JSON-serializable values are allowed.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Vue KeepAlive](https://vuejs.org/api/built-in-components#keepalive)

### `layoutTransition`

Default values for layout transitions.

This can be overridden with `definePageMeta` on an individual page. Only JSON-serializable values are allowed.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Vue Transition docs](https://vuejs.org/api/built-in-components#transition)

### `pageTransition`

Default values for page transitions.

This can be overridden with `definePageMeta` on an individual page. Only JSON-serializable values are allowed.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Vue Transition docs](https://vuejs.org/api/built-in-components#transition)

### `rootAttrs`

Customize Nuxt root element id.

- **Type**: `object`
- **Default**
```json
{
  "id": "__nuxt"
}
```

### `rootId`

Customize Nuxt root element id.

- **Type**: `string`
- **Default:** `"__nuxt"`

### `rootTag`

Customize Nuxt root element tag.

- **Type**: `string`
- **Default:** `"div"`

### `spaLoaderAttrs`

Customize Nuxt SPA loading template element attributes.

- **Type**: `object`
- **Default:**
```json
{
"id": "__nuxt-loader"
}
```

#### `id`

- **Type**: `string`
- **Default:** `"__nuxt-loader"`

### `spaLoaderTag`

Customize Nuxt SpaLoader element tag.

- **Type**: `string`
- **Default:** `"div"`

### `teleportAttrs`

Customize Nuxt Teleport element attributes.

- **Type**: `object`
- **Default**
```json
{
  "id": "teleports"
}
```

### `teleportId`

Customize Nuxt Teleport element id.

- **Type**: `string`
- **Default:** `"teleports"`

### `teleportTag`

Customize Nuxt Teleport element tag.

- **Type**: `string`
- **Default:** `"div"`

### `viewTransition`

Default values for view transitions.

This only has an effect when **experimental** support for View Transitions is [enabled in your nuxt.config file](/docs/4.x/getting-started/transitions#view-transitions-api-experimental).
This can be overridden with `definePageMeta` on an individual page.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Nuxt View Transition API docs](https://nuxt.com/docs/4.x/getting-started/transitions#view-transitions-api-experimental)

## appConfig

Additional app configuration

For programmatic usage and type support, you can directly provide app config with this option. It will be merged with `app.config` file as default value.

### `nuxt`

## appId

For multi-app projects, the unique id of the Nuxt application.

Defaults to `nuxt-app`.

- **Type**: `string`
- **Default:** `"nuxt-app"`

## build

Shared build configuration.

### `analyze`

Nuxt allows visualizing your bundles and how to optimize them.

Set to `true` to enable bundle analysis, or pass an object with options: [for webpack](https://github.com/webpack/webpack-bundle-analyzer#options-for-plugin) or [for vite](https://github.com/btd/rollup-plugin-visualizer#options).

- **Type**: `object`
- **Default**
```json
{
  "template": "treemap",
  "projectRoot": "/<rootDir>",
  "filename": "/<rootDir>/.nuxt/analyze/{name}.html"
}
```

**Example**:
```ts
export default defineNuxtConfig({
  analyze: {
    analyzerMode: 'static',
  },
})
```

### `templates`

It is recommended to use `addTemplate` from `@nuxt/kit` instead of this option.

- **Type**: `array`

**Example**:
```ts
export default defineNuxtConfig({
  build: {
    templates: [
      {
        src: '~/modules/support/plugin.js', // `src` can be absolute or relative
        dst: 'support.js', // `dst` is relative to project `.nuxt` dir
      },
    ],
  },
})
```

### `transpile`

If you want to transpile specific dependencies with Babel, you can add them here. Each item in transpile can be a package name, a function, a string or regex object matching the dependency's file name.

You can also use a function to conditionally transpile. The function will receive an object ({ isDev, isServer, isClient, isModern, isLegacy }).

- **Type**: `array`

**Example**:
```ts
export default defineNuxtConfig({
  build: {
    transpile: [({ isLegacy }) => isLegacy && 'ky'],
  },
})
```

## buildDir

Define the directory where your built Nuxt files will be placed.

Many tools assume that `.nuxt` is a hidden directory (because it starts with a `.`). If that is a problem, you can use this option to prevent that.

- **Type**: `string`
- **Default:** `"/<rootDir>/.nuxt"`

**Example**:
```ts
export default defineNuxtConfig({
  buildDir: 'nuxt-build',
})
```

## buildId

A unique identifier matching the build. This may contain the hash of the current state of the project.

- **Type**: `string`
- **Default:** `"4a2e2d30-418f-41df-8e58-ed5df06de7fd"`

## builder

The builder to use for bundling the Vue part of your application.

Nuxt supports multiple builders for the client-side application. By default, Vite is used, but you can switch to webpack, Rspack, or even provide a custom builder implementation.

- **Type**: `'vite' | 'webpack' | 'rspack' | string | { bundle: (nuxt: Nuxt) => Promise<void> }`
- **Default:** `"@nuxt/vite-builder"`

**Using supported builders:**

```ts
export default defineNuxtConfig({
  // default - uses @nuxt/vite-builder
  // builder: 'vite',

  // uses @nuxt/webpack-builder
  // builder: 'webpack',

  // uses @nuxt/rspack-builder
  builder: 'rspack',
})
```

If you are using `webpack` or `rspack` you will need to make sure `@nuxt/webpack-builder` or `@nuxt/rspack-builder` is explicitly installed in your project.

**Using a custom builder object:**

You can provide a custom builder by passing an object with a `bundle` function:

```ts
export default defineNuxtConfig({
  builder: {
    async bundle (nuxt) {
      const entry = await resolvePath(resolve(nuxt.options.appDir, 'entry'))

      // Build client and server bundles
      await buildClient(nuxt, entry)
      if (nuxt.options.ssr) {
        await buildServer(nuxt, entry)
      }

      // ... it's a bit more complicated than that, of course!
    },
  },
})
```

**Creating a custom builder package:**

To create a custom builder as a separate package, it should export a `bundle` function. You can then specify the package name in your `nuxt.config.ts`:

```ts
export default defineNuxtConfig({
  builder: 'my-custom-builder',
})
```

## compatibilityDate

Specify a compatibility date for your app.

This is used to control the behavior of presets in Nitro, Nuxt Image and other modules that may change behavior without a major version bump.
We plan to improve the tooling around this feature in the future.

## components

Configure Nuxt component auto-registration.

Any components in the directories configured here can be used throughout your pages, layouts (and other components) without needing to explicitly import them.

- **Type**: `object`
- **Default**
```json
{
  "dirs": [
    {
      "path": "~/components/global",
      "global": true
    },
    "~/components"
  ]
}
```

**See**: [`app/components/` directory documentation](https://nuxt.com/docs/4.x/directory-structure/app/components)

## css

You can define the CSS files/modules/libraries you want to set globally (included in every page).

Nuxt will automatically guess the file type by its extension and use the appropriate pre-processor. You will still need to install the required loader if you need to use them.

- **Type**: `array`

**Example**:
```ts
export default defineNuxtConfig({
  css: [
  // Load a Node.js module directly (here it's a Sass file).
    'bulma',
    // CSS file in the project
    '~/assets/css/main.css',
    // SCSS file in the project
    '~/assets/css/main.scss',
  ],
})
```

## debug

Set to `true` to enable debug mode.

At the moment, it prints out hook names and timings on the server, and logs hook arguments as well in the browser.
You can also set this to an object to enable specific debug options.

- **Type**: `boolean`
- **Default:** `false`

## dev

Whether Nuxt is running in development mode.

Normally, you should not need to set this.

- **Type**: `boolean`
- **Default:** `false`

## devServer

### `cors`

Set CORS options for the dev server

#### `origin`

- **Type**: `array`
- **Default**
```json
[
  {}
]
```

### `host`

Dev server listening host

### `https`

Whether to enable HTTPS.

- **Type**: `boolean`
- **Default:** `false`

**Example**:
```ts
export default defineNuxtConfig({
  devServer: {
    https: {
      key: './server.key',
      cert: './server.crt',
    },
  },
})
```

### `loadingTemplate`

Template to show a loading screen

- **Type**: `function`

### `port`

Dev server listening port

- **Type**: `number`
- **Default:** `3000`

### `url`

Listening dev server URL.

This should not be set directly as it will always be overridden by the dev server with the full URL (for module and internal use).

- **Type**: `string`
- **Default:** `"http://localhost:3000"`

## devServerHandlers

Nitro development-only server handlers.

- **Type**: `array`

**See**: [Nitro server routes documentation](https://nitro.build/guide/routing)

## devtools

Enable Nuxt DevTools for development.

Breaking changes for devtools might not reflect on the version of Nuxt.

**See**:  [Nuxt DevTools](https://devtools.nuxt.com/) for more information.

## dir

Customize default directory structure used by Nuxt.

It is better to stick with defaults unless needed.

### `app`

- **Type**: `string`
- **Default:** `"app"`

### `assets`

The assets directory (aliased as `~assets` in your build).

- **Type**: `string`
- **Default:** `"app/assets"`

### `layouts`

The layouts directory, each file of which will be auto-registered as a Nuxt layout.

- **Type**: `string`
- **Default:** `"app/layouts"`

### `middleware`

The middleware directory, each file of which will be auto-registered as a Nuxt middleware.

- **Type**: `string`
- **Default:** `"app/middleware"`

### `modules`

The modules directory, each file in which will be auto-registered as a Nuxt module.

- **Type**: `string`
- **Default:** `"modules"`

### `pages`

The directory which will be processed to auto-generate your application page routes.

- **Type**: `string`
- **Default:** `"app/pages"`

### `plugins`

The plugins directory, each file of which will be auto-registered as a Nuxt plugin.

- **Type**: `string`
- **Default:** `"app/plugins"`

### `public`

The directory containing your static files, which will be directly accessible via the Nuxt server and copied across into your `dist` folder when your app is generated.

- **Type**: `string`
- **Default:** `"public"`

### `shared`

The shared directory. This directory is shared between the app and the server.

- **Type**: `string`
- **Default:** `"shared"`

## esbuild

### `options`

Configure shared esbuild options used within Nuxt and passed to other builders, such as Vite or webpack.

#### `jsxFactory`

- **Type**: `string`
- **Default:** `"h"`

#### `jsxFragment`

- **Type**: `string`
- **Default:** `"Fragment"`

#### `target`

- **Type**: `string`
- **Default:** `"esnext"`

#### `tsconfigRaw`

- **Type**: `object`

## experimental

::read-more{to="/docs/4.x/guide/going-further/experimental-features"}
Learn more about Nuxt's experimental features.
::

## extends

Extend project from multiple local or remote sources.

Value should be either a string or array of strings pointing to source directories or config path relative to current config.
You can use `github:`, `gh:` `gitlab:` or `bitbucket:`

**See**: [`c12` docs on extending config layers](https://github.com/unjs/c12#extending-config-layer-from-remote-sources)

**See**: [`giget` documentation](https://github.com/unjs/giget)

## extensions

The extensions that should be resolved by the Nuxt resolver.

- **Type**: `array`
- **Default**
```json
[
  ".js",
  ".jsx",
  ".mjs",
  ".ts",
  ".tsx",
  ".vue"
]
```

## features

::read-more{to="/docs/4.x/guide/going-further/features#features"}
Learn more about Nuxt's opt-in features.
::

## future

::read-more{to="/docs/4.x/guide/going-further/features#features"}
Learn more about opting-in to new features that will become default in a future (possibly major) version of the framework.
::

## hooks

Hooks are listeners to Nuxt events that are typically used in modules, but are also available in `nuxt.config`.

Internally, hooks follow a naming pattern using colons (e.g., build:done).
For ease of configuration, you can also structure them as an hierarchical object in `nuxt.config` (as below).

**Example**:
```ts
import fs from 'node:fs'
import path from 'node:path'

export default defineNuxtConfig({
  hooks: {
    build: {
      done (builder) {
        const extraFilePath = path.join(
          builder.nuxt.options.buildDir,
          'extra-file',
        )
        fs.writeFileSync(extraFilePath, 'Something extra')
      },
    },
  },
})
```

## ignore

More customizable than `ignorePrefix`: all files matching glob patterns specified inside the `ignore` array will be ignored in building.

- **Type**: `array`
- **Default**
```json
[
  "**/*.stories.{js,cts,mts,ts,jsx,tsx}",
  "**/*.{spec,test}.{js,cts,mts,ts,jsx,tsx}",
  "**/*.d.{cts,mts,ts}",
  "**/*.d.vue.{cts,mts,ts}",
  "**/.{pnpm-store,vercel,netlify,output,git,cache,data}",
  "**/*.sock",
  ".nuxt/analyze",
  ".nuxt",
  "**/-*.*"
]
```

## ignoreOptions

Pass options directly to `node-ignore` (which is used by Nuxt to ignore files).

**See**: [node-ignore](https://github.com/kaelzhang/node-ignore)

**Example**:
```ts
export default defineNuxtConfig({
  ignoreOptions: {
    ignorecase: false,
  },
})
```

## ignorePrefix

Any file in `app/pages/`, `app/layouts/`, `app/middleware/`, and `public/` directories will be ignored during the build process if its filename starts with the prefix specified by `ignorePrefix`. This is intended to prevent certain files from being processed or served in the built application. By default, the `ignorePrefix` is set to '-', ignoring any files starting with '-'.

- **Type**: `string`
- **Default:** `"-"`

## imports

Configure how Nuxt auto-imports composables into your application.

**See**: [Nuxt documentation](https://nuxt.com/docs/4.x/directory-structure/app/composables)

### `dirs`

An array of custom directories that will be auto-imported. Note that this option will not override the default directories (~/composables, ~/utils).

- **Type**: `array`

**Example**:
```ts
export default defineNuxtConfig({
  imports: {
  // Auto-import pinia stores defined in `~/stores`
    dirs: ['stores'],
  },
})
```

### `global`

- **Type**: `boolean`
- **Default:** `false`

### `scan`

Whether to scan your `app/composables/` and `app/utils/` directories for composables to auto-import. Auto-imports registered by Nuxt or other modules, such as imports from `vue` or `nuxt`, will still be enabled.

- **Type**: `boolean`
- **Default:** `true`

## logLevel

Log level when building logs.

Defaults to 'silent' when running in CI or when a TTY is not available. This option is then used as 'silent' in Vite and 'none' in webpack

- **Type**: `string`
- **Default:** `"info"`

## modules

Modules are Nuxt extensions which can extend its core functionality and add endless integrations.

Each module is either a string (which can refer to a package, or be a path to a file), a tuple with the module as first string and the options as a second object, or an inline module function.
Nuxt tries to resolve each item in the modules array using node require path (in `node_modules`) and then will be resolved from project `srcDir` if `~` alias is used.

- **Type**: `array`

::callout
**Note**: Modules are executed sequentially so the order is important. First, the modules defined in `nuxt.config.ts` are loaded. Then, modules found in the `modules/`
directory are executed, and they load in alphabetical order.
::

**Example**:
```ts
export default defineNuxtConfig({
  modules: [
  // Using package name
    '@nuxt/scripts',
    // Relative to your project srcDir
    '~/custom-modules/awesome.js',
    // Providing options
    ['@nuxtjs/google-analytics', { ua: 'X1234567' }],
    // Inline definition
    function () {},
  ],
})
```

## modulesDir

Used to set the modules directories for path resolving (for example, webpack's `resolveLoading`, `nodeExternals` and `postcss`).

The configuration path is relative to `options.rootDir` (default is current working directory).
Setting this field may be necessary if your project is organized as a yarn workspace-styled mono-repository.

- **Type**: `array`
- **Default**
```json
[
  "/<rootDir>/node_modules"
]
```

**Example**:
```ts
export default defineNuxtConfig({
  modulesDir: ['../../node_modules'],
})
```

## nitro

Configuration for Nitro.

**See**: [Nitro configuration docs](https://nitro.build/config)

### `routeRules`

- **Type**: `object`

### `runtimeConfig`

- **Type**: `object`
- **Default**
```json
{
  "public": {},
  "app": {
    "buildId": "4a2e2d30-418f-41df-8e58-ed5df06de7fd",
    "baseURL": "/",
    "buildAssetsDir": "/_nuxt/",
    "cdnURL": ""
  },
  "nitro": {
    "envPrefix": "NUXT_"
  }
}
```

## optimization

Build time optimization configuration.

### `asyncTransforms`

Options passed directly to the transformer from `unctx` that preserves async context after `await`.

#### `asyncFunctions`

- **Type**: `array`
- **Default**
```json
[
  "defineNuxtPlugin",
  "defineNuxtRouteMiddleware"
]
```

#### `objectDefinitions`

##### `defineNuxtComponent`

- **Type**: `array`
- **Default**
```json
[
  "asyncData",
  "setup"
]
```

##### `defineNuxtPlugin`

- **Type**: `array`
- **Default**
```json
[
  "setup"
]
```

##### `definePageMeta`

- **Type**: `array`
- **Default**
```json
[
  "middleware",
  "validate"
]
```

### `keyedComposables`

Functions to inject a key for.

As long as the number of arguments passed to the function is less than `argumentLength`, an additional magic string will be injected that can be used to deduplicate requests between server and client. You will need to take steps to handle this additional key.
The key will be unique based on the location of the function being invoked within the file.

- **Type**: `array`
- **Default**
```json
[
  {
    "name": "callOnce",
    "argumentLength": 3
  },
  {
    "name": "defineNuxtComponent",
    "argumentLength": 2
  },
  {
    "name": "useState",
    "argumentLength": 2
  },
  {
    "name": "useFetch",
    "argumentLength": 3
  },
  {
    "name": "useAsyncData",
    "argumentLength": 3
  },
  {
    "name": "useLazyAsyncData",
    "argumentLength": 3
  },
  {
    "name": "useLazyFetch",
    "argumentLength": 3
  }
]
```

### `treeShake`

Tree shake code from specific builds.

#### `composables`

Tree shake composables from the server or client builds.

**Example**:
```ts
export default defineNuxtConfig({
  optimization: {
    treeShake: {
      composables: {
        client: { vue: ['onMounted'] },
        server: { vue: ['onServerPrefetch'] },
      },
    },
  },
})
```

##### `client`

- **Type**: `object`
- **Default**
```json
{
  "vue": [
    "onRenderTracked",
    "onRenderTriggered",
    "onServerPrefetch"
  ],
  "#app": [
    "definePayloadReducer",
    "definePageMeta",
    "onPrehydrate"
  ]
}
```

##### `server`

- **Type**: `object`
- **Default**
```json
{
  "vue": [
    "onMounted",
    "onUpdated",
    "onUnmounted",
    "onBeforeMount",
    "onBeforeUpdate",
    "onBeforeUnmount",
    "onRenderTracked",
    "onRenderTriggered",
    "onActivated",
    "onDeactivated"
  ],
  "#app": [
    "definePayloadReviver",
    "definePageMeta"
  ]
}
```

## pages

Whether to use the vue-router integration in Nuxt 3. If you do not provide a value it will be enabled if you have a `app/pages/` directory in your source folder.

Additionally, you can provide a glob pattern or an array of patterns to scan only certain files for pages.

**Example**:
```ts
export default defineNuxtConfig({
  pages: {
    pattern: ['**/*/*.vue', '!**/*.spec.*'],
  },
})
```

## plugins

An array of nuxt app plugins.

Each plugin can be a string (which can be an absolute or relative path to a file). If it ends with `.client` or `.server` then it will be automatically loaded only in the appropriate context.
It can also be an object with `src` and `mode` keys.

- **Type**: `array`

::callout
**Note**: Plugins are also auto-registered from the `~/plugins` directory
and these plugins do not need to be listed in `nuxt.config` unless you
need to customize their order. All plugins are deduplicated by their src path.
::

**See**: [`app/plugins/` directory documentation](https://nuxt.com/docs/4.x/directory-structure/app/plugins)

**Example**:
```ts
export default defineNuxtConfig({
  plugins: [
    '~/custom-plugins/foo.client.js', // only in client side
    '~/custom-plugins/bar.server.js', // only in server side
    '~/custom-plugins/baz.js', // both client & server
    { src: '~/custom-plugins/both-sides.js' },
    { src: '~/custom-plugins/client-only.js', mode: 'client' }, // only on client side
    { src: '~/custom-plugins/server-only.js', mode: 'server' }, // only on server side
  ],
})
```

## postcss

### `order`

A strategy for ordering PostCSS plugins.

- **Type**: `function`

### `plugins`

Options for configuring PostCSS plugins.

**See**: [PostCSS docs](https://postcss.org/)

#### `autoprefixer`

Plugin to parse CSS and add vendor prefixes to CSS rules.

**See**: [`autoprefixer`](https://github.com/postcss/autoprefixer)

#### `cssnano`

- **Type**: `object`

**See**: [`cssnano` configuration options](https://cssnano.github.io/cssnano/docs/config-file/#configuration-options)

## rootDir

Define the root directory of your application.

This property can be overwritten (for example, running `nuxt ./my-app/` will set the `rootDir` to the absolute path of `./my-app/` from the current/working directory.
It is normally not needed to configure this option.

- **Type**: `string`
- **Default:** `"/<rootDir>"`

## routeRules

Global route options applied to matching server routes.

**Experimental**: This is an experimental feature and API may change in the future.

**See**: [Nitro route rules documentation](https://nitro.build/config#routerules)

## router

### `options`

Additional router options passed to `vue-router`. On top of the options for `vue-router`, Nuxt offers additional options to customize the router (see below).

::callout
**Note**: Only JSON serializable options should be passed by Nuxt config.
For more control, you can use an `router.options.ts` file.
::

**See**: [Vue Router documentation](https://router.vuejs.org/api/interfaces/routeroptions)

#### `hashMode`

You can enable hash history in SPA mode. In this mode, router uses a hash character (#) before the actual URL that is internally passed. When enabled, the **URL is never sent to the server** and **SSR is not supported**.

- **Type**: `boolean`
- **Default:** `false`

**Default**: false

#### `scrollBehaviorType`

Customize the scroll behavior for hash links.

- **Type**: `string`
- **Default:** `"auto"`

**Default**: 'auto'

## runtimeConfig

Runtime config allows passing dynamic config and environment variables to the Nuxt app context.

The value of this object is accessible from server only using `useRuntimeConfig`.
It mainly should hold _private_ configuration which is not exposed on the frontend. This could include a reference to your API secret tokens.
Anything under `public` and `app` will be exposed to the frontend as well.
Values are automatically replaced by matching env variables at runtime, e.g. setting an environment variable `NUXT_API_KEY=my-api-key NUXT_PUBLIC_BASE_URL=/foo/` would overwrite the two values in the example below.

- **Type**: `object`
- **Default**
```json
{
  "public": {},
  "app": {
    "buildId": "4a2e2d30-418f-41df-8e58-ed5df06de7fd",
    "baseURL": "/",
    "buildAssetsDir": "/_nuxt/",
    "cdnURL": ""
  }
}
```

**Example**:
```ts
export default defineNuxtConfig({
  runtimeConfig: {
    apiKey: '', // Default to an empty string, automatically set at runtime using process.env.NUXT_API_KEY
    public: {
      baseURL: '', // Exposed to the frontend as well.
    },
  },
})
```

## server

Configuration for Nuxt's server builder.

### `builder`

Specify the server builder to use for bundling the server part of your application.

By default, Nuxt uses `@nuxt/nitro-server`, which provides standalone Nitro integration. This architecture allows for different Nitro integration patterns, such as using Nitro as a Vite plugin (with the Vite Environment API).

- **Type**: `string | { bundle: (nuxt: Nuxt) => Promise<void> }`
- **Default:** `"@nuxt/nitro-server"`

::callout{type="warning"}
This option is intended for internal use and the API is not finalized. Please open an issue before relying on the current implementation.
::

## serverDir

Define the server directory of your Nuxt application, where Nitro routes, middleware and plugins are kept.

If a relative path is specified, it will be relative to your `rootDir`.

- **Type**: `string`
- **Default:** `"/<srcDir>/server"`

## serverHandlers

Nitro server handlers.

Each handler accepts the following options:
- handler: The path to the file defining the handler. - route: The route under which the handler is available. This follows the conventions of [rou3](https://github.com/h3js/rou3). - method: The HTTP method of requests that should be handled. - middleware: Specifies whether it is a middleware handler. - lazy: Specifies whether to use lazy loading to import the handler.

- **Type**: `array`

**See**: [`server/` directory documentation](https://nuxt.com/docs/4.x/directory-structure/server)

::callout
**Note**: Files from `server/api`, `server/middleware` and `server/routes` will be automatically registered by Nuxt.
::

**Example**:
```ts
export default defineNuxtConfig({
  serverHandlers: [
    { route: '/path/foo/**:name', handler: '~/server/foohandler.ts' },
  ],
})
```

## sourcemap

Configures whether and how sourcemaps are generated for server and/or client bundles.

If set to a single boolean, that value applies to both server and client. Additionally, the `'hidden'` option is also available for both server and client.
Available options for both client and server: - `true`: Generates sourcemaps and includes source references in the final bundle. - `false`: Does not generate any sourcemaps. - `'hidden'`: Generates sourcemaps but does not include references in the final bundle.

- **Type**: `object`
- **Default**
```json
{
  "server": true,
  "client": false
}
```

## spaLoadingTemplate

Boolean or a path to an HTML file with the contents of which will be inserted into any HTML page rendered with `ssr: false`.

- If it is unset, it will use `~/spa-loading-template.html` file in one of your layers, if it exists. - If it is false, no SPA loading indicator will be loaded. - If true, Nuxt will look for `~/spa-loading-template.html` file in one of your layers, or a
  default Nuxt image will be used.
Some good sources for spinners are [SpinKit](https://github.com/tobiasahlin/SpinKit) or [SVG Spinners](https://icones.js.org/collection/svg-spinners).

- **Default:** `null`

**Example**: ~/spa-loading-template.html
```html
<!-- https://github.com/barelyhuman/snips/blob/dev/pages/css-loader.md -->
<div class="loader"></div>
<style>
.loader {
  display: block;
  position: fixed;
  z-index: 1031;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 18px;
  height: 18px;
  box-sizing: border-box;
  border: solid 2px transparent;
  border-top-color: #000;
  border-left-color: #000;
  border-bottom-color: #efefef;
  border-right-color: #efefef;
  border-radius: 50%;
  -webkit-animation: loader 400ms linear infinite;
  animation: loader 400ms linear infinite;
}

@-webkit-keyframes loader {
  0% {
    -webkit-transform: translate(-50%, -50%) rotate(0deg);
  }
  100% {
    -webkit-transform: translate(-50%, -50%) rotate(360deg);
  }
}
@keyframes loader {
  0% {
    transform: translate(-50%, -50%) rotate(0deg);
  }
  100% {
    transform: translate(-50%, -50%) rotate(360deg);
  }
}
</style>
```

## srcDir

Define the source directory of your Nuxt application.

If a relative path is specified, it will be relative to the `rootDir`.

- **Type**: `string`
- **Default:** `"app"` (Nuxt 4), `"."` (Nuxt 3 with `compatibilityMode: 3`)

**Example**:
```ts
export default defineNuxtConfig({
  srcDir: 'app/',
})
```
This expects the following folder structure:
```bash
-| app/
---| assets/
---| components/
---| layouts/
---| middleware/
---| pages/
---| plugins/
---| app.config.ts
---| app.vue
---| error.vue
-| server/
-| public/
-| modules/
-| nuxt.config.js
-| package.json
```

## ssr

Whether to enable rendering of HTML - either dynamically (in server mode) or at generate time. If set to `false` generated pages will have no content.

- **Type**: `boolean`
- **Default:** `true`

## telemetry

Manually disable nuxt telemetry.

**See**: [Nuxt Telemetry](https://github.com/nuxt/telemetry) for more information.

## test

Whether your app is being unit tested.

- **Type**: `boolean`
- **Default:** `false`

## theme

Extend project from a local or remote source.

Value should be a string pointing to source directory or config path relative to current config.
You can use `github:`, `gitlab:`, `bitbucket:` or `https://` to extend from a remote git repository.

- **Type**: `string`

## typescript

Configuration for Nuxt's TypeScript integration.

### `builder`

Which builder types to include for your project.

By default Nuxt infers this based on your `builder` option (defaulting to 'vite') but you can either turn off builder environment types (with `false`) to handle this fully yourself, or opt for a 'shared' option.
The 'shared' option is advised for module authors, who will want to support multiple possible builders.

- **Default:** `null`

### `hoist`

Modules to generate deep aliases for within `compilerOptions.paths`. This does not yet support subpaths. It may be necessary when using Nuxt within a pnpm monorepo with `shamefully-hoist=false`.

- **Type**: `array`
- **Default**
```json
[
  "nitropack/types",
  "nitropack/runtime",
  "nitropack",
  "defu",
  "h3",
  "consola",
  "ofetch",
  "@unhead/vue",
  "@nuxt/devtools",
  "vue",
  "@vue/runtime-core",
  "@vue/compiler-sfc",
  "vue-router",
  "vue-router/auto-routes",
  "unplugin-vue-router/client",
  "@nuxt/schema",
  "nuxt"
]
```

### `includeWorkspace`

Include parent workspace in the Nuxt project. Mostly useful for themes and module authors.

- **Type**: `boolean`
- **Default:** `false`

### `shim`

Generate a `*.vue` shim.

We recommend instead letting the [official Vue extension](https://marketplace.visualstudio.com/items?itemName=Vue.volar) generate accurate types for your components.
Note that you may wish to set this to `true` if you are using other libraries, such as ESLint, that are unable to understand the type of `.vue` files.

- **Type**: `boolean`
- **Default:** `false`

### `strict`

TypeScript comes with certain checks to give you more safety and analysis of your program. Once you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety. [Read More](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-stricter-checks)

- **Type**: `boolean`
- **Default:** `true`

<!-- @case-police-ignore tsConfig -->

### `tsConfig`

You can extend the generated TypeScript configurations (`.nuxt/tsconfig.app.json`, `.nuxt/tsconfig.server.json`, etc.) using this option.

### `typeCheck`

Enable build-time type checking.

If set to true, this will type check in development. You can restrict this to build-time type checking by setting it to `build`. Requires to install `typescript` and `vue-tsc` as dev dependencies.

- **Type**: `boolean`
- **Default:** `false`

**See**: [Nuxt TypeScript docs](https://nuxt.com/docs/4.x/guide/concepts/typescript)

## unhead

An object that allows us to configure the `unhead` nuxt module.

### `legacy`

Enable the legacy compatibility mode for `unhead` module. This applies the following changes: - Disables Capo.js sorting - Adds the `DeprecationsPlugin`: supports `hid`, `vmid`, `children`, `body` - Adds the `PromisesPlugin`: supports promises as input

- **Type**: `boolean`
- **Default:** `false`

**See**: [`unhead` migration documentation](https://unhead.unjs.io/docs/typescript/head/guides/get-started/migration)

**Example**:
```ts
export default defineNuxtConfig({
  unhead: {
    legacy: true,
  },
})
```

### `renderSSRHeadOptions`

An object that will be passed to `renderSSRHead` to customize the output.

- **Type**: `object`
- **Default**
```json
{
  "omitLineBreaks": false
}
```

**Example**:
```ts
export default defineNuxtConfig({
  unhead: {
    renderSSRHeadOptions: {
      omitLineBreaks: true,
    },
  },
})
```

## vite

Configuration that will be passed directly to Vite.

**See**: [Vite configuration docs](https://vite.dev/config/) for more information.
Please note that not all vite options are supported in Nuxt.

### `build`

#### `assetsDir`

- **Type**: `string`
- **Default:** `"_nuxt/"`

#### `emptyOutDir`

- **Type**: `boolean`
- **Default:** `false`

### `cacheDir`

- **Type**: `string`
- **Default:** `"/<rootDir>/node_modules/.cache/vite"`

### `clearScreen`

- **Type**: `boolean`
- **Default:** `true`

### `define`

- **Type**: `object`
- **Default**
```json
{
  "__VUE_PROD_HYDRATION_MISMATCH_DETAILS__": false,
  "process.dev": false,
  "import.meta.dev": false,
  "process.test": false,
  "import.meta.test": false
}
```

### `esbuild`

- **Type**: `object`
- **Default**
```json
{
  "target": "esnext",
  "jsxFactory": "h",
  "jsxFragment": "Fragment",
  "tsconfigRaw": {}
}
```

### `mode`

- **Type**: `string`
- **Default:** `"production"`

### `optimizeDeps`

#### `esbuildOptions`

- **Type**: `object`
- **Default**
```json
{
  "target": "esnext",
  "jsxFactory": "h",
  "jsxFragment": "Fragment",
  "tsconfigRaw": {}
}
```

#### `exclude`

- **Type**: `array`
- **Default**
```json
[
  "vue-demi"
]
```

### `publicDir`

### `resolve`

#### `extensions`

- **Type**: `array`
- **Default**
```json
[
  ".mjs",
  ".js",
  ".ts",
  ".jsx",
  ".tsx",
  ".json",
  ".vue"
]
```

### `root`

- **Type**: `string`
- **Default:** `"/<srcDir>"`

### `server`

#### `fs`

##### `allow`

- **Type**: `array`
- **Default**
```json
[
  "/<rootDir>/.nuxt",
  "/<srcDir>",
  "/<rootDir>",
  "/<workspaceDir>"
]
```

### `vue`

#### `features`

##### `propsDestructure`

- **Type**: `boolean`
- **Default:** `true`

#### `isProduction`

- **Type**: `boolean`
- **Default:** `true`

#### `script`

##### `hoistStatic`

#### `template`

##### `compilerOptions`

- **Type**: `object`

##### `transformAssetUrls`

- **Type**: `object`
- **Default**
```json
{
  "video": [
    "src",
    "poster"
  ],
  "source": [
    "src"
  ],
  "img": [
    "src"
  ],
  "image": [
    "xlink:href",
    "href"
  ],
  "use": [
    "xlink:href",
    "href"
  ]
}
```

### `vueJsx`

- **Type**: `object`
- **Default**
```json
{
  "isCustomElement": {
    "$schema": {
      "title": "",
      "description": "",
      "tags": []
    }
  }
}
```

## vue

Vue.js config

### `compilerOptions`

Options for the Vue compiler that will be passed at build time.

**See**: [Vue documentation](https://vuejs.org/api/application#app-config-compileroptions)

### `config`

It is possible to pass configure the Vue app globally. Only serializable options may be set in your `nuxt.config`. All other options should be set at runtime in a Nuxt plugin.

**See**: [Vue app config documentation](https://vuejs.org/api/application#app-config)

### `propsDestructure`

Enable reactive destructure for `defineProps`

- **Type**: `boolean`
- **Default:** `true`

### `runtimeCompiler`

Include Vue compiler in runtime bundle.

- **Type**: `boolean`
- **Default:** `false`

### `transformAssetUrls`

#### `image`

- **Type**: `array`
- **Default**
```json
[
  "xlink:href",
  "href"
]
```

#### `img`

- **Type**: `array`
- **Default**
```json
[
  "src"
]
```

#### `source`

- **Type**: `array`
- **Default**
```json
[
  "src"
]
```

#### `use`

- **Type**: `array`
- **Default**
```json
[
  "xlink:href",
  "href"
]
```

#### `video`

- **Type**: `array`
- **Default**
```json
[
  "src",
  "poster"
]
```

## watch

The watch property lets you define patterns that will restart the Nuxt dev server when changed.

It is an array of strings or regular expressions. Strings should be either absolute paths or relative to the `srcDir` (and the `srcDir` of any layers). Regular expressions will be matched against the path relative to the project `srcDir` (and the `srcDir` of any layers).

- **Type**: `array`

## watchers

The watchers property lets you overwrite watchers configuration in your `nuxt.config`.

### `chokidar`

Options to pass directly to `chokidar`.

**See**: [chokidar](https://github.com/paulmillr/chokidar#api)

#### `ignoreInitial`

- **Type**: `boolean`
- **Default:** `true`

#### `ignorePermissionErrors`

- **Type**: `boolean`
- **Default:** `true`

### `rewatchOnRawEvents`

An array of event types, which, when received, will cause the watcher to restart.

### `webpack`

`watchOptions` to pass directly to webpack.

**See**: [webpack@4 watch options](https://v4.webpack.js.org/configuration/watch/#watchoptions).

#### `aggregateTimeout`

- **Type**: `number`
- **Default:** `1000`

## webpack

### `aggressiveCodeRemoval`

Hard-replaces `typeof process`, `typeof window` and `typeof document` to tree-shake bundle.

- **Type**: `boolean`
- **Default:** `false`

### `analyze`

If you are using webpack, Nuxt uses `webpack-bundle-analyzer` to visualize your bundles and how to optimize them.

Set to `true` to enable bundle analysis, or pass an object with options: [for webpack](https://github.com/webpack/webpack-bundle-analyzer#options-for-plugin) or [for vite](https://github.com/btd/rollup-plugin-visualizer#options).

- **Type**: `object`
- **Default**
```json
{
  "template": "treemap",
  "projectRoot": "/<rootDir>",
  "filename": "/<rootDir>/.nuxt/analyze/{name}.html"
}
```

**Example**:
```ts
export default defineNuxtConfig({
  webpack: {
    analyze: {
      analyzerMode: 'static',
    },
  },
})
```

### `cssSourceMap`

Enables CSS source map support (defaults to `true` in development).

- **Type**: `boolean`
- **Default:** `false`

### `devMiddleware`

See [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware) for available options.

#### `stats`

- **Type**: `string`
- **Default:** `"none"`

### `experiments`

Configure [webpack experiments](https://webpack.js.org/configuration/experiments/)

### `extractCSS`

Enables Common CSS Extraction.

Using [mini-css-extract-plugin](https://github.com/webpack/mini-css-extract-plugin) under the hood, your CSS will be extracted into separate files, usually one per component. This allows caching your CSS and JavaScript separately.

- **Type**: `boolean`
- **Default:** `true`

**Example**:
```ts
export default defineNuxtConfig({
  webpack: {
    extractCSS: true,
    // or
    extractCSS: {
      ignoreOrder: true,
    },
  },
})
```

If you want to extract all your CSS to a single file, there is a workaround for this.
However, note that it is not recommended to extract everything into a single file.
Extracting into multiple CSS files is better for caching and preload isolation. It
can also improve page performance by downloading and resolving only those resources
that are needed.

**Example**:
```ts
export default defineNuxtConfig({
  webpack: {
    extractCSS: true,
    optimization: {
      splitChunks: {
        cacheGroups: {
          styles: {
            name: 'styles',
            test: /\.(css|vue)$/,
            chunks: 'all',
            enforce: true,
          },
        },
      },
    },
  },
})
```

### `filenames`

Customize bundle filenames.

To understand a bit more about the use of manifests, take a look at [webpack documentation](https://webpack.js.org/guides/code-splitting/).

::callout
**Note**: Be careful when using non-hashed based filenames in production
as most browsers will cache the asset and not detect the changes on first load.
::

This example changes fancy chunk names to numerical ids:

**Example**:
```ts
export default defineNuxtConfig({
  webpack: {
    filenames: {
      chunk: ({ isDev }) => (isDev ? '[name].js' : '[id].[contenthash].js'),
    },
  },
})
```

#### `app`

- **Type**: `function`

#### `chunk`

- **Type**: `function`

#### `css`

- **Type**: `function`

#### `font`

- **Type**: `function`

#### `img`

- **Type**: `function`

#### `video`

- **Type**: `function`

### `friendlyErrors`

Set to `false` to disable the overlay provided by [FriendlyErrorsWebpackPlugin](https://github.com/nuxt/friendly-errors-webpack-plugin).

- **Type**: `boolean`
- **Default:** `true`

### `hotMiddleware`

See [webpack-hot-middleware](https://github.com/webpack/webpack-hot-middleware) for available options.

### `loaders`

Customize the options of Nuxt's integrated webpack loaders.

#### `css`

See [css-loader](https://github.com/webpack/css-loader) for available options.

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `importLoaders`

- **Type**: `number`
- **Default:** `0`

##### `url`

###### `filter`

- **Type**: `function`

#### `cssModules`

See [css-loader](https://github.com/webpack/css-loader) for available options.

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `importLoaders`

- **Type**: `number`
- **Default:** `0`

##### `modules`

###### `localIdentName`

- **Type**: `string`
- **Default:** `"[local]_[hash:base64:5]"`

##### `url`

###### `filter`

- **Type**: `function`

#### `esbuild`

- **Type**: `object`
- **Default**
```json
{
  "target": "esnext",
  "jsxFactory": "h",
  "jsxFragment": "Fragment",
  "tsconfigRaw": {}
}
```

**See**: [esbuild loader](https://github.com/privatenumber/esbuild-loader)

#### `file`

**See**: [`file-loader` Options](https://github.com/webpack/file-loader#options)

**Default**:
```json
{ "esModule": false }
```

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `limit`

- **Type**: `number`
- **Default:** `1000`

#### `fontUrl`

**See**: [`file-loader` Options](https://github.com/webpack/file-loader#options)

**Default**:
```json
{ "esModule": false }
```

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `limit`

- **Type**: `number`
- **Default:** `1000`

#### `imgUrl`

**See**: [`file-loader` Options](https://github.com/webpack/file-loader#options)

**Default**:
```json
{ "esModule": false }
```

##### `esModule`

- **Type**: `boolean`
- **Default:** `false`

##### `limit`

- **Type**: `number`
- **Default:** `1000`

#### `less`

- **Default**
```json
{
  "sourceMap": false
}
```

**See**: [`less-loader` Options](https://github.com/webpack/less-loader#options)

#### `pugPlain`

**See**: [`pug` options](https://pugjs.org/api/reference.html#options)

#### `sass`

**See**: [`sass-loader` Options](https://github.com/webpack/sass-loader#options)

**Default**:
```json
{
  "sassOptions": {
    "indentedSyntax": true
  }
}
```

##### `sassOptions`

###### `indentedSyntax`

- **Type**: `boolean`
- **Default:** `true`

#### `scss`

- **Default**
```json
{
  "sourceMap": false
}
```

**See**: [`sass-loader` Options](https://github.com/webpack/sass-loader#options)

#### `stylus`

- **Default**
```json
{
  "sourceMap": false
}
```

**See**: [`stylus-loader` Options](https://github.com/webpack/stylus-loader#options)

#### `vue`

See [vue-loader](https://github.com/vuejs/vue-loader) for available options.

##### `compilerOptions`

- **Type**: `object`

##### `propsDestructure`

- **Type**: `boolean`
- **Default:** `true`

##### `transformAssetUrls`

- **Type**: `object`
- **Default**
```json
{
  "video": [
    "src",
    "poster"
  ],
  "source": [
    "src"
  ],
  "img": [
    "src"
  ],
  "image": [
    "xlink:href",
    "href"
  ],
  "use": [
    "xlink:href",
    "href"
  ]
}
```

#### `vueStyle`

- **Default**
```json
{
  "sourceMap": false
}
```

### `optimization`

Configure [webpack optimization](https://webpack.js.org/configuration/optimization/).

#### `minimize`

Set minimize to `false` to disable all minimizers. (It is disabled in development by default).

- **Type**: `boolean`
- **Default:** `true`

#### `minimizer`

You can set minimizer to a customized array of plugins.

#### `runtimeChunk`

- **Type**: `string`
- **Default:** `"single"`

#### `splitChunks`

##### `automaticNameDelimiter`

- **Type**: `string`
- **Default:** `"/"`

##### `cacheGroups`

##### `chunks`

- **Type**: `string`
- **Default:** `"all"`

### `optimizeCSS`

OptimizeCSSAssets plugin options.

Defaults to true when `extractCSS` is enabled.

- **Type**: `boolean`
- **Default:** `false`

**See**: [css-minimizer-webpack-plugin documentation](https://github.com/webpack/css-minimizer-webpack-plugin).

### `plugins`

Add webpack plugins.

- **Type**: `array`

**Example**:
```ts
import webpack from 'webpack'
import { version } from './package.json'

export default defineNuxtConfig({
  webpack: {
    plugins: [
      // ...
      new webpack.DefinePlugin({
        'process.VERSION': version,
      }),
    ],
  },
})
```

### `postcss`

Customize PostCSS Loader. same options as [`postcss-loader` options](https://github.com/webpack/postcss-loader#options)

#### `postcssOptions`

##### `plugins`

- **Type**: `object`
- **Default**
```json
{
  "autoprefixer": {},
  "cssnano": {}
}
```

### `profile`

Enable the profiler in webpackbar.

It is normally enabled by CLI argument `--profile`.

- **Type**: `boolean`
- **Default:** `false`

**See**: [webpackbar](https://github.com/unjs/webpackbar#profile).

### `serverURLPolyfill`

The polyfill library to load to provide URL and URLSearchParams.

Defaults to `'url'` ([see package](https://www.npmjs.com/package/url)).

- **Type**: `string`
- **Default:** `"url"`

### `warningIgnoreFilters`

Filters to hide build warnings.

- **Type**: `array`

## workspaceDir

Define the workspace directory of your application.

Often this is used when in a monorepo setup. Nuxt will attempt to detect your workspace directory automatically, but you can override it here.
It is normally not needed to configure this option.

- **Type**: `string`
- **Default:** `"/<workspaceDir>"`
</file>

<file path="docs/4.api/index.md">
---
title: 'Nuxt API Reference'
titleTemplate: '%s'
description: 'Explore all Nuxt Internals: Components, Composables, Utils, Commands and more.'
navigation: false
surround: false
---

::card-group
  ::card{icon="i-lucide-box" title="Components" to="/docs/4.x/api/components/client-only"}
  Explore Nuxt built-in components for pages, layouts, head, and more.
  ::
  ::card{icon="i-lucide-arrow-left-right" title="Composables" to="/docs/4.x/api/composables/use-app-config"}
  Discover Nuxt composable functions for data-fetching, head management and more.
  ::
  ::card{icon="i-lucide-square-function" title="Utils" to="/docs/4.x/api/utils/dollarfetch"}
  Learn about Nuxt utility functions for navigation, error handling and more.
  ::
  ::card{icon="i-lucide-square-terminal" title="Commands" to="/docs/4.x/api/commands/add"}
  List of Nuxt CLI commands to init, analyze, build, and preview your application.
  ::
  ::card{icon="i-lucide-package" title="Nuxt Kit" to="/docs/4.x/api/kit/modules"}
  Understand Nuxt Kit utilities to create modules and control Nuxt.
  ::
  ::card{icon="i-lucide-brain" title="Advanced" to="/docs/4.x/api/advanced/hooks"}
  Go deep in Nuxt internals with Nuxt lifecycle hooks.
  ::
  ::card{icon="i-lucide-cog" title="Nuxt Configuration" to="/docs/4.x/api/nuxt-config"}
  Explore all Nuxt configuration options to customize your application.
  ::
::
</file>

<file path="docs/5.community/.navigation.yml">
title: 'Community'
titleTemplate: '%s · Nuxt Community'
icon: i-lucide-messages-square
</file>

<file path="docs/5.community/2.getting-help.md">
---
title: Getting Help
description: We're a friendly community of developers and we'd love to help.
navigation:
  icon: i-lucide-life-buoy
---

At some point, you may find that there's an issue you need some help with.

But don't worry! We're a friendly community of developers and we'd love to help.

::card-group
  ::card{icon="i-simple-icons-discord" title="Discord" to="https://go.nuxt.com/discord" target="_blank"}
  Get real-time help, exchange with the core team and the community, and stay updated on the latest Nuxt news.
  ::
  ::card{icon="i-simple-icons-nuxt" title="Nuxters" to="https://nuxters.nuxt.com" target="_blank"}
  Connect with other Nuxt enthusiasts.
  ::
::

## "I can't figure out how to (...)."

You've read through these docs and you think it should be possible, but it's not clear how. The best thing is to [open a GitHub Discussion](https://github.com/nuxt/nuxt/discussions).

Please don't feel embarrassed about asking a question that you think is easy - we've all been there! ❤️

Everyone you'll encounter is helping out because they care, not because they are paid to do so. The kindest thing to do is make it easy for them to help you. Here are some ideas:

- _Explain what your objective is, not just the problem you're facing._ "I need to ensure my form inputs are accessible, so I'm trying to get the ids to match between server and client."
- _Make sure you've first read the docs and used your favorite search engine_. Let people know by saying something like "I've Googled for 'nuxt script setup' but I couldn't find code examples anywhere."
- _Explain what you've tried._ Tell people the kind of solutions you've experimented with, and why. Often this can make people's advice more relevant to your situation.
- _Share your code._ People probably won't be able to help if they just see an error message or a screenshot - but that all changes if you share your code in a copy/pasteable format - preferably in the form of a minimal reproduction like a CodeSandbox.

And finally, just ask the question! There's no need to [ask permission to ask a question](https://dontasktoask.com) or [wait for someone to reply to your 'hello'](https://www.nohello.com). If you do, you might not get a response because people are waiting for the whole question before engaging.

## "Could there be a bug?"

Something isn't working the way that the docs say that it should. You're not sure if it's a bug. You've searched through the [open issues](https://github.com/nuxt/nuxt/issues) and [discussions](https://github.com/nuxt/nuxt/discussions) but you can't find anything. (if there is a closed issue, please create a new one)

We recommend taking a look at [how to report bugs](/docs/4.x/community/reporting-bugs). Nuxt is still in active development, and every issue helps make it better.

## "I need professional help"

If the community couldn't provide the help you need in the time-frame you have, NuxtLabs offers professional support with the [Nuxt Experts](https://nuxt.com/enterprise/support).

The objective of the Nuxt Expert is to provide support to the Vue ecosystem, while also creating freelance opportunities for those contributing to open-source solutions, thus helping to maintain the sustainability of the ecosystem.

The Nuxt experts are Vue, Nuxt and Vite chosen contributors providing professional support and consulting services.
</file>

<file path="docs/5.community/3.reporting-bugs.md">
---
title: 'Reporting Bugs'
description: 'One of the most valuable roles in open source is taking the time to report bugs helpfully.'
navigation.icon: i-lucide-bug
---

Try as we might, we will never completely eliminate bugs.

Even if you can't fix the underlying code, reporting a bug well can enable someone else with a bit more familiarity with the codebase to spot a pattern or make a quick fix.

Here are a few key steps.

## Is It Really a Bug?

Consider if you're looking to get help with something, or whether you think there's a bug with Nuxt itself. If it's the former, we'd love to help you - but the best way to do that is through [asking for help](/docs/4.x/community/getting-help) rather than reporting a bug.

## Search the Issues

Search through the [open issues](https://github.com/nuxt/nuxt/issues) and [discussions](https://github.com/nuxt/nuxt/discussions) first. If you find anything that seems like the same bug, it's much better to comment on an existing thread than create a duplicate.

## Create a Minimal Reproduction

It's important to be able to reproduce the bug reliably - in a minimal way and apart from the rest of your project. This narrows down what could be causing the issue and makes it possible for someone not only to find the cause, but also to test a potential solution.

Start with the Nuxt sandbox and add the **minimum** amount of code necessary to reproduce the bug you're experiencing.

::note
If your issue concerns Vue or Vite, please try to reproduce it first with the Vue SSR starter.
::

**Nuxt**:

::card-group
  :card{title="Nuxt on StackBlitz" icon="i-simple-icons-stackblitz" to="https://nuxt.new/s/v4" target="_blank"}
  :card{title="Nuxt on CodeSandbox" icon="i-simple-icons-codesandbox" to="https://nuxt.new/c/v4" target="_blank"}
::

**Vue**:

::card-group
  :card{title="Vue SSR on StackBlitz" icon="i-simple-icons-stackblitz" to="https://stackblitz.com/github/nuxt-contrib/vue3-ssr-starter/tree/main?terminal=dev" target="_blank"}
  :card{title="Vue SSR on CodeSandbox" icon="i-simple-icons-codesandbox" to="https://codesandbox.io/p/sandbox/github/nuxt-contrib/vue3-ssr-starter/main" target="_blank"}
  :card{title="Vue SSR Template on GitHub" icon="i-simple-icons-github" to="https://github.com/nuxt-contrib/vue3-ssr-starter/generate" target="_blank"}
::

Once you've reproduced the issue, remove as much code from your reproduction as you can (while still recreating the bug). The time spent making the reproduction as minimal as possible will make a huge difference to whoever sets out to fix the issue.

## Figure Out What the Cause Might Be

With a Nuxt project, there are lots of moving pieces - from [Nuxt modules](/modules) to [other JavaScript libraries](https://www.npmjs.com). Try to report the bug at the most relevant and specific place. That will likely be the Nuxt module causing an issue, or the upstream library that Nuxt is depending on.
</file>

<file path="docs/5.community/4.contribution.md">
---
title: 'Contribution'
description: 'Nuxt is a community project - and so we love contributions of all kinds! ❤️'
navigation.icon: i-lucide-git-pull-request
---

There is a range of different ways you might be able to contribute to the Nuxt ecosystem.

## Ecosystem

The Nuxt ecosystem includes many different projects and organizations:

* [nuxt/](https://github.com/nuxt) - core repositories for the Nuxt framework itself. [**nuxt/nuxt**](https://github.com/nuxt/nuxt) contains the Nuxt framework (both versions 2 and 3).
* [nuxt-modules/](https://github.com/nuxt-modules) - community-contributed and maintained modules and libraries. There is a [process to migrate a module](/docs/4.x/guide/modules/ecosystem) to `nuxt-modules`. While these modules have individual maintainers, they are not dependent on a single person.
* [unjs/](https://github.com/unjs) - many of these libraries are used throughout the Nuxt ecosystem. They are designed to be universal libraries that are framework- and environment-agnostic. We welcome contributions and usage by other frameworks and projects.

## How To Contribute

### Triage Issues and Help Out in Discussions

Check out the issues and discussions for the project you want to help. For example, here are [the issues board](https://github.com/nuxt/nuxt/issues) and [discussions](https://github.com/nuxt/nuxt/discussions) for Nuxt. Helping other users, sharing workarounds, creating reproductions, or even poking into a bug a little bit and sharing your findings makes a huge difference.

### Creating an Issue

Thank you for taking the time to create an issue! ❤️

* **Reporting bugs**: Check out [our guide](/docs/4.x/community/reporting-bugs) for some things to do before opening an issue.

* **Feature requests**: Check that there is not an existing issue or discussion covering the scope of the feature you have in mind. If the feature is to another part of the Nuxt ecosystem (such as a module), please consider raising a feature request there first. If the feature you have in mind is general or the API is not entirely clear, consider opening a discussion in the **Ideas** section to discuss with the community first.

We'll do our best to follow our [internal issue decision making flowchart](https://mermaid.live/view#pako:eNqFlE1v2zAMhv8K4UuToslhx2Bo0TZt12Edhm7YMCAXWqJtorLk6qOpkfS_j7KdfpyWQ-BQr8mHL6nsCuU0FauiMm6rGvQRfq03FuRzvvvTYIQHthpcBT_ugQNwPHuZjheLxf4i1VDx8x4udrf5EBCOQvSsYg4ffS79KS9pmX9QALTgyid2KYB7Ih-4bmKWbDk2YB0E1gRUVaRi-FDmmjAmT3u4nB3DmoNKIUA1BsGSohA49jnVMQhHbDh_EZQUImyxh-gAtfaiG-KWSJ-N8nt6YtpCdgEeE5rXPOdav5YwWJIJU7zrvNADV9C7JBIyIC07Wxupkx3LFQ5vCkguRno5f9fP2qnUko0Y2dk9rGdvHAa9IIhVGlCp5FFNPN-ce4DKeXBd53xMliOLp9IZtyORQVsnrGm-WJzejtUu5fFqdr5FGQ3bLslYvGthjZbJTLpReZG5_lLYw7XQ_CbPVT92ws9gnEJj-v84dk-PiaXnmF1XGAaPsOsMKywNvYmG80ZohV8k4wDR9_N3KN_dHm5mh1lnkM5FsYzRfNiTvJoT5gnQsl6uxjqXLhkNQ9syHJ0UZZ8ERUIlNShr6N8gZDEliR-ow7QZa0fhY4LoHLRo-8N7ZxPwjRj5ZZYXpvOSNs9v3Jjs8NXB4ets92xan3zydXZHvj64lKMayh4-gZC1bjASW2ipLeWuzIuToiXfImu5rbucclMIc0ubYiWPGv3DptjYF9Fhiu5nb1Wxij7RSZE6jZHWjLXHtlhVaIJESXN0_m68_sO_wMs_oO9gyg) when responding to issues.

### Send a Pull Request

We always welcome pull requests! ❤️

#### Before You Start

Before you fix a bug, we recommend that you check whether **there's an issue that describes it**, as it's possible it's a documentation issue or that there is some context that would be helpful to know.

If you're working on a feature, then we ask that you **open a feature request issue first** to discuss with the maintainers whether the feature is desired - and the design of those features. This helps save time for both the maintainers and the contributors and means that features can be shipped faster. The issue **should be confirmed** by a framework team member before building out a feature in a pull request.

For typo fixes, it's recommended to batch multiple typo fixes into one pull request to maintain a cleaner commit history.

For bigger changes to Nuxt itself, we recommend that you first [create a Nuxt module](/docs/4.x/community/contribution#create-a-module) and implement the feature there. This allows for quick proof-of-concept. You can then [create an RFC](/docs/4.x/community/contribution#make-an-rfc) in the form of a discussion. As users adopt it and you gather feedback, it can then be refined and either added to Nuxt core or continue as a standalone module.

#### Commit Conventions

We use [Conventional Commits](https://www.conventionalcommits.org) for commit messages, which [allows a changelog to be auto-generated](https://github.com/unjs/changelogen) based on the commits. Please read the guide through if you aren't familiar with it already.

Note that `fix:` and `feat:` are for **actual code changes** (that might affect logic). For typo or document changes, use `docs:` or `chore:` instead:

* ~~`fix: typo`~~ -> `docs: fix typo`

If you are working in a project with a monorepo, like `nuxt/nuxt`, ensure that you specify the main scope of your commit in brackets. For example: `feat(kit): add 'addMagicStuff' utility`.

#### Making the Pull Request

If you don't know how to send a pull request, we recommend reading [the guide](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request).

When sending a pull request, make sure your PR's title also follows the [Commit Convention](/docs/4.x/community/contribution#commit-conventions).

If your PR fixes or resolves existing issues, please make sure you mention them in the PR description.

It's ok to have multiple commits in a single PR; you don't need to rebase or force push for your changes as we will use `Squash and Merge` to squash the commits into one commit when merging.

We do not add any commit hooks to allow for quick commits. But before you make a pull request, you should ensure that any lint/test scripts are passing.

In general, please also make sure that there are no _unrelated_ changes in a PR. For example, if your editor has made any changes to whitespace or formatting elsewhere in a file that you edited, please revert these so it is more obvious what your PR changes. And please avoid including multiple unrelated features or fixes in a single PR. If it is possible to separate them, it is better to have multiple PRs to review and merge separately. In general, a PR should do _one thing only_.

#### Once You've Made a Pull Request

Once you've made a pull request, we'll do our best to review it promptly.

If we assign it to a maintainer, then that means that person will take special care to review it and implement any changes that may be required.

If we request changes on a PR, please ignore the red text! It doesn't mean we think it's a bad PR - it's just a way of easily telling the status of a list of pull requests at a glance.

If we mark a PR as 'pending', that means we likely have another task to do in reviewing the PR - it's an internal note-to-self, and not necessarily a reflection on whether the PR is a good idea or not. We will do our best to explain via a comment the reason for the pending status.

We'll do our best to follow [our PR decision making flowchart](https://mermaid.live/view#pako:eNp9VE1v2kAQ_SsjXzBSEqlALlaUisSh0ACK2l4qcVm8Y9hi7672Iwly-O-ZtYPt5FAOCHbee_PmzdpVlCmOURLlhXrJ9sw4-JNuJNBnWs1UQafIQVjrERyWumAOv58-AJeXt29_0b7BXbWwwL0uRPa1vlZvcB_fF8oiMMmB2QM4BXkt3UoON7Lh3LWaDz2SVkK6QGt7DHvw0CKt5sxCKaQoWQEGtVHcZ04oGdw04LTVngW_LHOeFcURGGz97mw6PSv-iJdsi0UCA4nI7SfNwc3W3JZit3eQ1SZFDlKB15yswQ2MgbOjbYeatY3n8bcr-IWlekYYaJRcyB04I9gOB1CEfkF5dAVTzmFAtnqn4-bUYAiMMmHZgWhNPRhgus5mW2BATxq0NkIZ4Y4NbNjzE2ZchBzcHmGLe_ZMSKCcyRXyLrVFa_5n_PBK2xKy3kk9eOjULUdltk6C8kI-7NFDr8f4EVGDoqlp-wa4sJm3ltIMIuZ_mTQXJyTSkQZtunPqsKxShV9GKdkBYe1fHXjpbcjlvONlO9Kqx_M7YHmOmav_luxfE5zKwVs09hM5DLSupgYDlr5flDkwo7ykixKG-xDsUly1LZ-uY32dgDc7lG7YqwbNp0msJwmIUivjWFtfd-xRrEcJ7Omydz37qFplHOtxEp4GskI2qB5dRCWakglOz3oV8JuITJa4iRL6yZk5bKKNPBGOead-H2UWJc54vIiaW53SPgwrz4fIhVNm1bw76lfI6R2_MW21) when responding and reviewing to pull requests.

### AI-Assisted Contributions

We welcome the thoughtful use of AI tools when contributing to Nuxt, yet ask all contributors to follow [two core principles](https://roe.dev/blog/using-ai-in-open-source).

#### Never let an LLM speak for you

* All comments, issues, and pull request descriptions should be written in your own voice
* We value clear, human communication over perfect grammar or spelling
* Avoid copy-pasting AI-generated summaries that don't reflect your own understanding

#### Never let an LLM think for you

* Feel free to use AI tools to generate code or explore ideas
* Only submit contributions you fully understand and can explain
* Contributions should reflect your own reasoning and problem-solving

Our aim is ensuring quality and maintaining the joy of collaborating and communicating with real people. If you have ideas for improving our policy on AI in the Nuxt community, we'd love to hear them! ❤️

### Create a Module

If you've built something with Nuxt that's cool, why not [extract it into a module](/docs/4.x/guide/modules), so it can be shared with others? We have [many excellent modules already](/modules), but there's always room for more.

If you need help while building it, feel free to [check in with us](/docs/4.x/community/getting-help).

### Make an RFC

We highly recommend [creating a module](/docs/4.x/community/contribution#create-a-module) first to test out big new features and gain community adoption.

If you have done this already, or it's not appropriate to create a new module, then please start by creating a new discussion. Make sure it explains your thinking as clearly as possible. Include code examples or function signatures for new APIs. Reference existing issues or pain points with examples.

If we think this should be an RFC, we'll change the category to RFC and broadcast it more widely for feedback.

An RFC will then move through the following stages:

* `rfc: active` - currently open for comment
* `rfc: approved` - approved by the Nuxt team
* `rfc: ready to implement` - an issue has been created and assigned to implement
* `rfc: shipped` - implemented
* `rfc: archived` - not approved, but archived for future reference

### Conventions Across Ecosystem

The following conventions are _required_ within the `nuxt/` organization and recommended for other maintainers in the ecosystem.

#### Module Conventions

Modules should follow the [Nuxt module template](https://github.com/nuxt/starter/tree/module). See [module guide](/docs/4.x/guide/modules) for more information.

#### Use Core `unjs/` Libraries

We recommend the following libraries which are used throughout the ecosystem:

* [pathe](https://github.com/unjs/pathe) - universal path utilities (replacement for node `path`)
* [ufo](https://github.com/unjs/ufo) - URL parsing and joining utilities
* [unbuild](https://github.com/unjs/unbuild) - rollup-powered build system
* ... check out the rest of the [unjs/](https://github.com/unjs) organization for many more!

#### Use ESM Syntax and Default to `type: module`

Most of the Nuxt ecosystem can consume ESM directly. In general we advocate that you avoid using CJS-specific code, such as `__dirname` and `require` statements. You can [read more about ESM](/docs/4.x/guide/concepts/esm).

#### What's Corepack

[Corepack](https://github.com/nodejs/corepack) makes sure you are using the correct version for package manager when you run corresponding commands. Projects might have `packageManager` field in their `package.json`.

Under projects with configuration as shown below, Corepack will install `v7.5.0` of `pnpm` (if you don't have it already) and use it to run your commands.

```jsonc [package.json]
{
  "packageManager": "pnpm@7.5.0"
}
```

#### Use ESLint

We use [ESLint](https://eslint.org) for both linting and formatting with [`@nuxt/eslint`](https://github.com/nuxt/eslint).

##### IDE Setup

We recommend using [VS Code](https://code.visualstudio.com) along with the [ESLint extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint). If you would like, you can enable auto-fix and formatting when you save the code you are editing:

```json [settings.json]
{
  "editor.codeActionsOnSave": {
    "source.fixAll": "never",
    "source.fixAll.eslint": "explicit"
  }
}
```

#### No Prettier

Since ESLint is already configured to format the code, there is no need to duplicate the functionality with Prettier. To format the code, you can run `yarn lint --fix`, `pnpm lint --fix`, or `bun run lint --fix` or referring the [ESLint section](/docs/4.x/community/contribution#use-eslint) for IDE Setup.

If you have Prettier installed in your editor, we recommend you disable it when working on the project to avoid conflict.

#### Package Manager

We recommend `pnpm` as a package manager for modules, libraries and apps.

It is important to enable Corepack to ensure you are on the same version of the package manager as the project. Corepack is built-in to new node versions for seamless package manager integration.

To enable it, run

```bash [Terminal]
corepack enable
```

You only need to do this one time, after Node.js is installed on your computer.

## Documentation Style Guide

Documentation is an essential part of Nuxt. We aim to be an intuitive framework - and a big part of that is making sure that both the developer experience and the docs are perfect across the ecosystem. 👌

Here are some tips that may help improve your documentation:

* Avoid subjective words like _simply_, _just_, _obviously..._ when possible.

  Keep in mind your readers can have different backgrounds and experiences. Therefore, these words don't convey meaning and can be harmful.

  ::caution{ icon="i-lucide-circle-x"}
  Simply make sure the function returns a promise.
  ::

  ::tip{icon="i-lucide-circle-check"}
  Make sure the function returns a [promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
  ::

* Prefer [active voice](https://developers.google.com/tech-writing/one/active-voice).

  ::caution{icon="i-lucide-circle-x"}
  An error will be thrown by Nuxt.
  ::

  ::tip{icon="i-lucide-circle-check"}
  Nuxt will throw an error.
  ::

::read-more{to="/docs/4.x/community/framework-contribution#documentation-guide"}
Learn how to contribute to the documentation.
::
</file>

<file path="docs/5.community/5.framework-contribution.md">
---
title: 'Framework'
navigation.icon: i-lucide-github
description: Some specific points about contributions to the framework repository.
---

Once you've read the [general contribution guide](/docs/4.x/community/contribution), here are some specific points to make about contributions to the [`nuxt/nuxt`](https://github.com/nuxt/nuxt) repository.

## Monorepo Guide

- `packages/kit`: Toolkit for authoring Nuxt modules, published as [`@nuxt/kit`](https://www.npmjs.com/package/@nuxt/kit).
- `packages/nuxt`: The core of Nuxt, published as [`nuxt`](https://www.npmjs.com/package/nuxt).
- `packages/schema`: Cross-version Nuxt typedefs and defaults, published as [`@nuxt/schema`](https://www.npmjs.com/package/@nuxt/schema).
- `packages/rspack`: The [Rspack](https://rspack.rs) bundler for Nuxt, published as [`@nuxt/rspack-builder`](https://www.npmjs.com/package/@nuxt/rspack-builder).
- `packages/vite`: The [Vite](https://vite.dev) bundler for Nuxt, published as [`@nuxt/vite-builder`](https://www.npmjs.com/package/@nuxt/vite-builder).
- `packages/webpack`: The [webpack](https://webpack.js.org) bundler for Nuxt, published as [`@nuxt/webpack-builder`](https://www.npmjs.com/package/@nuxt/webpack-builder).

## Setup

To contribute to Nuxt, you need to set up a local environment.

1. [Fork](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo) the [`nuxt/nuxt`](https://github.com/nuxt/nuxt)  repository to your own GitHub account and then [clone](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository) it to your local device.
2. Ensure using the latest [Node.js](https://nodejs.org/en)
3. Enable [Corepack](https://github.com/nodejs/corepack) to have `pnpm` and `yarn`
    ```bash [Terminal]
    corepack enable
    ```
4. Run `pnpm install --frozen-lockfile` to Install the dependencies with pnpm:
    ```bash [Terminal]
    pnpm install --frozen-lockfile
    ```
    ::note
    If you are adding a dependency, please use `pnpm add`. :br
    The `pnpm-lock.yaml` file is the source of truth for all Nuxt dependencies.
    ::
5. Activate the passive development system
    ```bash [Terminal]
    pnpm dev:prepare
    ```
6. Check out a branch where you can work and commit your changes:
    ```bash [Terminal]
    git checkout -b my-new-branch
    ```

Then, test your changes against the [playground](/docs/4.x/community/framework-contribution#playground) and [test](/docs/4.x/community/framework-contribution#testing) your changes before submitting a pull request.

### Playground

While working on a pull request, you will likely want to check if your changes are working correctly.

You can modify the example app in `playground/`, and run:

```bash [Terminal]
pnpm dev
```

::important
Please make sure not to commit it to your branch, but it could be helpful to add some example code to your PR description. This can help reviewers and other Nuxt users understand the feature you've built in-depth.
::

### Testing

Every new feature should have a corresponding unit test (if possible). The `test/` directory in this repository is currently a work in progress, but do your best to create a new test following the example of what's already there.

Before creating a PR or marking it as ready-to-review, ensure that all tests pass by running:

```bash [Terminal]
pnpm test
```

### Linting

You might have noticed already that we use ESLint to enforce a coding standard.

Before committing your changes, to verify that the code style is correct, run:

```bash [Terminal]
pnpm lint
```

::note
You can use `pnpm lint --fix` to fix most of the style changes. :br
If there are still errors left, you must correct them manually.
::

### Documentation

If you are adding a new feature or refactoring or changing the behavior of Nuxt in any other manner, you'll likely want to document the changes. Please include any changes to the docs in the same PR. You don't have to write documentation up on the first commit (but please do so as soon as your pull request is mature enough).

::important
Make sure to make changes according to the [Documentation Style Guide](/docs/4.x/community/contribution#documentation-style-guide).
::

### Final Checklist

When submitting your PR, there is a simple template that you have to fill out. Please tick all appropriate "answers" in the checklists.

## Documentation Guide

If you spot an area where we can improve documentation or error messages, please do open a PR - even if it's just to fix a typo!

::important
Make sure to make changes according to the [Documentation Style Guide](/docs/4.x/community/contribution#documentation-style-guide).
::

### Quick Edits

If you spot a typo or want to rephrase a sentence, you can click on the **Edit this page** link located on the right aside in the **Community** section.

Make the change directly in the GitHub interface and open a Pull Request.

### Longer Edits

The documentation content is inside the `docs/` directory of the [nuxt/nuxt](https://github.com/nuxt/nuxt) repository and written in markdown.

::note
To preview the docs locally, follow the steps on [nuxt/nuxt.com](https://github.com/nuxt/nuxt.com) repository.
::

::note
We recommend that you install the [MDC extension](https://marketplace.visualstudio.com/items?itemName=Nuxt.mdc) for VS Code.
::

### Linting Docs

Documentation is linted using [MarkdownLint](https://github.com/DavidAnson/markdownlint) and [case police](https://github.com/antfu/case-police) to keep the documentation cohesive.

```bash [Terminal]
pnpm lint:docs
```

::note
You can also run `pnpm lint:docs:fix` to highlight and resolve any lint issues.
::

### Open a PR

Please make sure your PR title adheres to the [conventional commits](https://www.conventionalcommits.org) guidelines.

```bash [Example of PR title]
docs: update the section about the nuxt.config.ts file
```
</file>

<file path="docs/5.community/6.roadmap.md">
---
title: 'Roadmap'
description: 'Nuxt is constantly evolving, with new features and modules being added all the time.'
navigation.icon: i-lucide-map
---

::read-more{to="/blog"}
See our blog for the latest framework and ecosystem announcements.
::

## Status Reports

::read-more{icon="i-simple-icons-github" to="https://github.com/nuxt/nuxt/issues/13653" target="_blank"}
Documentation Progress
::
::read-more{icon="i-simple-icons-github" to="https://github.com/nuxt/nuxt/discussions/16119" target="_blank"}
Rendering Optimizations: Today and Tomorrow
::
::read-more{icon="i-simple-icons-github" to="https://github.com/nuxt/image/discussions/563" target="_blank"}
Nuxt Image: Performance and Status
::

## Roadmap

In roadmap below are some features we are planning or working on at the moment.

::tip
Check [Discussions](https://github.com/nuxt/nuxt/discussions) and [RFCs](https://github.com/nuxt/nuxt/discussions/categories/rfcs) for more upcoming features and ideas.
::

| Milestone    | Expected date | Notes                                                              | Description                                                                                                                                |
|--------------|---------------|--------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|
| SEO & PWA    | 2025          | [nuxt/nuxt#18395](https://github.com/nuxt/nuxt/discussions/18395)  | Migrating from [nuxt-community/pwa-module](https://github.com/nuxt-community/pwa-module) for built-in SEO utils and service worker support |
| Assets       | 2025          | [nuxt/nuxt#22012](https://github.com/nuxt/nuxt/discussions/22012)  | Allow developers and modules to handle loading third-party assets.                                                                         |
| Translations | -             | [nuxt/nuxt.com#1711](https://github.com/nuxt/nuxt.com/issues/1711) | A collaborative project for a stable translation process for Nuxt docs. Currently pending for ideas and documentation tooling support.     |

## Core Modules Roadmap

In addition to the Nuxt framework, there are modules that are vital for the ecosystem. Their status will be updated below.

| Module                                 | Status       | Nuxt Support | Repository                                      | Description                                                                                                                                                          |
|----------------------------------------|--------------|--------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [Scripts](https://scripts.nuxt.com)    | Public Beta  | 3.x, 4.x     | [nuxt/scripts](https://github.com/nuxt/scripts) | Easy 3rd party script management.                                                                                                                                    |
| Auth Utils                             | Planned      | 4.x, 5.x     | `nuxt/auth-utils` to be announced               | The temporary repository [atinux/nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils) is available while awaiting its official integration into Nuxt via RFC. |
| A11y                                   | Planned      | 4.x, 5.x     | `nuxt/a11y` to be announced                     | Accessibility hinting and utilities [nuxt/nuxt#23255](https://github.com/nuxt/nuxt/issues/23255)                                                                     |
| [Hints](https://github.com/nuxt/hints) | Public Alpha | 4.x, 5.x     | [nuxt/hints](https://github.com/nuxt/hints)     | Guidance and suggestions for enhancing development practices.                                                                                                        |

## Release Cycle

Since January 2023, we've adopted a consistent release cycle for Nuxt, following [semver](https://semver.org). We aim for major framework releases every year, with an expectation of patch releases every week or so and minor releases every month or so. They should never contain breaking changes except within options clearly marked as `experimental`.

We are planning a slight variation from this plan for Nuxt 4 and Nuxt 5. Nuxt 4 will be a stability-focused release containing all `compatibilityVersion: 4` features, and will be followed shortly by Nuxt 5 which will include an upgrade to Nitro v3 and additional changes.

This approach separates breaking changes into manageable phases, allowing for better ecosystem testing and smoother migrations.

### Ongoing Support for Nuxt

We commit to support each major version of Nuxt for a minimum of six months after the release of the next major version, and to providing an upgrade path for current users at that point.

### Current Packages

The current active version of [Nuxt](https://nuxt.com) is **v4** which is available as `nuxt` on npm with the `latest` tag.

Nuxt 3 will continue to receive maintenance updates (both bug fixes and backports of features from Nuxt 4) until the end of January 2026.

Each active version has its own nightly releases which are generated automatically. For more about enabling the Nuxt nightly release channel, see [the nightly release channel docs](/docs/4.x/guide/going-further/nightly-release-channel).

| Release               |                                                                                                                                                                                                                                                    | Initial release     | End Of Life                | Docs                                                              |
|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------|----------------------------|-------------------------------------------------------------------|
| **5.x** (scheduled)   |                                                                                                                                                                                                                                                    | Q4 2025 (estimated) | TBA                        | &nbsp;                                                            |
| **4.x** (stable)      | <a href="https://www.npmjs.com/package/nuxt?activeTab=versions"><img alt="Nuxt latest version" src="https://img.shields.io/npm/v/nuxt.svg?logo=nuxt&label=&style=flat&colorA=18181B&colorB=28CF8D" class="not-prose h-5 w-auto" :zoom="false"></a> | 2025-07-16          | 6 months after 5.x release | [nuxt.com](/docs/4.x/getting-started/introduction)                |
| **3.x** (maintenance) | <a href="https://www.npmjs.com/package/nuxt?activeTab=versions"><img alt="Nuxt 3.x version" src="https://img.shields.io/npm/v/nuxt/3x.svg?logo=nuxt&label=&style=flat&colorA=18181B&colorB=28CF8D" class="not-prose h-5 w-auto" :zoom="false"></a> | 2022-11-16          | 2026-01-31                 | [nuxt.com](/docs/3.x/getting-started/introduction)                |
| **2.x** (unsupported) | <a href="https://www.npmjs.com/package/nuxt?activeTab=versions"><img alt="Nuxt 2.x version" src="https://img.shields.io/npm/v/nuxt/2x.svg?logo=nuxt&label=&style=flat&colorA=18181B&colorB=28CF8D" class="not-prose h-5 w-auto" :zoom="false"></a> | 2018-09-21          | 2024-06-30                 | [v2.nuxt.com](https://v2.nuxt.com/docs/get-started/installation/) |
| **1.x** (unsupported) | <a href="https://www.npmjs.com/package/nuxt?activeTab=versions"><img alt="Nuxt 1.x version" src="https://img.shields.io/npm/v/nuxt/1x.svg?logo=nuxt&label=&style=flat&colorA=18181B&colorB=28CF8D" class="not-prose h-5 w-auto" :zoom="false"></a> | 2018-01-08          | 2019-09-21                 | &nbsp;                                                            |

### Support Status

| Status      | Description                                                                   |
|-------------|-------------------------------------------------------------------------------|
| Unsupported | This version is not maintained any more and will not receive security patches |
| Maintenance | This version will only receive security patches                               |
| Stable      | This version is being developed for and will receive security patches         |
| Development | This version could be unstable                                                |
| Scheduled   | This version does not exist yet but is planned                                |
</file>

<file path="docs/5.community/7.changelog.md">
---
title: 'Releases'
description: Discover the latest releases of Nuxt & Nuxt official modules.
navigation.icon: i-lucide-bell-dot
---

::card-group
  ::card
  ---
  icon: i-simple-icons-github
  title: nuxt/nuxt
  to: https://github.com/nuxt/nuxt/releases
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Nuxt framework releases.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: nuxt/cli
  to: https://github.com/nuxt/cli/releases
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Nuxt CLI (`@nuxt/cli`) releases.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: nuxt/content
  to: https://github.com/nuxt/content/releases
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Nuxt Content releases.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: nuxt/devtools
  to: https://github.com/nuxt/devtools/releases
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Nuxt DevTools releases.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: nuxt/fonts
  to: https://github.com/nuxt/fonts/releases
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Nuxt Fonts releases.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: nuxt/hints
  to: https://github.com/nuxt/hints/releases
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Nuxt Hints releases.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: nuxt/image
  to: https://github.com/nuxt/image/releases
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Nuxt Image releases.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: nuxt/scripts
  to: https://github.com/nuxt/scripts/releases
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Nuxt Scripts releases.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: nuxt/ui
  to: https://github.com/nuxt/ui/releases
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Nuxt UI releases.
  ::
::

::read-more{icon="i-simple-icons-github" to="https://github.com/nuxt" target="_blank"}
Discover the `nuxt` organization on GitHub
::
</file>

<file path="docs/6.bridge/.navigation.yml">
titleTemplate: 'Migrate to Nuxt Bridge: %s'
title: 'Migrate to Nuxt Bridge'
icon: i-lucide-ship
</file>

<file path="docs/6.bridge/1.overview.md">
---
title: Overview
description: Reduce the differences with Nuxt 3 and reduce the burden of migration to Nuxt 3.
---

::note
If you're starting a fresh Nuxt 3 project, please skip this section and go to [Nuxt 3 Installation](/docs/4.x/getting-started/introduction).
::

::warning
Nuxt Bridge provides identical features to Nuxt 3 ([docs](/docs/4.x/guide/concepts/auto-imports)) but there are some limitations, notably that [`useAsyncData`](/docs/4.x/api/composables/use-async-data) and [`useFetch`](/docs/4.x/api/composables/use-fetch) composables are not available. Please read the rest of this page for details.
::

Bridge is a forward-compatibility layer that allows you to experience many of the new Nuxt 3 features by simply installing and enabling a Nuxt module.

Using Nuxt Bridge, you can make sure your project is (almost) ready for Nuxt 3 and you can gradually proceed with the transition to Nuxt 3.

## First Step

### Upgrade Nuxt 2

Make sure your dev server (`nuxt dev`) isn't running, remove any package lock files (`package-lock.json` and `yarn.lock`), and install the latest Nuxt 2 version:

```diff [package.json]
- "nuxt": "^2.16.3"
+ "nuxt": "^2.17.3"
```

Then, reinstall your dependencies:

::code-group{sync="pm"}

```bash [npm]
npm install
```

```bash [yarn]
yarn install
```

```bash [pnpm]
pnpm install
```

```bash [bun]
bun install
```

::

::note
Once the installation is complete, make sure both development and production builds are working as expected before proceeding.
::

### Install Nuxt Bridge

Install `@nuxt/bridge` and `nuxi` as development dependencies:

::code-group{sync="pm"}

```bash [npm]
npm install -D @nuxt/bridge nuxi
```

```bash [yarn]
yarn add --dev @nuxt/bridge nuxi
```

```bash [pnpm]
pnpm add -D @nuxt/bridge nuxi
```

```bash [bun]
bun add -D @nuxt/bridge nuxi
```

::

### Update `nuxt.config`

Please make sure to avoid any CommonJS syntax such as `module.exports`, `require` or `require.resolve` in your config file. It will soon be deprecated and unsupported.

You can use static `import`, dynamic `import()` and `export default` instead. Using TypeScript by renaming to [`nuxt.config.ts`](/docs/4.x/directory-structure/nuxt-config) is also possible and recommended.

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: false,
})
```

### Update Commands

The `nuxt` command should now be changed to the `nuxt2` command.

```diff
{
  "scripts": {
-   "dev": "nuxt",
+   "dev": "nuxt2",
-   "build": "nuxt build",
+   "build": "nuxt2 build",
-   "start": "nuxt start",
+   "start": "nuxt2 start"
  }
}
```

Try running `nuxt2` once here. You will see that the application works as before.

(If 'bridge' is set to false, your application will operate without any changes as before.)

## Upgrade Steps

With Nuxt Bridge, the migration to Nuxt 3 can proceed in steps.
The below `Upgrade Steps` does not need to be done all at once.

- [TypeScript](/docs/4.x/bridge/typescript)

- [Migrate Legacy Composition API](/docs/4.x/bridge/bridge-composition-api)

- [Plugins and Middleware](/docs/4.x/bridge/plugins-and-middleware)

- [Migrate New Composition API](/docs/4.x/bridge/nuxt3-compatible-api)

- [Meta Tags](/docs/4.x/bridge/meta)

- [Runtime Config](/docs/4.x/bridge/runtime-config)

- [Nitro](/docs/4.x/bridge/nitro)

- [Vite](/docs/4.x/bridge/vite)

## Migrate from CommonJS to ESM

Nuxt 3 natively supports TypeScript and ECMAScript Modules. Please check [Native ES Modules](/docs/4.x/guide/concepts/esm) for more info and upgrading.
</file>

<file path="docs/6.bridge/10.configuration.md">
---
title: Configuration
description: 'Learn how to configure Nuxt Bridge to your own needs.'
---

## Feature Flags

You can optionally disable some features from bridge or opt-in to less stable ones. In normal circumstances, it is always best to stick with defaults!

You can check [bridge/src/module.ts](https://github.com/nuxt/bridge/blob/main/packages/bridge/src/module.ts) for latest defaults.

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {

    // -- Opt-in features --

    // Use Vite as the bundler instead of webpack 4
    // vite: true,

    // Enable Nuxt 3 compatible useHead
    // meta: true,

    // Enable definePageMeta macro
    // macros: {
    //   pageMeta: true
    // },

    // Enable transpiling TypeScript with esbuild
    // typescript: {
    //   esbuild: true
    // },

    // -- Default features --

    // Use legacy server instead of Nitro
    // nitro: false,

    // Disable Nuxt 3 compatible `nuxtApp` interface
    // app: false,

    // Disable Composition API support
    // capi: false,

    // ... or just disable legacy Composition API support
    // capi: {
    //   legacy: false
    // },

    // Do not transpile modules
    // transpile: false,

    // Disable <script setup> support
    // scriptSetup: false,

    // Disable composables auto importing
    // imports: false,

    // Do not warn about module incompatibilities
    // constraints: false
  },

  vite: {
    // Config for Vite
  },
})
```

## Migration of each option

### router.base

```diff
export default defineNuxtConfig({
- router: {
-   base: '/my-app/'
- }
+ app: {
+   baseURL: '/my-app/'
+ }
})
```

### build.publicPath

```diff
export default defineNuxtConfig({
- build: {
-   publicPath: 'https://my-cdn.net'
- }
+ app: {
+   cdnURL: 'https://my-cdn.net'
+ }
})
```
</file>

<file path="docs/6.bridge/2.typescript.md">
---
title: TypeScript
description: 'Learn how to use TypeScript with Nuxt Bridge.'
---

## Remove Modules

- Remove `@nuxt/typescript-build`: Bridge enables same functionality
- Remove `@nuxt/typescript-runtime` and `nuxt-ts`: Nuxt 2 has built-in runtime support

### Set `bridge.typescript`

```ts
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    typescript: true,
    nitro: false, // If migration to Nitro is complete, set to true
  },
})
```

## Update `tsconfig.json`

If you are using TypeScript, you can edit your `tsconfig.json` to benefit from auto-generated Nuxt types:

```diff [tsconfig.json]
{
+ "extends": "./.nuxt/tsconfig.json",
  "compilerOptions": {
    ...
  }
}
```

::note
As `.nuxt/tsconfig.json` is generated and not checked into version control, you'll need to generate that file before running your tests. Add `nuxi prepare` as a step before your tests, otherwise you'll see `TS5083: Cannot read file '~/.nuxt/tsconfig.json'`

For modern Nuxt projects, we recommend using [TypeScript project references](/docs/4.x/directory-structure/tsconfig) instead of directly extending `.nuxt/tsconfig.json`.
::

::note
Keep in mind that all options extended from `./.nuxt/tsconfig.json` will be overwritten by the options defined in your `tsconfig.json`.
Overwriting options such as `"compilerOptions.paths"` with your own configuration will lead TypeScript to not factor in the module resolutions from `./.nuxt/tsconfig.json`. This can lead to module resolutions such as `#imports` not being recognized.

In case you need to extend options provided by `./.nuxt/tsconfig.json` further, you can use the `alias` property within your `nuxt.config`. `nuxi` will pick them up and extend `./.nuxt/tsconfig.json` accordingly.
::
</file>

<file path="docs/6.bridge/3.bridge-composition-api.md">
---
title: Legacy Composition API
description: 'Learn how to migrate to Composition API with Nuxt Bridge.'
---

Nuxt Bridge provides access to Composition API syntax. It is specifically designed to be aligned with Nuxt 3. Because of this, there are a few extra steps to take when enabling Nuxt Bridge, if you have been using the Composition API previously.

## Remove Modules

- Remove `@vue/composition-api` from your dependencies.
- Remove `@nuxtjs/composition-api` from your dependencies (and from your modules in `nuxt.config`).

## Using `@vue/composition-api`

If you have been using just `@vue/composition-api` and not `@nuxtjs/composition-api`, then things are very straightforward.

1. First, remove the plugin where you are manually registering the Composition API. Nuxt Bridge will handle this for you.

   ```diff
   - import Vue from 'vue'
   - import VueCompositionApi from '@vue/composition-api'
   -
   - Vue.use(VueCompositionApi)
   ```

2. Otherwise, there is nothing you need to do. However, if you want, you can remove your explicit imports from `@vue/composition-api` and rely on Nuxt Bridge auto-importing them for you.

## Migrating from `@nuxtjs/composition-api`

Nuxt Bridge implements the Composition API slightly differently from `@nuxtjs/composition-api` and provides different composables (designed to be aligned with the composables that Nuxt 3 provides).

Because some composables have been removed and don't yet have a replacement, this will be a slightly more complicated process.

### Remove `@nuxtjs/composition-api/module` from your buildModules

You don't have to immediately update your imports yet - Nuxt Bridge will automatically provide a 'shim' for most imports you currently have, to give you time to migrate to the new, Nuxt 3-compatible composables, with the following exceptions:

- `withContext` has been removed. See [below](/docs/4.x/bridge/nuxt3-compatible-api#usecontext-and-withcontext).
- `useStatic` has been removed. There is no current replacement. Feel free to raise a discussion if you have a use case for this.
- `reqRef` and `reqSsrRef`, which were deprecated, have now been removed entirely. Follow the instructions below regarding [ssrRef](/docs/4.x/bridge/nuxt3-compatible-api#ssrref-and-shallowssrref) to replace this.

### Set `bridge.capi`

```ts
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    capi: true,
    nitro: false, // If migration to Nitro is complete, set to true
  },
})
```

For each other composable you are using from `@nuxtjs/composition-api`, follow the steps below.

### useFetch

`$fetchState` and `$fetch` have been removed.

```diff
const {
- $fetch,
- $fetchState,
+ fetch,
+ fetchState,
} = useFetch(() => { posts.value = await $fetch('/api/posts') })
```

### `defineNuxtMiddleware`

This was a type-helper stub function that is now removed.

Remove the `defineNuxtMiddleware` wrapper:

```diff
- import { defineNuxtMiddleware } from '@nuxtjs/composition-api`
- export default defineNuxtMiddleware((ctx) => {})
+ export default (ctx) => {}
```

For typescript support, you can use `@nuxt/types`:

```ts
import type { Middleware } from '@nuxt/types'

export default <Middleware> function (ctx) { }
```

### `defineNuxtPlugin`

This was a type-helper stub function that is now removed.

You may also keep using Nuxt 2-style plugins, by removing the function (as with [defineNuxtMiddleware](/docs/4.x/bridge/bridge-composition-api#definenuxtmiddleware)).

Remove the `defineNuxtPlugin` wrapper:

```diff
- import { defineNuxtPlugin } from '@nuxtjs/composition-api'
- export default defineNuxtPlugin((ctx, inject) => {})
+ export default (ctx, inject) => {}
```

For typescript support, you can use `@nuxt/types`:

```ts
import type { Plugin } from '@nuxt/types'

export default <Plugin> function (ctx, inject) {}
```

::warning
While this example is valid, Nuxt 3 introduces a new defineNuxtPlugin function that has a slightly different signature.
::

:ReadMore{link="/docs/4.x/directory-structure/app/plugins#creating-plugins"}

### `useRouter` and `useRoute`

Nuxt Bridge provides direct replacements for these composables via [`useRouter`](/docs/4.x/api/composables/use-router)  and `useRoute`.

The only key difference is that [`useRoute`](/docs/4.x/api/composables/use-route) no longer returns a computed property.

```diff
- import { useRouter, useRoute } from '@nuxtjs/composition-api'

  const router = useRouter()
  const route = useRoute()

- console.log(route.value.path)
+ console.log(route.path)
```
</file>

<file path="docs/6.bridge/4.plugins-and-middleware.md">
---
title: Plugins and Middleware
description: 'Learn how to migrate from Nuxt 2 to Nuxt Bridge new plugins and middleware.'
---

## New Plugins Format

You can now migrate to the Nuxt 3 plugins API, which is slightly different in format from Nuxt 2.

Plugins now take only one argument (`nuxtApp`). You can find out more in [the docs](/docs/4.x/directory-structure/app/plugins).

```ts [app/plugins/hello.ts]
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.provide('injected', () => 'my injected function')
  // now available on `nuxtApp.$injected`
})
```

::note
If you want to use the new Nuxt composables (such as [`useNuxtApp`](/docs/4.x/api/composables/use-nuxt-app) or `useRuntimeConfig`) within your plugins, you will need to use the `defineNuxtPlugin` helper for those plugins.
::

::warning
Although a compatibility interface is provided via `nuxtApp.vueApp` you should avoid registering plugins, directives, mixins or components this way without adding your own logic to ensure they are not installed more than once, or this may cause a memory leak.
::

## New Middleware Format

You can now migrate to the Nuxt 3 middleware API, which is slightly different in format from Nuxt 2.

Middleware now take only two argument (`to`, `from`). You can find out more in [the docs](/docs/4.x/directory-structure/app/middleware).

```ts twoslash
export default defineNuxtRouteMiddleware((to) => {
  if (to.path !== '/') {
    return navigateTo('/')
  }
})
```

::important
Use of `defineNuxtRouteMiddleware` is not supported outside of the `app/middleware` directory.
::

## definePageMeta

You can also use [`definePageMeta`](/docs/4.x/api/utils/define-page-meta) in Nuxt Bridge.

You can be enabled with the `macros.pageMeta` option in your configuration file

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    macros: {
      pageMeta: true,
    },
  },
})
```

::note
But only for `middleware` and `layout`.
::
</file>

<file path="docs/6.bridge/5.nuxt3-compatible-api.md">
---
title: New Composition API
description: Nuxt Bridge implements composables compatible with Nuxt 3.
---

By migrating from `@nuxtjs/composition-api` to the Nuxt 3 compatible API, there will be less rewriting when migrating to Nuxt 3.

## `ssrRef` and `shallowSsrRef`

These two functions have been replaced with a new composable that works very similarly under the hood: `useState`.

The key differences are that you must provide a _key_ for this state (which Nuxt generated automatically for `ssrRef` and `shallowSsrRef`), and that it can only be called within a Nuxt 3 plugin (which is defined by `defineNuxtPlugin`) or a component instance. (In other words, you cannot use [`useState`](/docs/4.x/api/composables/use-state) with a global/ambient context, because of the danger of shared state across requests.)

```diff
- import { ssrRef } from '@nuxtjs/composition-api'

- const ref1 = ssrRef('initialData')
- const ref2 = ssrRef(() => 'factory function')
+ const ref1 = useState('ref1-key', () => 'initialData')
+ const ref2 = useState('ref2-key', () => 'factory function')
  // accessing the state
  console.log(ref1.value)
```

Because the state is keyed, you can access the same state from multiple locations, as long as you are using the same key.

You can read more about how to use this composable in [the Nuxt 3 docs](/docs/4.x/api/composables/use-state).

## `ssrPromise`

This function has been removed, and you will need to find an alternative implementation if you were using it. If you have a use case for `ssrPromise`, please let us know via a discussion.

## `onGlobalSetup`

This function has been removed, but its use cases can be met by using [`useNuxtApp`](/docs/4.x/api/composables/use-nuxt-app) or [`useState`](/docs/4.x/api/composables/use-state) within `defineNuxtPlugin`. You can also run any custom code within the `setup()` function of a layout.

```diff
- import { onGlobalSetup } from '@nuxtjs/composition-api'

- export default () => {
-   onGlobalSetup(() => {
+ export default defineNuxtPlugin((nuxtApp) => {
+   nuxtApp.hook('vue:setup', () => {
      // ...
    })
- }
+ })
```

## `useStore`

In order to access Vuex store instance, you can use `useNuxtApp().$store`.

```diff
- import { useStore } from '@nuxtjs/composition-api`
+ const { $store } = useNuxtApp()
```

## `useContext` and `withContext`

You can access injected helpers using `useNuxtApp`.

```diff
- import { useContext } from '@nuxtjs/composition-api`
+ const { $axios } = useNuxtApp()
```

::note
`useNuxtApp()` also provides a key called `nuxt2Context` which contains all the same properties you would normally access from Nuxt 2 context, but it's advised _not_ to use this directly, as it won't exist in Nuxt 3. Instead, see if there is another way to access what you need. (If not, please raise a feature request or discussion.)
::

## `wrapProperty`

This helper function is not provided any more but you can replace it with the following code:

```ts
import { computed, getCurrentInstance } from 'vue'

const wrapProperty = (property: string, makeComputed = true) => () => {
  const vm = getCurrentInstance().proxy
  return makeComputed ? computed(() => vm[property]) : vm[property]
}
```

## `useAsync` and `useFetch`

These two composables can be replaced with `useLazyAsyncData` and `useLazyFetch`, which are documented [in the Nuxt 3 docs](/docs/4.x/getting-started/data-fetching). Just like the previous `@nuxtjs/composition-api` composables, these composables do not block route navigation on the client-side (hence the 'lazy' part of the name).

::important
Note that the API is entirely different, despite similar sounding names. Importantly, you should not attempt to change the value of other variables outside the composable (as you may have been doing with the previous `useFetch`).
::

::warning
The `useLazyFetch` must have been configured for [Nitro](/docs/4.x/bridge/nitro).
::

Migrating to the new composables from `useAsync`:

```diff
<script setup>
- import { useAsync } from '@nuxtjs/composition-api'
- const posts = useAsync(() => $fetch('/api/posts'))
+ const { data: posts } = useLazyAsyncData('posts', () => $fetch('/api/posts'))
+ // or, more simply!
+ const { data: posts } = useLazyFetch('/api/posts')
</script>
```

Migrating to the new composables from `useFetch`:

```diff
<script setup>
- import { useFetch } from '@nuxtjs/composition-api'
- const posts = ref([])
- const { fetch } = useFetch(() => { posts.value = await $fetch('/api/posts') })
+ const { data: posts, refresh } = useLazyAsyncData('posts', () => $fetch('/api/posts'))
+ // or, more simply!
+ const { data: posts, refresh } = useLazyFetch('/api/posts')
  function updatePosts() {
-   return fetch()
+   return refresh()
  }
</script>
```

### `useMeta`

In order to interact with `vue-meta`, you may use `useNuxt2Meta`, which will work in Nuxt Bridge (but not Nuxt 3) and will allow you to manipulate your meta tags in a `vue-meta`-compatible way.

```diff
<script setup>
- import { useMeta } from '@nuxtjs/composition-api'
  useNuxt2Meta({
    title: 'My Nuxt App',
  })
</script>
```

You can also pass in computed values or refs, and the meta values will be updated reactively:

```vue
<script setup>
const title = ref('my title')
useNuxt2Meta({
  title,
})
title.value = 'new title'
</script>
```

::note
Be careful not to use both `useNuxt2Meta()` and the Options API `head()` within the same component, as behavior may be unpredictable.
::

Nuxt Bridge also provides a Nuxt 3-compatible meta implementation that can be accessed with the [`useHead`](/docs/4.x/api/composables/use-head) composable.

```diff
<script setup>
- import { useMeta } from '@nuxtjs/composition-api'
  useHead({
    title: 'My Nuxt App',
  })
</script>
```

You will also need to enable it explicitly in your `nuxt.config`:

```js
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    meta: true,
  },
})
```

This [`useHead`](/docs/4.x/api/composables/use-head) composable uses `@unhead/vue` under the hood (rather than `vue-meta`) to manipulate your `<head>`. Accordingly, it is recommended not to use both the native Nuxt 2 `head()` properties as well as [`useHead`](/docs/4.x/api/composables/use-head) , as they may conflict.

For more information on how to use this composable, see [the Nuxt 3 docs](/docs/4.x/getting-started/seo-meta).

### Explicit Imports

Nuxt exposes every auto-import with the `#imports` alias that can be used to make the import explicit if needed:

```vue
<script setup lang="ts">
import { computed, ref } from '#imports'

const count = ref(1)
const double = computed(() => count.value * 2)
</script>
```

### Disabling Auto-imports

If you want to disable auto-importing composables and utilities, you can set `imports.autoImport` to `false` in the `nuxt.config` file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  imports: {
    autoImport: false,
  },
})
```

This will disable auto-imports completely but it's still possible to use [explicit imports](/docs/4.x/bridge/nuxt3-compatible-api#explicit-imports) from `#imports`.
</file>

<file path="docs/6.bridge/6.meta.md">
---
title: Meta Tags
description: 'Learn how to migrate from Nuxt 2 to Nuxt Bridge new meta tags.'
---

If you need to access the component state with `head`, you should migrate to using [`useHead`](/docs/4.x/api/composables/use-head) .

If you need to use the Options API, there is a `head()` method you can use when you use `defineNuxtComponent`.

## Migration

### Set `bridge.meta`

```js
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    meta: true,
    nitro: false, // If migration to Nitro is complete, set to true
  },
})
```

### Update head properties

In your `nuxt.config`, rename `head` to `app.head`. (Note that objects no longer have a `hid` key for deduplication.)

::code-group

```ts [Nuxt 2]
export default {
  head: {
    titleTemplate: '%s - Nuxt',
    meta: [
      { charset: 'utf-8' },
      { name: 'viewport', content: 'width=device-width, initial-scale=1' },
      { hid: 'description', name: 'description', content: 'Meta description' },
    ],
  },
}
```

```ts [Nuxt 3]
export default defineNuxtConfig({
  app: {
    head: {
      titleTemplate: '%s - Nuxt',
      meta: [
        { charset: 'utf-8' },
        { name: 'viewport', content: 'width=device-width, initial-scale=1' },
        { name: 'description', content: 'Meta description' },
      ],
    },
  },
})
```

::

## `useHead` Composables

Nuxt Bridge provides a new Nuxt 3 meta API that can be accessed with a new [`useHead`](/docs/4.x/api/composables/use-head) composable.

```vue
<script setup lang="ts">
useHead({
  title: 'My Nuxt App',
})
</script>
```

::tip
This [`useHead`](/docs/4.x/api/composables/use-head) composable uses `@unhead/vue` under the hood (rather than `vue-meta`) to manipulate your `<head>`.
::

::warning
We recommend not using the native Nuxt 2 `head()` properties in addition to [`useHead`](/docs/4.x/api/composables/use-head) , as they may conflict.
::

For more information on how to use this composable, see [the docs](/docs/4.x/getting-started/seo-meta).

## Options API

```vue
<script>
// if using options API `head` method you must use `defineNuxtComponent`
export default defineNuxtComponent({
  head (nuxtApp) {
    // `head` receives the nuxt app but cannot access the component instance
    return {
      meta: [{
        name: 'description',
        content: 'This is my page description.',
      }],
    }
  },
})
</script>
```

::warning
Possible breaking change: `head` receives the nuxt app but cannot access the component instance. If the code in your `head` tries to access the data object through `this` or `this.$data`, you will need to migrate to the `useHead` composable.
::

## Title Template

If you want to use a function (for full control), then this cannot be set in your nuxt.config, and it is recommended instead to set it within your `/layouts` directory.

```vue [app/layouts/default.vue]
<script setup lang="ts">
useHead({
  titleTemplate: (titleChunk) => {
    return titleChunk ? `${titleChunk} - Site Title` : 'Site Title'
  },
})
</script>
```
</file>

<file path="docs/6.bridge/7.runtime-config.md">
---
title: Runtime Config
description: 'Nuxt provides a runtime config API to expose configuration and secrets within your application.'
---

::warning
When using `runtimeConfig` option, [nitro](/docs/4.x/bridge/nitro) must have been configured.
::

## Update Runtime Config

Nuxt 3 approaches runtime config differently than Nuxt 2, using a new combined `runtimeConfig` option.

First, you'll need to combine your `publicRuntimeConfig` and `privateRuntimeConfig` properties into a new one called `runtimeConfig`, with the public config within a key called `public`.

```diff
// nuxt.config.js
- privateRuntimeConfig: {
-   apiKey: process.env.NUXT_API_KEY || 'super-secret-key'
- },
- publicRuntimeConfig: {
-   websiteURL: 'https://public-data.com'
- }
+ runtimeConfig: {
+   apiKey: process.env.NUXT_API_KEY || 'super-secret-key',
+   public: {
+     websiteURL: 'https://public-data.com'
+   }
+ }
```

This also means that when you need to access public runtime config, it's behind a property called `public`. If you use public runtime config, you'll need to update your code.

```diff
// MyWidget.vue
- <div>Website: {{ $config.websiteURL }}</div>
+ <div>Website: {{ $config.public.websiteURL }}</div>
```
</file>

<file path="docs/6.bridge/8.nitro.md">
---
title: Nitro
description: 'Activate Nitro to your Nuxt 2 application with Nuxt Bridge.'
---

## Remove Modules

- Remove `@nuxt/nitro`: Bridge injects same functionality

## Update Config

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    nitro: true,
  },
})
```

## Update Your Scripts

You will also need to update your scripts within your `package.json` to reflect the fact that Nuxt will now produce a Nitro server as build output.

### Install Nuxi

Install `nuxi` as a development dependency:

::code-group{sync="pm"}

```bash [npm]
npm install -D nuxi
```

```bash [yarn]
yarn add --dev nuxi
```

```bash [pnpm]
pnpm add -D nuxi
```

```bash [bun]
bun add -D nuxi
```

::

### Nuxi

Nuxt 3 introduced the new Nuxt CLI command [`nuxi`](/docs/4.x/api/commands/add). Update your scripts as follows to leverage the better support from Nuxt Bridge:

```diff
{
  "scripts": {
-   "dev": "nuxt",
+   "dev": "nuxi dev",
-   "build": "nuxt build",
+   "build": "nuxi build",
-   "start": "nuxt start",
+   "start": "nuxi preview"
  }
}
```

::tip
If `nitro: false`, use the `nuxt2` command.
::

### Static Target

If you have set `target: 'static'` in your `nuxt.config` then you need to ensure that you update your build script to be `nuxi generate`.

```json [package.json]
{
  "scripts": {
    "build": "nuxi generate"
  }
}
```

### Server Target

For all other situations, you can use the `nuxi build` command.

```json [package.json]
{
  "scripts": {
    "build": "nuxi build",
    "start": "nuxi preview"
  }
}
```

## Exclude Built Nitro Folder From Git

Add the folder `.output` to the `.gitignore` file.

## Ensure Everything Goes Well

✔️ Try with `nuxi dev` and `nuxi build` (or `nuxi generate`) to see if everything goes well.
</file>

<file path="docs/6.bridge/9.vite.md">
---
title: Vite
description: 'Activate Vite to your Nuxt 2 application with Nuxt Bridge.'
---

::warning
When using `vite`, [nitro](/docs/4.x/bridge/nitro) must have been configured.
::

## Remove Modules

- Remove `nuxt-vite`: Bridge enables same functionality

## Update Config

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    vite: true,
    nitro: true,
  },
})
```

## Configuration

```ts [nuxt.config.ts]
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  vite: {
    // Config for Vite
  },
})
```
</file>

<file path="docs/7.migration/.navigation.yml">
title: 'Migrate to Nuxt 3'
titleTemplate: 'Migrate to Nuxt 3: %s'
icon: i-lucide-circle-arrow-up
</file>

<file path="docs/7.migration/1.overview.md">
---
title: Overview
description: Nuxt 3 is a complete rewrite of Nuxt 2, and also based on a new set of underlying technologies.
---

There are significant changes when migrating a Nuxt 2 app to Nuxt 3, although you can expect migration to become more straightforward as we move toward a stable release.

::note
This migration guide is under progress to align with the development of Nuxt 3.
::

Some of these significant changes include:

1. Moving from Vue 2 to Vue 3, including defaulting to the Composition API and script setup.
1. Moving from webpack 4 and Babel to Vite or webpack 5 and esbuild.
1. Moving from a runtime Nuxt dependency to a minimal, standalone server compiled with nitropack.

::tip
If you need to remain on Nuxt 2, but want to benefit from Nuxt 3 features in Nuxt 2, you can alternatively check out [how to get started with Bridge](/docs/4.x/bridge/overview).
::

## Next Steps

- Learn about differences in [configuration](/docs/4.x/migration/configuration)
</file>

<file path="docs/7.migration/10.bundling.md">
---
title: Build Tooling
description: 'Learn how to migrate from Nuxt 2 to Nuxt 3 build tooling.'
---

We use the following build tools by default:

- [Vite](https://vite.dev) or [webpack](https://webpack.js.org)
- [Rollup](https://rollupjs.org)
- [PostCSS](https://postcss.org)
- [esbuild](https://esbuild.github.io)

For this reason, most of your previous `build` configuration in `nuxt.config` will now be ignored, including any custom babel configuration.

If you need to configure any of Nuxt's build tools, you can do so in your `nuxt.config`, using the new top-level `vite`, `webpack` and `postcss` keys.

In addition, Nuxt ships with TypeScript support.

:read-more{to="/docs/4.x/guide/concepts/typescript"}

## Steps

1. Remove `@nuxt/typescript-build` and `@nuxt/typescript-runtime` from your dependencies and modules.
2. Remove any unused babel dependencies from your project.
3. Remove any explicit core-js dependencies.
4. Migrate `require` to `import`.

<!-- TODO: Enabling webpack builder -->
</file>

<file path="docs/7.migration/11.server.md">
---
title: Server
description: 'Learn how to migrate from Nuxt 2 to Nuxt 3 server.'
---

In a built Nuxt 3 application, there is no runtime Nuxt dependency. That means your site will be highly performant, and ultra-slim. But it also means you can no longer hook into runtime Nuxt server hooks.

:read-more{to="/docs/4.x/guide/concepts/server-engine"}

## Steps

1. Remove the `render` key in your `nuxt.config`.
2. Any files in `~/server/api` and `~/server/middleware` will be automatically registered; you can remove them from your `serverMiddleware` array.
3. Update any other items in your `serverMiddleware` array to point to files or npm packages directly, rather than using inline functions.

:read-more{to="/docs/4.x/directory-structure/server"}
:read-more{to="/docs/4.x/guide/going-further/hooks#server-hooks-runtime"}
</file>

<file path="docs/7.migration/2.configuration.md">
---
title: Configuration
description: 'Learn how to migrate from Nuxt 2 to Nuxt 3 new configuration.'
---

## `nuxt.config`

The starting point for your Nuxt app remains your `nuxt.config` file.

::note
Nuxt configuration will be loaded using [`unjs/jiti`](https://github.com/unjs/jiti) and [`unjs/c12`](https://github.com/unjs/c12).
::

### Migration

1. You should migrate to the new `defineNuxtConfig` function that provides a typed configuration schema.

   ::code-group

   ```ts [Nuxt 2]
   export default {
     // ...
   }
   ```

   ```ts [Nuxt 3]
   export default defineNuxtConfig({
     // ...
   })
   ```

   ::

1. If you were using `router.extendRoutes` you can migrate to the new `pages:extend` hook:

   ::code-group

   ```ts [Nuxt 2]
   export default {
     router: {
       extendRoutes (routes) {
         //
       },
     },
   }
   ```

   ```ts [Nuxt 3]
   export default defineNuxtConfig({
     hooks: {
       'pages:extend' (routes) {
         //
       },
     },
   })
   ```

   ::

1. If you were using `router.routeNameSplitter` you can achieve same result by updating route name generation logic in the new `pages:extend` hook:

   ::code-group

   ```ts [Nuxt 2]
   export default {
     router: {
       routeNameSplitter: '/',
     },
   }
   ```

   ```ts [Nuxt 3]
   import { createResolver } from '@nuxt/kit'

   export default defineNuxtConfig({
     hooks: {
       'pages:extend' (routes) {
         const routeNameSplitter = '/'
         const root = createResolver(import.meta.url).resolve('./pages')

         function updateName (routes) {
           if (!routes) {
             return
           }

           for (const route of routes) {
             const relativePath = route.file.substring(root.length + 1)
             route.name = relativePath.slice(0, -4).replace(/\/index$/, '').replace(/\//g, routeNameSplitter)

             updateName(route.children)
           }
         }
         updateName(routes)
       },
     },
   })
   ```

   ::

#### ESM Syntax

Nuxt 3 is an [ESM native framework](/docs/4.x/guide/concepts/esm). Although [`unjs/jiti`](https://github.com/unjs/jiti) provides semi compatibility when loading `nuxt.config` file, avoid any usage of `require` and `module.exports` in this file.

1. Change `module.exports` to `export default`
1. Change `const lib = require('lib')` to `import lib from 'lib'`

#### Async Configuration

In order to make Nuxt loading behavior more predictable, async config syntax is deprecated. Consider using Nuxt hooks for async operations.

#### Dotenv

Nuxt has built-in support for loading `.env` files. Avoid directly importing it from `nuxt.config`.

## Modules

Nuxt and Nuxt modules are now build-time-only.

### Migration

1. Move all your `buildModules` into `modules`.
2. Check for Nuxt 3 compatibility of modules.
3. If you have any local modules pointing to a directory you should update this to point to the entry file:

```diff
  export default defineNuxtConfig({
    modules: [
-     '~/modules/my-module'
+     '~/modules/my-module/index'
    ]
  })
```

::tip
If you are a module author, you can check out [more information about module compatibility](/docs/4.x/migration/module-authors) and [our module author guide](/docs/4.x/guide/modules).
::

## Directory Changes

The `static/` (for storing static assets) has been renamed to `public/`. You can either rename your `static` directory to `public`, or keep the name by setting `dir.public` in your `nuxt.config`.

:read-more{to="/docs/4.x/directory-structure/public"}

## TypeScript

It will be much easier to migrate your application if you use Nuxt's TypeScript integration. This does not mean you need to write your application in TypeScript, just that Nuxt will provide automatic type hints for your editor.

You can read more about Nuxt's TypeScript support [in the docs](/docs/4.x/guide/concepts/typescript).

::note
Nuxt can type-check your app using [`vue-tsc`](https://github.com/vuejs/language-tools/tree/master/packages/tsc) with `nuxt typecheck` command.
::

### Migration

1. Create a `tsconfig.json` with the following content:

   ```json
   {
     "files": [],
     "references": [
       {
         "path": "./.nuxt/tsconfig.app.json"
       },
       {
         "path": "./.nuxt/tsconfig.server.json"
       },
       {
         "path": "./.nuxt/tsconfig.shared.json"
       },
       {
         "path": "./.nuxt/tsconfig.node.json"
       }
     ]
   }
   ```

1. Run `npx nuxt prepare` to generate the tsconfig files.
1. Install Volar following the instructions in the [docs](/docs/4.x/getting-started/installation#prerequisites).

## Vue Changes

There are a number of changes to what is recommended Vue best practice, as well as a number of breaking changes between Vue 2 and 3.

It is recommended to read the [Vue 3 migration guide](https://v3-migration.vuejs.org) and in particular the [breaking changes list](https://v3-migration.vuejs.org/breaking-changes/).

It is not currently possible to use the [Vue 3 migration build](https://v3-migration.vuejs.org/migration-build.html) with Nuxt 3.

## Vuex

Nuxt no longer provides a Vuex integration. Instead, the official Vue recommendation is to use `pinia`, which has built-in Nuxt support via a [Nuxt module](https://pinia.vuejs.org/ssr/nuxt.html). [Find out more about pinia here](https://pinia.vuejs.org).

A simple way to provide global state management with pinia would be:

Install the [`@pinia/nuxt`](/modules/pinia) module:

```bash [Terminal]
yarn add pinia @pinia/nuxt
```

Enable the module in your nuxt configuration:

```ts [nuxt.config.ts]
import { defineNuxtConfig } from 'nuxt/config'

export default defineNuxtConfig({
  modules: ['@pinia/nuxt'],
})
```

Create a `store` folder at the root of your application:

```ts [store/index.ts]
import { defineStore } from 'pinia'

export const useMainStore = defineStore('main', {
  state: () => ({
    counter: 0,
  }),
  actions: {
    increment () {
      // `this` is the store instance
      this.counter++
    },
  },
})
```

Create a [plugin](/docs/4.x/directory-structure/app/plugins) file to globalize your store:

```ts [app/plugins/pinia.ts]
import { useMainStore } from '~/store'

export default defineNuxtPlugin(({ $pinia }) => {
  return {
    provide: {
      store: useMainStore($pinia),
    },
  }
})
```

If you want to keep using Vuex, you can manually migrate to Vuex 4 following [these steps](https://vuex.vuejs.org/guide/migrating-to-4-0-from-3-x.html).

Once it's done you will need to add the following plugin to your Nuxt app:

```ts [app/plugins/vuex.ts]
import store from '~/store'

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(store)
})
```

For larger apps, this migration can entail a lot of work. If updating Vuex still creates roadblocks, you may want to use the community module: [nuxt3-vuex-module](https://github.com/vedmant/nuxt3-vuex#nuxt3-vuex-module), which should work out of the box.
</file>

<file path="docs/7.migration/20.module-authors.md">
---
title: Modules
description: 'Learn how to migrate from Nuxt 2 to Nuxt 3 modules.'
---

## Module Compatibility

Nuxt 3 has a basic backward compatibility layer for Nuxt 2 modules using `@nuxt/kit` auto wrappers. But there are usually steps to follow to make modules compatible with Nuxt 3 and sometimes, using Nuxt Bridge is required for cross-version compatibility.

We have prepared a [Dedicated Guide](/docs/4.x/guide/modules) for authoring Nuxt 3 ready modules using `@nuxt/kit`. Currently best migration path is to follow it and rewrite your modules. Rest of this guide includes preparation steps if you prefer to avoid a full rewrite yet making modules compatible with Nuxt 3.

::tip{icon="i-lucide-puzzle" to="/modules"}
Explore Nuxt 3 compatible modules.
::

### Plugin Compatibility

Nuxt 3 plugins are **not** fully backward compatible with Nuxt 2.

:read-more{to="/docs/4.x/directory-structure/app/plugins"}

### Vue Compatibility

Plugins or components using the Composition API need exclusive Vue 2 or Vue 3 support.

By using [vue-demi](https://github.com/vueuse/vue-demi) they should be compatible with both Nuxt 2 and 3.

## Module Migration

When Nuxt 3 users add your module, you will not have access to the module container (`this.*`) so you will need to use utilities from `@nuxt/kit` to access the container functionality.

### Test with `@nuxt/bridge`

Migrating to `@nuxt/bridge` is the first and most important step for supporting Nuxt 3.

If you have a fixture or example in your module, add `@nuxt/bridge` package to its config (see [example](/docs/4.x/bridge/overview#update-nuxtconfig))

### Migrate from CommonJS to ESM

Nuxt 3 natively supports TypeScript and ECMAScript Modules. Please check [Native ES Modules](/docs/4.x/guide/concepts/esm) for more info and upgrading.

### Ensure Plugins Default Export

If you inject a Nuxt plugin that does not have `export default` (such as global Vue plugins), ensure you add `export default () => { }` to the end of it.

::code-group

```js [Before]
// ~/plugins/vuelidate.js
import Vue from 'vue'
import Vuelidate from 'vuelidate'

Vue.use(Vuelidate)
```

```js [After]
// ~/plugins/vuelidate.js
import Vue from 'vue'
import Vuelidate from 'vuelidate'

Vue.use(Vuelidate)

export default () => { }
```

::

### Avoid Runtime Modules

With Nuxt 3, Nuxt is now a build-time-only dependency, which means that modules shouldn't attempt to hook into the Nuxt runtime.

Your module should work even if it's only added to [`buildModules`](/docs/4.x/api/nuxt-config#runtimeconfig) (instead of `modules`). For example:

- Avoid updating `process.env` within a Nuxt module and reading by a Nuxt plugin; use [`runtimeConfig`](/docs/4.x/api/nuxt-config#runtimeconfig) instead.
- (*) Avoid depending on runtime hooks like `vue-renderer:*` for production
- (*) Avoid adding `serverMiddleware` by importing them inside the module. Instead, add them by referencing a file path so that they are independent of the module's context

(*) Unless it is for `nuxt dev` purpose only and guarded with `if (nuxt.options.dev) { }`.

::tip
Continue reading about Nuxt 3 modules in the [Modules Author Guide](/docs/4.x/guide/modules).
::

### Use TypeScript (Optional)

While it is not essential, most of the Nuxt ecosystem is shifting to use TypeScript, so it is highly recommended to consider migration.

::tip
You can start migration by renaming `.js` files, to `.ts`. TypeScript is designed to be progressive!
::

::tip
You can use TypeScript syntax for Nuxt 2 and 3 modules and plugins without any extra dependencies.
::
</file>

<file path="docs/7.migration/3.auto-imports.md">
---
title: Auto Imports
description:  Nuxt 3 adopts a minimal friction approach, meaning wherever possible components and composables are auto-imported.
---

::note
In the rest of the migration documentation, you will notice that key Nuxt and Vue utilities do not have explicit imports. This is not a typo; Nuxt will automatically import them for you, and you should get full type hinting if you have followed [the instructions](/docs/4.x/migration/configuration#typescript) to use Nuxt's TypeScript support.
::

[Read more about auto imports](/docs/4.x/guide/concepts/auto-imports)

## Migration

1. If you have been using `@nuxt/components` in Nuxt 2, you can remove `components: true` in your `nuxt.config`. If you had a more complex setup, then note that the component options have changed somewhat. See the [components documentation](/docs/4.x/directory-structure/app/components) for more information.

::tip
You can look at `.nuxt/types/components.d.ts` and `.nuxt/types/imports.d.ts` to see how Nuxt has resolved your components and composable auto-imports.
::
</file>

<file path="docs/7.migration/4.meta.md">
---
title: Meta Tags
description: Manage your meta tags, from Nuxt 2 to Nuxt 3.
---

Nuxt 3 provides several different ways to manage your meta tags:
1. Through your `nuxt.config`.
2. Through the [`useHead`](/docs/4.x/api/composables/use-head) [composable](/docs/4.x/getting-started/seo-meta)
3. Through [global meta components](/docs/4.x/getting-started/seo-meta)

You can customize `title`, `titleTemplate`, `base`, `script`, `noscript`, `style`, `meta`, `link`, `htmlAttrs` and `bodyAttrs`.

::tip
Nuxt currently uses [`Unhead`](https://github.com/unjs/unhead) to manage your meta tags, but implementation details may change.
::

:read-more{to="/docs/4.x/getting-started/seo-meta"}

## Migration

1. In your `nuxt.config`, rename `head` to `meta`. Consider moving this shared meta configuration into your `app.vue` instead. (Note that objects no longer have a `hid` key for deduplication.)
2. If you need to access the component state with `head`, you should migrate to using [`useHead`](/docs/4.x/api/composables/use-head) . You might also consider using the built-in meta-components.
3. If you need to use the Options API, there is a `head()` method you can use when you use `defineNuxtComponent`.

### useHead

::code-group

```vue [Nuxt 2]
<script>
export default {
  data: () => ({
    title: 'My App',
    description: 'My App Description',
  }),
  head () {
    return {
      title: this.title,
      meta: [{
        hid: 'description',
        name: 'description',
        content: this.description,
      }],
    }
  },
}
</script>
```

```vue [Nuxt 3]
<script setup lang="ts">
const title = ref('My App')
const description = ref('My App Description')

// This will be reactive when you change title/description above
useHead({
  title,
  meta: [{
    name: 'description',
    content: description,
  }],
})
</script>
```

::

### Meta-components

Nuxt 3 also provides meta components that you can use to accomplish the same task. While these components look similar to HTML tags, they are provided by Nuxt and have similar functionality.

::code-group

```vue [Nuxt 2]
<script>
export default {
  head () {
    return {
      title: 'My App',
      meta: [{
        hid: 'description',
        name: 'description',
        content: 'My App Description',
      }],
    }
  },
}
</script>
```

```vue [Nuxt 3]
<template>
  <div>
    <Head>
      <Title>My App</Title>
      <Meta
        name="description"
        content="My app description"
      />
    </Head>
    <!-- -->
  </div>
</template>
```

::

::important
1. Make sure you use capital letters for these component names to distinguish them from native HTML elements (`<Title>` rather than `<title>`).
2. You can place these components anywhere in your template for your page.
::

### Options API

```vue [Nuxt 3 (Options API)]
<script>
// if using options API `head` method you must use `defineNuxtComponent`
export default defineNuxtComponent({
  head (nuxtApp) {
    // `head` receives the nuxt app but cannot access the component instance
    return {
      meta: [{
        name: 'description',
        content: 'This is my page description.',
      }],
    }
  },
})
</script>
```
</file>

<file path="docs/7.migration/5.plugins-and-middleware.md">
---
title: Plugins and Middleware
description: 'Learn how to migrate from Nuxt 2 to Nuxt 3 plugins and middleware.'
---

## Plugins

Plugins now have a different format, and take only one argument (`nuxtApp`).

::code-group

```ts [Nuxt 2]
export default (ctx, inject) => {
  inject('injected', () => 'my injected function')
}
```

```ts [Nuxt 3]
export default defineNuxtPlugin((nuxtApp) => {
  // now available on `nuxtApp.$injected`
  nuxtApp.provide('injected', () => 'my injected function')

  // You can alternatively use this format, which comes with automatic type support
  return {
    provide: {
      injected: () => 'my injected function',
    },
  }
})
```

::

:read-more{to="/docs/4.x/directory-structure/app/plugins"}

::read-more{to="/docs/4.x/api/composables/use-nuxt-app"}
Read more about the format of `nuxtApp`.
::

### Migration

1. Migrate your plugins to use the `defineNuxtPlugin` helper function.
2. Remove any entries in your `nuxt.config` plugins array that are located in your `app/plugins/` folder. All files in this directory at the top level (and any index files in any subdirectories) will be automatically registered. Instead of setting `mode` to `client` or `server`, you can indicate this in the file name. For example, `~/plugins/my-plugin.client.ts` will only be loaded on client-side.

## Route Middleware

Route middleware has a different format.

::code-group

```js [Nuxt 2]
export default function ({ store, redirect }) {
  // If the user is not authenticated
  if (!store.state.authenticated) {
    return redirect('/login')
  }
}
```

```ts [Nuxt 3]
export default defineNuxtRouteMiddleware((to, from) => {
  const auth = useState('auth')
  if (!auth.value.authenticated) {
    return navigateTo('/login')
  }
})
```

::

Much like Nuxt 2, route middleware placed in your `~/middleware` folder is automatically registered. You can then specify it by name in a component. However, this is done with `definePageMeta` rather than as a component option.

`navigateTo` is one of a number of route helper functions.

:read-more{to="/docs/4.x/directory-structure/app/middleware"}

### Migration

1. Migrate your route middleware to use the `defineNuxtRouteMiddleware` helper function.
1. Any global middleware (such as in your `nuxt.config`) can be placed in your `~/middleware` folder with a `.global` extension, for example `~/middleware/auth.global.ts`.
</file>

<file path="docs/7.migration/6.pages-and-layouts.md">
---
title: Pages and Layouts
description: Learn how to migrate from Nuxt 2 to Nuxt 3 pages and layouts.
---

## `app.vue`

Nuxt 3 provides a central entry point to your app via `~/app.vue`.

::note
If you don't have an `app.vue` file in your source directory, Nuxt will use its own default version.
::

This file is a great place to put any custom code that needs to be run once when your app starts up, as well as any components that are present on every page of your app. For example, if you only have one layout, you can move this to `app.vue` instead.

:read-more{to="/docs/4.x/directory-structure/app/app"}

:link-example{to="/docs/4.x/examples/hello-world"}

### Migration

Consider creating an `app.vue` file and including any logic that needs to run once at the top-level of your app. You can check out [an example here](/docs/4.x/directory-structure/app/app).

## Layouts

If you are using layouts in your app for multiple pages, there is only a slight change required.

In Nuxt 2, the `<Nuxt>` component is used within a layout to render the current page. In Nuxt 3, layouts use slots instead, so you will have to replace that component with a `<slot />`. This also allows advanced use cases with named and scoped slots. [Read more about layouts](/docs/4.x/directory-structure/app/layouts).

You will also need to change how you define the layout used by a page using the `definePageMeta` compiler macro. Layouts will be kebab-cased. So `app/layouts/customLayout.vue` becomes `custom-layout` when referenced in your page.

### Migration

1. Replace `<Nuxt />` with `<slot />`
    ```diff [app/layouts/custom.vue]
      <template>
        <div id="app-layout">
          <main>
    -       <Nuxt />
    +       <slot />
          </main>
        </div>
      </template>
    ```
2. Use [`definePageMeta`](/docs/4.x/api/utils/define-page-meta) to select the layout used by your page.
    ```diff [app/pages/index.vue]
    + <script setup>
    + definePageMeta({
    +   layout: 'custom'
    + })
    - <script>
    - export default {
    -   layout: 'custom'
    - }
      </script>
    ```
3. Move `~/layouts/_error.vue` to `~/error.vue`. See [the error handling docs](/docs/4.x/getting-started/error-handling). If you want to ensure that this page uses a layout, you can use [`<NuxtLayout>`](/docs/4.x/directory-structure/app/layouts) directly within `error.vue`:
    ```vue [error.vue]
    <template>
      <div>
        <NuxtLayout name="default">
          <!-- -->
        </NuxtLayout>
      </div>
    </template>
    ```

## Pages

Nuxt 3 ships with an optional `vue-router` integration triggered by the existence of a [`app/pages/`](/docs/4.x/directory-structure/app/pages) directory in your source directory. If you only have a single page, you may consider instead moving it to `app.vue` for a lighter build.

### Dynamic Routes

The format for defining dynamic routes in Nuxt 3 is slightly different from Nuxt 2, so you may need to rename some of the files within `app/pages/`.

1. Where you previously used `_id` to define a dynamic route parameter you now use `[id]`.
2. Where you previously used `_.vue` to define a catch-all route, you now use `[...slug].vue`.

### Nested Routes

In Nuxt 2, you will have defined any nested routes (with parent and child components) using `<Nuxt>` and `<NuxtChild>`. In Nuxt 3, these have been replaced with a single `<NuxtPage>` component.

### Page Keys and Keep-alive Props

If you were passing a custom page key or keep-alive props to `<Nuxt>`, you will now use `definePageMeta` to set these options.

:read-more{to="/docs/4.x/directory-structure/app/pages#special-metadata"}

### Page and Layout Transitions

If you have been defining transitions for your page or layout directly in your component options, you will now need to use `definePageMeta` to set the transition. Since Vue 3, [-enter and -leave CSS classes have been renamed](https://v3-migration.vuejs.org/breaking-changes/transition.html). The `style` prop from `<Nuxt>` no longer applies to transition when used on `<slot>`, so move the styles to your `-active` class.

:read-more{to="/docs/4.x/getting-started/transitions"}

### Migration

1. Rename any pages with dynamic parameters to match the new format.
2. Update `<Nuxt>` and `<NuxtChild>` to be `<NuxtPage>`.
3. If you're using the Composition API, you can also migrate `this.$route` and `this.$router` to use [`useRoute`](/docs/4.x/api/composables/use-route) and [`useRouter`](/docs/4.x/api/composables/use-router)  composables.

#### Example: Dynamic Routes

::code-group

``` [Nuxt 2]
- URL: /users
- Page: /pages/users/index.vue

- URL: /users/some-user-name
- Page: /pages/users/_user.vue
- Usage: params.user

- URL: /users/some-user-name/edit
- Page: /pages/users/_user/edit.vue
- Usage: params.user

- URL: /users/anything-else
- Page: /pages/users/_.vue
- Usage: params.pathMatch
```

``` [Nuxt 3]
- URL: /users
- Page: /pages/users/index.vue

- URL: /users/some-user-name
- Page: /pages/users/[user].vue
- Usage: params.user

- URL: /users/some-user-name/edit
- Page: /pages/users/[user]/edit.vue
- Usage: params.user

- URL: /users/anything-else
- Page: /pages/users/[...slug].vue
- Usage: params.slug
```

::

#### Example: Nested Routes and `definePageMeta`

::code-group

```vue [Nuxt 2]
<template>
  <div>
    <NuxtChild
      keep-alive
      :keep-alive-props="{ exclude: ['modal'] }"
      :nuxt-child-key="$route.slug"
    />
  </div>
</template>

<script>
export default {
  transition: 'page', // or { name: 'page' }
}
</script>
```

```vue [Nuxt 3]
<template>
  <div>
    <NuxtPage />
  </div>
</template>

<script setup lang="ts">
// This compiler macro works in both <script> and <script setup>
definePageMeta({
  // you can also pass a string or a computed property
  key: route => route.slug,
  transition: {
    name: 'page',
  },
  keepalive: {
    exclude: ['modal'],
  },
})
</script>
```

::

## `<NuxtLink>` Component

Most of the syntax and functionality are the same for the global [NuxtLink](/docs/4.x/api/components/nuxt-link) component. If you have been using the shortcut `<NLink>` format, you should update this to use `<NuxtLink>`.

`<NuxtLink>` is now a drop-in replacement for _all_ links, even external ones. You can read more about it, and how to extend it to provide your own link component.

:read-more{to="/docs/4.x/api/components/nuxt-link"}

## Programmatic Navigation

When migrating from Nuxt 2 to Nuxt 3, you will have to update how you programmatically navigate your users. In Nuxt 2, you had access to the underlying Vue Router with `this.$router`. In Nuxt 3, you can use the `navigateTo()` utility method which allows you to pass a route and parameters to Vue Router.

::warning
Make sure to always `await` on [`navigateTo`](/docs/4.x/api/utils/navigate-to) or chain its result by returning from functions.
::

::code-group

```vue [Nuxt 2]
<script>
export default {
  methods: {
    navigate () {
      this.$router.push({
        path: '/search',
        query: {
          name: 'first name',
          type: '1',
        },
      })
    },
  },
}
</script>
```

```vue [Nuxt 3]
<script setup lang="ts">
function navigate () {
  return navigateTo({
    path: '/search',
    query: {
      name: 'first name',
      type: '1',
    },
  })
}
</script>
```

::
</file>

<file path="docs/7.migration/7.component-options.md">
---
title: Component Options
description: 'Learn how to migrate from Nuxt 2 components options to Nuxt 3 composables.'
---

## `asyncData` and `fetch`

Nuxt 3 provides new options for [fetching data from an API](/docs/4.x/getting-started/data-fetching).

<!-- TODO: Intro to <script setup> -->
<!-- TODO: Mention about options compatibility with asyncData -->

### Isomorphic Fetch

In Nuxt 2 you might use `@nuxtjs/axios` or `@nuxt/http` to fetch your data - or just the polyfilled global `fetch`.

In Nuxt 3 you can use a globally available `fetch` method that has the same API as [the Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) or [`$fetch`](/docs/4.x/api/utils/dollarfetch) method which is using [unjs/ofetch](https://github.com/unjs/ofetch). It has a number of benefits, including:

1. It will handle 'smartly' making [direct API calls](/docs/4.x/guide/concepts/server-engine#direct-api-calls) if it's running on the server, or making a client-side call to your API if it's running on the client. (It can also handle calling third-party APIs.)

2. Plus, it comes with convenience features including automatically parsing responses and stringifying data.

You can read more [about direct API calls](/docs/4.x/guide/concepts/server-engine#direct-api-calls) or [fetching data](/docs/4.x/getting-started/data-fetching).

### Composables

Nuxt 3 provides new composables for fetching data: [`useAsyncData`](/docs/4.x/api/composables/use-async-data) and `useFetch`. They each have 'lazy' variants (`useLazyAsyncData` and `useLazyFetch`), which do not block client-side navigation.

In Nuxt 2, you'd fetch your data in your component using a syntax similar to:

```ts
export default {
  async asyncData ({ params, $http }) {
    const post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)
    return { post }
  },
  // or alternatively
  fetch () {
    this.post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)
  },
}
```

Within your methods and templates, you could use the `post` variable similar how you'd use any other piece of data provided by your component.

With Nuxt 3, you can perform this data fetching using composables in your `setup()` method or `<script setup>` tag:

```vue
<script setup lang="ts">
// Define params wherever, through `defineProps()`, `useRoute()`, etc.
const { data: post, refresh } = await useAsyncData('post', () => $fetch(`https://api.nuxtjs.dev/posts/${params.id}`))
// Or instead - useFetch is a convenience wrapper around useAsyncData when you're just performing a simple fetch
const { data: post, refresh } = await useFetch(`https://api.nuxtjs.dev/posts/${params.id}`)
</script>
```

You can now use `post` inside of your Nuxt 3 template, or call `refresh` to update the data.

::note
Despite the names, [`useFetch`](/docs/4.x/api/composables/use-fetch) is not a direct replacement of the `fetch()` hook. Rather, [`useAsyncData`](/docs/4.x/api/composables/use-async-data) replaces both hooks and is more customizable; it can do more than simply fetching data from an endpoint. [`useFetch`](/docs/4.x/api/composables/use-fetch) is a convenience wrapper around [`useAsyncData`](/docs/4.x/api/composables/use-async-data) for simply fetching data from an endpoint.
::

### Migration

1. Replace the `asyncData` hook with [`useAsyncData`](/docs/4.x/api/composables/use-async-data) or [`useFetch`](/docs/4.x/api/composables/use-fetch) in your page/component.
2. Replace the `fetch` hook with [`useAsyncData`](/docs/4.x/api/composables/use-async-data) or [`useFetch`](/docs/4.x/api/composables/use-fetch) in your component.

## `head`

:read-more{to="/docs/4.x/migration/meta"}

## `key`

You can now define a key within the [`definePageMeta`](/docs/4.x/api/utils/define-page-meta) compiler macro.

```diff [app/pages/index.vue]
- <script>
- export default {
-   key: 'index'
-   // or a method
-   // key: route => route.fullPath
- }
+ <script setup>
+ definePageMeta({
+   key: 'index'
+   // or a method
+   // key: route => route.fullPath
+ })
</script>
```

## `layout`

:read-more{to="/docs/4.x/migration/pages-and-layouts"}

## `loading`

This feature is not yet supported in Nuxt 3.

## `middleware`

:read-more{to="/docs/4.x/migration/plugins-and-middleware"}

## `scrollToTop`

This feature is not yet supported in Nuxt 3. If you want to overwrite the default scroll behavior of `vue-router`, you can do so in an `~/router.options.ts` (see [docs](/docs/4.x/guide/recipes/custom-routing#router-options)) for more info.
Similar to `key`, specify it within the [`definePageMeta`](/docs/4.x/api/utils/define-page-meta) compiler macro.

```diff [app/pages/index.vue]
- <script>
- export default {
-   scrollToTop: false
- }
+ <script setup>
+ definePageMeta({
+   scrollToTop: false
+ })
</script>
```

## `transition`

:read-more{to="/docs/4.x/getting-started/transitions"}

## `validate`

The validate hook in Nuxt 3 only accepts a single argument, the `route`. Just as in Nuxt 2, you can return a boolean value. If you return false and another match can't be found, this will mean a 404. You can also directly return an object with `status`/`statusText` to respond immediately with an error (other matches will not be checked).

```diff [app/pages/users/[id\\].vue]
- <script>
- export default {
-   async validate({ params }) {
-     return /^\d+$/.test(params.id)
-   }
- }
+ <script setup>
+ definePageMeta({
+   validate: async (route) => {
+     const nuxtApp = useNuxtApp()
+     return /^\d+$/.test(route.params.id)
+   }
+ })
  </script>
```

## `watchQuery`

This is not supported in Nuxt 3. Instead, you can directly use a watcher to trigger refetching data.

```vue [app/pages/users/[id\\].vue]
<script setup lang="ts">
const route = useRoute()
const { data, refresh } = await useFetch('/api/user')
watch(() => route.query, () => refresh())
</script>
```
</file>

<file path="docs/7.migration/8.runtime-config.md">
---
title: Runtime Config
description: 'Learn how to migrate from Nuxt 2 to Nuxt 3 runtime config.'
---

If you wish to reference environment variables within your Nuxt 3 app, you will need to use runtime config.

When referencing these variables within your components, you will have to use the [`useRuntimeConfig`](/docs/4.x/api/composables/use-runtime-config) composable in your setup method (or Nuxt plugin).

In the `server/` portion of your app, you can use [`useRuntimeConfig`](/docs/4.x/api/composables/use-runtime-config) without any import.

:read-more{to="/docs/4.x/guide/going-further/runtime-config"}

## Migration

1. Add any environment variables that you use in your app to the `runtimeConfig` property of the `nuxt.config` file.
2. Migrate `process.env` to [`useRuntimeConfig`](/docs/4.x/api/composables/use-runtime-config) throughout the Vue part of your app.

::code-group

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  runtimeConfig: {
    // Private config that is only available on the server
    apiSecret: '123',
    // Config within public will be also exposed to the client
    public: {
      apiBase: '/api',
    },
  },
})
```

```vue [app/pages/index.vue]
<script setup lang="ts">
const config = useRuntimeConfig()

// instead of process.env you will now access config.public.apiBase
console.log(config.public.apiBase)
</script>
```

```ts [server/api/hello.ts]
export default defineEventhandler((event) => {
  const config = useRuntimeConfig(event)
  // In server, you can now access config.apiSecret, in addition to config.public
  console.log(config.apiSecret)
  console.log(config.public.apiBase)
})
```

```ini [.env]
# Runtime config values are automatically replaced by matching environment variables at runtime
NUXT_API_SECRET=api_secret_token
NUXT_PUBLIC_API_BASE=https://nuxtjs.org
```

::
</file>

<file path="docs/.navigation.yml">
title: Docs
icon: i-lucide-book-marked
</file>

<file path="docs/package.json">
{
  "name": "@nuxt/docs",
  "version": "4.2.2",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nuxt/nuxt.git",
    "directory": "docs"
  },
  "homepage": "https://nuxt.com",
  "description": "Documentation for Nuxt in raw markdown",
  "license": "MIT",
  "type": "module",
  "exports": {
    "./*": "./*"
  },
  "files": [
    "**/*.md",
    "**/*.yml"
  ]
}
</file>

<file path="docs/README.md">
---
navigation: false
---

# Nuxt Docs

This repository contains the documentation of Nuxt, hosted on <https://nuxt.com/docs/4.x/getting-started/introduction>

## Contributing

Have a look at <https://github.com/nuxt/nuxt.com> to run the website locally.
</file>

<file path="examples/README.md">
# Nuxt Examples

- 👉 See examples in your browser at https://nuxt.com/docs/4.x/examples
- 👉 View on GitHub at https://github.com/nuxt/examples
</file>

<file path="packages/kit/src/internal/esm.ts">
import { pathToFileURL } from 'node:url'
import { interopDefault } from 'mlly'
import { resolveModulePath } from 'exsolve'
import { createJiti } from 'jiti'
import { getUserCaller, warn } from './trace.ts'
import { resolveAlias } from '../resolve.ts'

export interface ResolveModuleOptions {
  /** @deprecated use `url` with URLs pointing at a file - never a directory */
  paths?: string | string[]
  url?: URL | URL[]
  /** @default ['.js', '.mjs', '.cjs', '.ts', '.mts', '.cts'] */
  extensions?: string[]
}

export function directoryToURL (dir: string): URL {
  return pathToFileURL(dir + '/')
}

/**
 * Resolve a module from a given root path using an algorithm patterned on
 * the upcoming `import.meta.resolve`. It returns a file URL
 *
 * @internal
 */
export async function tryResolveModule (id: string, url: URL | URL[]): Promise<string | undefined>
/** @deprecated pass URLs pointing at files */
export function tryResolveModule (id: string, url: string | string[]): Promise<string | undefined>
export function tryResolveModule (id: string, url: string | string[] | URL | URL[] = import.meta.url) {
  return Promise.resolve(resolveModulePath(id, {
    from: url,
    suffixes: ['', 'index'],
    try: true,
  }))
}

export function resolveModule (id: string, options?: ResolveModuleOptions): string {
  return resolveModulePath(id, {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    from: options?.url ?? options?.paths ?? [import.meta.url],
    extensions: options?.extensions ?? ['.js', '.mjs', '.cjs', '.ts', '.mts', '.cts'],
  })
}

export interface ImportModuleOptions extends ResolveModuleOptions {
  /** Automatically de-default the result of requiring the module. */
  interopDefault?: boolean
}

export async function importModule<T = unknown> (id: string, opts?: ImportModuleOptions): Promise<T> {
  const resolvedPath = resolveModule(id, opts)
  return await import(pathToFileURL(resolvedPath).href).then(r => opts?.interopDefault !== false ? interopDefault(r) : r) as Promise<T>
}

export function tryImportModule<T = unknown> (id: string, opts?: ImportModuleOptions): Promise<T | undefined> | undefined {
  try {
    return importModule<T>(id, opts).catch(() => undefined)
  } catch {
    // intentionally empty as this is a `try-` function
  }
}

/**
 * @deprecated Please use `importModule` instead.
 */
export function requireModule<T = unknown> (id: string, opts?: ImportModuleOptions) {
  const caller = getUserCaller()
  const explanation = caller ? ` (used at \`${resolveAlias(caller.source)}:${caller.line}:${caller.column}\`)` : ''
  const warning = `[@nuxt/kit] \`requireModule\` is deprecated${explanation}. Please use \`importModule\` instead.`
  warn(warning)
  const resolvedPath = resolveModule(id, opts)
  const jiti = createJiti(import.meta.url, {
    interopDefault: opts?.interopDefault !== false,
  })
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  return jiti(pathToFileURL(resolvedPath).href) as T
}

/**
 * @deprecated Please use `tryImportModule` instead.
 */
export function tryRequireModule<T = unknown> (id: string, opts?: ImportModuleOptions): T | undefined {
  try {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    return requireModule<T>(id, opts)
  } catch {
    // intentionally empty as this is a `try-` function
  }
}
</file>

<file path="packages/kit/src/internal/trace.ts">
import { captureStackTrace } from 'errx'

const distURL = import.meta.url.replace(/\/dist\/.*$/, '/')

export function getUserCaller () {
  if (!import.meta.dev) {
    return null
  }

  const { source, line, column } = captureStackTrace().find(entry => !entry.source.startsWith(distURL)) ?? {}

  if (!source) {
    return null
  }

  return {
    source: source.replace(/^file:\/\//, ''),
    line,
    column,
  }
}

const warnings = new Set<string>()

export function warn (warning: string) {
  if (!warnings.has(warning)) {
    console.warn(warning)
    warnings.add(warning)
  }
}
</file>

<file path="packages/kit/src/loader/config.ts">
import { existsSync } from 'node:fs'
import process from 'node:process'
import type { JSValue } from 'untyped'
import { applyDefaults } from 'untyped'
import type { ConfigLayer, ConfigLayerMeta, LoadConfigOptions } from 'c12'
import { loadConfig } from 'c12'
import type { NuxtConfig, NuxtOptions } from '@nuxt/schema'
import { glob } from 'tinyglobby'
import { createDefu, defu } from 'defu'
import { basename, join, relative } from 'pathe'
import { resolveModuleURL } from 'exsolve'
import { withTrailingSlash, withoutTrailingSlash } from 'ufo'

import { directoryToURL } from '../internal/esm.ts'

export interface LoadNuxtConfigOptions extends Omit<LoadConfigOptions<NuxtConfig>, 'overrides'> {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  overrides?: Exclude<LoadConfigOptions<NuxtConfig>['overrides'], Promise<any> | Function>
}

const merger = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = obj[key].concat(value)
    return true
  }
})

export async function loadNuxtConfig (opts: LoadNuxtConfigOptions): Promise<NuxtOptions> {
  // Automatically detect and import layers from `~~/layers/` directory
  const localLayers = (await glob('layers/*', {
    onlyDirectories: true, cwd: opts.cwd || process.cwd(),
  }))
    .map((d: string) => withTrailingSlash(d))
    .sort((a, b) => b.localeCompare(a))
  opts.overrides = defu(opts.overrides, { _extends: localLayers })

  const { configFile, layers = [], cwd, config: nuxtConfig, meta } = await withDefineNuxtConfig(
    () => loadConfig<NuxtConfig>({
      name: 'nuxt',
      configFile: 'nuxt.config',
      rcFile: '.nuxtrc',
      extend: { extendKey: ['theme', '_extends', 'extends'] },
      dotenv: true,
      globalRc: true,
      // @ts-expect-error TODO: fix type in c12, it should accept createDefu directly
      merger,
      ...opts,
    }),
  )

  // Fill config
  nuxtConfig.rootDir ||= cwd
  nuxtConfig._nuxtConfigFile = configFile
  nuxtConfig._nuxtConfigFiles = [configFile]
  nuxtConfig._loadOptions = opts
  nuxtConfig.alias ||= {}

  if (meta?.name) {
    const alias = `#layers/${meta.name}`
    nuxtConfig.alias[alias] ||= withTrailingSlash(nuxtConfig.rootDir)
  }

  const defaultBuildDir = join(nuxtConfig.rootDir!, '.nuxt')
  if (!opts.overrides?._prepare && !nuxtConfig.dev && !nuxtConfig.buildDir && existsSync(defaultBuildDir)) {
    nuxtConfig.buildDir = join(nuxtConfig.rootDir!, 'node_modules/.cache/nuxt/.nuxt')
  }

  const NuxtConfigSchema = await loadNuxtSchema(nuxtConfig.rootDir || cwd || process.cwd())

  const layerSchemaKeys = ['future', 'srcDir', 'rootDir', 'serverDir', 'dir']
  const layerSchema = Object.create(null)
  for (const key of layerSchemaKeys) {
    if (key in NuxtConfigSchema) {
      layerSchema[key] = NuxtConfigSchema[key]
    }
  }

  const _layers: ConfigLayer<NuxtConfig, ConfigLayerMeta>[] = []
  const processedLayers = new Set<string>()
  const localRelativePaths = new Set(localLayers.map(layer => withoutTrailingSlash(layer)))
  for (const layer of layers) {
    // Resolve `rootDir` & `srcDir` of layers
    // Create a shallow copy to avoid mutating the cached ESM config object
    const resolvedRootDir = layer.config?.rootDir ?? layer.cwd!
    layer.config = {
      ...(layer.config || {}),
      rootDir: resolvedRootDir,
    }

    // Only process/resolve layers once
    if (processedLayers.has(resolvedRootDir)) { continue }
    processedLayers.add(resolvedRootDir)

    // Normalise layer directories
    layer.config = await applyDefaults(layerSchema, layer.config as NuxtConfig & Record<string, JSValue>) as unknown as NuxtConfig

    // Filter layers
    if (!layer.configFile || layer.configFile.endsWith('.nuxtrc')) { continue }

    // Add layer name for local layers
    if (layer.cwd && cwd && localRelativePaths.has(relative(cwd, layer.cwd))) {
      layer.meta ||= {}
      layer.meta.name ||= basename(layer.cwd)
    }

    // Add layer alias
    if (layer.meta?.name) {
      const alias = `#layers/${layer.meta.name}`
      nuxtConfig.alias[alias] ||= withTrailingSlash(layer.config.rootDir || layer.cwd)
    }
    _layers.push(layer)
  }

  ;(nuxtConfig as any)._layers = _layers

  // Ensure at least one layer remains (without nuxt.config)
  if (!_layers.length) {
    _layers.push({
      cwd,
      config: {
        rootDir: cwd,
        srcDir: cwd,
      },
    })
  }

  // Resolve and apply defaults
  return await applyDefaults(NuxtConfigSchema, nuxtConfig as NuxtConfig & Record<string, JSValue>) as unknown as NuxtOptions
}

async function loadNuxtSchema (cwd: string) {
  const url = directoryToURL(cwd)
  const urls: Array<URL | string> = [url]
  const nuxtPath = resolveModuleURL('nuxt', { try: true, from: url }) ?? resolveModuleURL('nuxt-nightly', { try: true, from: url })
  if (nuxtPath) {
    urls.unshift(nuxtPath)
  }
  const schemaPath = resolveModuleURL('@nuxt/schema', { try: true, from: urls }) ?? '@nuxt/schema'
  return await import(schemaPath).then(r => r.NuxtConfigSchema)
}

async function withDefineNuxtConfig<T> (fn: () => Promise<T>) {
  const key = 'defineNuxtConfig'
  const globalSelf = globalThis as any

  if (!globalSelf[key]) {
    globalSelf[key] = (c: any) => c
    globalSelf[key].count = 0
  }
  globalSelf[key].count++
  try {
    return await fn()
  } finally {
    globalSelf[key].count--
    if (!globalSelf[key].count) {
      delete globalSelf[key]
    }
  }
}
</file>

<file path="packages/kit/src/loader/nuxt.ts">
import { pathToFileURL } from 'node:url'
import type { Nuxt, NuxtConfig } from '@nuxt/schema'
import { resolve } from 'pathe'
import { resolveModulePath } from 'exsolve'
import { interopDefault } from 'mlly'
import { directoryToURL, importModule, tryImportModule } from '../internal/esm.ts'
import { runWithNuxtContext } from '../context.ts'
import type { LoadNuxtConfigOptions } from './config.ts'

export interface LoadNuxtOptions extends LoadNuxtConfigOptions {
  /** Load nuxt with development mode */
  dev?: boolean

  /** Use lazy initialization of nuxt if set to false */
  ready?: boolean
}

export async function loadNuxt (opts: LoadNuxtOptions): Promise<Nuxt> {
  // Backward compatibility
  opts.cwd = resolve(opts.cwd || (opts as any).rootDir /* backwards compat */ || '.')
  opts.overrides ||= (opts as any).config as NuxtConfig /* backwards compat */ || {}

  // Apply dev as config override
  opts.overrides.dev = !!opts.dev

  const resolvedPath = ['nuxt-nightly', 'nuxt'].reduce((resolvedPath, pkg) => {
    const path = resolveModulePath(pkg, { try: true, from: [directoryToURL(opts.cwd!)] })
    return path && path.length > resolvedPath.length ? path : resolvedPath
  }, '')

  if (!resolvedPath) {
    throw new Error(`Cannot find any nuxt version from ${opts.cwd}`)
  }
  const { loadNuxt } = await import(pathToFileURL(resolvedPath).href).then(r => interopDefault(r)) as typeof import('nuxt')
  const nuxt = await loadNuxt(opts)
  return nuxt
}

export async function buildNuxt (nuxt: Nuxt): Promise<any> {
  const rootURL = directoryToURL(nuxt.options.rootDir)

  const { build } = await tryImportModule<typeof import('nuxt')>('nuxt-nightly', { url: rootURL }) || await importModule<typeof import('nuxt')>('nuxt', { url: rootURL })
  return runWithNuxtContext(nuxt, () => build(nuxt))
}
</file>

<file path="packages/kit/src/loader/schema.ts">
import type { SchemaDefinition } from '@nuxt/schema'
import { useNuxt } from '../context.ts'

export function extendNuxtSchema (def: SchemaDefinition | (() => SchemaDefinition)): void {
  const nuxt = useNuxt()
  nuxt.hook('schema:extend', (schemas) => {
    schemas.push(typeof def === 'function' ? def() : def)
  })
}
</file>

<file path="packages/kit/src/module/compatibility.test.ts">
import { describe, expect, it } from 'vitest'
import { loadNuxt } from '../loader/nuxt.ts'
import { getNuxtModuleVersion, hasNuxtModule, hasNuxtModuleCompatibility } from './compatibility.ts'
import { defineNuxtModule } from './define.ts'

describe('nuxt module compatibility', () => {
  it('check module installed', async () => {
    const nuxt = await loadNuxt({
      overrides: {
        modules: [
          defineNuxtModule({
            meta: {
              name: 'nuxt-module-foo',
            },
          }),
          [
            defineNuxtModule({
              meta: {
                name: 'module-instance-with-options',
              },
            }),
            {
              foo: 'bar',
            },
          ],
        ],
      },
    })
    expect(hasNuxtModule('nuxt-module-foo', nuxt)).toStrictEqual(true)
    expect(hasNuxtModule('module-instance-with-options', nuxt)).toStrictEqual(true)
    await nuxt.close()
  })
  it('can retrieve module version from module instance', async () => {
    const nuxt = await loadNuxt({})
    const module = defineNuxtModule({
      meta: {
        name: 'nuxt-module-foo',
        version: '1.0.0',
      },
    })
    expect(await getNuxtModuleVersion(module, nuxt)).toEqual('1.0.0')
    await nuxt.close()
  })
  it('check module instance version compatibility', async () => {
    const nuxt = await loadNuxt({})
    const module = defineNuxtModule({
      meta: {
        name: 'nuxt-module-foo',
        version: '1.0.0',
      },
    })
    expect(await hasNuxtModuleCompatibility(module, '^1.0.0', nuxt)).toStrictEqual(true)
    expect(await hasNuxtModuleCompatibility(module, '^2.0.0', nuxt)).toStrictEqual(false)
    await nuxt.close()
  })
})
</file>

<file path="packages/kit/src/module/compatibility.ts">
import satisfies from 'semver/functions/satisfies.js' // npm/node-semver#381
import type { Nuxt, NuxtModule, NuxtOptions } from '@nuxt/schema'
import { useNuxt } from '../context.ts'
import { normalizeSemanticVersion } from '../compatibility.ts'
import { loadNuxtModuleInstance } from './install.ts'

function resolveNuxtModuleEntryName (m: NuxtOptions['modules'][number]): string | false {
  if (typeof m === 'object' && !Array.isArray(m)) {
    return (m as any as NuxtModule).name
  }
  if (Array.isArray(m)) {
    return resolveNuxtModuleEntryName(m[0])
  }
  return m as string || false
}

/**
 * Check if a Nuxt module is installed by name.
 *
 * This will check both the installed modules and the modules to be installed. Note
 * that it cannot detect if a module is _going to be_ installed programmatically by another module.
 */
export function hasNuxtModule (moduleName: string, nuxt: Nuxt = useNuxt()): boolean {
  // check installed modules
  return nuxt.options._installedModules.some(({ meta }) => meta.name === moduleName) ||
    // check modules to be installed
    nuxt.options.modules.some(m => moduleName === resolveNuxtModuleEntryName(m))
}

/**
 * Checks if a Nuxt module is compatible with a given semver version.
 */
export async function hasNuxtModuleCompatibility (module: string | NuxtModule, semverVersion: string, nuxt: Nuxt = useNuxt()): Promise<boolean> {
  const version = await getNuxtModuleVersion(module, nuxt)
  if (!version) {
    return false
  }
  return satisfies(normalizeSemanticVersion(version), semverVersion, {
    includePrerelease: true,
  })
}

/**
 * Get the version of a Nuxt module.
 *
 * Scans installed modules for the version, if it's not found it will attempt to load the module instance and get the version from there.
 */
export async function getNuxtModuleVersion (module: string | NuxtModule, nuxt: Nuxt | any = useNuxt()): Promise<string | false> {
  const moduleMeta = (typeof module === 'string' ? { name: module } : await module.getMeta?.()) || {}
  if (moduleMeta.version) { return moduleMeta.version }
  // need a name from here
  if (!moduleMeta.name) { return false }
  // maybe the version got attached within the installed module instance?
  for (const m of nuxt.options._installedModules) {
    if (m.meta.name === moduleMeta.name && m.meta.version) {
      return m.meta.version
    }
  }
  // it's possible that the module will be installed, it just hasn't been done yet, preemptively load the instance
  if (hasNuxtModule(moduleMeta.name)) {
    const { nuxtModule, buildTimeModuleMeta } = await loadNuxtModuleInstance(moduleMeta.name, nuxt)
    return buildTimeModuleMeta.version || await nuxtModule.getMeta?.().then(r => r.version) || false
  }
  return false
}
</file>

<file path="packages/kit/src/module/define.ts">
import { performance } from 'node:perf_hooks'
import { defu } from 'defu'
import { applyDefaults } from 'untyped'
import type { ModuleDefinition, ModuleOptions, ModuleSetupInstallResult, ModuleSetupReturn, Nuxt, NuxtModule, NuxtOptions, ResolvedModuleOptions } from '@nuxt/schema'
import { logger } from '../logger.ts'
import { tryUseNuxt, useNuxt } from '../context.ts'
import { checkNuxtCompatibility } from '../compatibility.ts'

/**
 * Define a Nuxt module, automatically merging defaults with user provided options, installing
 * any hooks that are provided, and calling an optional setup function for full control.
 */
export function defineNuxtModule<TOptions extends ModuleOptions> (
  definition: ModuleDefinition<TOptions, Partial<TOptions>, false> | NuxtModule<TOptions, Partial<TOptions>, false>,
): NuxtModule<TOptions, TOptions, false>

export function defineNuxtModule<TOptions extends ModuleOptions> (): {
  with: <TOptionsDefaults extends Partial<TOptions>> (
    definition: ModuleDefinition<TOptions, TOptionsDefaults, true> | NuxtModule<TOptions, TOptionsDefaults, true>,
  ) => NuxtModule<TOptions, TOptionsDefaults, true>
}

export function defineNuxtModule<TOptions extends ModuleOptions> (
  definition?: ModuleDefinition<TOptions, Partial<TOptions>, false> | NuxtModule<TOptions, Partial<TOptions>, false>,
) {
  if (definition) {
    return _defineNuxtModule(definition)
  }

  return {
    with: <TOptionsDefaults extends Partial<TOptions>>(
      definition: ModuleDefinition<TOptions, TOptionsDefaults, true> | NuxtModule<TOptions, TOptionsDefaults, true>,
    ) => _defineNuxtModule(definition),
  }
}

function _defineNuxtModule<
  TOptions extends ModuleOptions,
  TOptionsDefaults extends Partial<TOptions>,
  TWith extends boolean,
> (
  definition: ModuleDefinition<TOptions, TOptionsDefaults, TWith> | NuxtModule<TOptions, TOptionsDefaults, TWith>,
): NuxtModule<TOptions, TOptionsDefaults, TWith> {
  if (typeof definition === 'function') {
    return _defineNuxtModule<TOptions, TOptionsDefaults, TWith>({ setup: definition })
  }

  // Normalize definition and meta
  const module: ModuleDefinition<TOptions, TOptionsDefaults, TWith> & Required<Pick<ModuleDefinition<TOptions, TOptionsDefaults, TWith>, 'meta'>> = defu(definition, { meta: {} })

  module.meta.configKey ||= module.meta.name

  // Resolves module options from inline options, [configKey] in nuxt.config, defaults and schema
  async function getOptions (inlineOptions?: Partial<TOptions>, nuxt: Nuxt = useNuxt()): Promise<
    TWith extends true
      ? ResolvedModuleOptions<TOptions, TOptionsDefaults>
      : TOptions
  > {
    const nuxtConfigOptionsKey = module.meta.configKey || module.meta.name

    const nuxtConfigOptions: Partial<TOptions> = nuxtConfigOptionsKey && nuxtConfigOptionsKey in nuxt.options ? nuxt.options[nuxtConfigOptionsKey as keyof NuxtOptions] as Partial<TOptions> : {}

    const optionsDefaults: TOptionsDefaults =
      module.defaults instanceof Function
        ? await module.defaults(nuxt)
        : module.defaults ?? {} as TOptionsDefaults

    let options = defu(inlineOptions, nuxtConfigOptions, optionsDefaults)

    if (module.schema) {
      options = await applyDefaults(module.schema, options) as any
    }

    // @ts-expect-error ignore type mismatch when calling `defineNuxtModule` without `.with()`
    return Promise.resolve(options)
  }

  function getModuleDependencies (nuxt: Nuxt = useNuxt()) {
    if (typeof module.moduleDependencies === 'function') {
      return module.moduleDependencies(nuxt)
    }
    return module.moduleDependencies
  }

  // Module format is always a simple function
  async function normalizedModule (inlineOptions: Partial<TOptions>, nuxt = tryUseNuxt()!): Promise<ModuleSetupReturn> {
    if (!nuxt) {
      throw new TypeError(`Cannot use ${module.meta.name || 'module'} outside of Nuxt context`)
    }

    // Avoid duplicate installs
    const uniqueKey = module.meta.name || module.meta.configKey
    if (uniqueKey) {
      nuxt.options._requiredModules ||= {}
      if (nuxt.options._requiredModules[uniqueKey]) {
        return false
      }
      nuxt.options._requiredModules[uniqueKey] = true
    }

    // Check compatibility constraints
    if (module.meta.compatibility) {
      const issues = await checkNuxtCompatibility(module.meta.compatibility, nuxt)
      if (issues.length) {
        const errorMessage = `Module \`${module.meta.name}\` is disabled due to incompatibility issues:\n${issues.toString()}`
        if (nuxt.options.experimental.enforceModuleCompatibility) {
          const error = new Error(errorMessage)
          error.name = 'ModuleCompatibilityError'
          throw error
        }
        logger.warn(errorMessage)
        return
      }
    }

    // Resolve module and options
    const _options = await getOptions(inlineOptions, nuxt)

    // Register hooks
    if (module.hooks) {
      nuxt.hooks.addHooks(module.hooks)
    }

    // Call setup
    const start = performance.now()
    const res = await module.setup?.call(null as any, _options, nuxt) ?? {}
    const perf = performance.now() - start
    const setupTime = Math.round((perf * 100)) / 100

    // Measure setup time
    if (setupTime > 5000 && uniqueKey !== '@nuxt/telemetry') {
      logger.warn(`Slow module \`${uniqueKey || '<no name>'}\` took \`${setupTime}ms\` to setup.`)
    } else if (nuxt.options.debug && nuxt.options.debug.modules) {
      logger.info(`Module \`${uniqueKey || '<no name>'}\` took \`${setupTime}ms\` to setup.`)
    }

    // Check if module is ignored
    if (res === false) { return false }

    // Return module install result
    return defu(res, {
      timings: {
        setup: setupTime,
      },
    } as ModuleSetupInstallResult)
  }

  // Define getters for options and meta
  normalizedModule.getMeta = () => Promise.resolve(module.meta)
  normalizedModule.getOptions = getOptions
  normalizedModule.getModuleDependencies = getModuleDependencies

  normalizedModule.onInstall = module.onInstall
  normalizedModule.onUpgrade = module.onUpgrade

  return normalizedModule as NuxtModule<TOptions, TOptionsDefaults, TWith>
}
</file>

<file path="packages/kit/src/module/install.ts">
import { existsSync, promises as fsp, lstatSync } from 'node:fs'
import { fileURLToPath } from 'node:url'
import type { ModuleMeta, ModuleOptions, Nuxt, NuxtConfig, NuxtModule, NuxtOptions } from '@nuxt/schema'
import { dirname, isAbsolute, join, resolve } from 'pathe'
import { defu } from 'defu'
import { createJiti } from 'jiti'
import { lookupNodeModuleSubpath, parseNodeModulePath } from 'mlly'
import { resolveModulePath, resolveModuleURL } from 'exsolve'
import { isRelative } from 'ufo'
import { readPackageJSON, resolvePackageJSON } from 'pkg-types'
import { read as readRc, update as updateRc } from 'rc9'
import semver from 'semver'
import { directoryToURL } from '../internal/esm.ts'
import { useNuxt } from '../context.ts'
import { resolveAlias } from '../resolve.ts'
import { logger } from '../logger.ts'
import { getLayerDirectories } from '../layers.ts'

const NODE_MODULES_RE = /[/\\]node_modules[/\\]/

type ModuleToInstall = string | NuxtModule<ModuleOptions, Partial<ModuleOptions>, false>
interface ResolvedModule {
  moduleToInstall: ModuleToInstall
  nuxtModule: NuxtModule<ModuleOptions, Partial<ModuleOptions>, false>
  buildTimeModuleMeta: ModuleMeta
  resolvedModulePath: string | undefined
  inlineOptions: Record<string, any>
  meta: ModuleMeta | undefined
}

// config keys that accept `false` as a valid config value or are known to handle disabling internally
const ignoredConfigKeys = new Set(['components', 'imports', 'pages', 'devtools', 'telemetry'])

/**
 * Installs a set of modules on a Nuxt instance.
 * @internal
 */
export async function installModules (modulesToInstall: Map<ModuleToInstall, Record<string, any>>, resolvedModulePaths: Set<string>, nuxt: Nuxt = useNuxt()): Promise<void> {
  const localLayerModuleDirs: string[] = []
  for (const l of nuxt.options._layers) {
    const srcDir = l.config.srcDir || l.cwd
    if (!NODE_MODULES_RE.test(srcDir)) {
      localLayerModuleDirs.push(resolve(srcDir, l.config?.dir?.modules || 'modules').replace(/\/?$/, '/'))
    }
  }

  nuxt._moduleOptionsFunctions ||= new Map<ModuleToInstall, Array<() => { defaults?: Record<string, unknown>, overrides?: Record<string, unknown> }>>()
  const resolvedModules: Array<ResolvedModule> = []
  const inlineConfigKeys = new Set(
    await Promise.all([...modulesToInstall].map(([mod]) => typeof mod !== 'string' && Promise.resolve(mod.getMeta?.())?.then(r => r?.configKey))),
  )
  let error: Error | undefined
  const dependencyMap = new Map<ModuleToInstall, string>()
  for (const [key, options] of modulesToInstall) {
    const res = await loadNuxtModuleInstance(key, nuxt).catch((err) => {
      if (dependencyMap.has(key) && typeof key === 'string') {
        (err as Error).cause = `Could not resolve \`${key}\` (specified as a dependency of ${dependencyMap.get(key)!}).`
      }
      throw err
    })

    const dependencyMeta = await res.nuxtModule.getModuleDependencies?.(nuxt) || {}
    for (const [name, value] of Object.entries(dependencyMeta)) {
      if (!value.overrides && !value.defaults && !value.version && value.optional) {
        continue
      }

      const resolvedModule = resolveModuleWithOptions(name, nuxt)
      const moduleToAttribute = typeof key === 'string' ? `\`${key}\`` : 'a module in `nuxt.options`'

      if (!resolvedModule?.module) {
        const message = `Could not resolve \`${name}\` (specified as a dependency of ${moduleToAttribute}).`
        error = new TypeError(message)
        continue
      }

      if (value.version) {
        const resolvePaths = [res.resolvedModulePath!, ...nuxt.options.modulesDir].filter(Boolean)
        const pkg = await readPackageJSON(name, { from: resolvePaths }).catch(() => null)
        if (pkg?.version && !semver.satisfies(pkg.version, value.version)) {
          const message = `Module \`${name}\` version (\`${pkg.version}\`) does not satisfy \`${value.version}\` (requested by ${moduleToAttribute}).`
          error = new TypeError(message)
        }
      }

      if (value.overrides || value.defaults) {
        const currentFns = nuxt._moduleOptionsFunctions.get(resolvedModule.module) || []
        nuxt._moduleOptionsFunctions.set(resolvedModule.module, [
          ...currentFns,
          () => ({ defaults: value.defaults, overrides: value.overrides }),
        ])
      }

      if (value.optional === true) {
        continue
      }

      // ensure types are recognised for modules that are dependencies of other modules
      nuxt.options.typescript.hoist.push(name)

      if (resolvedModule && !modulesToInstall.has(resolvedModule.module) && (!resolvedModule.resolvedPath || !resolvedModulePaths.has(resolvedModule.resolvedPath))) {
        // check for config key already registered
        if (typeof resolvedModule.module === 'string' && inlineConfigKeys.has(resolvedModule.module)) {
          continue
        }
        modulesToInstall.set(resolvedModule.module, resolvedModule.options)
        dependencyMap.set(resolvedModule.module, moduleToAttribute)
        const path = resolvedModule.resolvedPath || resolvedModule.module
        if (typeof path === 'string') {
          resolvedModulePaths.add(path)
        }
      }
    }

    resolvedModules.push({
      moduleToInstall: key,
      meta: await res.nuxtModule.getMeta?.(),
      nuxtModule: res.nuxtModule,
      buildTimeModuleMeta: res.buildTimeModuleMeta,
      resolvedModulePath: res.resolvedModulePath,
      inlineOptions: options,
    })
  }

  if (error) {
    throw error
  }

  for (const { nuxtModule, meta = {}, moduleToInstall, buildTimeModuleMeta, resolvedModulePath, inlineOptions } of resolvedModules) {
    const configKey = meta.configKey as keyof NuxtOptions | undefined

    // Merge options
    const optionsFns = [
      ...nuxt._moduleOptionsFunctions.get(moduleToInstall) || [],
      ...meta?.name ? nuxt._moduleOptionsFunctions.get(meta.name) || [] : [],
      // TODO: consider dropping options functions keyed by config key
      ...configKey ? nuxt._moduleOptionsFunctions.get(configKey) || [] : [],
    ]
    if (optionsFns.length > 0) {
      const overrides = [] as unknown as [Record<string, unknown> | undefined, ...Array<Record<string, unknown> | undefined>]
      const defaults: Array<Record<string, unknown> | undefined> = []
      for (const fn of optionsFns) {
        const options = fn()
        overrides.push(options.overrides)
        defaults.push(options.defaults)
      }
      if (configKey) {
        ;(nuxt.options[configKey] as any) = defu(...overrides, nuxt.options[configKey], ...defaults)
      }
    }

    // Check if module should be disabled
    const isDisabled = configKey && !ignoredConfigKeys.has(configKey) && nuxt.options[configKey] === false
    if (!isDisabled) {
      await callLifecycleHooks(nuxtModule, meta, inlineOptions, nuxt)
    }
    const path = typeof moduleToInstall === 'string' ? moduleToInstall : undefined
    await callModule(nuxt, nuxtModule, inlineOptions, {
      meta: defu({ disabled: isDisabled }, meta, buildTimeModuleMeta),
      nameOrPath: path,
      modulePath: resolvedModulePath || path,
      localLayerModuleDirs,
    })
  }

  // clean up merging options
  delete nuxt._moduleOptionsFunctions
}

/**
 * Installs a module on a Nuxt instance.
 * @deprecated Use module dependencies.
 */
export async function installModule<
  T extends string | NuxtModule,
  Config extends Extract<NonNullable<NuxtConfig['modules']>[number], [T, any]>,
> (moduleToInstall: T, inlineOptions?: [Config] extends [never] ? any : Config[1], nuxt: Nuxt = useNuxt()): Promise<void> {
  const { nuxtModule, buildTimeModuleMeta, resolvedModulePath } = await loadNuxtModuleInstance(moduleToInstall, nuxt)

  const localLayerModuleDirs: string[] = []
  for (const dirs of getLayerDirectories(nuxt)) {
    if (!NODE_MODULES_RE.test(dirs.app)) {
      localLayerModuleDirs.push(dirs.modules)
    }
  }

  // module lifecycle hooks
  const meta = await nuxtModule.getMeta?.()

  // Apply options from moduleDependencies if available
  let mergedOptions = inlineOptions
  const configKey = meta?.configKey as keyof NuxtOptions | undefined
  if (configKey && nuxt._moduleOptionsFunctions) {
    const optionsFns = [
      ...nuxt._moduleOptionsFunctions.get(moduleToInstall) || [],
      ...nuxt._moduleOptionsFunctions.get(configKey) || [],
    ]
    if (optionsFns.length > 0) {
      const overrides = [] as unknown as [Record<string, unknown> | undefined, ...Array<Record<string, unknown> | undefined>]
      const defaults: Array<Record<string, unknown> | undefined> = []
      for (const fn of optionsFns) {
        const options = fn()
        overrides.push(options.overrides)
        defaults.push(options.defaults)
      }
      mergedOptions = defu(inlineOptions, ...overrides, nuxt.options[configKey], ...defaults) as any
      ;(nuxt.options[configKey] as any) = mergedOptions
    }
  }

  // Check if module should be disabled
  const isDisabled = configKey && !ignoredConfigKeys.has(configKey) && nuxt.options[configKey] === false

  if (!isDisabled) {
    await callLifecycleHooks(nuxtModule, meta, mergedOptions, nuxt)
  }
  const path = typeof moduleToInstall === 'string' ? moduleToInstall : undefined
  await callModule(nuxt, nuxtModule, mergedOptions, {
    meta: defu({ disabled: isDisabled }, meta, buildTimeModuleMeta),
    nameOrPath: path,
    modulePath: resolvedModulePath || path,
    localLayerModuleDirs,
  })
}

export function resolveModuleWithOptions (
  definition: NuxtModule<any> | string | false | undefined | null | [(NuxtModule | string)?, Record<string, any>?],
  nuxt: Nuxt,
): { resolvedPath?: string, module: string | NuxtModule<any>, options: Record<string, any> } | undefined {
  const [module, options = {}] = Array.isArray(definition) ? definition : [definition, {}]

  if (!module) {
    return
  }

  if (typeof module !== 'string') {
    return {
      module,
      options,
    }
  }

  const modAlias = resolveAlias(module, nuxt.options.alias)
  const modPath = resolveModulePath(modAlias, {
    try: true,
    from: nuxt.options.modulesDir.map(m => directoryToURL(m.replace(/\/node_modules\/?$/, '/'))),
    suffixes: ['nuxt', 'nuxt/index', 'module', 'module/index', '', 'index'],
    extensions: ['.js', '.mjs', '.cjs', '.ts', '.mts', '.cts'],
  })

  return {
    module,
    resolvedPath: modPath || modAlias,
    options,
  }
}

export async function loadNuxtModuleInstance (nuxtModule: string | NuxtModule, nuxt: Nuxt = useNuxt()): Promise<{ nuxtModule: NuxtModule<any>, buildTimeModuleMeta: ModuleMeta, resolvedModulePath?: string }> {
  let buildTimeModuleMeta: ModuleMeta = {}

  if (typeof nuxtModule === 'function') {
    return {
      nuxtModule,
      buildTimeModuleMeta,
    }
  }

  if (typeof nuxtModule !== 'string') {
    throw new TypeError(`Nuxt module should be a function or a string to import. Received: ${nuxtModule}.`)
  }

  const jiti = createJiti(nuxt.options.rootDir, { alias: nuxt.options.alias })

  // Import if input is string
  nuxtModule = resolveAlias(nuxtModule, nuxt.options.alias)

  if (isRelative(nuxtModule)) {
    nuxtModule = resolve(nuxt.options.rootDir, nuxtModule)
  }

  try {
    const src = resolveModuleURL(nuxtModule, {
      from: nuxt.options.modulesDir.map(m => directoryToURL(m.replace(/\/node_modules\/?$/, '/'))),
      suffixes: ['nuxt', 'nuxt/index', 'module', 'module/index', '', 'index'],
      extensions: ['.js', '.mjs', '.cjs', '.ts', '.mts', '.cts'],
    })
    const resolvedModulePath = fileURLToPath(src)
    const resolvedNuxtModule = await jiti.import<NuxtModule<any>>(src, { default: true })

    if (typeof resolvedNuxtModule !== 'function') {
      throw new TypeError(`Nuxt module should be a function: ${nuxtModule}.`)
    }

    // nuxt-module-builder generates a module.json with metadata including the version
    const moduleMetadataPath = new URL('module.json', src)
    if (existsSync(moduleMetadataPath)) {
      buildTimeModuleMeta = JSON.parse(await fsp.readFile(moduleMetadataPath, 'utf-8'))
    }

    return { nuxtModule: resolvedNuxtModule, buildTimeModuleMeta, resolvedModulePath }
  } catch (error: unknown) {
    const code = (error as Error & { code?: string }).code
    if (code === 'ERR_PACKAGE_PATH_NOT_EXPORTED' || code === 'ERR_UNSUPPORTED_DIR_IMPORT' || code === 'ENOTDIR') {
      throw new TypeError(`Could not load \`${nuxtModule}\`. Is it installed?`)
    }
    if (code === 'MODULE_NOT_FOUND' || code === 'ERR_MODULE_NOT_FOUND') {
      const module = MissingModuleMatcher.exec((error as Error).message)?.[1]
      // verify that it's missing the nuxt module otherwise it may be a sub dependency of the module itself
      // i.e. module is importing a module that is missing
      if (module && !module.includes(nuxtModule as string)) {
        throw new TypeError(`Error while importing module \`${nuxtModule}\`: ${error}`)
      }
    }
  }

  throw new TypeError(`Could not load \`${nuxtModule}\`. Is it installed?`)
}

// --- Internal ---

export function getDirectory (p: string): string {
  try {
    // we need to target directories instead of module file paths themselves
    // /home/user/project/node_modules/module/index.js -> /home/user/project/node_modules/module
    return isAbsolute(p) && lstatSync(p).isFile() ? dirname(p) : p
  } catch {
    // maybe the path is absolute but does not exist, allow this to bubble up
  }
  return p
}

export const normalizeModuleTranspilePath = (p: string) => {
  return getDirectory(p).split('node_modules/').pop() as string
}

const MissingModuleMatcher = /Cannot find module\s+['"]?([^'")\s]+)['"]?/i

async function callLifecycleHooks (nuxtModule: NuxtModule<any, Partial<any>, false>, meta: ModuleMeta = {}, inlineOptions?: Record<string, unknown>, nuxt = useNuxt()) {
  if (!meta.name || !meta.version) {
    return
  }
  if (!nuxtModule.onInstall && !nuxtModule.onUpgrade) {
    return
  }

  const rc = readRc({ dir: nuxt.options.rootDir, name: '.nuxtrc' })
  const previousVersion = rc?.setups?.[meta.name]

  try {
    if (!previousVersion) {
      await nuxtModule.onInstall?.(nuxt)
    } else if (semver.gt(meta.version, previousVersion)) {
      await nuxtModule.onUpgrade?.(nuxt, inlineOptions, previousVersion)
    }
    if (previousVersion !== meta.version) {
      updateRc(
        { setups: { [meta.name]: meta?.version } },
        { dir: nuxt.options.rootDir, name: '.nuxtrc' },
      )
    }
  } catch (e) {
    logger.error(
      `Error while executing ${!previousVersion ? 'install' : 'upgrade'} hook for module \`${meta.name}\`: ${e}`,
    )
  }
}

interface CallModuleOptions {
  meta: ModuleMeta
  modulePath?: string
  nameOrPath?: string
  localLayerModuleDirs: string[]
}

async function callModule (nuxt: Nuxt, nuxtModule: NuxtModule<any, Partial<any>, false>, moduleOptions: Record<string, unknown> = {}, options: CallModuleOptions) {
  const modulePath = options.modulePath
  const nameOrPath = options.nameOrPath
  const localLayerModuleDirs = options.localLayerModuleDirs

  const fn = () => nuxt.options.experimental?.debugModuleMutation && nuxt._asyncLocalStorageModule
    ? nuxt._asyncLocalStorageModule.run(nuxtModule, () => nuxtModule(moduleOptions, nuxt))
    : nuxtModule(moduleOptions, nuxt)

  const res = options.meta.disabled ? false : await fn()

  let entryPath: string | undefined
  if (typeof modulePath === 'string') {
    const parsed = parseNodeModulePath(modulePath)
    if (parsed.name) {
      const subpath = await lookupNodeModuleSubpath(modulePath) || '.'
      entryPath = join(parsed.name, subpath === './' ? '.' : subpath)
    }
    if (res !== false) {
      const moduleRoot = parsed.dir
        ? parsed.dir + parsed.name
        : await resolvePackageJSON(modulePath, { try: true }).then(r => r ? dirname(r) : modulePath)
      nuxt.options.build.transpile.push(normalizeModuleTranspilePath(moduleRoot))
      const directory = moduleRoot.replace(/\/?$/, '/')
      if (moduleRoot !== nameOrPath && !localLayerModuleDirs.some(dir => directory.startsWith(dir))) {
        nuxt.options.modulesDir.push(join(moduleRoot, 'node_modules'))
      }
    }
  }

  if (nameOrPath) {
    entryPath ||= resolveAlias(nameOrPath, nuxt.options.alias)

    if (entryPath !== nameOrPath) {
      options.meta.rawPath = nameOrPath
    }
  }

  nuxt.options._installedModules ||= []
  nuxt.options._installedModules.push({
    meta: options.meta,
    module: nuxtModule,
    timings: (res || {} as Record<string, undefined>).timings,
    entryPath,
  })
}
</file>

<file path="packages/kit/src/build.ts">
import type { Configuration as WebpackConfig, WebpackPluginInstance } from 'webpack'
import type { RspackPluginInstance } from '@rspack/core'
import type { UserConfig as ViteConfig, Plugin as VitePlugin } from 'vite'
import { useNuxt } from './context.ts'
import { toArray } from './utils.ts'
import { resolveAlias } from './resolve.ts'
import { getUserCaller, warn } from './internal/trace.ts'

type Arrayable<T> = T | T[]
type Thenable<T> = T | Promise<T>

export interface ExtendConfigOptions {
  /**
   * Install plugin on dev
   * @default true
   */
  dev?: boolean
  /**
   * Install plugin on build
   * @default true
   */
  build?: boolean
  /**
   * Install plugin on server side
   * @default true
   */
  server?: boolean
  /**
   * Install plugin on client side
   * @default true
   */
  client?: boolean
  /**
   * Prepends the plugin to the array with `unshift()` instead of `push()`.
   */
  prepend?: boolean
}

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface ExtendWebpackConfigOptions extends ExtendConfigOptions {}

export interface ExtendViteConfigOptions extends Omit<ExtendConfigOptions, 'server' | 'client'> {
  /**
   * Extend server Vite configuration
   * @default true
   * @deprecated calling \`extendViteConfig\` with only server/client environment is deprecated.
   * Nuxt 5+ uses the Vite Environment API which shares a configuration between environments.
   * You can likely use a Vite plugin to achieve the same result.
   */
  server?: boolean
  /**
   * Extend client Vite configuration
   * @default true
   * @deprecated calling \`extendViteConfig\` with only server/client environment is deprecated.
   * Nuxt 5+ uses the Vite Environment API which shares a configuration between environments.
   * You can likely use a Vite plugin to achieve the same result.
   */
  client?: boolean
}

const extendWebpackCompatibleConfig = (builder: 'rspack' | 'webpack') => (fn: ((config: WebpackConfig) => Thenable<void>), options: ExtendWebpackConfigOptions = {}) => {
  const nuxt = useNuxt()

  if (options.dev === false && nuxt.options.dev) {
    return
  }
  if (options.build === false && nuxt.options.build) {
    return
  }

  nuxt.hook(`${builder}:config`, async (configs) => {
    if (options.server !== false) {
      const config = configs.find(i => i.name === 'server')
      if (config) {
        await fn(config)
      }
    }
    if (options.client !== false) {
      const config = configs.find(i => i.name === 'client')
      if (config) {
        await fn(config)
      }
    }
  })
}

type ExtendWebpacklikeConfig = (fn: (config: WebpackConfig) => void, options?: ExtendWebpackConfigOptions) => void

/**
 * Extend webpack config
 *
 * The fallback function might be called multiple times
 * when applying to both client and server builds.
 */
export const extendWebpackConfig: ExtendWebpacklikeConfig = extendWebpackCompatibleConfig('webpack')
/**
 * Extend rspack config
 *
 * The fallback function might be called multiple times
 * when applying to both client and server builds.
 */
export const extendRspackConfig: ExtendWebpacklikeConfig = extendWebpackCompatibleConfig('rspack')

/**
 * Extend Vite config
 */
export function extendViteConfig (fn: ((config: ViteConfig) => Thenable<void>), options: ExtendViteConfigOptions = {}): (() => void) | undefined {
  const nuxt = useNuxt()

  if (options.dev === false && nuxt.options.dev) {
    return
  }
  if (options.build === false && nuxt.options.build) {
    return
  }

  // eslint-disable-next-line @typescript-eslint/no-deprecated
  if (options.server === false || options.client === false) {
    const caller = getUserCaller()
    const explanation = caller ? ` (used at \`${resolveAlias(caller.source)}:${caller.line}:${caller.column}\`)` : ''
    const warning = `[@nuxt/kit] calling \`extendViteConfig\` with only server/client environment is deprecated${explanation}. Nuxt 5+ will use the Vite Environment API which shares a configuration between environments. You can likely use a Vite plugin to achieve the same result.`
    warn(warning)
  }

  // Call fn() only once
  return nuxt.hook('vite:extend', ({ config }) => fn(config))
}

/**
 * Append webpack plugin to the config.
 */
export function addWebpackPlugin (pluginOrGetter: Arrayable<WebpackPluginInstance> | (() => Thenable<Arrayable<WebpackPluginInstance>>), options?: ExtendWebpackConfigOptions): void {
  extendWebpackConfig(async (config) => {
    const method: 'push' | 'unshift' = options?.prepend ? 'unshift' : 'push'
    const plugin = typeof pluginOrGetter === 'function' ? await pluginOrGetter() : pluginOrGetter

    config.plugins ||= []
    config.plugins[method](...toArray(plugin))
  }, options)
}
/**
 * Append rspack plugin to the config.
 */
export function addRspackPlugin (pluginOrGetter: Arrayable<RspackPluginInstance> | (() => Thenable<Arrayable<RspackPluginInstance>>), options?: ExtendWebpackConfigOptions): void {
  extendRspackConfig(async (config) => {
    const method: 'push' | 'unshift' = options?.prepend ? 'unshift' : 'push'
    const plugin = typeof pluginOrGetter === 'function' ? await pluginOrGetter() : pluginOrGetter

    config.plugins ||= []
    config.plugins[method](...toArray(plugin))
  }, options)
}

/**
 * Append Vite plugin to the config.
 */
export function addVitePlugin (pluginOrGetter: Arrayable<VitePlugin> | (() => Thenable<Arrayable<VitePlugin>>), options: ExtendConfigOptions = {}): void {
  const nuxt = useNuxt()

  if (options.dev === false && nuxt.options.dev) {
    return
  }
  if (options.build === false && nuxt.options.build) {
    return
  }

  let needsEnvInjection = false
  nuxt.hook('vite:extend', async ({ config }) => {
    config.plugins ||= []

    const plugin = toArray(typeof pluginOrGetter === 'function' ? await pluginOrGetter() : pluginOrGetter)
    if (options.server !== false && options.client !== false) {
      const method: 'push' | 'unshift' = options?.prepend ? 'unshift' : 'push'
      config.plugins[method](...plugin)
      return
    }

    if (!config.environments?.ssr || !config.environments.client) {
      needsEnvInjection = true
      return
    }

    const environmentName = options.server === false ? 'client' : 'ssr'
    const pluginName = plugin.map(p => p.name).join('|')
    config.plugins.push({
      name: `${pluginName}:wrapper`,
      enforce: options?.prepend ? 'pre' : 'post',
      applyToEnvironment (environment) {
        if (environment.name === environmentName) {
          return plugin
        }
      },
    })
  })

  nuxt.hook('vite:extendConfig', async (config, env) => {
    if (!needsEnvInjection) {
      return
    }
    const plugin = toArray(typeof pluginOrGetter === 'function' ? await pluginOrGetter() : pluginOrGetter)
    const method: 'push' | 'unshift' = options?.prepend ? 'unshift' : 'push'
    if (env.isClient && options.server === false) {
      config.plugins![method](...plugin)
    }
    if (env.isServer && options.client === false) {
      config.plugins![method](...plugin)
    }
  })
}

interface AddBuildPluginFactory {
  vite?: () => Thenable<Arrayable<VitePlugin>>
  webpack?: () => Thenable<Arrayable<WebpackPluginInstance>>
  rspack?: () => Thenable<Arrayable<RspackPluginInstance>>
}

export function addBuildPlugin (pluginFactory: AddBuildPluginFactory, options?: ExtendConfigOptions): void {
  if (pluginFactory.vite) {
    addVitePlugin(pluginFactory.vite, options)
  }

  if (pluginFactory.webpack) {
    addWebpackPlugin(pluginFactory.webpack, options)
  }

  if (pluginFactory.rspack) {
    addRspackPlugin(pluginFactory.rspack, options)
  }
}
</file>

<file path="packages/kit/src/compatibility.ts">
import satisfies from 'semver/functions/satisfies.js' // npm/node-semver#381
import { readPackageJSON } from 'pkg-types'
import type { Nuxt, NuxtCompatibility, NuxtCompatibilityIssues } from '@nuxt/schema'
import { useNuxt } from './context.ts'

const SEMANTIC_VERSION_RE = /-\d+\.[0-9a-f]+/
export function normalizeSemanticVersion (version: string): string {
  return version.replace(SEMANTIC_VERSION_RE, '') // Remove edge prefix
}

const builderMap = {
  '@nuxt/rspack-builder': 'rspack',
  '@nuxt/vite-builder': 'vite',
  '@nuxt/webpack-builder': 'webpack',
}

export function checkNuxtVersion (version: string, nuxt: Nuxt = useNuxt()): boolean {
  const nuxtVersion = getNuxtVersion(nuxt)
  return satisfies(normalizeSemanticVersion(nuxtVersion), version, { includePrerelease: true })
}

/**
 * Check version constraints and return incompatibility issues as an array
 */
export async function checkNuxtCompatibility (constraints: NuxtCompatibility, nuxt: Nuxt = useNuxt()): Promise<NuxtCompatibilityIssues> {
  const issues: NuxtCompatibilityIssues = []

  // Nuxt version check
  if (constraints.nuxt) {
    const nuxtVersion = getNuxtVersion(nuxt)
    if (!checkNuxtVersion(constraints.nuxt, nuxt)) {
      issues.push({
        name: 'nuxt',
        message: `Nuxt version \`${constraints.nuxt}\` is required but currently using \`${nuxtVersion}\``,
      })
    }
  }

  // Builder compatibility check
  if (constraints.builder && typeof nuxt.options.builder === 'string') {
    const currentBuilder = builderMap[nuxt.options.builder] || nuxt.options.builder
    if (currentBuilder in constraints.builder) {
      const constraint = constraints.builder[currentBuilder]!
      if (constraint === false) {
        issues.push({
          name: 'builder',
          message: `Not compatible with \`${nuxt.options.builder}\`.`,
        })
      } else {
        for (const parent of [nuxt.options.rootDir, nuxt.options.workspaceDir, import.meta.url]) {
          const builderVersion = await readPackageJSON(nuxt.options.builder, { parent }).then(r => r.version).catch(() => undefined)
          if (builderVersion) {
            if (!satisfies(normalizeSemanticVersion(builderVersion), constraint, { includePrerelease: true })) {
              issues.push({
                name: 'builder',
                message: `Not compatible with \`${builderVersion}\` of \`${currentBuilder}\`. This module requires \`${constraint}\`.`,
              })
            }
            break
          }
        }
      }
    }
  }

  // Allow extending compatibility checks
  await nuxt.callHook('kit:compatibility', constraints, issues)

  // Issues formatter
  issues.toString = () =>
    issues.map(issue => ` - [${issue.name}] ${issue.message}`).join('\n')

  return issues
}

/**
 * Check version constraints and throw a detailed error if has any, otherwise returns true
 */
export async function assertNuxtCompatibility (constraints: NuxtCompatibility, nuxt: Nuxt = useNuxt()): Promise<true> {
  const issues = await checkNuxtCompatibility(constraints, nuxt)
  if (issues.length) {
    throw new Error('Nuxt compatibility issues found:\n' + issues.toString())
  }
  return true
}

/**
 * Check version constraints and return true if passed, otherwise returns false
 */
export async function hasNuxtCompatibility (constraints: NuxtCompatibility, nuxt: Nuxt = useNuxt()): Promise<boolean> {
  const issues = await checkNuxtCompatibility(constraints, nuxt)
  return !issues.length
}

export type NuxtMajorVersion = 2 | 3 | 4

/**
 * Check if current Nuxt instance is of specified major version
 */
export function isNuxtMajorVersion (majorVersion: NuxtMajorVersion, nuxt: Nuxt = useNuxt()): boolean {
  const version = getNuxtVersion(nuxt)

  return version[0] === majorVersion.toString() && version[1] === '.'
}

/**
 * @deprecated Use `isNuxtMajorVersion(2, nuxt)` instead. This may be removed in \@nuxt/kit v5 or a future major version.
 */
export function isNuxt2 (nuxt: Nuxt = useNuxt()): boolean {
  return isNuxtMajorVersion(2, nuxt)
}

/**
 * @deprecated Use `isNuxtMajorVersion(3, nuxt)` instead. This may be removed in \@nuxt/kit v5 or a future major version.
 */
export function isNuxt3 (nuxt: Nuxt = useNuxt()): boolean {
  return isNuxtMajorVersion(3, nuxt)
}

const NUXT_VERSION_RE = /^v/g
/**
 * Get nuxt version
 */
export function getNuxtVersion (nuxt: Nuxt | any = useNuxt() /* TODO: LegacyNuxt */): string {
  const rawVersion = nuxt?._version || nuxt?.version || nuxt?.constructor?.version
  if (typeof rawVersion !== 'string') {
    throw new TypeError('Cannot determine nuxt version! Is current instance passed?')
  }
  return rawVersion.replace(NUXT_VERSION_RE, '')
}
</file>

<file path="packages/kit/src/components.ts">
import { kebabCase, pascalCase } from 'scule'
import type { Component, ComponentsDir } from '@nuxt/schema'
import { resolveModuleExportNames } from 'mlly'

import { useNuxt } from './context.ts'
import { logger } from './logger.ts'
import { resolvePath } from './resolve.ts'
import { MODE_RE } from './utils.ts'

/**
 * Register a directory to be scanned for components and imported only when used.
 */
export function addComponentsDir (dir: ComponentsDir, opts: { prepend?: boolean } = {}): void {
  const nuxt = useNuxt()
  nuxt.options.components ||= []
  dir.priority ||= 0
  nuxt.hook('components:dirs', (dirs) => { dirs[opts.prepend ? 'unshift' : 'push'](dir) })
}

export type AddComponentOptions = { name: string, filePath: string } & Partial<Exclude<Component,
'shortPath' | 'async' | 'level' | 'import' | 'asyncImport'
>>

/**
 * This utility takes a file path or npm package that is scanned for named exports, which are get added automatically
 */
export function addComponentExports (opts: Omit<AddComponentOptions, 'name'> & { prefix?: string }): void {
  const nuxt = useNuxt()
  const components: Component[] = []
  nuxt.hook('components:dirs', async () => {
    const filePath = await resolvePath(opts.filePath)

    const names = await resolveModuleExportNames(filePath, { extensions: nuxt.options.extensions })
    components.length = 0
    for (const name of names) {
      components.push(normalizeComponent({ name: pascalCase([opts.prefix || '', name === 'default' ? '' : name]), export: name, ...opts }))
    }
  })
  addComponents(components)
}

/**
 * Register a component by its name and filePath.
 */
export function addComponent (opts: AddComponentOptions): void {
  const component = normalizeComponent(opts)
  addComponents([component])
}

function addComponents (addedComponents: Component[]) {
  const nuxt = useNuxt()
  nuxt.options.components ||= []

  nuxt.hook('components:extend', (components: Component[]) => {
    for (const component of addedComponents) {
      const existingComponentIndex = components.findIndex(c => (c.pascalName === component.pascalName || c.kebabName === component.kebabName) && c.mode === component.mode)
      if (existingComponentIndex !== -1) {
        const existingComponent = components[existingComponentIndex]!
        const existingPriority = existingComponent.priority ?? 0
        const newPriority = component.priority ?? 0

        if (newPriority < existingPriority) { continue }

        // We override where new component priority is equal or higher
        // but we warn if they are equal.
        if (newPriority === existingPriority) {
          const name = existingComponent.pascalName || existingComponent.kebabName
          logger.warn(`Overriding ${name} component. You can specify a \`priority\` option when calling \`addComponent\` to avoid this warning.`)
        }
        components.splice(existingComponentIndex, 1, component)
      } else {
        components.push(component)
      }
    }
  })
}

function normalizeComponent (opts: AddComponentOptions) {
  if (!opts.mode) {
    const [, mode = 'all'] = opts.filePath.match(MODE_RE) || []
    opts.mode = mode as 'all' | 'client' | 'server'
  }

  // Apply defaults
  const component: Component = {
    export: opts.export || 'default',
    chunkName: 'components/' + kebabCase(opts.name),
    global: opts.global ?? false,
    kebabName: kebabCase(opts.name || ''),
    pascalName: pascalCase(opts.name || ''),
    prefetch: false,
    preload: false,
    mode: 'all',
    shortPath: opts.filePath,
    priority: 0,
    meta: {},
    ...opts,
  }

  return component
}
</file>

<file path="packages/kit/src/context.ts">
import { AsyncLocalStorage } from 'node:async_hooks'
import { createContext, getContext } from 'unctx'
import type { UseContext } from 'unctx'
import type { Nuxt } from '@nuxt/schema'

/**
 * Direct access to the Nuxt global context - see https://github.com/unjs/unctx.
 * @deprecated Use `getNuxtCtx` instead
 */
export const nuxtCtx: UseContext<Nuxt> = getContext<Nuxt>('nuxt')

/** async local storage for the name of the current nuxt instance */
const asyncNuxtStorage = createContext<Nuxt>({
  asyncContext: true,
  AsyncLocalStorage,
})

/** Direct access to the Nuxt context with asyncLocalStorage - see https://github.com/unjs/unctx. */
export const getNuxtCtx = (): Nuxt | null => asyncNuxtStorage.tryUse()

/**
 * Get access to Nuxt instance.
 *
 * Throws an error if Nuxt instance is unavailable.
 * @example
 * ```js
 * const nuxt = useNuxt()
 * ```
 */
export function useNuxt (): Nuxt {
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  const instance = asyncNuxtStorage.tryUse() || nuxtCtx.tryUse()
  if (!instance) {
    throw new Error('Nuxt instance is unavailable!')
  }
  return instance
}

/**
 * Get access to Nuxt instance.
 *
 * Returns null if Nuxt instance is unavailable.
 * @example
 * ```js
 * const nuxt = tryUseNuxt()
 * if (nuxt) {
 *  // Do something
 * }
 * ```
 */
export function tryUseNuxt (): Nuxt | null {
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  return asyncNuxtStorage.tryUse() || nuxtCtx.tryUse()
}

export function runWithNuxtContext<T extends (...args: any[]) => any> (nuxt: Nuxt, fn: T) {
  return asyncNuxtStorage.call(nuxt, fn) as ReturnType<T>
}
</file>

<file path="packages/kit/src/head.ts">
import type { NuxtAppConfig } from '@nuxt/schema'
import { useNuxt } from './context.ts'
import { defu } from 'defu'

export function setGlobalHead (head: NuxtAppConfig['head']): void {
  const nuxt = useNuxt()
  nuxt.options.app.head = defu(head, nuxt.options.app.head)
}
</file>

<file path="packages/kit/src/ignore.test.ts">
import { describe, expect, it, vi } from 'vitest'
import type { Nuxt, NuxtConfig } from '@nuxt/schema'
import { isIgnored, resolveGroupSyntax, resolveIgnorePatterns } from './ignore.ts'
import * as context from './context.ts'

describe('isIgnored', () => {
  it('should populate _ignore', () => {
    const mockNuxt = { options: { ignore: ['my-dir'], _layers: [] } as NuxtConfig } as unknown as Nuxt
    vi.spyOn(context, 'tryUseNuxt').mockReturnValue(mockNuxt)

    expect(isIgnored('my-dir/my-file.ts')).toBe(true)
    expect(resolveIgnorePatterns()?.includes('my-dir')).toBe(true)
  })
})

describe('resolveGroupSyntax', () => {
  it('should resolve single group syntax', () => {
    expect(resolveGroupSyntax('**/*.{spec}.{js,ts}')).toStrictEqual([
      '**/*.spec.js',
      '**/*.spec.ts',
    ])
  })

  it('should resolve multi-group syntax', () => {
    expect(resolveGroupSyntax('**/*.{spec,test}.{js,ts}')).toStrictEqual([
      '**/*.spec.js',
      '**/*.spec.ts',
      '**/*.test.js',
      '**/*.test.ts',
    ])
  })

  it('should do nothing with normal globs', () => {
    expect(resolveGroupSyntax('**/*.spec.js')).toStrictEqual([
      '**/*.spec.js',
    ])
  })
})
</file>

<file path="packages/kit/src/ignore.ts">
import { existsSync, readFileSync } from 'node:fs'
import ignore from 'ignore'
import { join, relative, resolve } from 'pathe'
import { tryUseNuxt } from './context.ts'
import { getLayerDirectories } from './layers.ts'
import type { Nuxt } from '@nuxt/schema'

export function createIsIgnored (nuxt: Nuxt | null | undefined = tryUseNuxt()): (pathname: string, stats?: unknown) => boolean {
  return (pathname, stats) => isIgnored(pathname, stats, nuxt)
}

/**
 * Return a filter function to filter an array of paths
 */
export function isIgnored (pathname: string, _stats?: unknown, nuxt: Nuxt | null | undefined = tryUseNuxt()): boolean {
  // Happens with CLI reloads
  if (!nuxt) {
    return false
  }

  if (!nuxt._ignore) {
    nuxt._ignore = ignore(nuxt.options.ignoreOptions)
    nuxt._ignore.add(resolveIgnorePatterns())
  }

  const cwds = getLayerDirectories(nuxt)
    .map(dirs => dirs.root)
    .sort((a, b) => b.length - a.length)
  const layer = cwds.find(cwd => pathname.startsWith(cwd))
  const relativePath = relative(layer ?? nuxt.options.rootDir, pathname)
  if (relativePath[0] === '.' && relativePath[1] === '.') {
    return false
  }
  return !!(relativePath && nuxt._ignore.ignores(relativePath))
}

const NEGATION_RE = /^(!?)(.*)$/

export function resolveIgnorePatterns (relativePath?: string): string[] {
  const nuxt = tryUseNuxt()

  // Happens with CLI reloads
  if (!nuxt) {
    return []
  }

  const ignorePatterns = nuxt.options.ignore.flatMap(s => resolveGroupSyntax(s))

  const nuxtignoreFile = join(nuxt.options.rootDir, '.nuxtignore')
  if (existsSync(nuxtignoreFile)) {
    const contents = readFileSync(nuxtignoreFile, 'utf-8')
    ignorePatterns.push(...contents.trim().split(/\r?\n/))
  }

  if (relativePath) {
    // Map ignore patterns based on if they start with * or !*
    return ignorePatterns.map((p) => {
      const [_, negation = '', pattern] = p.match(NEGATION_RE) || []
      if (pattern && pattern[0] === '*') {
        return p
      }
      return negation + relative(relativePath, resolve(nuxt.options.rootDir, pattern || p))
    })
  }

  return ignorePatterns
}

/**
 * This function turns string containing groups '**\/*.{spec,test}.{js,ts}' into an array of strings.
 * For example will '**\/*.{spec,test}.{js,ts}' be resolved to:
 * ['**\/*.spec.js', '**\/*.spec.ts', '**\/*.test.js', '**\/*.test.ts']
 * @param group string containing the group syntax
 * @returns {string[]} array of strings without the group syntax
 */
export function resolveGroupSyntax (group: string): string[] {
  let groups = [group]
  while (groups.some(group => group.includes('{'))) {
    groups = groups.flatMap((group) => {
      const [head, ...tail] = group.split('{')
      if (tail.length) {
        const [body = '', ...rest] = tail.join('{').split('}')
        return body.split(',').map(part => `${head}${part}${rest.join('')}`)
      }

      return group
    })
  }
  return groups
}
</file>

<file path="packages/kit/src/imports.ts">
import type { Import, InlinePreset } from 'unimport'
import { useNuxt } from './context.ts'
import { toArray } from './utils.ts'

export function addImports (imports: Import | Import[]): void {
  useNuxt().hook('imports:extend', (_imports) => {
    _imports.push(...toArray(imports))
  })
}

export function addImportsDir (dirs: string | string[], opts: { prepend?: boolean } = {}): void {
  useNuxt().hook('imports:dirs', (_dirs: string[]) => {
    for (const dir of toArray(dirs)) {
      _dirs[opts.prepend ? 'unshift' : 'push'](dir)
    }
  })
}
export function addImportsSources (presets: InlinePreset | InlinePreset[]): void {
  useNuxt().hook('imports:sources', (_presets: InlinePreset[]) => {
    for (const preset of toArray(presets)) {
      _presets.push(preset)
    }
  })
}
</file>

<file path="packages/kit/src/index.ts">
// Module
export { defineNuxtModule } from './module/define.ts'
// eslint-disable-next-line @typescript-eslint/no-deprecated
export { getDirectory, installModule, installModules, loadNuxtModuleInstance, normalizeModuleTranspilePath, resolveModuleWithOptions } from './module/install.ts'
export { getNuxtModuleVersion, hasNuxtModule, hasNuxtModuleCompatibility } from './module/compatibility.ts'

// Loader
export { loadNuxtConfig } from './loader/config.ts'
export type { LoadNuxtConfigOptions } from './loader/config.ts'
export { extendNuxtSchema } from './loader/schema.ts'
export { buildNuxt, loadNuxt } from './loader/nuxt.ts'
export type { LoadNuxtOptions } from './loader/nuxt.ts'

// Layers
export { getLayerDirectories } from './layers.ts'
export type { LayerDirectories } from './layers.ts'

// Utils
export { setGlobalHead } from './head.ts'
export { addImports, addImportsDir, addImportsSources } from './imports.ts'
export { updateRuntimeConfig, useRuntimeConfig } from './runtime-config.ts'
export { addBuildPlugin, addVitePlugin, addRspackPlugin, addWebpackPlugin, extendViteConfig, extendRspackConfig, extendWebpackConfig } from './build.ts'
export type { ExtendConfigOptions, ExtendViteConfigOptions, ExtendWebpackConfigOptions } from './build.ts'
// eslint-disable-next-line @typescript-eslint/no-deprecated
export { assertNuxtCompatibility, checkNuxtCompatibility, getNuxtVersion, hasNuxtCompatibility, isNuxtMajorVersion, normalizeSemanticVersion, isNuxt2, isNuxt3 } from './compatibility.ts'
export type { NuxtMajorVersion } from './compatibility.ts'
export { addComponent, addComponentExports, addComponentsDir } from './components.ts'
export type { AddComponentOptions } from './components.ts'
// eslint-disable-next-line @typescript-eslint/no-deprecated
export { getNuxtCtx, runWithNuxtContext, tryUseNuxt, useNuxt, nuxtCtx } from './context.ts'
export { createIsIgnored, isIgnored, resolveIgnorePatterns } from './ignore.ts'
export { addLayout } from './layout.ts'
export { addRouteMiddleware, extendPages, extendRouteRules } from './pages.ts'
export type { AddRouteMiddlewareOptions, ExtendRouteRulesOptions } from './pages.ts'
export { addPlugin, addPluginTemplate, normalizePlugin } from './plugin.ts'
export type { AddPluginOptions } from './plugin.ts'
export { createResolver, findPath, resolveAlias, resolveFiles, resolveNuxtModule, resolvePath } from './resolve.ts'
export type { ResolvePathOptions, Resolver } from './resolve.ts'
export { addServerHandler, addDevServerHandler, addServerPlugin, addPrerenderRoutes, useNitro, addServerImports, addServerImportsDir, addServerScanDir } from './nitro.ts'
export { addTemplate, addServerTemplate, addTypeTemplate, normalizeTemplate, updateTemplates, writeTypes } from './template.ts'
export { logger, useLogger } from './logger.ts'

// Internal Utils
// eslint-disable-next-line @typescript-eslint/no-deprecated
export { directoryToURL, resolveModule, tryResolveModule, importModule, tryImportModule, requireModule, tryRequireModule } from './internal/esm.ts'
export type { ImportModuleOptions, ResolveModuleOptions } from './internal/esm.ts'
</file>

<file path="packages/kit/src/layers.ts">
import type { Nuxt, NuxtConfigLayer, NuxtOptions } from '@nuxt/schema'
import { resolve } from 'pathe'

import { useNuxt } from './context.ts'
import { resolveAlias } from './resolve.ts'

export interface LayerDirectories {
  /** Nuxt rootDir (`/` by default) */
  readonly root: string
  /** Nitro source directory (`/server` by default) */
  readonly server: string
  /** Local modules directory (`/modules` by default) */
  readonly modules: string
  /** Shared directory (`/shared` by default) */
  readonly shared: string
  /** Public directory (`/public` by default) */
  readonly public: string
  /** Nuxt srcDir (`/app/` by default) */
  readonly app: string
  /** Layouts directory (`/app/layouts` by default) */
  readonly appLayouts: string
  /** Middleware directory (`/app/middleware` by default) */
  readonly appMiddleware: string
  /** Pages directory (`/app/pages` by default) */
  readonly appPages: string
  /** Plugins directory (`/app/plugins` by default) */
  readonly appPlugins: string
}

const layerMap = new WeakMap<NuxtConfigLayer, LayerDirectories>()

/**
 * Get the resolved directory paths for all layers in a Nuxt application.
 *
 * Returns an array of LayerDirectories objects, ordered by layer priority:
 * - The first layer is the user/project layer (highest priority)
 * - Earlier layers override later layers in the array
 * - Base layers appear last in the array (lowest priority)
 *
 * @param nuxt - The Nuxt instance to get layers from. Defaults to the current Nuxt context.
 * @returns Array of LayerDirectories objects, ordered by priority (user layer first)
 */
export function getLayerDirectories (nuxt: Nuxt = useNuxt()): LayerDirectories[] {
  return nuxt.options._layers.map((layer) => {
    if (layerMap.has(layer)) {
      return layerMap.get(layer)!
    }

    const isRoot = withTrailingSlash(layer.config.rootDir) === withTrailingSlash(nuxt.options.rootDir)
    const config = isRoot ? nuxt.options : (layer.config as Omit<NuxtOptions, '_layers'>)

    const src = withTrailingSlash(config.srcDir || layer.cwd)
    const root = withTrailingSlash(config.rootDir || layer.cwd)

    const directories = {
      root,
      shared: withTrailingSlash(resolve(root, resolveAlias(config.dir?.shared || 'shared', nuxt.options.alias))),
      // these are resolved relative to root in `@nuxt/schema` for v4+
      // so resolving relative to `src` covers backward compatibility for v3
      server: withTrailingSlash(resolve(src, resolveAlias(config.serverDir || 'server', nuxt.options.alias))),
      modules: withTrailingSlash(resolve(src, resolveAlias(config.dir?.modules || 'modules', nuxt.options.alias))),
      public: withTrailingSlash(resolve(src, resolveAlias(config.dir?.public || 'public', nuxt.options.alias))),
      // nuxt app
      app: src,
      appLayouts: withTrailingSlash(resolve(src, resolveAlias(config.dir?.layouts || 'layouts', nuxt.options.alias))),
      appMiddleware: withTrailingSlash(resolve(src, resolveAlias(config.dir?.middleware || 'middleware', nuxt.options.alias))),
      appPages: withTrailingSlash(resolve(src, resolveAlias(config.dir?.pages || 'pages', nuxt.options.alias))),
      appPlugins: withTrailingSlash(resolve(src, resolveAlias(config.dir?.plugins || 'plugins', nuxt.options.alias))),
    }
    layerMap.set(layer, directories)
    return directories
  })
}

function withTrailingSlash (dir: string) {
  return dir.replace(/[^/]$/, '$&/')
}
</file>

<file path="packages/kit/src/layout.ts">
import type { NuxtTemplate } from '@nuxt/schema'
import { join, parse } from 'pathe'
import { kebabCase } from 'scule'
import { useNuxt } from './context.ts'
import { logger } from './logger.ts'
import { addTemplate } from './template.ts'
import { reverseResolveAlias } from 'pathe/utils'

const LAYOUT_RE = /["']/g
export function addLayout (template: NuxtTemplate | string, name?: string): void {
  const nuxt = useNuxt()
  const { filename, src } = addTemplate(template)
  const layoutName = kebabCase(name || parse(filename).name).replace(LAYOUT_RE, '')

  // Nuxt 3 adds layouts on app
  nuxt.hook('app:templates', (app) => {
    if (layoutName in app.layouts) {
      const relativePath = reverseResolveAlias(app.layouts[layoutName]!.file, { ...nuxt?.options.alias || {}, ...strippedAtAliases }).pop() || app.layouts[layoutName]!.file
      return logger.warn(
        `Not overriding \`${layoutName}\` (provided by \`${relativePath}\`) with \`${src || filename}\`.`,
      )
    }
    app.layouts[layoutName] = {
      file: join('#build', filename),
      name: layoutName,
    }
  })
}

const strippedAtAliases = {
  '@': '',
  '@@': '',
}
</file>

<file path="packages/kit/src/logger.test.ts">
import { describe, expect, it, vi } from 'vitest'

import { consola } from 'consola'
import { logger, useLogger } from './logger.ts'

vi.mock('consola', () => {
  const logger = {} as any

  logger.create = vi.fn(() => ({ ...logger }))
  logger.withTag = vi.fn(() => ({ ...logger }))

  return { consola: logger }
})

describe('logger', () => {
  it('should expose consola', () => {
    expect(logger).toBe(consola)
  })
})

describe('useLogger', () => {
  it('should expose consola when not passing a tag', () => {
    expect(useLogger()).toBe(consola)
  })

  it('should create a new instance when passing a tag', () => {
    const logger = vi.mocked(consola)

    const instance = useLogger('tag')

    expect(instance).toEqual(logger)
    expect(instance).not.toBe(logger)
    expect(logger.create).toBeCalledWith({})
    expect(logger.withTag).toBeCalledWith('tag')
  })

  it('should create a new instance when passing a tag and options', () => {
    const logger = vi.mocked(consola)

    const instance = useLogger('tag', { level: 0 })

    expect(instance).toEqual(logger)
    expect(instance).not.toBe(logger)
    expect(logger.create).toBeCalledWith({ level: 0 })
    expect(logger.withTag).toBeCalledWith('tag')
  })
})
</file>

<file path="packages/kit/src/logger.ts">
import { consola } from 'consola'
import type { ConsolaInstance, ConsolaOptions } from 'consola'

export const logger: ConsolaInstance = consola

export function useLogger (tag?: string, options: Partial<ConsolaOptions> = {}): ConsolaInstance {
  return tag ? logger.create(options).withTag(tag) : logger
}
</file>

<file path="packages/kit/src/nitro.ts">
import type { Nitro, NitroDevEventHandler, NitroEventHandler } from 'nitropack/types'
import type { Import } from 'unimport'
import { normalize } from 'pathe'
import { useNuxt } from './context.ts'
import { toArray } from './utils.ts'

const HANDLER_METHOD_RE = /\.(get|head|patch|post|put|delete|connect|options|trace)(\.\w+)*$/
/**
 * normalize handler object
 *
 */
function normalizeHandlerMethod (handler: NitroEventHandler) {
  // retrieve method from handler file name
  const [, method = undefined] = handler.handler.match(HANDLER_METHOD_RE) || []
  return {
    method: method as 'get' | 'head' | 'patch' | 'post' | 'put' | 'delete' | 'connect' | 'options' | 'trace',
    ...handler,
    handler: normalize(handler.handler),
  }
}

/**
 * Adds a nitro server handler
 *
 */
export function addServerHandler (handler: NitroEventHandler): void {
  useNuxt().options.serverHandlers.push(normalizeHandlerMethod(handler))
}

/**
 * Adds a nitro server handler for development-only
 *
 */
export function addDevServerHandler (handler: NitroDevEventHandler): void {
  useNuxt().options.devServerHandlers.push(handler)
}

/**
 * Adds a Nitro plugin
 */
export function addServerPlugin (plugin: string): void {
  const nuxt = useNuxt()
  nuxt.options.nitro.plugins ||= []
  nuxt.options.nitro.plugins.push(normalize(plugin))
}

/**
 * Adds routes to be prerendered
 */
export function addPrerenderRoutes (routes: string | string[]): void {
  const nuxt = useNuxt()

  routes = toArray(routes).filter(Boolean)
  if (!routes.length) {
    return
  }
  nuxt.hook('prerender:routes', (ctx) => {
    for (const route of routes) {
      ctx.routes.add(route)
    }
  })
}

/**
 * Access to the Nitro instance
 *
 * **Note:** You can call `useNitro()` only after `ready` hook.
 *
 * **Note:** Changes to the Nitro instance configuration are not applied.
 * @example
 *
 * ```ts
 * nuxt.hook('ready', () => {
 *   console.log(useNitro())
 * })
 * ```
 */
export function useNitro (): Nitro {
  const nuxt = useNuxt()
  if (!(nuxt as any)._nitro) {
    throw new Error('Nitro is not initialized yet. You can call `useNitro()` only after `ready` hook.')
  }
  return (nuxt as any)._nitro
}

/**
 * Add server imports to be auto-imported by Nitro
 */
export function addServerImports (imports: Import | Import[]): void {
  const nuxt = useNuxt()
  const _imports = toArray(imports)
  nuxt.hook('nitro:config', (config) => {
    config.imports ||= {}
    config.imports.imports ||= []
    config.imports.imports.push(..._imports)
  })
}

/**
 * Add directories to be scanned for auto-imports by Nitro
 */
export function addServerImportsDir (dirs: string | string[], opts: { prepend?: boolean } = {}): void {
  const nuxt = useNuxt()
  const _dirs = toArray(dirs)
  nuxt.hook('nitro:config', (config) => {
    config.imports ||= {}
    config.imports.dirs ||= []
    config.imports.dirs[opts.prepend ? 'unshift' : 'push'](..._dirs)
  })
}

/**
 * Add directories to be scanned by Nitro. It will check for subdirectories,
 * which will be registered just like the `~/server` folder is.
 */
export function addServerScanDir (dirs: string | string[], opts: { prepend?: boolean } = {}): void {
  const nuxt = useNuxt()
  nuxt.hook('nitro:config', (config) => {
    config.scanDirs ||= []

    for (const dir of toArray(dirs)) {
      config.scanDirs[opts.prepend ? 'unshift' : 'push'](dir)
    }
  })
}
</file>

<file path="packages/kit/src/pages.ts">
import type { NuxtHooks, NuxtMiddleware } from '@nuxt/schema'
import type { NitroRouteConfig } from 'nitropack/types'
import { defu } from 'defu'
import { useNuxt } from './context.ts'
import { logger } from './logger.ts'
import { toArray } from './utils.ts'

export function extendPages (cb: NuxtHooks['pages:extend']): void {
  useNuxt().hook('pages:extend', cb)
}

export interface ExtendRouteRulesOptions {
  /**
   * Override route rule config
   * @default false
   */
  override?: boolean
}

export function extendRouteRules (route: string, rule: NitroRouteConfig, options: ExtendRouteRulesOptions = {}): void {
  const nuxt = useNuxt()
  for (const opts of [nuxt.options, nuxt.options.nitro]) {
    opts.routeRules ||= {}
    opts.routeRules[route] = options.override
      ? defu(rule, opts.routeRules[route])
      : defu(opts.routeRules[route], rule)
  }
}

export interface AddRouteMiddlewareOptions {
  /**
   * Override existing middleware with the same name, if it exists
   * @default false
   */
  override?: boolean
  /**
   * Prepend middleware to the list
   * @default false
   */
  prepend?: boolean
}

export function addRouteMiddleware (input: NuxtMiddleware | NuxtMiddleware[], options: AddRouteMiddlewareOptions = {}): void {
  const nuxt = useNuxt()
  const middlewares = toArray(input)
  nuxt.hook('app:resolve', (app) => {
    for (const middleware of middlewares) {
      const find = app.middleware.findIndex(item => item.name === middleware.name)
      if (find >= 0) {
        const foundPath = app.middleware[find]!.path
        if (foundPath === middleware.path) { continue }
        if (options.override === true) {
          app.middleware[find] = { ...middleware }
        } else {
          logger.warn(`'${middleware.name}' middleware already exists at '${foundPath}'. You can set \`override: true\` to replace it.`)
        }
      } else if (options.prepend === true) {
        app.middleware.unshift({ ...middleware })
      } else {
        app.middleware.push({ ...middleware })
      }
    }
  })
}
</file>

<file path="packages/kit/src/plugin.ts">
import { existsSync } from 'node:fs'
import { isAbsolute } from 'node:path'
import { normalize } from 'pathe'
import type { NuxtPlugin, NuxtPluginTemplate } from '@nuxt/schema'
import { resolveModulePath } from 'exsolve'
import { MODE_RE, filterInPlace } from './utils.ts'
import { tryUseNuxt, useNuxt } from './context.ts'
import { addTemplate } from './template.ts'
import { resolveAlias } from './resolve.ts'

/**
 * Normalize a nuxt plugin object
 */
const pluginSymbol = Symbol.for('nuxt plugin')
export function normalizePlugin (plugin: NuxtPlugin | string): NuxtPlugin {
  // Normalize src
  if (typeof plugin === 'string') {
    plugin = { src: plugin }
  } else {
    plugin = { ...plugin }
  }

  if (pluginSymbol in plugin) {
    return plugin
  }

  if (!plugin.src) {
    throw new Error('Invalid plugin. src option is required: ' + JSON.stringify(plugin))
  }

  // Normalize full path to plugin
  plugin.src = normalize(resolveAlias(plugin.src))

  if (!existsSync(plugin.src) && isAbsolute(plugin.src)) {
    try {
      plugin.src = resolveModulePath(plugin.src, {
        extensions: tryUseNuxt()?.options.extensions ?? ['.js', '.mjs', '.cjs', '.ts', '.tsx', '.mts', '.cts'],
      })
    } catch {
      // ignore errors as the file may be in the nuxt vfs
    }
  }

  // Normalize mode
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  if (plugin.ssr) {
    plugin.mode = 'server'
  }
  if (!plugin.mode) {
    const [, mode = 'all'] = plugin.src.match(MODE_RE) || []
    plugin.mode = mode as 'all' | 'client' | 'server'
  }

  // @ts-expect-error not adding symbol to types to avoid conflicts
  plugin[pluginSymbol] = true

  return plugin
}

/**
 * Registers a nuxt plugin and to the plugins array.
 *
 * Note: You can use mode or .client and .server modifiers with fileName option
 * to use plugin only in client or server side.
 *
 * Note: By default plugin is prepended to the plugins array. You can use second argument to append (push) instead.
 * @example
 * ```js
 * import { createResolver } from '@nuxt/kit'
 * const resolver = createResolver(import.meta.url)
 *
 * addPlugin({
 *   src: resolver.resolve('templates/foo.js'),
 *   filename: 'foo.server.js' // [optional] only include in server bundle
 * })
 * ```
 */
export interface AddPluginOptions { append?: boolean }
export function addPlugin (_plugin: NuxtPlugin | string, opts: AddPluginOptions = {}): NuxtPlugin {
  const nuxt = useNuxt()

  // Normalize plugin
  const plugin = normalizePlugin(_plugin)

  // Remove any existing plugin with the same src
  filterInPlace(nuxt.options.plugins, p => normalizePlugin(p).src !== plugin.src)

  // Prepend to array by default to be before user provided plugins since is usually used by modules
  nuxt.options.plugins[opts.append ? 'push' : 'unshift'](plugin)

  return plugin
}

/**
 * Adds a template and registers as a nuxt plugin.
 */
export function addPluginTemplate (plugin: NuxtPluginTemplate | string, opts: AddPluginOptions = {}): NuxtPlugin {
  const normalizedPlugin: NuxtPlugin = typeof plugin === 'string'
    ? { src: plugin }
    // Update plugin src to template destination
    : { ...plugin, src: addTemplate(plugin).dst! }

  return addPlugin(normalizedPlugin, opts)
}
</file>

<file path="packages/kit/src/resolve.test.ts">
import { stat } from 'node:fs/promises'
import { describe, expect, it } from 'vitest'
import { resolve } from 'pathe'
import { withTrailingSlash } from 'ufo'
import { loadNuxt } from './loader/nuxt.ts'
import { findPath, resolveNuxtModule, resolvePath } from './resolve.ts'
import { defineNuxtModule } from './module/define.ts'
import { addTemplate } from './template.ts'

const nuxt = await loadNuxt({
  overrides: {
    modules: [
      defineNuxtModule(() => {
        addTemplate({
          filename: 'my-template.mjs',
          getContents: () => 'export const myUtil = () => \'hello\'',
        })
      }),
    ],
  },
})

describe('resolvePath', () => {
  it('should resolve paths correctly', async () => {
    expect(await resolvePath('.nuxt/app.config')).toBe(resolve('.nuxt/app.config.mjs'))
  })
})

describe('resolveNuxtModule', () => {
  it('should resolve Nuxt module paths correctly', async () => {
    const installedModulePaths = nuxt.options._installedModules.map(m => m.meta?.rawPath || m.entryPath!).filter(Boolean)
    expect(installedModulePaths).toMatchInlineSnapshot(`
      [
        "@nuxt/devtools",
        "@nuxt/telemetry",
      ]
    `)

    const resolved = await resolveNuxtModule(withTrailingSlash(nuxt.options.rootDir), [
      ...installedModulePaths,
      '@nuxt/test-utils/module',
    ])

    expect(resolved.length).toBe(3)

    for (const path of resolved) {
      expect(await stat(path).then(r => r.isDirectory() && path.endsWith('node_modules/')).catch(() => false)).toBe(true)
    }
  })
})

describe('findPath', () => {
  it('should find paths correctly', async () => {
    expect(await findPath(resolve(nuxt.options.buildDir, 'my-template'), { virtual: true })).toBe(resolve(nuxt.options.buildDir, 'my-template.mjs'))
  })
})
</file>

<file path="packages/kit/src/resolve.ts">
import { promises as fsp } from 'node:fs'
import { fileURLToPath } from 'node:url'
import process from 'node:process'
import { basename, dirname, isAbsolute, join, normalize, resolve } from 'pathe'
import { type GlobOptions, glob } from 'tinyglobby'
import { resolveModulePath } from 'exsolve'
import { resolveAlias as _resolveAlias } from 'pathe/utils'
import { parseNodeModulePath } from 'mlly'
import { directoryToURL } from './internal/esm.ts'
import { tryUseNuxt } from './context.ts'
import { isIgnored } from './ignore.ts'
import { type RequirePicked, toArray } from './utils.ts'

export interface ResolvePathOptions {
  /** Base for resolving paths from. Default is Nuxt rootDir. */
  cwd?: string

  /** An object of aliases. Default is Nuxt configured aliases. */
  alias?: Record<string, string>

  /**
   * The file extensions to try.
   * Default is Nuxt configured extensions.
   *
   * Isn't considered when `type` is set to `'dir'`.
   */
  extensions?: string[]

  /**
   * Whether to resolve files that exist in the Nuxt VFS (for example, as a Nuxt template).
   * @default false
   */
  virtual?: boolean

  /**
   * Whether to fallback to the original path if the resolved path does not exist instead of returning the normalized input path.
   * @default false
   */
  fallbackToOriginal?: boolean
  /**
   * The type of the path to be resolved.
   * @default 'file'
   */
  type?: PathType
}

/**
 * Resolve the full path to a file or a directory (based on the provided type), respecting Nuxt alias and extensions options.
 *
 * If a path cannot be resolved, normalized input will be returned unless the `fallbackToOriginal` option is set to `true`,
 * in which case the original input path will be returned.
 */
export async function resolvePath (path: string, opts: ResolvePathOptions = {}): Promise<string> {
  const { type = 'file' } = opts

  const res = await _resolvePathGranularly(path, { ...opts, type })

  if (res.type === type) {
    return res.path
  }

  // Return normalized input
  return opts.fallbackToOriginal ? path : res.path
}

/**
 * Try to resolve first existing file in paths
 */
export async function findPath (paths: string | string[], opts?: ResolvePathOptions, pathType: PathType = 'file'): Promise<string | null> {
  for (const path of toArray(paths)) {
    const res = await _resolvePathGranularly(path, {
      ...opts,
      // TODO: this is for backwards compatibility, remove the `pathType` argument in Nuxt 5
      type: opts?.type || pathType,
    })

    if (!res.type || (pathType && res.type !== pathType)) {
      continue
    }

    // Check file system
    if (res.virtual || await existsSensitive(res.path)) {
      return res.path
    }
  }
  return null
}

/**
 * Resolve path aliases respecting Nuxt alias options
 */
export function resolveAlias (path: string, alias?: Record<string, string>): string {
  alias ||= tryUseNuxt()?.options.alias || {}
  return _resolveAlias(path, alias)
}

export interface Resolver {
  resolve (...path: string[]): string
  resolvePath (path: string, opts?: ResolvePathOptions): Promise<string>
}

/**
 * Create a relative resolver
 */
export function createResolver (base: string | URL): Resolver {
  if (!base) {
    throw new Error('`base` argument is missing for createResolver(base)!')
  }

  base = base.toString()
  if (base.startsWith('file://')) {
    base = dirname(fileURLToPath(base))
  }

  return {
    resolve: (...path) => resolve(base as string, ...path),
    resolvePath: (path, opts) => resolvePath(path, { cwd: base as string, ...opts }),
  }
}

export async function resolveNuxtModule (base: string, paths: string[]): Promise<string[]> {
  const resolved: string[] = []
  const resolver = createResolver(base)

  for (const path of paths) {
    if (path.startsWith(base)) {
      resolved.push(path.split('/index.ts')[0]!)
      continue
    }
    const resolvedPath = await resolver.resolvePath(path)
    const dir = parseNodeModulePath(resolvedPath).dir
    if (dir) {
      resolved.push(dir)
      continue
    }
    const index = resolvedPath.lastIndexOf(path)
    resolved.push(index === -1 ? dirname(resolvedPath) : resolvedPath.slice(0, index + path.length))
  }

  return resolved
}

// --- Internal ---

type PathType = 'file' | 'dir'

interface PathResolution {
  path: string
  type?: PathType
  virtual?: boolean
}

async function _resolvePathType (path: string, opts: ResolvePathOptions = {}, skipFs = false): Promise<PathResolution | undefined> {
  if (opts?.virtual && existsInVFS(path)) {
    return {
      path,
      type: 'file',
      virtual: true,
    }
  }

  if (skipFs) {
    return
  }

  const fd = await fsp.open(path, 'r').catch(() => null)
  try {
    const stats = await fd?.stat()
    if (stats) {
      return {
        path,
        type: stats.isFile() ? 'file' : 'dir',
        virtual: false,
      }
    }
  } finally {
    fd?.close()
  }
}

function normalizeExtension (ext: string) {
  return ext.startsWith('.') ? ext : `.${ext}`
}

async function _resolvePathGranularly (path: string, opts: RequirePicked<ResolvePathOptions, 'type'> = { type: 'file' }): Promise<PathResolution> {
  // Always normalize input
  const _path = path
  path = normalize(path)

  // Fast return if the path exists
  if (isAbsolute(path)) {
    const res = await _resolvePathType(path, opts)
    if (res && res.type === opts.type) {
      return res
    }
  }

  // Use current nuxt options
  const nuxt = tryUseNuxt()
  const cwd = opts.cwd || (nuxt ? nuxt.options.rootDir : process.cwd())
  const extensions = opts.extensions || (nuxt ? nuxt.options.extensions : ['.ts', '.mjs', '.cjs', '.json'])
  const modulesDir = nuxt ? nuxt.options.modulesDir : []

  // Resolve aliases
  path = _resolveAlias(path, opts.alias ?? nuxt?.options.alias ?? {})

  // Resolve relative to cwd
  if (!isAbsolute(path)) {
    path = resolve(cwd, path)
  }

  const res = await _resolvePathType(path, opts)
  if (res && res.type === opts.type) {
    return res
  }

  // Check possible extensions
  if (opts.type === 'file') {
    for (const ext of extensions) {
      const normalizedExt = normalizeExtension(ext)

      // path.[ext]
      const extPath = await _resolvePathType(path + normalizedExt, opts)
      if (extPath && extPath.type === 'file') {
        return extPath
      }

      // path/index.[ext]
      const indexPath = await _resolvePathType(join(path, 'index' + normalizedExt), opts, res?.type !== 'dir' /* skip checking if parent is not a directory */)
      if (indexPath && indexPath.type === 'file') {
        return indexPath
      }
    }

    // Try to resolve as module id
    const resolvedModulePath = resolveModulePath(_path, {
      try: true,
      suffixes: ['', 'index'],
      from: [cwd, ...modulesDir].map(d => directoryToURL(d)),
    })
    if (resolvedModulePath) {
      return {
        path: resolvedModulePath,
        type: 'file',
        virtual: false,
      }
    }
  }

  // Return normalized input
  return {
    path,
  }
}

async function existsSensitive (path: string) {
  const dirFiles = new Set(await fsp.readdir(dirname(path)).catch(() => []))
  return dirFiles.has(basename(path))
}

function existsInVFS (path: string, nuxt = tryUseNuxt()) {
  if (!nuxt) { return false }

  if (path in nuxt.vfs) {
    return true
  }

  const templates = nuxt.apps.default?.templates ?? nuxt.options.build.templates
  return templates.some(template => template.dst === path)
}

/**
 * Resolve absolute file paths in the provided directory with respect to `.nuxtignore` and return them sorted.
 * @param path path to the directory to resolve files in
 * @param pattern glob pattern or an array of glob patterns to match files
 * @param opts options for globbing
 * @param opts.followSymbolicLinks whether to follow symbolic links, default is `true`
 * @param opts.ignore additional glob patterns to ignore
 * @returns sorted array of absolute file paths
 */
export async function resolveFiles (path: string, pattern: string | string[], opts: { followSymbolicLinks?: boolean, ignore?: GlobOptions['ignore'] } = {}): Promise<string[]> {
  const files: string[] = []
  for (const p of await glob(pattern, { cwd: path, followSymbolicLinks: opts.followSymbolicLinks ?? true, absolute: true, ignore: opts.ignore })) {
    if (!isIgnored(p)) {
      files.push(p)
    }
  }
  return files.sort()
}
</file>

<file path="packages/kit/src/runtime-config.test.ts">
import { afterEach, describe, expect, it, vi } from 'vitest'
import { useRuntimeConfig } from './runtime-config.ts'

const { useNuxt, klona } = vi.hoisted(() => ({ useNuxt: vi.fn(), klona: vi.fn() }))

vi.mock('./context', () => ({ useNuxt }))
vi.mock('klona', () => ({ klona }))

const testCases = [
  {
    description:
      'should return runtime config with environment variables applied',
    runtimeConfig: {
      apiUrl: 'http://localhost',
      authUrl: 'http://auth.com',
    },
    envExpansion: true,
    env: {
      NITRO_API_URL: 'http://example.com',
    },
    expected: {
      apiUrl: 'http://example.com',
      authUrl: 'http://auth.com',
    },
  },
  {
    description: 'should expand environment variables in strings',
    runtimeConfig: {
      apiUrl: '{{BASE_URL}}/api',
      mail: '{{MAIL_SCHEME}}://{{MAIL_HOST}}:{{MAIL_PORT}}',
    },
    envExpansion: true,
    env: {
      BASE_URL: 'http://example.com',
      MAIL_SCHEME: 'http',
      MAIL_HOST: 'localhost',
      MAIL_PORT: '3366',
    },
    expected: {
      apiUrl: 'http://example.com/api',
      mail: 'http://localhost:3366',
    },
  },
  {
    description:
      'should not expand environment variables if envExpansion is false',
    runtimeConfig: {
      apiUrl: '{{BASE_URL}}/api',
      someUrl: '',
    },
    envExpansion: false,
    env: {
      BASE_URL: 'http://example1.com',
      NITRO_NOT_API_URL: 'http://example2.com',
      NUXT_SOME_URL: 'http://example3.com',
    },
    expected: {
      apiUrl: '{{BASE_URL}}/api',
      someUrl: 'http://example3.com',
    },
  },
]

describe('useRuntimeConfig', () => {
  afterEach(() => {
    vi.unstubAllEnvs()
  })

  it.each(testCases)('$description', ({ runtimeConfig, envExpansion, env, expected }) => {
    useNuxt.mockReturnValue({ options: { nitro: { runtimeConfig, experimental: { envExpansion } } } })
    klona.mockReturnValue(runtimeConfig)
    Object.entries(env).forEach(([key, value]) => vi.stubEnv(key, value))

    expect(useRuntimeConfig()).toEqual(expected)
  })
})
</file>

<file path="packages/kit/src/runtime-config.ts">
import process from 'node:process'
import destr from 'destr'
import { snakeCase } from 'scule'
import { klona } from 'klona'

import { defu } from 'defu'
import { useNuxt } from './context.ts'
import { useNitro } from './nitro.ts'

/**
 * Access 'resolved' Nuxt runtime configuration, with values updated from environment.
 *
 * This mirrors the runtime behavior of Nitro.
 */
export function useRuntimeConfig (): Record<string, any> {
  const nuxt = useNuxt()
  return applyEnv(klona(nuxt.options.nitro.runtimeConfig!), {
    prefix: 'NITRO_',
    altPrefix: 'NUXT_',
    envExpansion: nuxt.options.nitro.experimental?.envExpansion ?? !!process.env.NITRO_ENV_EXPANSION,
  })
}

/**
 * Update Nuxt runtime configuration.
 */
export function updateRuntimeConfig (runtimeConfig: Record<string, unknown>): void | Promise<void> {
  const nuxt = useNuxt()
  Object.assign(nuxt.options.nitro.runtimeConfig as Record<string, unknown>, defu(runtimeConfig, nuxt.options.nitro.runtimeConfig))

  try {
    return useNitro().updateConfig({ runtimeConfig })
  } catch {
    // Nitro is not yet initialised - we can safely ignore this error
  }
}

/**
 * https://github.com/nitrojs/nitro/blob/v2/src/runtime/internal/utils.env.ts.
*
 * These utils will be replaced by util exposed from nitropack. See https://github.com/nitrojs/nitro/pull/2404
 * for more context and future plans.)
 *
 * @internal
 */

type EnvOptions = {
  prefix?: string
  altPrefix?: string
  envExpansion?: boolean
}

function getEnv (key: string, opts: EnvOptions, env = process.env) {
  const envKey = snakeCase(key).toUpperCase()
  return destr(
    env[opts.prefix + envKey] ?? env[opts.altPrefix + envKey],
  )
}

function _isObject (input: unknown) {
  return typeof input === 'object' && !Array.isArray(input)
}

function applyEnv (
  obj: Record<string, any>,
  opts: EnvOptions,
  parentKey = '',
) {
  for (const key in obj) {
    const subKey = parentKey ? `${parentKey}_${key}` : key
    const envValue = getEnv(subKey, opts)
    if (_isObject(obj[key])) {
      // Same as before
      if (_isObject(envValue)) {
        obj[key] = { ...(obj[key] as any), ...(envValue as any) }
        applyEnv(obj[key], opts, subKey)
      } else if (envValue === undefined) {
        // If envValue is undefined
        // Then proceed to nested properties
        applyEnv(obj[key], opts, subKey)
      } else {
        // If envValue is a primitive other than undefined
        // Then set objValue and ignore the nested properties
        obj[key] = envValue ?? obj[key]
      }
    } else {
      obj[key] = envValue ?? obj[key]
    }
    // Experimental env expansion
    if (opts.envExpansion && typeof obj[key] === 'string') {
      obj[key] = _expandFromEnv(obj[key])
    }
  }
  return obj
}

const envExpandRx = /\{\{([^{}]*)\}\}/g

function _expandFromEnv (value: string, env: Record<string, any> = process.env) {
  return value.replace(envExpandRx, (match, key) => {
    return env[key] || match
  })
}
</file>

<file path="packages/kit/src/template.ts">
import { existsSync, promises as fsp } from 'node:fs'
import { fileURLToPath } from 'node:url'
import { basename, isAbsolute, join, normalize, parse, relative, resolve } from 'pathe'
import { hash } from 'ohash'
import type { Nuxt, NuxtServerTemplate, NuxtTemplate, NuxtTypeTemplate, ResolvedNuxtTemplate, TSReference } from '@nuxt/schema'
import { defu } from 'defu'
import type { TSConfig } from 'pkg-types'
import { gte } from 'semver'
import { readPackageJSON } from 'pkg-types'
import { resolveModulePath } from 'exsolve'
import { captureStackTrace } from 'errx'

import { distDirURL, filterInPlace } from './utils.ts'
import { directoryToURL } from './internal/esm.ts'
import { getDirectory } from './module/install.ts'
import { tryUseNuxt, useNuxt } from './context.ts'
import { resolveNuxtModule } from './resolve.ts'
import { getLayerDirectories } from './layers.ts'
import type { LayerDirectories } from './layers.ts'

/**
 * Renders given template during build into the virtual file system (and optionally to disk in the project `buildDir`)
 */
export function addTemplate<T> (_template: NuxtTemplate<T> | string): ResolvedNuxtTemplate<T> {
  const nuxt = useNuxt()

  // Normalize template
  const template = normalizeTemplate(_template)

  // Remove any existing template with the same destination path
  filterInPlace(nuxt.options.build.templates, p => (p.dst || normalizeTemplate(p).dst) !== template.dst)

  try {
    const distDir = distDirURL.toString()
    const { source } = captureStackTrace().find(e => e.source && !e.source.startsWith(distDir)) ?? {}
    if (source) {
      const path = normalize(fileURLToPath(source))
      if (existsSync(path)) {
        template._path = path
      }
    }
  } catch {
    // ignore errors as this is an additive feature
  }

  // Add to templates array
  nuxt.options.build.templates.push(template)

  return template
}

/**
 * Adds a virtual file that can be used within the Nuxt Nitro server build.
 */
export function addServerTemplate (template: NuxtServerTemplate): NuxtServerTemplate {
  const nuxt = useNuxt()

  nuxt.options.nitro.virtual ||= {}
  nuxt.options.nitro.virtual[template.filename] = template.getContents

  return template
}

/**
 * Renders given types during build to disk in the project `buildDir`
 * and register them as types.
 *
 * You can pass a second context object to specify in which context the type should be added.
 *
 * If no context object is passed, then it will only be added to the nuxt context.
 */
export function addTypeTemplate<T> (_template: NuxtTypeTemplate<T>, context?: { nitro?: boolean, nuxt?: boolean, node?: boolean, shared?: boolean }): ResolvedNuxtTemplate<T> {
  const nuxt = useNuxt()

  const template = addTemplate(_template)

  if (!template.filename.endsWith('.d.ts')) {
    throw new Error(`Invalid type template. Filename must end with .d.ts : "${template.filename}"`)
  }

  // Add template to types reference
  if (!context || context.nuxt) {
    nuxt.hook('prepare:types', (payload) => {
      payload.references ||= []
      payload.references.push({ path: template.dst })
    })
  }
  if (context?.node) {
    nuxt.hook('prepare:types', (payload) => {
      payload.nodeReferences ||= []
      payload.nodeReferences.push({ path: template.dst })
    })
  }
  if (context?.shared) {
    nuxt.hook('prepare:types', (payload) => {
      payload.sharedReferences ||= []
      payload.sharedReferences.push({ path: template.dst })
    })
  }

  if (!context || context.nuxt || context.shared) {
    // expose global types to vue compiler
    nuxt.options.vite.vue = defu(nuxt.options.vite.vue, {
      script: {
        globalTypeFiles: [template.dst],
      },
    })
  }

  if (context?.nitro) {
    nuxt.hook('nitro:prepare:types', (payload) => {
      payload.references ||= []
      payload.references.push({ path: template.dst })
    })
  }

  return template
}

/**
 * Normalize a nuxt template object
 */
export function normalizeTemplate<T> (template: NuxtTemplate<T> | string, buildDir?: string): ResolvedNuxtTemplate<T> {
  if (!template) {
    throw new Error('Invalid template: ' + JSON.stringify(template))
  }

  // Normalize
  if (typeof template === 'string') {
    template = { src: template }
  } else {
    template = { ...template }
  }

  // Use src if provided
  if (template.src) {
    if (!existsSync(template.src)) {
      throw new Error('Template not found: ' + template.src)
    }
    if (!template.filename) {
      const srcPath = parse(template.src)
      template.filename = (template as any).fileName || `${basename(srcPath.dir)}.${srcPath.name}.${hash(template.src).replace(/-/g, '_')}${srcPath.ext}`
    }
  }

  if (!template.src && !template.getContents) {
    throw new Error('Invalid template. Either `getContents` or `src` should be provided: ' + JSON.stringify(template))
  }

  if (!template.filename) {
    throw new Error('Invalid template. `filename` must be provided: ' + JSON.stringify(template))
  }

  // Always write declaration files
  if (template.filename.endsWith('.d.ts')) {
    template.write = true
  }

  // Resolve dst
  template.dst ||= resolve(buildDir ?? useNuxt().options.buildDir, template.filename)

  return template as ResolvedNuxtTemplate<T>
}

/**
 * Trigger rebuilding Nuxt templates
 *
 * You can pass a filter within the options to selectively regenerate a subset of templates.
 */
export async function updateTemplates (options?: { filter?: (template: ResolvedNuxtTemplate<any>) => boolean }): Promise<void> {
  return await tryUseNuxt()?.hooks.callHook('builder:generateApp', options)
}

interface LayerPaths {
  nuxt: string[]
  nitro: string[]
  node: string[]
  shared: string[]
  sharedDeclarations: string[]
  globalDeclarations: string[]
}

export function resolveLayerPaths (dirs: LayerDirectories, projectBuildDir: string): LayerPaths {
  const relativeRootDir = relativeWithDot(projectBuildDir, dirs.root)
  const relativeSrcDir = relativeWithDot(projectBuildDir, dirs.app)
  const relativeModulesDir = relativeWithDot(projectBuildDir, dirs.modules)
  const relativeSharedDir = relativeWithDot(projectBuildDir, dirs.shared)
  return {
    nuxt: [
      join(relativeSrcDir, '**/*'),
      join(relativeModulesDir, `*/runtime/**/*`),
      join(relativeRootDir, `test/nuxt/**/*`),
      join(relativeRootDir, `tests/nuxt/**/*`),
      join(relativeRootDir, `layers/*/app/**/*`),
      join(relativeRootDir, `layers/*/modules/*/runtime/**/*`),
    ],
    nitro: [
      join(relativeModulesDir, `*/runtime/server/**/*`),
      join(relativeRootDir, `layers/*/server/**/*`),
      join(relativeRootDir, `layers/*/modules/*/runtime/server/**/*`),
    ],
    node: [
      join(relativeModulesDir, `*.*`),
      join(relativeRootDir, `nuxt.config.*`),
      join(relativeRootDir, `.config/nuxt.*`),
      join(relativeRootDir, `layers/*/nuxt.config.*`),
      join(relativeRootDir, `layers/*/.config/nuxt.*`),
      join(relativeRootDir, `layers/*/modules/**/*`),
    ],
    shared: [
      join(relativeSharedDir, `**/*`),
      join(relativeModulesDir, `*/shared/**/*`),
      join(relativeRootDir, `layers/*/shared/**/*`),
    ],
    sharedDeclarations: [
      join(relativeSharedDir, `**/*.d.ts`),
      join(relativeModulesDir, `*/shared/**/*.d.ts`),
      join(relativeRootDir, `layers/*/shared/**/*.d.ts`),
    ],
    globalDeclarations: [
      join(relativeRootDir, `*.d.ts`),
      join(relativeRootDir, `layers/*/*.d.ts`),
    ],
  }
}

const EXTENSION_RE = /\b(?:\.d\.[cm]?ts|\.\w+)$/g
// Exclude bridge alias types to support Volar
const excludedAlias = [/^@vue\/.*$/, /^#internal\/nuxt/]

interface GenerateTypesReturn {
  declaration: string
  sharedTsConfig: TSConfig
  sharedDeclaration: string
  nodeTsConfig: TSConfig
  nodeDeclaration: string
  tsConfig: TSConfig
  legacyTsConfig: TSConfig
}
export async function _generateTypes (nuxt: Nuxt): Promise<GenerateTypesReturn> {
  const include = new Set<string>(['./nuxt.d.ts'])
  const nodeInclude = new Set<string>(['./nuxt.node.d.ts'])
  const sharedInclude = new Set<string>(['./nuxt.shared.d.ts'])
  const legacyInclude = new Set<string>([...include, ...nodeInclude])

  const exclude = new Set<string>()
  const nodeExclude = new Set<string>()
  const sharedExclude = new Set<string>()
  const legacyExclude = new Set<string>()

  if (nuxt.options.typescript.includeWorkspace && nuxt.options.workspaceDir !== nuxt.options.srcDir) {
    include.add(join(relative(nuxt.options.buildDir, nuxt.options.workspaceDir), '**/*'))
    legacyInclude.add(join(relative(nuxt.options.buildDir, nuxt.options.workspaceDir), '**/*'))
  }

  const layerDirs = getLayerDirectories(nuxt)

  const sourceDirs = layerDirs.map(layer => layer.app)

  // node_modules folders
  for (const dir of nuxt.options.modulesDir) {
    // we only need to exclude node_modules directories if they are
    // being included automatically by being inside the source directory
    if (!sourceDirs.some(srcDir => dir.startsWith(srcDir))) {
      exclude.add(relativeWithDot(nuxt.options.buildDir, dir))
    }
    nodeExclude.add(relativeWithDot(nuxt.options.buildDir, dir))
    legacyExclude.add(relativeWithDot(nuxt.options.buildDir, dir))
  }

  // nitro generate output: https://github.com/nuxt/nuxt/blob/main/packages/nitro-server/src/index.ts
  // + nitro generate .data in development when kv storage is used
  for (const dir of ['dist', '.data']) {
    exclude.add(relativeWithDot(nuxt.options.buildDir, resolve(nuxt.options.rootDir, dir)))
    nodeExclude.add(relativeWithDot(nuxt.options.buildDir, resolve(nuxt.options.rootDir, dir)))
    legacyExclude.add(relativeWithDot(nuxt.options.buildDir, resolve(nuxt.options.rootDir, dir)))
  }

  const rootDirWithSlash = withTrailingSlash(nuxt.options.rootDir)
  for (const dirs of layerDirs) {
    if (!dirs.app.startsWith(rootDirWithSlash) || dirs.root === rootDirWithSlash || dirs.app.includes('node_modules')) {
      const rootGlob = join(relativeWithDot(nuxt.options.buildDir, dirs.root), '**/*')
      const paths = resolveLayerPaths(dirs, nuxt.options.buildDir)
      for (const path of paths.nuxt) {
        include.add(path)
        legacyInclude.add(path)
        if (path !== rootGlob) {
          nodeExclude.add(path)
        }
      }
      for (const path of paths.nitro) {
        exclude.add(path)
        nodeExclude.add(path)
        legacyExclude.add(path)
      }
      for (const path of paths.node) {
        nodeInclude.add(path)
        legacyInclude.add(path)
        exclude.add(path)
      }
      for (const path of paths.shared) {
        legacyInclude.add(path)
        sharedInclude.add(path)
      }
      for (const path of paths.sharedDeclarations) {
        include.add(path)
      }
      for (const path of paths.globalDeclarations) {
        include.add(path)
        legacyInclude.add(path)
        sharedInclude.add(path)
      }
    }
  }

  const moduleEntryPaths: string[] = []
  for (const m of nuxt.options._installedModules) {
    const path = m.meta?.rawPath || m.entryPath
    if (path) {
      moduleEntryPaths.push(getDirectory(path))
    }
  }

  const modulePaths = await resolveNuxtModule(rootDirWithSlash, moduleEntryPaths)

  for (const path of modulePaths) {
    const relative = relativeWithDot(nuxt.options.buildDir, path)
    if (!path.includes('node_modules') && path.startsWith(rootDirWithSlash)) {
      include.add(join(relative, 'runtime'))
      include.add(join(relative, 'dist/runtime'))
      nodeInclude.add(join(relative, '*.*'))
    }

    legacyInclude.add(join(relative, 'runtime'))
    legacyInclude.add(join(relative, 'dist/runtime'))

    nodeExclude.add(join(relative, 'runtime'))
    nodeExclude.add(join(relative, 'dist/runtime'))

    exclude.add(join(relative, 'runtime/server'))
    exclude.add(join(relative, 'dist/runtime/server'))
    exclude.add(join(relative, '*.*'))
    exclude.add(join(relative, 'dist/*.*'))
    legacyExclude.add(join(relative, 'runtime/server'))
    legacyExclude.add(join(relative, 'dist/runtime/server'))
  }

  const nestedModulesDirs: string[] = []
  for (const dir of [...nuxt.options.modulesDir].sort()) {
    const withSlash = withTrailingSlash(dir)
    if (nestedModulesDirs.every(d => !d.startsWith(withSlash))) {
      nestedModulesDirs.push(withSlash)
    }
  }

  let hasTypescriptVersionWithModulePreserve
  for (const parent of nestedModulesDirs) {
    hasTypescriptVersionWithModulePreserve ??= await readPackageJSON('typescript', { parent })
      .then(r => r?.version && gte(r.version, '5.4.0'))
      .catch(() => undefined)
  }
  hasTypescriptVersionWithModulePreserve ??= true

  const useDecorators = Boolean(nuxt.options.experimental?.decorators)

  // https://www.totaltypescript.com/tsconfig-cheat-sheet
  const tsConfig: TSConfig = defu(nuxt.options.typescript?.tsConfig, {
    compilerOptions: {
      /* Base options: */
      esModuleInterop: true,
      skipLibCheck: true,
      target: 'ESNext',
      allowJs: true,
      resolveJsonModule: true,
      moduleDetection: 'force',
      isolatedModules: true,
      verbatimModuleSyntax: true,
      /* Strictness */
      strict: nuxt.options.typescript?.strict ?? true,
      noUncheckedIndexedAccess: true,
      forceConsistentCasingInFileNames: true,
      noImplicitOverride: true,
      /* Decorator support */
      ...useDecorators
        ? {
            experimentalDecorators: false,
          }
        : {},
      /* If NOT transpiling with TypeScript: */
      module: hasTypescriptVersionWithModulePreserve ? 'preserve' : 'ESNext',
      noEmit: true,
      /* If your code runs in the DOM: */
      lib: [
        'ESNext',
        ...useDecorators ? ['esnext.decorators'] : [],
        'dom',
        'dom.iterable',
        'webworker',
      ],
      /* JSX support for Vue */
      jsx: 'preserve',
      jsxImportSource: 'vue',
      /* remove auto-scanning for types */
      types: [],
      /* add paths object for filling-in later */
      paths: {},
      /* Possibly consider removing the following in future */
      moduleResolution: nuxt.options.future?.typescriptBundlerResolution || (nuxt.options.experimental as any)?.typescriptBundlerResolution ? 'Bundler' : 'Node', /* implied by module: preserve */
      useDefineForClassFields: true, /* implied by target: es2022+ */
      noImplicitThis: true, /* enabled with `strict` */
      allowSyntheticDefaultImports: true,
    },
    include: [...include],
    exclude: [...exclude],
  } satisfies TSConfig)

  // This describes the environment where we load `nuxt.config.ts` (and modules)
  const nodeTsConfig: TSConfig = defu(nuxt.options.typescript?.nodeTsConfig, {
    compilerOptions: {
      /* Base options: */
      esModuleInterop: tsConfig.compilerOptions?.esModuleInterop,
      skipLibCheck: tsConfig.compilerOptions?.skipLibCheck,
      target: tsConfig.compilerOptions?.target,
      allowJs: tsConfig.compilerOptions?.allowJs,
      resolveJsonModule: tsConfig.compilerOptions?.resolveJsonModule,
      moduleDetection: tsConfig.compilerOptions?.moduleDetection,
      isolatedModules: tsConfig.compilerOptions?.isolatedModules,
      verbatimModuleSyntax: tsConfig.compilerOptions?.verbatimModuleSyntax,
      /* Strictness */
      strict: tsConfig.compilerOptions?.strict,
      noUncheckedIndexedAccess: tsConfig.compilerOptions?.noUncheckedIndexedAccess,
      forceConsistentCasingInFileNames: tsConfig.compilerOptions?.forceConsistentCasingInFileNames,
      noImplicitOverride: tsConfig.compilerOptions?.noImplicitOverride,
      /* If NOT transpiling with TypeScript: */
      module: tsConfig.compilerOptions?.module,
      noEmit: true,
      /* remove auto-scanning for types */
      types: [],
      /* add paths object for filling-in later */
      paths: {},
      /* Possibly consider removing the following in future */
      moduleResolution: tsConfig.compilerOptions?.moduleResolution,
      useDefineForClassFields: tsConfig.compilerOptions?.useDefineForClassFields,
      noImplicitThis: tsConfig.compilerOptions?.noImplicitThis,
      allowSyntheticDefaultImports: tsConfig.compilerOptions?.allowSyntheticDefaultImports,
    },
    include: [...nodeInclude],
    exclude: [...nodeExclude],
  } satisfies TSConfig)

  // This describes the environment where we load `nuxt.config.ts` (and modules)
  const sharedTsConfig: TSConfig = defu(nuxt.options.typescript?.sharedTsConfig, {
    compilerOptions: {
      /* Base options: */
      esModuleInterop: tsConfig.compilerOptions?.esModuleInterop,
      skipLibCheck: tsConfig.compilerOptions?.skipLibCheck,
      target: tsConfig.compilerOptions?.target,
      allowJs: tsConfig.compilerOptions?.allowJs,
      resolveJsonModule: tsConfig.compilerOptions?.resolveJsonModule,
      moduleDetection: tsConfig.compilerOptions?.moduleDetection,
      isolatedModules: tsConfig.compilerOptions?.isolatedModules,
      verbatimModuleSyntax: tsConfig.compilerOptions?.verbatimModuleSyntax,
      /* Strictness */
      strict: tsConfig.compilerOptions?.strict,
      noUncheckedIndexedAccess: tsConfig.compilerOptions?.noUncheckedIndexedAccess,
      forceConsistentCasingInFileNames: tsConfig.compilerOptions?.forceConsistentCasingInFileNames,
      noImplicitOverride: tsConfig.compilerOptions?.noImplicitOverride,
      /* If NOT transpiling with TypeScript: */
      module: tsConfig.compilerOptions?.module,
      noEmit: true,
      /* remove auto-scanning for types */
      types: [],
      /* add paths object for filling-in later */
      paths: {},
      /* Possibly consider removing the following in future */
      moduleResolution: tsConfig.compilerOptions?.moduleResolution,
      useDefineForClassFields: tsConfig.compilerOptions?.useDefineForClassFields,
      noImplicitThis: tsConfig.compilerOptions?.noImplicitThis,
      allowSyntheticDefaultImports: tsConfig.compilerOptions?.allowSyntheticDefaultImports,
    },
    include: [...sharedInclude],
    exclude: [...sharedExclude],
  } satisfies TSConfig)

  const aliases: Record<string, string> = nuxt.options.alias

  const basePath = tsConfig.compilerOptions!.baseUrl
    ? resolve(nuxt.options.buildDir, tsConfig.compilerOptions!.baseUrl)
    : nuxt.options.buildDir

  tsConfig.compilerOptions ||= {}
  tsConfig.compilerOptions.paths ||= {}
  tsConfig.include ||= []

  const importPaths = nuxt.options.modulesDir.map(d => directoryToURL(d))

  for (const alias in aliases) {
    if (excludedAlias.some(re => re.test(alias))) {
      continue
    }
    let absolutePath = resolve(basePath, aliases[alias]!)
    let stats = await fsp.stat(absolutePath).catch(() => null /* file does not exist */)
    if (!stats) {
      const resolvedModule = resolveModulePath(aliases[alias]!, {
        try: true,
        from: importPaths,
        extensions: [...nuxt.options.extensions, '.d.ts', '.d.mts', '.d.cts'],
      })
      if (resolvedModule) {
        absolutePath = resolvedModule
        stats = await fsp.stat(resolvedModule).catch(() => null)
      }
    }

    const relativePath = relativeWithDot(nuxt.options.buildDir, absolutePath)
    if (stats?.isDirectory() || aliases[alias]!.endsWith('/')) {
      tsConfig.compilerOptions.paths[alias] = [relativePath]
      tsConfig.compilerOptions.paths[`${alias}/*`] = [`${relativePath}/*`]
    } else {
      const path = stats?.isFile()
        // remove extension
        ? relativePath.replace(EXTENSION_RE, '')
        // non-existent file probably shouldn't be resolved
        : aliases[alias]!

      tsConfig.compilerOptions.paths[alias] = [path]
    }
  }

  const references: TSReference[] = []
  const nodeReferences: TSReference[] = []
  const sharedReferences: TSReference[] = []

  // This adds types of all modules
  await Promise.all([...nuxt.options.modules, ...nuxt.options._modules].map(async (id) => {
    if (typeof id !== 'string') { return }

    for (const parent of nestedModulesDirs) {
      const pkg = await readPackageJSON(id, { parent }).catch(() => null)
      if (pkg) {
        nodeReferences.push(({ types: pkg.name ?? id }))
        references.push(({ types: pkg.name ?? id }))
        return
      }
    }

    nodeReferences.push(({ types: id }))
    references.push(({ types: id }))
  }))

  const declarations: string[] = []

  await nuxt.callHook('prepare:types', { references, declarations, tsConfig, nodeTsConfig, nodeReferences, sharedTsConfig, sharedReferences })

  // Legacy tsConfig for backward compatibility
  const legacyTsConfig: TSConfig = defu({}, {
    ...tsConfig,
    include: [...tsConfig.include, ...legacyInclude],
    exclude: [...legacyExclude],
  })

  async function resolveConfig (tsConfig: TSConfig) {
    for (const alias in tsConfig.compilerOptions!.paths) {
      const paths = tsConfig.compilerOptions!.paths[alias]
      tsConfig.compilerOptions!.paths[alias] = [...new Set(await Promise.all(paths.map(async (path: string) => {
        if (!isAbsolute(path)) { return path }
        const stats = await fsp.stat(path).catch(() => null /* file does not exist */)
        return relativeWithDot(nuxt.options.buildDir, stats?.isFile() ? path.replace(EXTENSION_RE, '') /* remove extension */ : path)
      })))]
    }

    // Ensure `#build` is placed at the end of the paths object.
    // https://github.com/nuxt/nuxt/issues/30325
    sortTsPaths(tsConfig.compilerOptions!.paths)

    tsConfig.include = [...new Set(tsConfig.include!.map(p => isAbsolute(p) ? relativeWithDot(nuxt.options.buildDir, p) : p))]
    tsConfig.exclude = [...new Set(tsConfig.exclude!.map(p => isAbsolute(p) ? relativeWithDot(nuxt.options.buildDir, p) : p))]
  }

  await Promise.all([
    resolveConfig(tsConfig),
    resolveConfig(nodeTsConfig),
    resolveConfig(sharedTsConfig),
    resolveConfig(legacyTsConfig),
  ])

  const declaration = [
    ...references.map((ref) => {
      if ('path' in ref && isAbsolute(ref.path)) {
        ref.path = relative(nuxt.options.buildDir, ref.path)
      }
      return `/// <reference ${renderAttrs(ref)} />`
    }),
    ...declarations,
    '',
    'export {}',
    '',
  ].join('\n')

  const nodeDeclaration = [
    ...nodeReferences.map((ref) => {
      if ('path' in ref && isAbsolute(ref.path)) {
        ref.path = relative(nuxt.options.buildDir, ref.path)
      }
      return `/// <reference ${renderAttrs(ref)} />`
    }),
    '',
    'export {}',
    '',
  ].join('\n')

  const sharedDeclaration = [
    ...sharedReferences.map((ref) => {
      if ('path' in ref && isAbsolute(ref.path)) {
        ref.path = relative(nuxt.options.buildDir, ref.path)
      }
      return `/// <reference ${renderAttrs(ref)} />`
    }),
    '',
    'export {}',
    '',
  ].join('\n')

  return {
    declaration,
    sharedTsConfig,
    sharedDeclaration,
    nodeTsConfig,
    nodeDeclaration,
    tsConfig,
    legacyTsConfig,
  }
}

export async function writeTypes (nuxt: Nuxt): Promise<void> {
  const { tsConfig, nodeTsConfig, nodeDeclaration, declaration, legacyTsConfig, sharedDeclaration, sharedTsConfig } = await _generateTypes(nuxt)

  const appTsConfigPath = resolve(nuxt.options.buildDir, 'tsconfig.app.json')
  const legacyTsConfigPath = resolve(nuxt.options.buildDir, 'tsconfig.json')
  const nodeTsConfigPath = resolve(nuxt.options.buildDir, 'tsconfig.node.json')
  const sharedTsConfigPath = resolve(nuxt.options.buildDir, 'tsconfig.shared.json')

  const declarationPath = resolve(nuxt.options.buildDir, 'nuxt.d.ts')
  const nodeDeclarationPath = resolve(nuxt.options.buildDir, 'nuxt.node.d.ts')
  const sharedDeclarationPath = resolve(nuxt.options.buildDir, 'nuxt.shared.d.ts')

  await fsp.mkdir(nuxt.options.buildDir, { recursive: true })
  await Promise.all([
    fsp.writeFile(appTsConfigPath, JSON.stringify(tsConfig, null, 2)),
    fsp.writeFile(legacyTsConfigPath, JSON.stringify(legacyTsConfig, null, 2)),
    fsp.writeFile(nodeTsConfigPath, JSON.stringify(nodeTsConfig, null, 2)),
    fsp.writeFile(sharedTsConfigPath, JSON.stringify(sharedTsConfig, null, 2)),
    fsp.writeFile(declarationPath, declaration),
    fsp.writeFile(nodeDeclarationPath, nodeDeclaration),
    fsp.writeFile(sharedDeclarationPath, sharedDeclaration),
  ])
}

function sortTsPaths (paths: Record<string, string[]>) {
  for (const pathKey in paths) {
    if (pathKey.startsWith('#build')) {
      const pathValue = paths[pathKey]!
      // Delete & Reassign to ensure key is inserted at the end of object.
      delete paths[pathKey]
      paths[pathKey] = pathValue
    }
  }
}

function renderAttrs (obj: Record<string, string>) {
  const attrs: string[] = []
  for (const key in obj) {
    attrs.push(renderAttr(key, obj[key]))
  }
  return attrs.join(' ')
}

function renderAttr (key: string, value?: string) {
  return value ? `${key}="${value}"` : ''
}

const RELATIVE_WITH_DOT_RE = /^([^.])/
function relativeWithDot (from: string, to: string) {
  return relative(from, to).replace(RELATIVE_WITH_DOT_RE, './$1') || '.'
}

function withTrailingSlash (dir: string) {
  return dir.replace(/[^/]$/, '$&/')
}
</file>

<file path="packages/kit/src/utils.ts">
/** @since 3.9.0 */
export function toArray<T> (value: T | T[]): T[] {
  return Array.isArray(value) ? value : [value]
}

/**
 * Filter out items from an array in place. This function mutates the array.
 * `predicate` get through the array from the end to the start for performance.
 *
 * This function should be faster than `Array.prototype.filter` on large arrays.
 */
export function filterInPlace<T> (array: T[], predicate: (item: T, index: number, arr: T[]) => unknown) {
  for (let i = array.length; i--; i >= 0) {
    if (!predicate(array[i]!, i, array)) {
      array.splice(i, 1)
    }
  }
  return array
}

export const MODE_RE = /\.(server|client)(\.\w+)*$/

export const distDirURL = new URL('.', import.meta.url)

export type RequirePicked<T extends Record<string, any>, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>
</file>

<file path="packages/kit/test/components-fixture/Named.ts">
import { defineComponent } from 'vue'

export const NamedExport = defineComponent({
  setup () {
    return () => 'hello'
  },
})

export default defineComponent({
  setup () {
    return () => 'default'
  },
})
</file>

<file path="packages/kit/test/layer-fixture/custom-layers/a/nuxt.config.ts">
export default {}
</file>

<file path="packages/kit/test/layer-fixture/custom-layers/b/nuxt.config.ts">
export default {}
</file>

<file path="packages/kit/test/layer-fixture/layers/c/assets/foo.js">
export const foo = 'bar'
</file>

<file path="packages/kit/test/layer-fixture/layers/c/nuxt.config.ts">
export default defineNuxtConfig({})
</file>

<file path="packages/kit/test/layer-fixture/layers/d/nuxt.config.ts">
export default defineNuxtConfig({})
</file>

<file path="packages/kit/test/layer-fixture/nuxt.config.ts">
export default defineNuxtConfig({
  extends: ['./custom-layers/b', './custom-layers/a'],
  $meta: {
    name: 'layer-fixture',
  },
})
</file>

<file path="packages/kit/test/components.spec.ts">
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { createHooks } from 'hookable'
import type { Component } from '@nuxt/schema'
import { relative } from 'pathe'

import { addComponent, addComponentExports } from '../src/components.ts'
import { createResolver } from '../src/resolve.ts'

const mockNuxt = {
  options: {
    components: [],
    modulesDir: [],
    extensions: ['.vue', '.js', '.ts'],
  },
  hook: undefined as unknown,
}

vi.mock('../src/context', async original => ({
  ...await original(),
  tryUseNuxt: () => mockNuxt,
  useNuxt: () => mockNuxt,
}))

describe('addComponentExports', () => {
  let mockHooks: ReturnType<typeof createHooks>
  beforeEach(() => {
    mockHooks = createHooks()
    mockNuxt.hook = mockHooks.hook.bind(mockHooks)
  })

  it('should add components exports', async () => {
    const resolver = createResolver(import.meta.url)
    addComponentExports({
      filePath: resolver.resolve('./components-fixture/Named'),
      prefix: 'test',
    })
    await mockHooks.callHook('components:dirs', [])
    const components: Component[] = []
    await mockHooks.callHook('components:extend', components)
    for (const c of components) {
      c.filePath = relative(resolver.resolve('./components-fixture'), c.filePath)
      c.shortPath = relative(resolver.resolve('./components-fixture'), c.shortPath)
    }
    expect(components).toMatchInlineSnapshot(`
      [
        {
          "chunkName": "components/test-named-export",
          "export": "NamedExport",
          "filePath": "Named",
          "global": false,
          "kebabName": "test-named-export",
          "meta": {},
          "mode": "all",
          "name": "TestNamedExport",
          "pascalName": "TestNamedExport",
          "prefetch": false,
          "prefix": "test",
          "preload": false,
          "priority": 0,
          "shortPath": "Named",
        },
        {
          "chunkName": "components/test",
          "export": "default",
          "filePath": "Named",
          "global": false,
          "kebabName": "test",
          "meta": {},
          "mode": "all",
          "name": "Test",
          "pascalName": "Test",
          "prefetch": false,
          "prefix": "test",
          "preload": false,
          "priority": 0,
          "shortPath": "Named",
        },
      ]
    `)
  })
  it('should add components other than an existing component', async () => {
    const resolver = createResolver(import.meta.url)
    addComponent({
      filePath: resolver.resolve('./components-fixture/Named'),
      name: 'TestNamedExport',
      export: 'NamedExport',
      priority: 1,
    })
    addComponentExports({
      filePath: resolver.resolve('./components-fixture/Named'),
      prefix: 'test',
    })
    await mockHooks.callHook('components:dirs', [])
    const components: Component[] = []
    await mockHooks.callHook('components:extend', components)
    for (const c of components) {
      c.filePath = relative(resolver.resolve('./components-fixture'), c.filePath)
      c.shortPath = relative(resolver.resolve('./components-fixture'), c.shortPath)
    }
    expect(components.length).eq(2)
    expect(components[1]).toMatchInlineSnapshot(`
        {
          "chunkName": "components/test",
          "export": "default",
          "filePath": "Named",
          "global": false,
          "kebabName": "test",
          "meta": {},
          "mode": "all",
          "name": "Test",
          "pascalName": "Test",
          "prefetch": false,
          "prefix": "test",
          "preload": false,
          "priority": 0,
          "shortPath": "Named",
        }
    `)
  })
})
</file>

<file path="packages/kit/test/generate-types.spec.ts">
import { describe, expect, it } from 'vitest'
import type { Nuxt, NuxtConfig } from '@nuxt/schema'
import { defu } from 'defu'
import { findWorkspaceDir } from 'pkg-types'

import { loadNuxtConfig } from '../src/loader/config.ts'
import { _generateTypes, resolveLayerPaths } from '../src/template.ts'
import { getLayerDirectories } from 'nuxt/kit'

type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends Record<string, any> ? DeepPartial<T[P]> : T[P]
}

const mockNuxt = {
  options: {
    rootDir: '/my-app',
    srcDir: '/my-app',
    alias: {
      '~': '/my-app',
      'some-custom-alias': '/my-app/some-alias',
    },
    typescript: { includeWorkspace: false },
    buildDir: '/my-app/.nuxt',
    modulesDir: ['/my-app/node_modules', '/node_modules'],
    modules: [],
    extensions: ['.ts', '.mjs', '.js'],
    _layers: [{ config: { rootDir: '/my-app', srcDir: '/my-app' } }],
    _installedModules: [],
    _modules: [],
  },
  callHook: () => {},
} satisfies DeepPartial<Nuxt> as unknown as Nuxt

const mockNuxtWithOptions = (options: NuxtConfig) => defu({ options }, mockNuxt) as Nuxt

describe('tsConfig generation', () => {
  it('should add correct relative paths for aliases', async () => {
    const { tsConfig } = await _generateTypes(mockNuxt)
    expect(tsConfig.compilerOptions?.paths).toMatchInlineSnapshot(`
      {
        "some-custom-alias": [
          "../some-alias",
        ],
        "~": [
          "..",
        ],
      }
    `)
  })

  it('should add exclude for module paths', async () => {
    const { tsConfig } = await _generateTypes(mockNuxtWithOptions({
      modulesDir: ['/my-app/modules/test/node_modules', '/my-app/modules/node_modules', '/my-app/node_modules/@some/module/node_modules'],
    }))
    expect(tsConfig.exclude).toMatchInlineSnapshot(`
      [
        "../../node_modules",
        "../dist",
        "../.data",
        "../modules/*/runtime/server/**/*",
        "../layers/*/server/**/*",
        "../layers/*/modules/*/runtime/server/**/*",
        "../modules/*.*",
        "../nuxt.config.*",
        "../.config/nuxt.*",
        "../layers/*/nuxt.config.*",
        "../layers/*/.config/nuxt.*",
        "../layers/*/modules/**/*",
      ]
    `)
  })

  it('should add #build after #components to paths', async () => {
    const { tsConfig } = await _generateTypes(mockNuxtWithOptions({
      alias: {
        '~': '/my-app',
        '@': '/my-app',
        'some-custom-alias': '/my-app/some-alias',
        '#build': './build-dir',
        '#build/*': './build-dir/*',
        '#imports': './imports',
        '#components': './components',
      },
    }))

    expect(tsConfig.compilerOptions?.paths).toMatchObject({
      '~': [
        '..',
      ],
      'some-custom-alias': [
        '../some-alias',
      ],
      '@': [
        '..',
      ],
      '#imports': [
        './imports',
      ],
      '#components': [
        './components',
      ],
      '#build': [
        './build-dir',
      ],
      '#build/*': [
        './build-dir/*',
      ],
    })
  })
})

describe('resolveLayerPaths', async () => {
  const repoRoot = await findWorkspaceDir()

  it('should respect custom nuxt options', async () => {
    const nuxtOptions = await loadNuxtConfig({
      cwd: repoRoot,
      overrides: {
        _prepare: true,
        srcDir: 'app',
        dir: {
          modules: 'custom-modules',
          shared: 'custom-shared',
        },
      },
    })
    const [layer] = getLayerDirectories({ options: nuxtOptions } as Nuxt)
    const paths = resolveLayerPaths(layer!, nuxtOptions.buildDir)
    expect(paths).toMatchInlineSnapshot(`
      {
        "globalDeclarations": [
          "../*.d.ts",
          "../layers/*/*.d.ts",
        ],
        "nitro": [
          "../custom-modules/*/runtime/server/**/*",
          "../layers/*/server/**/*",
          "../layers/*/modules/*/runtime/server/**/*",
        ],
        "node": [
          "../custom-modules/*.*",
          "../nuxt.config.*",
          "../.config/nuxt.*",
          "../layers/*/nuxt.config.*",
          "../layers/*/.config/nuxt.*",
          "../layers/*/modules/**/*",
        ],
        "nuxt": [
          "../app/**/*",
          "../custom-modules/*/runtime/**/*",
          "../test/nuxt/**/*",
          "../tests/nuxt/**/*",
          "../layers/*/app/**/*",
          "../layers/*/modules/*/runtime/**/*",
        ],
        "shared": [
          "../custom-shared/**/*",
          "../custom-modules/*/shared/**/*",
          "../layers/*/shared/**/*",
        ],
        "sharedDeclarations": [
          "../custom-shared/**/*.d.ts",
          "../custom-modules/*/shared/**/*.d.ts",
          "../layers/*/shared/**/*.d.ts",
        ],
      }
    `)
  })
})
</file>

<file path="packages/kit/test/load-nuxt-config.bench.ts">
import { bench, describe } from 'vitest'
import { join } from 'pathe'
import { loadNuxtConfig } from '@nuxt/kit'
import { findWorkspaceDir } from 'pkg-types'

const fixtures = {
  'empty directory': 'node_modules/fixture',
  'basic test fixture': 'test/fixtures/basic',
  'basic test fixture (types)': 'test/fixtures/basic-types',
  'minimal test fixture': 'test/fixtures/minimal',
  'minimal test fixture (types)': 'test/fixtures/minimal-types',
}

describe('loadNuxtConfig', async () => {
  const repoRoot = await findWorkspaceDir()
  for (const fixture in fixtures) {
    const path = join(repoRoot, fixtures[fixture as keyof typeof fixtures])
    bench(`loadNuxtConfig in the ${fixture}`, async () => {
      await loadNuxtConfig({ cwd: path })
    })
  }
})
</file>

<file path="packages/kit/test/load-nuxt-config.spec.ts">
import { fileURLToPath } from 'node:url'
import { describe, expect, it } from 'vitest'
import { loadNuxtConfig } from '@nuxt/kit'
import { basename } from 'pathe'

describe('loadNuxtConfig', () => {
  it('should add named aliases for local layers', async () => {
    const cwd = fileURLToPath(new URL('./layer-fixture', import.meta.url)).replace(/\\/g, '/')
    const config = await loadNuxtConfig({ cwd })
    for (const alias in config.alias) {
      config.alias[alias] = config.alias[alias]!.replace(cwd, '<rootDir>')
    }
    expect(config.alias).toMatchInlineSnapshot(`
      {
        "#build": "<rootDir>/.nuxt/",
        "#internal/nuxt/paths": "<rootDir>/.nuxt/paths.mjs",
        "#layers/c": "<rootDir>/layers/c/",
        "#layers/d": "<rootDir>/layers/d/",
        "#layers/layer-fixture": "<rootDir>/",
        "#server": "<rootDir>/server/",
        "#shared": "<rootDir>/shared/",
        "@": "<rootDir>/",
        "@@": "<rootDir>/",
        "~": "<rootDir>/",
        "~~": "<rootDir>/",
      }
    `)
  })

  it('should respect alphabetical order of local layers', async () => {
    const cwd = fileURLToPath(new URL('./layer-fixture', import.meta.url)).replace(/\\/g, '/')
    const config = await loadNuxtConfig({ cwd })
    // priority list
    // 1. layers in nuxt.config (first overrides second)
    // 2. then local layers in alphabetical order (Z overrides A)
    // 3. local project overrides
    expect(config._layers.map(l => basename(l.cwd))).toMatchInlineSnapshot(`
      [
        "layer-fixture",
        "d",
        "c",
        "b",
        "a",
      ]
    `)
  })
})
</file>

<file path="packages/kit/test/load-nuxt.test.ts">
import { mkdir, rm, writeFile } from 'node:fs/promises'
import { afterAll, beforeAll, describe, expect, it } from 'vitest'
import { join } from 'pathe'
import { x } from 'tinyexec'

import { loadNuxt } from '../src/loader/nuxt.ts'
import { findWorkspaceDir } from 'pkg-types'

const repoRoot = await findWorkspaceDir()

describe('loadNuxt', () => {
  const tempDir = join(repoRoot, 'temp')

  beforeAll(async () => {
    await mkdir(join(tempDir, 'nuxt'), { recursive: true })
    await writeFile(join(tempDir, 'package.json'), '{"dependencies":{"nuxt":"file:./nuxt"}}')
    await writeFile(join(tempDir, 'nuxt', 'package.json'), '{"name":"nuxt","type":"module","exports":{".":"./index.js"}}')
    await writeFile(join(tempDir, 'nuxt', 'index.js'), 'export const loadNuxt = (opts) => ({ name: "it me" })')
    await x('npm', ['install'], { nodeOptions: { cwd: tempDir } })
  })

  afterAll(async () => {
    await rm(tempDir, { recursive: true, force: true })
  })

  it('respects correct directory', async () => {
    const nuxt = await loadNuxt({ cwd: tempDir })
    expect(nuxt).toStrictEqual({
      name: 'it me',
    })
  })
})
</file>

<file path="packages/kit/test/module.test.ts">
import { mkdir, readFile, rm, writeFile } from 'node:fs/promises'
import { appendFileSync } from 'node:fs'

import type { Nuxt } from 'nuxt/schema'

import { afterAll, afterEach, beforeAll, beforeEach, describe, expect, it } from 'vitest'
import { join } from 'pathe'
import { findWorkspaceDir } from 'pkg-types'
import { read as readRc, write as writeRc } from 'rc9'

import { defineNuxtModule, installModule, loadNuxt } from '../src/index.ts'

const repoRoot = await findWorkspaceDir()

describe('installNuxtModule', { sequential: true }, () => {
  let nuxt: Nuxt

  const tempDir = join(repoRoot, 'node_modules/.temp/module-temp-hooks')
  const hooksLogFile = join(tempDir, 'hooks-logs')

  async function getHooksLogs () {
    const logs = await readFile(hooksLogFile, { encoding: 'utf8' }).catch(_ => '')
    return logs.split('\n').slice(0, -1)
  }

  const testModule = defineNuxtModule({
    meta: {
      name: 'test-module',
      version: '1.0.0',
    },

    onInstall () {
      appendFileSync(hooksLogFile, 'install\n')
    },

    onUpgrade () {
      appendFileSync(hooksLogFile, 'upgrade\n')
    },
  })

  beforeAll(async () => {
    await mkdir(join(tempDir, 'nuxt'), { recursive: true })
    await rm(hooksLogFile, { force: true })
  })

  afterAll(async () => {
    await rm(tempDir, { recursive: true, force: true })
  })

  afterEach(async () => {
    await nuxt?.close()
    await rm(hooksLogFile, { force: true })
  })

  it('runs onInstall hook when a module is added', async () => {
    nuxt = await loadNuxt({ cwd: tempDir })
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    await installModule(testModule, {}, nuxt)

    expect(await getHooksLogs()).toEqual(['install'])
    const rc = readRc({ dir: tempDir, name: '.nuxtrc' })
    expect(rc.setups['test-module']).toBe('1.0.0')
  })

  it('runs onInstall only once', async () => {
    writeRc(
      { setups: { 'test-module': '1.0.0' } },
      { dir: tempDir, name: '.nuxtrc' },
    )

    nuxt = await loadNuxt({ cwd: tempDir })
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    await installModule(testModule, {}, nuxt)

    expect(await getHooksLogs()).toEqual([])
  })

  it('runs onUpgrade hook when a module is upgraded', async () => {
    writeRc(
      { setups: { 'test-module': '0.1.0' } },
      { dir: tempDir, name: '.nuxtrc' },
    )

    nuxt = await loadNuxt({ cwd: tempDir })
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    await installModule(testModule, {}, nuxt)

    expect(await getHooksLogs()).toEqual(['upgrade'])
    const rc = readRc({ dir: tempDir, name: '.nuxtrc' })
    expect(rc.setups['test-module']).toBe('1.0.0')
  })
})

describe('module dependencies', { sequential: true }, () => {
  let nuxt: Nuxt

  const tempDir = join(repoRoot, 'node_modules/.temp/module-dependencies')

  beforeAll(async () => {
    const fakeModule = join(tempDir, 'node_modules/some-module')
    await mkdir(fakeModule, { recursive: true })
    await writeFile(join(fakeModule, 'package.json'), JSON.stringify({ name: 'some-module', version: '1.0.0', type: 'module', exports: './index.js' }))
    await writeFile(join(fakeModule, 'index.js'), `
export default Object.assign((options) => {
  globalThis.someModuleLoaded ||= 0
  globalThis.someModuleLoaded++
  globalThis.someModuleOptions = options
}, {
  getMeta: () => ({
    configKey: 'someModule'
  })
})
    `)
  })

  beforeEach(() => {
    delete globalThis.someModuleLoaded
    delete globalThis.someModuleOptions
  })

  afterEach(async () => {
    await nuxt?.close()
  })

  it('should install modules that are not marked as optional', async () => {
    nuxt = await loadNuxt({
      cwd: tempDir,
      overrides: {
        modules: [
          defineNuxtModule({
            meta: { name: 'foo' },
            moduleDependencies: {
              'some-module': {},
              'non-existent-module': { optional: true },
            },
          }),
        ],
      },
    })

    expect(globalThis.someModuleLoaded).toBe(1)
  })

  it('should resolve moduleDependencies provided as async functions', async () => {
    nuxt = await loadNuxt({
      cwd: tempDir,
      overrides: {
        modules: [
          defineNuxtModule({
            meta: { name: 'foo' },
            async moduleDependencies () {
              await Promise.resolve()
              return {
                'some-module': {},
              }
            },
          }),
        ],
      },
    })

    expect(globalThis.someModuleLoaded).toBe(1)
  })

  it('should not install modules that are already installed by the user', async () => {
    nuxt = await loadNuxt({
      cwd: tempDir,
      overrides: {
        modules: [
          defineNuxtModule({
            meta: { name: 'some-module' },
          }),
          defineNuxtModule({
            meta: { name: 'foo' },
            moduleDependencies: {
              'some-module': {},
            },
          }),
        ],
      },
    })

    expect(globalThis.someModuleLoaded).toBeUndefined()
  })

  it('should not load a module from disk if it is present inline', async () => {
    nuxt = await loadNuxt({
      cwd: tempDir,
      overrides: {
        modules: [
          defineNuxtModule({
            meta: { name: 'foo' },
            moduleDependencies: {
              'some-module': {},
            },
          }),
          'some-module',
        ],
      },
    })

    expect(globalThis.someModuleLoaded).toBe(1)
  })

  it('should merge options as expected', async () => {
    nuxt = await loadNuxt({
      cwd: tempDir,
      overrides: {
        // @ts-expect-error untyped nuxt options
        a: {
          user: 'provided by user',
        },
        modules: [
          defineNuxtModule({
            meta: { name: 'a' },
            defaults: {
              value: 'provided by a',
              user: 'provided by a',
              default: 'provided by a',
            },
            setup (options) {
              expect(options).toMatchInlineSnapshot(`
                {
                  "default": "provided by c",
                  "user": "provided by user",
                  "value": "provided by c",
                }
              `)
            },
          }),
          defineNuxtModule({
            meta: { name: 'b' },
            setup (options) {
              expect(options).toMatchInlineSnapshot(`
                {
                  "default": "provided by c",
                  "value": "provided by c",
                }
              `)
            },
          }),
          defineNuxtModule({
            meta: { name: 'c' },
            setup (options) {
              expect(options).toMatchInlineSnapshot(`{}`)
            },
            moduleDependencies: {
              'a': {
                overrides: {
                  value: 'provided by c',
                },
                defaults: {
                  user: 'provided by c',
                  default: 'provided by c',
                },
              },
              'b': {
                overrides: {
                  value: 'provided by c',
                },
                defaults: {
                  default: 'provided by c',
                },
              },
            },
          }),
          defineNuxtModule({
            meta: { name: 'd' },
            setup (options) {
              expect(options).toMatchInlineSnapshot(`{}`)
            },
            moduleDependencies: {
              'b': {
                overrides: {
                  value: 'provided by d',
                },
                defaults: {
                  default: 'provided by d',
                },
              },
            },
          }),
        ],
      },
    })

    // @ts-expect-error untyped nuxt option
    expect(nuxt.options.a).toMatchInlineSnapshot(`
      {
        "default": "provided by c",
        "user": "provided by user",
        "value": "provided by c",
      }
    `)
    // @ts-expect-error untyped nuxt option
    expect(nuxt.options.b).toMatchInlineSnapshot(`
      {
        "default": "provided by c",
        "value": "provided by c",
      }
    `)
    // @ts-expect-error untyped nuxt option
    expect(nuxt.options.c).toMatchInlineSnapshot(`undefined`)
    // @ts-expect-error untyped nuxt option
    expect(nuxt.options.d).toMatchInlineSnapshot(`undefined`)
  })

  it('should warn if version constraints do not match', async () => {
    await expect(loadNuxt({
      cwd: tempDir,
      overrides: {
        modules: [
          defineNuxtModule({
            meta: { name: 'foo' },
            moduleDependencies: {
              'some-module': {
                version: '>=2',
              },
            },
          }),
        ],
      },
    })).rejects.toThrowErrorMatchingInlineSnapshot(`[TypeError: Module \`some-module\` version (\`1.0.0\`) does not satisfy \`>=2\` (requested by a module in \`nuxt.options\`).]`)
  })

  it('should apply moduleDependencies config when installModule is called explicitly', async () => {
    const setupOrder: string[] = []

    nuxt = await loadNuxt({
      cwd: tempDir,
      overrides: {
        // @ts-expect-error no types for someModule
        someModule: {
          value: 'from user',
          moduleOverride: 'from user',
          userDefault: 'from user',
        },
        modules: [
          // Module A defines config for module C via moduleDependencies
          defineNuxtModule({
            meta: { name: 'module-a' },
            moduleDependencies: {
              'someModule': {
                optional: true,
                overrides: {
                  value: 'from module-a override',
                  moduleOverride: 'from module-a',
                },
                defaults: {
                  defaultValue: 'from module-a default',
                  userDefault: 'from module-a default',
                },
              },
            },
            setup () {
              setupOrder.push('module-a')
            },
          }),
          // Module B calls installModule on module C
          defineNuxtModule({
            meta: { name: 'module-b' },
            async setup (_, nuxt) {
              setupOrder.push('module-b')

              // eslint-disable-next-line @typescript-eslint/no-deprecated
              await installModule('some-module', {
                value: 'from module-b',
                inlineValue: 'from module-b inline',
              }, nuxt)
            },
          }),
        ],
      },
    })

    expect(setupOrder).toEqual(['module-a', 'module-b'])
    expect(globalThis.someModuleLoaded).toBe(1)

    expect(globalThis.someModuleOptions).toMatchObject({
      // `installModule` should always override values
      value: 'from module-b',
      // extra values should be passed alone
      inlineValue: 'from module-b inline',
      // modules should be able to set default values
      defaultValue: 'from module-a default',
      // modules should be able to override user configuration
      moduleOverride: 'from module-a',
      // user configuration should be merged in
      userDefault: 'from user',
    })
  })
})

declare global {
  var someModuleLoaded: number | undefined
  var someModuleOptions: Record<string, any> | undefined
}
</file>

<file path="packages/kit/test/templates.spec.ts">
import { describe, expect, it } from 'vitest'
import { addTypeTemplate, buildNuxt, loadNuxt } from '../src/index.ts'
import { findWorkspaceDir } from 'pkg-types'
import { resolve } from 'node:path'
import { randomUUID } from 'node:crypto'
import { mkdir, writeFile } from 'node:fs/promises'

describe('addTypeTemplate', () => {
  it('should add type templates to vue global files', { timeout: 20_000 }, async () => {
    const repoRoot = await findWorkspaceDir()
    const rootDir = resolve(repoRoot, 'node_modules/.fixture', randomUUID())
    await mkdir(rootDir, { recursive: true })
    await writeFile(resolve(rootDir, 'app.vue'), `
      <script setup lang="ts">
      defineProps<TestComponentProps>()
      </script>
      <template><div /></template>
    `)
    const nuxt = await loadNuxt({
      cwd: rootDir,
      overrides: {
        modules: [
          function () {
            addTypeTemplate({
              filename: 'some-type-template.d.ts',
              getContents: () => `
                declare global {
                  type TestComponentProps = { foo?: string }
                }
                export {};
              `,
            })
          },
        ],
      },
    })

    await expect(buildNuxt(nuxt)).resolves.not.toThrow()

    await nuxt.close()
  })
})
</file>

<file path="packages/kit/test/write-types.bench.ts">
import { rm } from 'node:fs/promises'
import { afterAll, beforeAll, bench, describe } from 'vitest'
import { join, resolve } from 'pathe'
import type { Nuxt } from 'nuxt/schema'
import { loadNuxt, writeTypes } from '@nuxt/kit'
import { findWorkspaceDir } from 'pkg-types'

describe('writeTypes', async () => {
  const repoRoot = await findWorkspaceDir()
  const path = join(repoRoot, 'test/fixtures/basic-types')

  let nuxt: Nuxt

  beforeAll(async () => {
    nuxt = await loadNuxt({ cwd: path })
    await rm(resolve(path, '.nuxt'), { recursive: true, force: true })
  }, 20_000)

  afterAll(async () => {
    await nuxt.close()
  }, 20_000)

  bench('writeTypes in the basic-types fixture', async () => {
    await writeTypes(nuxt)
  })
})
</file>

<file path="packages/kit/.attw.json">
{
  "ignoreRules": ["cjs-resolves-to-esm"]
}
</file>

<file path="packages/kit/.gitignore">
/schema
</file>

<file path="packages/kit/build.config.ts">
import { defineBuildConfig } from 'unbuild'
import { addRollupTimingsPlugin } from '../../debug/build-config.ts'

export default defineBuildConfig({
  declaration: true,
  entries: [
    'src/index',
  ],
  hooks: {
    'rollup:options' (ctx, options) {
      addRollupTimingsPlugin(options)
    },
  },
  externals: [
    '@rspack/core',
    '@nuxt/schema',
    'nitropack',
    'nitro',
    'webpack',
    'vite',
    'h3',
    'unimport',
  ],
})
</file>

<file path="packages/kit/package.json">
{
  "name": "@nuxt/kit",
  "version": "4.2.2",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nuxt/nuxt.git",
    "directory": "packages/kit"
  },
  "homepage": "https://nuxt.com/docs/4.x/api/kit",
  "description": "Toolkit for authoring modules and interacting with Nuxt",
  "license": "MIT",
  "type": "module",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.mjs"
    },
    "./package.json": "./package.json"
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "prepack": "unbuild",
    "build:stub": "unbuild --stub",
    "test:attw": "attw --pack"
  },
  "dependencies": {
    "c12": "^3.3.3",
    "consola": "^3.4.2",
    "defu": "^6.1.4",
    "destr": "^2.0.5",
    "errx": "^0.1.0",
    "exsolve": "^1.0.8",
    "ignore": "^7.0.5",
    "jiti": "^2.6.1",
    "klona": "^2.0.6",
    "mlly": "^1.8.0",
    "ohash": "^2.0.11",
    "pathe": "^2.0.3",
    "pkg-types": "^2.3.0",
    "rc9": "^2.1.2",
    "scule": "^1.3.0",
    "semver": "^7.7.3",
    "tinyglobby": "^0.2.15",
    "ufo": "^1.6.1",
    "unctx": "^2.5.0",
    "untyped": "^2.0.0"
  },
  "devDependencies": {
    "@nuxt/schema": "workspace:*",
    "@rspack/core": "1.7.0",
    "@types/semver": "7.7.1",
    "hookable": "5.5.3",
    "nitropack": "2.12.9",
    "unbuild": "3.6.1",
    "unimport": "5.6.0",
    "vite": "7.3.0",
    "vitest": "3.2.4",
    "webpack": "5.104.1"
  },
  "engines": {
    "node": ">=18.12.0"
  }
}
</file>

<file path="packages/nitro-server/src/runtime/handlers/error.ts">
import { joinURL, withQuery, withoutBase } from 'ufo'
import type { NitroErrorHandler } from 'nitropack/types'
import { appendResponseHeader, getRequestHeaders, send, setResponseHeader, setResponseHeaders, setResponseStatus } from 'h3'
import type { NuxtPayload } from 'nuxt/app'

import { useNitroApp, useRuntimeConfig } from 'nitropack/runtime'
import { isJsonRequest } from '../utils/error'
import { generateErrorOverlayHTML } from '../utils/dev'

export default <NitroErrorHandler> async function errorhandler (error, event, { defaultHandler }) {
  if (event.handled || isJsonRequest(event)) {
    // let Nitro handle JSON errors
    return
  }
  // invoke default Nitro error handler (which will log appropriately if required)
  const defaultRes = await defaultHandler(error, event, { json: true })

  // let Nitro handle redirect if appropriate
  const status = (error as any).status || error.statusCode || 500
  if (status === 404 && defaultRes.status === 302) {
    setResponseHeaders(event, defaultRes.headers)
    setResponseStatus(event, defaultRes.status, defaultRes.statusText)
    return send(event, JSON.stringify(defaultRes.body, null, 2))
  }

  if (import.meta.dev && typeof defaultRes.body !== 'string' && Array.isArray(defaultRes.body.stack)) {
    // normalize to string format expected by nuxt `error.vue`
    defaultRes.body.stack = defaultRes.body.stack.join('\n')
  }

  const errorObject = defaultRes.body as Pick<NonNullable<NuxtPayload['error']>, 'error' | 'status' | 'statusText' | 'message' | 'stack'> & { url: string, data: any }
  // remove proto/hostname/port from URL
  const url = new URL(errorObject.url)
  errorObject.url = withoutBase(url.pathname, useRuntimeConfig(event).app.baseURL) + url.search + url.hash
  // add default server message
  errorObject.message ||= 'Server Error'
  // we will be rendering this error internally so we can pass along the error.data safely
  errorObject.data ||= error.data
  errorObject.statusText ||= (error as any).statusText || error.statusMessage

  delete defaultRes.headers['content-type'] // this would be set to application/json
  delete defaultRes.headers['content-security-policy'] // this would disable JS execution in the error page

  setResponseHeaders(event, defaultRes.headers)

  // Access request headers
  const reqHeaders = getRequestHeaders(event)

  // Detect to avoid recursion in SSR rendering of errors
  const isRenderingError = event.path.startsWith('/__nuxt_error') || !!reqHeaders['x-nuxt-error']

  // HTML response (via SSR)
  const res = isRenderingError
    ? null
    : await useNitroApp().localFetch(
        withQuery(joinURL(useRuntimeConfig(event).app.baseURL, '/__nuxt_error'), errorObject),
        {
          headers: { ...reqHeaders, 'x-nuxt-error': 'true' },
          redirect: 'manual',
        },
      ).catch(() => null)

  if (event.handled) { return }

  // Fallback to static rendered error page
  if (!res) {
    const { template } = await import('../templates/error-500')
    if (import.meta.dev) {
      // TODO: Support `message` in template
      (errorObject as any).description = errorObject.message
    }
    setResponseHeader(event, 'Content-Type', 'text/html;charset=UTF-8')
    return send(event, template(errorObject))
  }

  const html = await res.text()
  for (const [header, value] of res.headers.entries()) {
    if (header === 'set-cookie') {
      appendResponseHeader(event, header, value)
      continue
    }
    setResponseHeader(event, header, value)
  }
  setResponseStatus(event, res.status && res.status !== 200 ? res.status : defaultRes.status, res.statusText || defaultRes.statusText)

  if (import.meta.dev && !import.meta.test && typeof html === 'string') {
    const prettyResponse = await defaultHandler(error, event, { json: false })
    if (typeof prettyResponse.body === 'string') {
      return send(event, html.replace('</body>', `${generateErrorOverlayHTML(prettyResponse.body, { startMinimized: 300 <= status && status < 500 })}</body>`))
    }
  }

  return send(event, html)
}
</file>

<file path="packages/nitro-server/src/runtime/handlers/island.ts">
import { useNitroApp } from 'nitropack/runtime'
import type { RenderResponse } from 'nitropack/types'
import type { Link, SerializableHead } from '@unhead/vue/types'
import { destr } from 'destr'
import type { H3Event } from 'h3'
import { defineEventHandler, getQuery, readBody, setResponseHeaders } from 'h3'
import { resolveUnrefHeadInput } from '@unhead/vue'
import { getRequestDependencies } from 'vue-bundle-renderer/runtime'
import { getQuery as getURLQuery } from 'ufo'
import type { NuxtIslandContext, NuxtIslandResponse } from 'nuxt/app'
import { islandCache, islandPropCache } from '../utils/cache'
import { createSSRContext } from '../utils/renderer/app'
import { getSSRRenderer } from '../utils/renderer/build-files'
import { renderInlineStyles } from '../utils/renderer/inline-styles'
import { getClientIslandResponse, getServerComponentHTML, getSlotIslandResponse } from '../utils/renderer/islands'

const ISLAND_SUFFIX_RE = /\.json(?:\?.*)?$/

export default defineEventHandler(async (event) => {
  const nitroApp = useNitroApp()

  setResponseHeaders(event, {
    'content-type': 'application/json;charset=utf-8',
    'x-powered-by': 'Nuxt',
  })

  if (import.meta.prerender && event.path && await islandCache!.hasItem(event.path)) {
    return islandCache!.getItem(event.path) as Promise<Partial<RenderResponse>>
  }

  const islandContext = await getIslandContext(event)

  const ssrContext = {
    ...createSSRContext(event),
    islandContext,
    noSSR: false,
    url: islandContext.url,
  }

  // Render app
  const renderer = await getSSRRenderer()

  const renderResult = await renderer.renderToString(ssrContext).catch(async (err) => {
    await ssrContext.nuxt?.hooks.callHook('app:error', err)
    throw err
  })

  // Handle errors
  if (ssrContext.payload?.error) {
    throw ssrContext.payload.error
  }

  const inlinedStyles = await renderInlineStyles(ssrContext.modules ?? [])

  await ssrContext.nuxt?.hooks.callHook('app:rendered', { ssrContext, renderResult })

  if (inlinedStyles.length) {
    ssrContext.head.push({ style: inlinedStyles })
  }

  if (import.meta.dev) {
    const { styles } = getRequestDependencies(ssrContext, renderer.rendererContext)

    const link: Link[] = []
    for (const resource of Object.values(styles)) {
      // Do not add links to resources that are inlined (vite v5+)
      if ('inline' in getURLQuery(resource.file)) {
        continue
      }
      // Add CSS links in <head> for CSS files
      // - in dev mode when rendering an island and the file has scoped styles and is not a page
      if (resource.file.includes('scoped') && !resource.file.includes('pages/')) {
        link.push({ rel: 'stylesheet', href: renderer.rendererContext.buildAssetsURL(resource.file), crossorigin: '' })
      }
    }
    if (link.length) {
      ssrContext.head.push({ link }, { mode: 'server' })
    }
  }

  const islandHead: SerializableHead = {}
  for (const entry of ssrContext.head.entries.values()) {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    for (const [key, value] of Object.entries(resolveUnrefHeadInput(entry.input as any) as SerializableHead)) {
      const currentValue = islandHead[key as keyof SerializableHead]
      if (Array.isArray(currentValue)) {
        currentValue.push(...value)
      } else {
        islandHead[key as keyof SerializableHead] = value
      }
    }
  }

  const islandResponse: NuxtIslandResponse = {
    id: islandContext.id,
    head: islandHead,
    html: getServerComponentHTML(renderResult.html),
    components: getClientIslandResponse(ssrContext),
    slots: getSlotIslandResponse(ssrContext),
  }

  await nitroApp.hooks.callHook('render:island', islandResponse, { event, islandContext })

  if (import.meta.prerender) {
    await islandCache!.setItem(`/__nuxt_island/${islandContext!.name}_${islandContext!.id}.json`, islandResponse)
    await islandPropCache!.setItem(`/__nuxt_island/${islandContext!.name}_${islandContext!.id}.json`, event.path)
  }
  return islandResponse
})

async function getIslandContext (event: H3Event): Promise<NuxtIslandContext> {
  // TODO: Strict validation for url
  let url = event.path || ''
  if (import.meta.prerender && event.path && await islandPropCache!.hasItem(event.path)) {
    // rehydrate props from cache so we can rerender island if cache does not have it any more
    url = await islandPropCache!.getItem(event.path) as string
  }
  const componentParts = url.substring('/__nuxt_island'.length + 1).replace(ISLAND_SUFFIX_RE, '').split('_')
  const hashId = componentParts.length > 1 ? componentParts.pop() : undefined
  const componentName = componentParts.join('_')

  // TODO: Validate context
  const context = event.method === 'GET' ? getQuery(event) : await readBody(event)

  const ctx: NuxtIslandContext = {
    url: '/',
    ...context,
    id: hashId,
    name: componentName,
    props: destr(context.props) || {},
    slots: {},
    components: {},
  }

  return ctx
}
</file>

<file path="packages/nitro-server/src/runtime/handlers/renderer.ts">
import { AsyncLocalStorage } from 'node:async_hooks'
import { getPrefetchLinks, getPreloadLinks, getRequestDependencies, renderResourceHeaders } from 'vue-bundle-renderer/runtime'
import type { RenderResponse } from 'nitropack/types'
import { appendResponseHeader, createError, getQuery, getResponseStatus, getResponseStatusText, writeEarlyHints } from 'h3'
import { getQuery as getURLQuery, joinURL } from 'ufo'
import { propsToString, renderSSRHead } from '@unhead/vue/server'
import type { HeadEntryOptions, Link, Script } from '@unhead/vue/types'
import destr from 'destr'
import { defineRenderHandler, getRouteRules, useNitroApp } from 'nitropack/runtime'
import type { NuxtPayload, NuxtRenderHTMLContext, NuxtSSRContext } from 'nuxt/app'

import { getRenderer } from '../utils/renderer/build-files'
import { payloadCache } from '../utils/cache'

import { renderPayloadJsonScript, renderPayloadResponse, renderPayloadScript, splitPayload } from '../utils/renderer/payload'
import { createSSRContext, setSSRError } from '../utils/renderer/app'
import { renderInlineStyles } from '../utils/renderer/inline-styles'
import { replaceIslandTeleports } from '../utils/renderer/islands'
// @ts-expect-error virtual file
import { renderSSRHeadOptions } from '#internal/unhead.config.mjs'
// @ts-expect-error virtual file
import { NUXT_ASYNC_CONTEXT, NUXT_EARLY_HINTS, NUXT_INLINE_STYLES, NUXT_JSON_PAYLOADS, NUXT_NO_SCRIPTS, NUXT_PAYLOAD_EXTRACTION, NUXT_RUNTIME_PAYLOAD_EXTRACTION, PARSE_ERROR_DATA } from '#internal/nuxt/nitro-config.mjs'
// @ts-expect-error virtual file
import { appHead, appTeleportAttrs, appTeleportTag, componentIslands, appManifest as isAppManifestEnabled } from '#internal/nuxt.config.mjs'
// @ts-expect-error virtual file
import entryIds from '#internal/nuxt/entry-ids.mjs'
// @ts-expect-error virtual file
import { entryFileName } from '#internal/entry-chunk.mjs'
// @ts-expect-error virtual file
import { buildAssetsURL, publicAssetsURL } from '#internal/nuxt/paths'
import { relative } from 'pathe'

// @ts-expect-error private property consumed by vite-generated url helpers
globalThis.__buildAssetsURL = buildAssetsURL
// @ts-expect-error private property consumed by vite-generated url helpers
globalThis.__publicAssetsURL = publicAssetsURL

// Polyfill for unctx (https://github.com/unjs/unctx#native-async-context)
if (NUXT_ASYNC_CONTEXT && !('AsyncLocalStorage' in globalThis)) {
  (globalThis as any).AsyncLocalStorage = AsyncLocalStorage
}

const HAS_APP_TELEPORTS = !!(appTeleportTag && appTeleportAttrs.id)
const APP_TELEPORT_OPEN_TAG = HAS_APP_TELEPORTS ? `<${appTeleportTag}${propsToString(appTeleportAttrs)}>` : ''
const APP_TELEPORT_CLOSE_TAG = HAS_APP_TELEPORTS ? `</${appTeleportTag}>` : ''

const PAYLOAD_URL_RE = NUXT_JSON_PAYLOADS ? /^[^?]*\/_payload.json(?:\?.*)?$/ : /^[^?]*\/_payload.js(?:\?.*)?$/
const PAYLOAD_FILENAME = NUXT_JSON_PAYLOADS ? '_payload.json' : '_payload.js'

let entryPath: string

export default defineRenderHandler(async (event): Promise<Partial<RenderResponse>> => {
  const nitroApp = useNitroApp()

  // Whether we're rendering an error page
  const ssrError = event.path.startsWith('/__nuxt_error')
    ? getQuery(event) as unknown as NuxtPayload['error'] & { url: string }
    : null

  if (ssrError && !('__unenv__' in event.node.req) /* allow internal fetch */) {
    throw createError({
      status: 404,
      statusText: 'Page Not Found: /__nuxt_error',
      message: 'Page Not Found: /__nuxt_error',
    })
  }

  // Initialize ssr context
  const ssrContext: NuxtSSRContext = createSSRContext(event)

  // needed for hash hydration plugin to work
  const headEntryOptions: HeadEntryOptions = { mode: 'server' }
  ssrContext.head.push(appHead, headEntryOptions)

  if (ssrError) {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    const status = ssrError.status || ssrError.statusCode
    if (status) {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ssrError.status = ssrError.statusCode = Number.parseInt(status as any)
    }
    if (PARSE_ERROR_DATA && typeof ssrError.data === 'string') {
      try {
        ssrError.data = destr(ssrError.data)
      } catch {
        // ignore
      }
    }
    setSSRError(ssrContext, ssrError)
  }

  // Get route options (for `ssr: false`, `isr`, `cache` and `noScripts`)
  const routeOptions = getRouteRules(event)

  // Whether we are prerendering route or using ISR/SWR caching
  const _PAYLOAD_EXTRACTION = !ssrContext.noSSR && (
    (import.meta.prerender && NUXT_PAYLOAD_EXTRACTION)
    || (NUXT_RUNTIME_PAYLOAD_EXTRACTION && (routeOptions.isr || routeOptions.cache))
  )

  const isRenderingPayload = (_PAYLOAD_EXTRACTION || (import.meta.dev && routeOptions.prerender)) && PAYLOAD_URL_RE.test(ssrContext.url)
  if (isRenderingPayload) {
    const url = ssrContext.url.substring(0, ssrContext.url.lastIndexOf('/')) || '/'
    ssrContext.url = url

    event._path = event.node.req.url = url
    if (import.meta.prerender && await payloadCache!.hasItem(url)) {
      return payloadCache!.getItem(url) as Promise<Partial<RenderResponse>>
    }
  }

  if (routeOptions.ssr === false) {
    ssrContext.noSSR = true
  }

  const payloadURL = _PAYLOAD_EXTRACTION ? joinURL(ssrContext.runtimeConfig.app.cdnURL || ssrContext.runtimeConfig.app.baseURL, ssrContext.url.replace(/\?.*$/, ''), PAYLOAD_FILENAME) + '?' + ssrContext.runtimeConfig.app.buildId : undefined

  // Render app
  const renderer = await getRenderer(ssrContext)

  // Render 103 Early Hints
  if (NUXT_EARLY_HINTS && !isRenderingPayload && !import.meta.prerender) {
    const { link } = renderResourceHeaders({}, renderer.rendererContext)
    if (link) {
      writeEarlyHints(event, link)
    }
  }

  if (NUXT_INLINE_STYLES) {
    for (const id of entryIds) {
      ssrContext.modules!.add(id)
    }
  }

  const _rendered = await renderer.renderToString(ssrContext).catch(async (error) => {
    // We use error to bypass full render if we have an early response we can make
    // TODO: remove _renderResponse in nuxt v5
    if ((ssrContext['~renderResponse'] || ssrContext._renderResponse) && error.message === 'skipping render') { return {} as ReturnType<typeof renderer['renderToString']> }

    // Use explicitly thrown error in preference to subsequent rendering errors
    const _err = (!ssrError && ssrContext.payload?.error) || error
    await ssrContext.nuxt?.hooks.callHook('app:error', _err)
    throw _err
  })

  // Render inline styles
  // TODO: remove _renderResponse in nuxt v5
  const inlinedStyles = NUXT_INLINE_STYLES && !ssrContext['~renderResponse'] && !ssrContext._renderResponse && !isRenderingPayload
    ? await renderInlineStyles(ssrContext.modules ?? [])
    : []

  await ssrContext.nuxt?.hooks.callHook('app:rendered', { ssrContext, renderResult: _rendered })

  if (ssrContext['~renderResponse'] || ssrContext._renderResponse) {
    // TODO: remove _renderResponse in nuxt v5
    return ssrContext['~renderResponse'] || (ssrContext._renderResponse as never)
  }

  // Handle errors
  if (ssrContext.payload?.error && !ssrError) {
    throw ssrContext.payload.error
  }

  // Directly render payload routes
  if (isRenderingPayload) {
    const response = renderPayloadResponse(ssrContext)
    if (import.meta.prerender) {
      await payloadCache!.setItem(ssrContext.url, response)
    }
    return response
  }

  if (_PAYLOAD_EXTRACTION && import.meta.prerender) {
    // Hint nitro to prerender payload for this route
    appendResponseHeader(event, 'x-nitro-prerender', joinURL(ssrContext.url.replace(/\?.*$/, ''), PAYLOAD_FILENAME))
    // Use same ssr context to generate payload for this route
    await payloadCache!.setItem(ssrContext.url === '/' ? '/' : ssrContext.url.replace(/\/$/, ''), renderPayloadResponse(ssrContext))
  }

  const NO_SCRIPTS = NUXT_NO_SCRIPTS || routeOptions.noScripts

  // Setup head
  const { styles, scripts } = getRequestDependencies(ssrContext, renderer.rendererContext)

  // 0. Add import map for stable chunk hashes
  if (entryFileName && !NO_SCRIPTS) {
    let path = entryPath
    if (!path) {
      path = buildAssetsURL(entryFileName) as string
      if (ssrContext.runtimeConfig.app.cdnURL || /^(?:\/|\.+\/)/.test(path)) {
        // cache absolute entry path
        entryPath = path
      } else {
        // TODO: provide support for relative paths in assets as well
        // relativise path
        path = relative(event.path.replace(/\/[^/]+$/, '/'), joinURL('/', path))
        if (!/^(?:\/|\.+\/)/.test(path)) {
          path = `./${path}`
        }
      }
    }
    ssrContext.head.push({
      script: [{
        tagPosition: 'head',
        tagPriority: -2,
        type: 'importmap',
        innerHTML: JSON.stringify({ imports: { '#entry': path } }),
      }],
    }, headEntryOptions)
  }
  // 1. Preload payloads and app manifest
  if (_PAYLOAD_EXTRACTION && !NO_SCRIPTS) {
    ssrContext.head.push({
      link: [
        NUXT_JSON_PAYLOADS
          ? { rel: 'preload', as: 'fetch', crossorigin: 'anonymous', href: payloadURL }
          : { rel: 'modulepreload', crossorigin: '', href: payloadURL },
      ],
    }, headEntryOptions)
  }

  if (isAppManifestEnabled && ssrContext['~preloadManifest'] && !NO_SCRIPTS) {
    ssrContext.head.push({
      link: [
        { rel: 'preload', as: 'fetch', fetchpriority: 'low', crossorigin: 'anonymous', href: buildAssetsURL(`builds/meta/${ssrContext.runtimeConfig.app.buildId}.json`) },
      ],
    }, { ...headEntryOptions, tagPriority: 'low' })
  }

  // 2. Styles
  if (inlinedStyles.length) {
    ssrContext.head.push({ style: inlinedStyles })
  }

  const link: Link[] = []
  for (const resource of Object.values(styles)) {
    // Do not add links to resources that are inlined (vite v5+)
    if (import.meta.dev && 'inline' in getURLQuery(resource.file)) {
      continue
    }
    // Add CSS links in <head> for CSS files
    // - in production
    // - in dev mode when not rendering an island
    link.push({ rel: 'stylesheet', href: renderer.rendererContext.buildAssetsURL(resource.file), crossorigin: '' })
  }

  if (link.length) {
    ssrContext.head.push({ link }, headEntryOptions)
  }

  if (!NO_SCRIPTS) {
    // 4. Resource Hints
    ssrContext.head.push({
      link: getPreloadLinks(ssrContext, renderer.rendererContext) as Link[],
    }, headEntryOptions)
    ssrContext.head.push({
      link: getPrefetchLinks(ssrContext, renderer.rendererContext) as Link[],
    }, headEntryOptions)
    // 5. Payloads
    ssrContext.head.push({
      script: _PAYLOAD_EXTRACTION
        ? NUXT_JSON_PAYLOADS
          ? renderPayloadJsonScript({ ssrContext, data: splitPayload(ssrContext).initial, src: payloadURL })
          : renderPayloadScript({ ssrContext, data: splitPayload(ssrContext).initial, routeOptions, src: payloadURL })
        : NUXT_JSON_PAYLOADS
          ? renderPayloadJsonScript({ ssrContext, data: ssrContext.payload })
          : renderPayloadScript({ ssrContext, data: ssrContext.payload, routeOptions }),
    }, {
      ...headEntryOptions,
      // this should come before another end of body scripts
      tagPosition: 'bodyClose',
      tagPriority: 'high',
    })
  }

  // 6. Scripts
  if (!routeOptions.noScripts) {
    const tagPosition = (_PAYLOAD_EXTRACTION && !NUXT_JSON_PAYLOADS) ? 'bodyClose' : 'head'

    ssrContext.head.push({
      script: Object.values(scripts).map(resource => (<Script> {
        type: resource.module ? 'module' : null,
        src: renderer.rendererContext.buildAssetsURL(resource.file),
        defer: resource.module ? null : true,
        // if we are rendering script tag payloads that import an async payload
        // we need to ensure this resolves before executing the Nuxt entry
        tagPosition,
        crossorigin: '',
      })),
    }, headEntryOptions)
  }

  const { headTags, bodyTags, bodyTagsOpen, htmlAttrs, bodyAttrs } = await renderSSRHead(ssrContext.head, renderSSRHeadOptions)

  // Create render context
  const htmlContext: NuxtRenderHTMLContext = {
    htmlAttrs: htmlAttrs ? [htmlAttrs] : [],
    head: normalizeChunks([headTags]),
    bodyAttrs: bodyAttrs ? [bodyAttrs] : [],
    bodyPrepend: normalizeChunks([bodyTagsOpen, ssrContext.teleports?.body]),
    body: [
      componentIslands ? replaceIslandTeleports(ssrContext, _rendered.html) : _rendered.html,
      APP_TELEPORT_OPEN_TAG + (HAS_APP_TELEPORTS ? joinTags([ssrContext.teleports?.[`#${appTeleportAttrs.id}`]]) : '') + APP_TELEPORT_CLOSE_TAG,
    ],
    bodyAppend: [bodyTags],
  }

  // Allow hooking into the rendered result
  await nitroApp.hooks.callHook('render:html', htmlContext, { event })

  // Construct HTML response
  return {
    body: renderHTMLDocument(htmlContext),
    statusCode: getResponseStatus(event),
    statusMessage: getResponseStatusText(event),
    headers: {
      'content-type': 'text/html;charset=utf-8',
      'x-powered-by': 'Nuxt',
    },
  } satisfies RenderResponse
})

function normalizeChunks (chunks: (string | undefined)[]) {
  const result: string[] = []
  for (const _chunk of chunks) {
    const chunk = _chunk?.trim()
    if (chunk) {
      result.push(chunk)
    }
  }
  return result
}

function joinTags (tags: Array<string | undefined>) {
  return tags.join('')
}

function joinAttrs (chunks: string[]) {
  if (chunks.length === 0) { return '' }
  return ' ' + chunks.join(' ')
}

function renderHTMLDocument (html: NuxtRenderHTMLContext) {
  return '<!DOCTYPE html>' +
    `<html${joinAttrs(html.htmlAttrs)}>` +
    `<head>${joinTags(html.head)}</head>` +
    `<body${joinAttrs(html.bodyAttrs)}>${joinTags(html.bodyPrepend)}${joinTags(html.body)}${joinTags(html.bodyAppend)}</body>` +
    '</html>'
}
</file>

<file path="packages/nitro-server/src/runtime/middleware/no-ssr.ts">
import { defineEventHandler, getRequestHeader } from 'h3'

export default defineEventHandler((event) => {
  if (getRequestHeader(event, 'x-nuxt-no-ssr')) {
    event.context.nuxt ||= {}
    event.context.nuxt.noSSR = true
  }
})
</file>

<file path="packages/nitro-server/src/runtime/plugins/dev-server-logs.ts">
import { AsyncLocalStorage } from 'node:async_hooks'
import type { LogObject } from 'consola'
import { consola } from 'consola'
import { stringify } from 'devalue'
import type { H3Event } from 'h3'
import { withTrailingSlash } from 'ufo'
import { getContext } from 'unctx'
import { captureRawStackTrace, parseRawStackTrace } from 'errx'
import type { ParsedTrace } from 'errx'

import { isVNode } from 'vue'
import type { NitroApp } from 'nitropack/types'

// @ts-expect-error virtual file
import { rootDir } from '#internal/dev-server-logs-options'
// @ts-expect-error virtual file
import { appId } from '#internal/nuxt.config.mjs'

const devReducers: Record<string, (data: any) => any> = {
  VNode: data => isVNode(data) ? { type: data.type, props: data.props } : undefined,
  URL: data => data instanceof URL ? data.toString() : undefined,
}

interface NuxtDevAsyncContext {
  logs: LogObject[]
  event: H3Event
}

const asyncContext = getContext<NuxtDevAsyncContext>('nuxt-dev', { asyncContext: true, AsyncLocalStorage })

export default (nitroApp: NitroApp) => {
  const handler = nitroApp.h3App.handler
  nitroApp.h3App.handler = (event) => {
    return asyncContext.callAsync({ logs: [], event }, () => handler(event))
  }

  onConsoleLog((_log) => {
    const ctx = asyncContext.tryUse()
    if (!ctx) { return }

    const rawStack = captureRawStackTrace()
    if (!rawStack || rawStack.includes('runtime/vite-node.mjs')) { return }

    const trace: ParsedTrace[] = []
    let filename = ''
    for (const entry of parseRawStackTrace(rawStack)) {
      if (entry.source === import.meta.url) { continue }
      if (EXCLUDE_TRACE_RE.test(entry.source)) { continue }

      filename ||= entry.source.replace(withTrailingSlash(rootDir), '')
      trace.push({
        ...entry,
        source: entry.source.startsWith('file://') ? entry.source.replace('file://', '') : entry.source,
      })
    }

    const log = {
      ..._log,
      // Pass along filename to allow the client to display more info about where log comes from
      filename,
      // Clean up file names in stack trace
      stack: trace,
    }

    // retain log to be include in the next render
    ctx.logs.push(log)
  })

  nitroApp.hooks.hook('afterResponse', () => {
    const ctx = asyncContext.tryUse()
    if (!ctx) { return }
    return nitroApp.hooks.callHook('dev:ssr-logs', { logs: ctx.logs, path: ctx.event.path })
  })

  // Pass any logs to the client
  nitroApp.hooks.hook('render:html', (htmlContext) => {
    const ctx = asyncContext.tryUse()
    if (!ctx) { return }
    try {
      const reducers = Object.assign(Object.create(null), devReducers, ctx.event.context['~payloadReducers'])
      htmlContext.bodyAppend.unshift(`<script type="application/json" data-nuxt-logs="${appId}">${stringify(ctx.logs, reducers)}</script>`)
    } catch (e) {
      const shortError = e instanceof Error && 'toString' in e ? ` Received \`${e.toString()}\`.` : ''
      console.warn(`[nuxt] Failed to stringify dev server logs.${shortError} You can define your own reducer/reviver for rich types following the instructions in https://nuxt.com/docs/4.x/api/composables/use-nuxt-app#payload.`)
    }
  })
}

const EXCLUDE_TRACE_RE = /\/node_modules\/(?:.*\/)?(?:nuxt|nuxt-nightly|nuxt-edge|nuxt3|consola|@vue)\/|core\/runtime\/nitro/

function onConsoleLog (callback: (log: LogObject) => void) {
  consola.addReporter({
    log (logObj) {
      callback(logObj)
    },
  })
  consola.wrapConsole()
}
</file>

<file path="packages/nitro-server/src/runtime/utils/renderer/app.ts">
import type { H3Event } from 'h3'
import { decodePath } from 'ufo'
import { useRuntimeConfig } from 'nitropack/runtime'
import { createHead } from '@unhead/vue/server'
import type { NuxtPayload, NuxtSSRContext } from 'nuxt/app'
import { sharedPrerenderCache } from '../cache'
// @ts-expect-error virtual file
import unheadOptions from '#internal/unhead-options.mjs'
// @ts-expect-error virtual file
import { NUXT_NO_SSR, NUXT_SHARED_DATA } from '#internal/nuxt/nitro-config.mjs'

const PRERENDER_NO_SSR_ROUTES = new Set(['/index.html', '/200.html', '/404.html'])

export function createSSRContext (event: H3Event): NuxtSSRContext {
  const ssrContext: NuxtSSRContext = {
    url: decodePath(event.path),
    event,
    runtimeConfig: useRuntimeConfig(event) as NuxtSSRContext['runtimeConfig'],
    noSSR: !!(NUXT_NO_SSR) || event.context.nuxt?.noSSR || (import.meta.prerender ? PRERENDER_NO_SSR_ROUTES.has(event.path) : false),
    head: createHead(unheadOptions),
    error: false,
    nuxt: undefined!, /* NuxtApp */
    payload: {},
    ['~payloadReducers']: Object.create(null),
    modules: new Set(),
  }

  if (import.meta.prerender) {
    if (NUXT_SHARED_DATA) {
      ssrContext['~sharedPrerenderCache'] = sharedPrerenderCache!
    }
    ssrContext.payload.prerenderedAt = Date.now()
  }

  return ssrContext
}

export function setSSRError (ssrContext: NuxtSSRContext, error: NuxtPayload['error'] & { url: string }): void {
  ssrContext.error = true
  ssrContext.payload = { error }
  ssrContext.url = error.url
}
</file>

<file path="packages/nitro-server/src/runtime/utils/renderer/build-files.ts">
import process from 'node:process'
import type { RendererContext } from 'vue-bundle-renderer/runtime'
import { createRenderer } from 'vue-bundle-renderer/runtime'
import type { Manifest, PrecomputedData } from 'vue-bundle-renderer'
import { renderToString as _renderToString } from 'vue/server-renderer'
import { propsToString } from '@unhead/vue/server'
import { useRuntimeConfig } from 'nitropack/runtime'
import type { NuxtSSRContext } from 'nuxt/app'

// @ts-expect-error virtual file
import { NUXT_NO_SSR } from '#internal/nuxt/nitro-config.mjs'
// @ts-expect-error virtual file
import { appRootAttrs, appRootTag, appSpaLoaderAttrs, appSpaLoaderTag, spaLoadingTemplateOutside } from '#internal/nuxt.config.mjs'
// @ts-expect-error virtual file
import { buildAssetsURL } from '#internal/nuxt/paths'

const APP_ROOT_OPEN_TAG = `<${appRootTag}${propsToString(appRootAttrs)}>`
const APP_ROOT_CLOSE_TAG = `</${appRootTag}>`

// @ts-expect-error file will be produced after app build
const getServerEntry = () => import('#build/dist/server/server.mjs').then(r => r.default || r)

// @ts-expect-error file will be produced after app build
const getClientManifest: () => Promise<Manifest> = () => import('#build/dist/server/client.manifest.mjs')
  .then(r => r.default || r)
  .then(r => typeof r === 'function' ? r() : r) as Promise<Manifest>

// @ts-expect-error file will be produced after app build
const getPrecomputedDependencies: () => Promise<PrecomputedData> = () => import('#build/dist/server/client.precomputed.mjs')
  .then(r => r.default || r)
  .then(r => typeof r === 'function' ? r() : r) as Promise<PrecomputedData>

interface Renderer {
  rendererContext: RendererContext
  renderToString(ssrContext: NuxtSSRContext): Promise<{
    html: string
    renderResourceHeaders: () => Record<string, string>
    renderResourceHints: () => string
    renderStyles: () => string
    renderScripts: () => string
  }>
}

// -- SSR Renderer --
export const getSSRRenderer = lazyCachedFunction(async (): Promise<Renderer> => {
  // Load server bundle
  const createSSRApp = await getServerEntry()
  if (!createSSRApp) { throw new Error('Server bundle is not available') }

  // Load precomputed dependencies
  const precomputed = import.meta.dev ? undefined : await getPrecomputedDependencies()

  // Create renderer
  const renderer = createRenderer(createSSRApp, {
    precomputed,
    manifest: import.meta.dev ? await getClientManifest() : undefined,
    renderToString,
    buildAssetsURL,
  })

  type RenderToStringParams = Parameters<typeof _renderToString>
  async function renderToString (input: RenderToStringParams[0], context: RenderToStringParams[1]) {
    const html = await _renderToString(input, context)
    // In development with vite-node, the manifest is on-demand and will be available after rendering
    if (import.meta.dev && process.env.NUXT_VITE_NODE_OPTIONS) {
      renderer.rendererContext.updateManifest(await getClientManifest())
    }
    return APP_ROOT_OPEN_TAG + html + APP_ROOT_CLOSE_TAG
  }

  return renderer
})

// -- SPA Renderer --
const getSPARenderer = lazyCachedFunction(async (): Promise<Renderer> => {
  const precomputed = import.meta.dev ? undefined : await getPrecomputedDependencies()

  // @ts-expect-error virtual file
  const spaTemplate = await import('#spa-template').then(r => r.template).catch(() => '')
    .then((r) => {
      if (spaLoadingTemplateOutside) {
        const APP_SPA_LOADER_OPEN_TAG = `<${appSpaLoaderTag}${propsToString(appSpaLoaderAttrs)}>`
        const APP_SPA_LOADER_CLOSE_TAG = `</${appSpaLoaderTag}>`
        const appTemplate = APP_ROOT_OPEN_TAG + APP_ROOT_CLOSE_TAG
        const loaderTemplate = r ? APP_SPA_LOADER_OPEN_TAG + r + APP_SPA_LOADER_CLOSE_TAG : ''
        return appTemplate + loaderTemplate
      } else {
        return APP_ROOT_OPEN_TAG + r + APP_ROOT_CLOSE_TAG
      }
    })

  // Create SPA renderer and cache the result for all requests
  const renderer = createRenderer(() => () => {}, {
    precomputed,
    manifest: import.meta.dev ? await getClientManifest() : undefined,
    renderToString: () => spaTemplate,
    buildAssetsURL,
  })
  const result = await renderer.renderToString({})

  const renderToString = (ssrContext: NuxtSSRContext) => {
    const config = useRuntimeConfig(ssrContext.event)
    ssrContext.modules ||= new Set<string>()
    ssrContext.payload.serverRendered = false
    ssrContext.config = {
      public: config.public,
      app: config.app,
    }
    return Promise.resolve(result)
  }

  return {
    rendererContext: renderer.rendererContext,
    renderToString,
  }
})

function lazyCachedFunction<T> (fn: () => Promise<T>): () => Promise<T> {
  let res: Promise<T> | null = null
  return () => {
    if (res === null) {
      res = fn().catch((err) => { res = null; throw err })
    }
    return res
  }
}

export function getRenderer (ssrContext: NuxtSSRContext): Promise<Renderer> {
  return (NUXT_NO_SSR || ssrContext.noSSR) ? getSPARenderer() : getSSRRenderer()
}

// @ts-expect-error file will be produced after app build
export const getSSRStyles = lazyCachedFunction((): Promise<Record<string, () => Promise<string[]>>> => import('#build/dist/server/styles.mjs').then(r => r.default || r))
</file>

<file path="packages/nitro-server/src/runtime/utils/renderer/inline-styles.ts">
import type { Style } from '@unhead/vue/types'
import { getSSRStyles } from './build-files'

export async function renderInlineStyles (usedModules: Set<string> | string[]): Promise<Style[]> {
  const styleMap = await getSSRStyles()
  const inlinedStyles = new Set<string>()
  for (const mod of usedModules) {
    if (mod in styleMap && styleMap[mod]) {
      for (const style of await styleMap[mod]()) {
        inlinedStyles.add(style)
      }
    }
  }
  return Array.from(inlinedStyles).map(style => ({ innerHTML: style }))
}
</file>

<file path="packages/nitro-server/src/runtime/utils/renderer/islands.ts">
import type { NuxtIslandResponse, NuxtSSRContext } from 'nuxt/app'
// @ts-expect-error virtual file
import { appRootTag } from '#internal/nuxt.config.mjs'

const ROOT_NODE_REGEX = new RegExp(`^<${appRootTag}[^>]*>([\\s\\S]*)<\\/${appRootTag}>$`)

/**
 * remove the root node from the html body
 */
export function getServerComponentHTML (body: string): string {
  const match = body.match(ROOT_NODE_REGEX)
  return match?.[1] || body
}

const SSR_SLOT_TELEPORT_MARKER = /^uid=([^;]*);slot=(.*)$/
const SSR_CLIENT_TELEPORT_MARKER = /^uid=([^;]*);client=(.*)$/
const SSR_CLIENT_SLOT_MARKER = /^island-slot=([^;]*);(.*)$/

export function getSlotIslandResponse (ssrContext: NuxtSSRContext): NuxtIslandResponse['slots'] {
  if (!ssrContext.islandContext || !Object.keys(ssrContext.islandContext.slots).length) { return undefined }
  const response: NuxtIslandResponse['slots'] = {}
  for (const [name, slot] of Object.entries(ssrContext.islandContext.slots)) {
    response[name] = {
      ...slot,
      fallback: ssrContext.teleports?.[`island-fallback=${name}`],
    }
  }
  return response
}

export function getClientIslandResponse (ssrContext: NuxtSSRContext): NuxtIslandResponse['components'] {
  if (!ssrContext.islandContext || !Object.keys(ssrContext.islandContext.components).length) { return undefined }
  const response: NuxtIslandResponse['components'] = {}

  for (const [clientUid, component] of Object.entries(ssrContext.islandContext.components)) {
    // remove teleport anchor to avoid hydration issues
    const html = ssrContext.teleports?.[clientUid]?.replaceAll('<!--teleport start anchor-->', '') || ''
    response[clientUid] = {
      ...component,
      html,
      slots: getComponentSlotTeleport(clientUid, ssrContext.teleports ?? {}),
    }
  }
  return response
}

export function getComponentSlotTeleport (clientUid: string, teleports: Record<string, string>): Record<string, string> {
  const entries = Object.entries(teleports)
  const slots: Record<string, string> = {}

  for (const [key, value] of entries) {
    const match = key.match(SSR_CLIENT_SLOT_MARKER)
    if (match) {
      const [, id, slot] = match
      if (!slot || clientUid !== id) { continue }
      slots[slot] = value
    }
  }
  return slots
}

export function replaceIslandTeleports (ssrContext: NuxtSSRContext, html: string): string {
  const { teleports, islandContext } = ssrContext

  if (islandContext || !teleports) { return html }
  for (const key in teleports) {
    const matchClientComp = key.match(SSR_CLIENT_TELEPORT_MARKER)
    if (matchClientComp) {
      const [, uid, clientId] = matchClientComp
      if (!uid || !clientId) { continue }
      html = html.replace(new RegExp(` data-island-uid="${uid}" data-island-component="${clientId}"[^>]*>`), (full) => {
        return full + teleports[key]
      })
      continue
    }
    const matchSlot = key.match(SSR_SLOT_TELEPORT_MARKER)
    if (matchSlot) {
      const [, uid, slot] = matchSlot
      if (!uid || !slot) { continue }
      html = html.replace(new RegExp(` data-island-uid="${uid}" data-island-slot="${slot}"[^>]*>`), (full) => {
        return full + teleports[key]
      })
    }
  }
  return html
}
</file>

<file path="packages/nitro-server/src/runtime/utils/renderer/payload.ts">
import type { NitroRouteRules, RenderResponse } from 'nitropack/types'
import { getResponseStatus, getResponseStatusText } from 'h3'
import devalue from '@nuxt/devalue'
import { stringify, uneval } from 'devalue'
import type { Script } from '@unhead/vue'

import type { NuxtPayload, NuxtSSRContext } from 'nuxt/app'

// @ts-expect-error virtual file
import { appId, multiApp } from '#internal/nuxt.config.mjs'
// @ts-expect-error virtual file
import { NUXT_JSON_PAYLOADS, NUXT_NO_SSR, NUXT_PAYLOAD_EXTRACTION, NUXT_RUNTIME_PAYLOAD_EXTRACTION } from '#internal/nuxt/nitro-config.mjs'

export function renderPayloadResponse (ssrContext: NuxtSSRContext): RenderResponse {
  return {
    body: NUXT_JSON_PAYLOADS
      ? stringify(splitPayload(ssrContext).payload, ssrContext['~payloadReducers'])
      : `export default ${devalue(splitPayload(ssrContext).payload)}`,
    statusCode: getResponseStatus(ssrContext.event),
    statusMessage: getResponseStatusText(ssrContext.event),
    headers: {
      'content-type': NUXT_JSON_PAYLOADS ? 'application/json;charset=utf-8' : 'text/javascript;charset=utf-8',
      'x-powered-by': 'Nuxt',
    },
  }
}

export function renderPayloadJsonScript (opts: { ssrContext: NuxtSSRContext, data?: any, src?: string }): Script[] {
  const contents = opts.data ? stringify(opts.data, opts.ssrContext['~payloadReducers']) : ''
  const payload: Script = {
    'type': 'application/json',
    'innerHTML': contents,
    'data-nuxt-data': appId,
    'data-ssr': !(NUXT_NO_SSR || opts.ssrContext.noSSR),
  }
  if (!multiApp) {
    payload.id = '__NUXT_DATA__'
  }
  if (opts.src) {
    payload['data-src'] = opts.src
  }
  const config = uneval(opts.ssrContext.config)
  return [
    payload,
    {
      innerHTML: multiApp
        ? `window.__NUXT__=window.__NUXT__||{};window.__NUXT__[${JSON.stringify(appId)}]={config:${config}}`
        : `window.__NUXT__={};window.__NUXT__.config=${config}`,
    },
  ]
}

export function renderPayloadScript (opts: { ssrContext: NuxtSSRContext, routeOptions: NitroRouteRules, data?: any, src?: string }): Script[] {
  opts.data.config = opts.ssrContext.config
  const _PAYLOAD_EXTRACTION = !opts.ssrContext.noSSR && (
    (import.meta.prerender && NUXT_PAYLOAD_EXTRACTION)
    || (NUXT_RUNTIME_PAYLOAD_EXTRACTION && (opts.routeOptions.isr || opts.routeOptions.cache))
  )
  const nuxtData = devalue(opts.data)
  if (_PAYLOAD_EXTRACTION) {
    const singleAppPayload = `import p from "${opts.src}";window.__NUXT__={...p,...(${nuxtData})}`
    const multiAppPayload = `import p from "${opts.src}";window.__NUXT__=window.__NUXT__||{};window.__NUXT__[${JSON.stringify(appId)}]={...p,...(${nuxtData})}`
    return [
      {
        type: 'module',
        innerHTML: multiApp ? multiAppPayload : singleAppPayload,
      },
    ]
  }
  const singleAppPayload = `window.__NUXT__=${nuxtData}`
  const multiAppPayload = `window.__NUXT__=window.__NUXT__||{};window.__NUXT__[${JSON.stringify(appId)}]=${nuxtData}`
  return [
    {
      innerHTML: multiApp ? multiAppPayload : singleAppPayload,
    },
  ]
}

interface SplitPayload {
  initial: Omit<NuxtPayload, 'data'>
  payload: {
    data?: NuxtPayload['data']
    prerenderedAt?: NuxtPayload['prerenderedAt']
  }
}

export function splitPayload (ssrContext: NuxtSSRContext): SplitPayload {
  const { data, prerenderedAt, ...initial } = ssrContext.payload
  return {
    initial: { ...initial, prerenderedAt },
    payload: { data, prerenderedAt },
  }
}
</file>

<file path="packages/nitro-server/src/runtime/utils/app-config.ts">
import type { H3Event } from 'h3'
import { klona } from 'klona'
import type { AppConfig } from '@nuxt/schema'

// @ts-expect-error virtual file
import _inlineAppConfig from '#internal/nuxt/app-config'

// App config
const _sharedAppConfig = _deepFreeze(klona(_inlineAppConfig))
export function useAppConfig (event?: H3Event): AppConfig {
  // Backwards compatibility with ambient context
  if (!event) {
    return _sharedAppConfig
  }
  event.context.nuxt ||= {}
  // Reuse cached app config from event context
  if (event.context.nuxt.appConfig) {
    return event.context.nuxt.appConfig
  }
  // Prepare app config for event context
  const appConfig = klona(_inlineAppConfig)
  event.context.nuxt.appConfig = appConfig
  return appConfig
}

// --- Utils ---

function _deepFreeze (object: Record<string, any>) {
  const propNames = Object.getOwnPropertyNames(object)
  for (const name of propNames) {
    const value = object[name]
    if (value && typeof value === 'object') {
      _deepFreeze(value)
    }
  }
  return Object.freeze(object)
}
</file>

<file path="packages/nitro-server/src/runtime/utils/cache-driver.js">
// @ts-check

import crypto from 'node:crypto'
import { defineDriver } from 'unstorage'
import fsDriver from 'unstorage/drivers/fs-lite'
import lruCache from 'unstorage/drivers/lru-cache'

/**
 * @param {string} item
 */
function normalizeFsKey (item) {
  const safe = item.replace(/[^\w.-]/g, '_')
  const prefix = safe.slice(0, 20)
  const hash = crypto.createHash('sha256').update(item).digest('hex')
  return `${prefix}-${hash}`
}

export default defineDriver(
  /**
   * @param {{ base?: string }} opts
   */
  (opts) => {
    const fs = fsDriver({ base: opts.base })
    const lru = lruCache({ max: 1000 })

    return {
      ...fs, // fall back to file system - only the bottom three methods are used in renderer
      async setItem (key, value, opts) {
        await Promise.all([
          fs.setItem?.(normalizeFsKey(key), value, opts),
          lru.setItem?.(key, value, opts),
        ])
      },
      async hasItem (key, opts) {
        return await lru.hasItem(key, opts) || await fs.hasItem(normalizeFsKey(key), opts)
      },
      async getItem (key, opts) {
        return await lru.getItem(key, opts) || await fs.getItem(normalizeFsKey(key), opts)
      },
    }
  },
)
</file>

<file path="packages/nitro-server/src/runtime/utils/cache.ts">
// Workaround for 'The inferred type of 'payloadCache' cannot be named without a reference to '.pnpm/unstorage@1.16.0_db0@0.3.2_ioredis@5.6.1/node_modules/unstorage'.
// This is likely not portable. A type annotation is necessary.
import type {} from 'unstorage'
import { useStorage } from 'nitropack/runtime'
// @ts-expect-error virtual file
import { NUXT_SHARED_DATA } from '#internal/nuxt/nitro-config.mjs'

export const payloadCache = import.meta.prerender ? useStorage('internal:nuxt:prerender:payload') : null
export const islandCache = import.meta.prerender ? useStorage('internal:nuxt:prerender:island') : null
export const islandPropCache = import.meta.prerender ? useStorage('internal:nuxt:prerender:island-props') : null
export const sharedPrerenderPromises = import.meta.prerender && NUXT_SHARED_DATA ? new Map<string, Promise<any>>() : null

const sharedPrerenderKeys = new Set<string>()
export const sharedPrerenderCache = import.meta.prerender && NUXT_SHARED_DATA
  ? {
      get<T = unknown> (key: string): Promise<T> | undefined {
        if (sharedPrerenderKeys.has(key)) {
          return sharedPrerenderPromises!.get(key) ?? useStorage('internal:nuxt:prerender:shared').getItem(key) as Promise<T>
        }
      },
      async set<T> (key: string, value: Promise<T>): Promise<void> {
        sharedPrerenderKeys.add(key)
        sharedPrerenderPromises!.set(key, value)
        useStorage('internal:nuxt:prerender:shared').setItem(key, await value as any)
        // free up memory after the promise is resolved
          .finally(() => sharedPrerenderPromises!.delete(key))
      },
    }
  : null
</file>

<file path="packages/nitro-server/src/runtime/utils/config.ts">
export const defineAppConfig = (config: any) => config
</file>

<file path="packages/nitro-server/src/runtime/utils/dev.ts">
const iframeStorageBridge = (nonce: string) => /* js */ `
(function () {
  const NONCE = ${JSON.stringify(nonce)};
  const memoryStore = Object.create(null);

  const post = (type, payload) => {
    window.parent.postMessage({ type, nonce: NONCE, ...payload }, '*');
  };

  const isValid = (data) => data && data.nonce === NONCE;

  const mockStorage = {
    getItem(key) {
      return Object.hasOwn(memoryStore, key)
        ? memoryStore[key]
        : null;
    },
    setItem(key, value) {
      const v = String(value);
      memoryStore[key] = v;
      post('storage-set', { key, value: v });
    },
    removeItem(key) {
      delete memoryStore[key];
      post('storage-remove', { key });
    },
    clear() {
      for (const key of Object.keys(memoryStore))
        delete memoryStore[key];
      post('storage-clear', {});
    },
    key(index) {
      const keys = Object.keys(memoryStore);
      return keys[index] ?? null;
    },
    get length() {
      return Object.keys(memoryStore).length;
    }
  };

  const defineLocalStorage = () => {
    try {
      Object.defineProperty(window, 'localStorage', {
        value: mockStorage,
        writable: false,
        configurable: true
      });
    } catch {
      window.localStorage = mockStorage;
    }
  };

  defineLocalStorage();

  window.addEventListener('message', (event) => {
    const data = event.data;
    if (!isValid(data) || data.type !== 'storage-sync-data') return;

    const incoming = data.data || {};
    for (const key of Object.keys(incoming))
      memoryStore[key] = incoming[key];

    if (typeof window.initTheme === 'function')
      window.initTheme();
    window.dispatchEvent(new Event('storage-ready'));
  });

  // Clipboard API is unavailable in data: URL iframe, so we use postMessage
  document.addEventListener('DOMContentLoaded', function() {
    window.copyErrorMessage = function(button) {
      post('clipboard-copy', { text: button.dataset.errorText });
      button.classList.add('copied');
      setTimeout(function() { button.classList.remove('copied'); }, 2000);
    };
  });

  post('storage-sync-request', {});
})();
`

const parentStorageBridge = (nonce: string) => /* js */ `
(function () {
  const host = document.querySelector('nuxt-error-overlay');
  if (!host) return;

  const NONCE = ${JSON.stringify(nonce)};
  const isValid = (data) => data && data.nonce === NONCE;

  // Handle clipboard copy from iframe
  window.addEventListener('message', function(e) {
    if (isValid(e) && e.data.type === 'clipboard-copy') {
      navigator.clipboard.writeText(e.data.text).catch(function() {});
    }
  });

  const collectLocalStorage = () => {
    const all = {};
    for (let i = 0; i < localStorage.length; i++) {
      const k = localStorage.key(i);
      if (k != null) all[k] = localStorage.getItem(k);
    }
    return all;
  };

  const attachWhenReady = () => {
    const root = host.shadowRoot;
    if (!root)
      return false;
    const iframe = root.getElementById('frame');
    if (!iframe || !iframe.contentWindow)
      return false;

    const handlers = {
      'storage-set': (d) => localStorage.setItem(d.key, d.value),
      'storage-remove': (d) => localStorage.removeItem(d.key),
      'storage-clear': () => localStorage.clear(),
      'storage-sync-request': () => {
        iframe.contentWindow.postMessage({
          type: 'storage-sync-data',
          data: collectLocalStorage(),
          nonce: NONCE
        }, '*');
      }
    };

    window.addEventListener('message', (event) => {
      const data = event.data;
      if (!isValid(data)) return;
      const fn = handlers[data.type];
      if (fn) fn(data);
    });

    return true;
  };

  if (attachWhenReady())
    return;

  const obs = new MutationObserver(() => {
    if (attachWhenReady())
      obs.disconnect();
  });

  obs.observe(host, { childList: true, subtree: true });
})();
`

const errorCSS = /* css */ `
:host {
  --preview-width: 240px;
  --preview-height: 180px;
  --base-width: 1200px;
  --base-height: 900px;
  --z-base: 999999998;
  --error-pip-left: auto;
  --error-pip-top: auto;
  --error-pip-right: 5px;
  --error-pip-bottom: 5px;
  --error-pip-origin: bottom right;
  --app-preview-left: auto;
  --app-preview-top: auto;
  --app-preview-right: 5px;
  --app-preview-bottom: 5px;
  all: initial;
  display: contents;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
#frame {
  position: fixed;
  left: 0;
  top: 0;
  width: 100vw;
  height: 100vh;
  border: none;
  z-index: var(--z-base);
}
#frame[inert] {
  left: var(--error-pip-left);
  top: var(--error-pip-top);
  right: var(--error-pip-right);
  bottom: var(--error-pip-bottom);
  width: var(--base-width);
  height: var(--base-height);
  transform: scale(calc(240 / 1200));
  transform-origin: var(--error-pip-origin);
  overflow: hidden;
  border-radius: calc(1200 * 8px / 240);
}
#preview {
  position: fixed;
  left: var(--app-preview-left);
  top: var(--app-preview-top);
  right: var(--app-preview-right);
  bottom: var(--app-preview-bottom);
  width: var(--preview-width);
  height: var(--preview-height);
  overflow: hidden;
  border-radius: 6px;
  pointer-events: none;
  z-index: var(--z-base);
  background: white;
  display: none;
}
#preview iframe {
  transform-origin: var(--error-pip-origin);
}
#frame:not([inert]) + #preview {
  display: block;
}
#toggle {
  position: fixed;
  left: var(--app-preview-left);
  top: var(--app-preview-top);
  right: calc(var(--app-preview-right) - 3px);
  bottom: calc(var(--app-preview-bottom) - 3px);
  width: var(--preview-width);
  height: var(--preview-height);
  background: none;
  border: 3px solid #00DC82;
  border-radius: 8px;
  cursor: pointer;
  opacity: 0.8;
  transition: opacity 0.2s, box-shadow 0.2s;
  z-index: calc(var(--z-base) + 1);
  display: flex;
  align-items: center;
  justify-content: center;
}
#toggle:hover,
#toggle:focus {
  opacity: 1;
  box-shadow: 0 0 20px rgba(0, 220, 130, 0.6);
}
#toggle:focus-visible {
  outline: 3px solid #00DC82;
  outline-offset: 0;
  box-shadow: 0 0 24px rgba(0, 220, 130, 0.8);
}
#frame[inert] ~ #toggle {
  left: var(--error-pip-left);
  top: var(--error-pip-top);
  right: calc(var(--error-pip-right) - 3px);
  bottom: calc(var(--error-pip-bottom) - 3px);
  cursor: grab;
}
:host(.dragging) #frame[inert] ~ #toggle {
  cursor: grabbing;
}
#frame:not([inert]) ~ #toggle,
#frame:not([inert]) + #preview {
  cursor: grab;
}
:host(.dragging-preview) #frame:not([inert]) ~ #toggle,
:host(.dragging-preview) #frame:not([inert]) + #preview {
  cursor: grabbing;
}

#pip-close {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: none;
  background: rgba(0, 0, 0, 0.75);
  color: #fff;
  font-size: 16px;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  pointer-events: auto;
}
#pip-close:focus-visible {
  outline: 2px solid #00DC82;
  outline-offset: 2px;
}

#pip-restore {
  position: fixed;
  right: 16px;
  bottom: 16px;
  padding: 8px 14px;
  border-radius: 999px;
  border: 2px solid #00DC82;
  background: #111;
  color: #fff;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
  font-size: 14px;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  z-index: calc(var(--z-base) + 2);
  cursor: grab;
}
#pip-restore:focus-visible {
  outline: 2px solid #00DC82;
  outline-offset: 2px;
}
:host(.dragging-restore) #pip-restore {
  cursor: grabbing;
}

#frame[hidden],
#toggle[hidden],
#preview[hidden],
#pip-restore[hidden],
#pip-close[hidden] {
  display: none !important;
}

@media (prefers-reduced-motion: reduce) {
  #toggle {
    transition: none;
  }
}
`

function webComponentScript (base64HTML: string, startMinimized: boolean) {
  return /* js */ `
(function () {
  try {
    // =========================
    // Host + Shadow
    // =========================
    const host = document.querySelector('nuxt-error-overlay');
    if (!host)
      return;
    const shadow = host.attachShadow({ mode: 'open' });

    // =========================
    // DOM helpers
    // =========================
    const el = (tag) => document.createElement(tag);
    const on = (node, type, fn, opts) => node.addEventListener(type, fn, opts);
    const hide = (node, v) => node.toggleAttribute('hidden', !!v);
    const setVar = (name, value) => host.style.setProperty(name, value);
    const unsetVar = (name) => host.style.removeProperty(name);

    // =========================
    // Create DOM
    // =========================
    const style = el('style');
    style.textContent = ${JSON.stringify(errorCSS)};

    const iframe = el('iframe');
    iframe.id = 'frame';
    iframe.src = 'data:text/html;base64,${base64HTML}';
    iframe.title = 'Detailed error stack trace';
    iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');

    const preview = el('div');
    preview.id = 'preview';

    const toggle = el('div');
    toggle.id = 'toggle';
    toggle.setAttribute('aria-expanded', 'true');
    toggle.setAttribute('role', 'button');
    toggle.setAttribute('tabindex', '0');
    toggle.innerHTML = '<span class="sr-only">Toggle detailed error view</span>';

    const liveRegion = el('div');
    liveRegion.setAttribute('role', 'status');
    liveRegion.setAttribute('aria-live', 'polite');
    liveRegion.className = 'sr-only';

    const pipCloseButton = el('button');
    pipCloseButton.id = 'pip-close';
    pipCloseButton.setAttribute('type', 'button');
    pipCloseButton.setAttribute('aria-label', 'Hide error preview overlay');
    pipCloseButton.innerHTML = '&times;';
    pipCloseButton.hidden = true;
    toggle.appendChild(pipCloseButton);

    const pipRestoreButton = el('button');
    pipRestoreButton.id = 'pip-restore';
    pipRestoreButton.setAttribute('type', 'button');
    pipRestoreButton.setAttribute('aria-label', 'Show error overlay');
    pipRestoreButton.innerHTML = '<span aria-hidden="true">⟲</span><span>Show error overlay</span>';
    pipRestoreButton.hidden = true;

    // Order matters: #frame + #preview adjacency
    shadow.appendChild(style);
    shadow.appendChild(liveRegion);
    shadow.appendChild(iframe);
    shadow.appendChild(preview);
    shadow.appendChild(toggle);
    shadow.appendChild(pipRestoreButton);

    // =========================
    // Constants / keys
    // =========================
    const POS_KEYS = {
      position: 'nuxt-error-overlay:position',
      hiddenPretty: 'nuxt-error-overlay:error-pip:hidden',
      hiddenPreview: 'nuxt-error-overlay:app-preview:hidden'
    };

    const CSS_VARS = {
      pip: {
        left: '--error-pip-left',
        top: '--error-pip-top',
        right: '--error-pip-right',
        bottom: '--error-pip-bottom'
      },
      preview: {
        left: '--app-preview-left',
        top: '--app-preview-top',
        right: '--app-preview-right',
        bottom: '--app-preview-bottom'
      }
    };

    const MIN_GAP = 5;
    const DRAG_THRESHOLD = 2;

    // =========================
    // Local storage safe access + state
    // =========================
    let storageReady = true;
    let isPrettyHidden = false;
    let isPreviewHidden = false;

    const safeGet = (k) => {
      try {
        return localStorage.getItem(k);
      } catch {
        return null;
      }
    };

    const safeSet = (k, v) => {
      if (!storageReady) 
        return;
      try {
        localStorage.setItem(k, v);
      } catch {}
    };

    // =========================
    // Sizing helpers
    // =========================
    const vvSize = () => {
      const v = window.visualViewport;
      return v ? { w: v.width, h: v.height } : { w: window.innerWidth, h: window.innerHeight };
    };

    const previewSize = () => {
      const styles = getComputedStyle(host);
      const w = parseFloat(styles.getPropertyValue('--preview-width')) || 240;
      const h = parseFloat(styles.getPropertyValue('--preview-height')) || 180;
      return { w, h };
    };

    const sizeForTarget = (target) => {
      if (!target)
        return previewSize();
      const rect = target.getBoundingClientRect();
      if (rect.width && rect.height)
        return { w: rect.width, h: rect.height };
      return previewSize();
    };

    // =========================
    // Dock model + offset/alignment calculations
    // =========================
    const dock = { edge: null, offset: null, align: null, gap: null };

    const maxOffsetFor = (edge, size) => {
      const vv = vvSize();
      if (edge === 'left' || edge === 'right')
        return Math.max(MIN_GAP, vv.h - size.h - MIN_GAP);
      return Math.max(MIN_GAP, vv.w - size.w - MIN_GAP);
    };

    const clampOffset = (edge, value, size) => {
      const max = maxOffsetFor(edge, size);
      return Math.min(Math.max(value, MIN_GAP), max);
    };

    const updateDockAlignment = (size) => {
      if (!dock.edge || dock.offset == null)
        return;
      const max = maxOffsetFor(dock.edge, size);
      if (dock.offset <= max / 2) {
        dock.align = 'start';
        dock.gap = dock.offset;
      } else {
        dock.align = 'end';
        dock.gap = Math.max(0, max - dock.offset);
      }
    };

    const appliedOffsetFor = (size) => {
      if (!dock.edge || dock.offset == null)
        return null;
      const max = maxOffsetFor(dock.edge, size);

      if (dock.align === 'end' && typeof dock.gap === 'number') {
        return clampOffset(dock.edge, max - dock.gap, size);
      }
      if (dock.align === 'start' && typeof dock.gap === 'number') {
        return clampOffset(dock.edge, dock.gap, size);
      }
      return clampOffset(dock.edge, dock.offset, size);
    };

    const nearestEdgeAt = (x, y) => {
      const { w, h } = vvSize();
      const d = { left: x, right: w - x, top: y, bottom: h - y };
      return Object.keys(d).reduce((a, b) => (d[a] < d[b] ? a : b));
    };

    const cornerDefaultDock = () => {
      const vv = vvSize();
      const size = previewSize();
      const offset = Math.max(MIN_GAP, vv.w - size.w - MIN_GAP);
      return { edge: 'bottom', offset };
    };

    const currentTransformOrigin = () => {
      if (!dock.edge) return null;
      if (dock.edge === 'left' || dock.edge === 'top')
        return 'top left';
      if (dock.edge === 'right')
        return 'top right';
      return 'bottom left';
    };

    // =========================
    // Persist / load dock
    // =========================
    const loadDock = () => {
      const raw = safeGet(POS_KEYS.position);
      if (!raw)
        return;
      try {
        const parsed = JSON.parse(raw);
        const { edge, offset, align, gap } = parsed || {};
        if (!['left', 'right', 'top', 'bottom'].includes(edge))
          return;
        if (typeof offset !== 'number')
          return;

        dock.edge = edge;
        dock.offset = clampOffset(edge, offset, previewSize());
        dock.align = align === 'start' || align === 'end' ? align : null;
        dock.gap = typeof gap === 'number' ? gap : null;

        if (!dock.align || dock.gap == null)
          updateDockAlignment(previewSize());
      } catch {}
    };

    const persistDock = () => {
      if (!dock.edge || dock.offset == null)
        return; 
      safeSet(POS_KEYS.position, JSON.stringify({
        edge: dock.edge,
        offset: dock.offset,
        align: dock.align,
        gap: dock.gap
      }));
    };

    // =========================
    // Apply dock
    // =========================
    const dockToVars = (vars) => ({
      set: (side, v) => host.style.setProperty(vars[side], v),
      clear: (side) => host.style.removeProperty(vars[side])
    });

    const dockToEl = (node) => ({
      set: (side, v) => { node.style[side] = v; },
      clear: (side) => { node.style[side] = ''; }
    });

    const applyDock = (target, size, opts) => {
      if (!dock.edge || dock.offset == null) {
        target.clear('left');
        target.clear('top');
        target.clear('right');
        target.clear('bottom');
        return;
      }

      target.set('left', 'auto');
      target.set('top', 'auto');
      target.set('right', 'auto');
      target.set('bottom', 'auto');

      const applied = appliedOffsetFor(size);

      if (dock.edge === 'left') {
        target.set('left', MIN_GAP + 'px');
        target.set('top', applied + 'px');
      } else if (dock.edge === 'right') {
        target.set('right', MIN_GAP + 'px');
        target.set('top', applied + 'px');
      } else if (dock.edge === 'top') {
        target.set('top', MIN_GAP + 'px');
        target.set('left', applied + 'px');
      } else {
        target.set('bottom', MIN_GAP + 'px');
        target.set('left', applied + 'px');
      }

      if (!opts || opts.persist !== false)
        persistDock();
    };

    const applyDockAll = (opts) => {
      applyDock(dockToVars(CSS_VARS.pip), previewSize(), opts);
      applyDock(dockToVars(CSS_VARS.preview), previewSize(), opts);
      applyDock(dockToEl(pipRestoreButton), sizeForTarget(pipRestoreButton), opts);
    };

    const repaintToDock = () => {
      if (!dock.edge || dock.offset == null)
        return;
      const origin = currentTransformOrigin();
      if (origin)
        setVar('--error-pip-origin', origin);
      else 
        unsetVar('--error-pip-origin');
      applyDockAll({ persist: false });
    };

    // =========================
    // Hidden state + UI
    // =========================
    const loadHidden = () => {
      const rawPretty = safeGet(POS_KEYS.hiddenPretty);
      if (rawPretty != null)
        isPrettyHidden = rawPretty === '1' || rawPretty === 'true';
      const rawPreview = safeGet(POS_KEYS.hiddenPreview);
      if (rawPreview != null)
        isPreviewHidden = rawPreview === '1' || rawPreview === 'true';
    };

    const setPrettyHidden = (v) => {
      isPrettyHidden = !!v;
      safeSet(POS_KEYS.hiddenPretty, isPrettyHidden ? '1' : '0');
      updateUI();
    };

    const setPreviewHidden = (v) => {
      isPreviewHidden = !!v;
      safeSet(POS_KEYS.hiddenPreview, isPreviewHidden ? '1' : '0');
      updateUI();
    };

    const isMinimized = () => iframe.hasAttribute('inert');

    const setMinimized = (v) => {
      if (v) {
        iframe.setAttribute('inert', '');
        toggle.setAttribute('aria-expanded', 'false');
      } else {
        iframe.removeAttribute('inert');
        toggle.setAttribute('aria-expanded', 'true');
      }
    };

    const setRestoreLabel = (kind) => {
      if (kind === 'pretty') {
        pipRestoreButton.innerHTML = '<span aria-hidden="true">⟲</span><span>Show error overlay</span>';
        pipRestoreButton.setAttribute('aria-label', 'Show error overlay');
      } else {
        pipRestoreButton.innerHTML = '<span aria-hidden="true">⟲</span><span>Show error page</span>';
        pipRestoreButton.setAttribute('aria-label', 'Show error page');
      }
    };

    const updateUI = () => {
      const minimized = isMinimized();
      const showPiP = minimized && !isPrettyHidden;
      const showPreview = !minimized && !isPreviewHidden;
      const pipHiddenByUser = minimized && isPrettyHidden;
      const previewHiddenByUser = !minimized && isPreviewHidden;
      const showToggle = minimized ? showPiP : showPreview;
      const showRestore = pipHiddenByUser || previewHiddenByUser;

      hide(iframe, pipHiddenByUser);
      hide(preview, !showPreview);
      hide(toggle, !showToggle);
      hide(pipCloseButton, !showToggle);
      hide(pipRestoreButton, !showRestore);

      pipCloseButton.setAttribute('aria-label', minimized ? 'Hide error overlay' : 'Hide error page preview');

      if (pipHiddenByUser)
        setRestoreLabel('pretty');
      else if (previewHiddenByUser)
        setRestoreLabel('preview');

      host.classList.toggle('pip-hidden', isPrettyHidden);
      host.classList.toggle('preview-hidden', isPreviewHidden);
    };

    // =========================
    // Preview snapshot
    // =========================
    const updatePreview = () => {
      try {
        let previewIframe = preview.querySelector('iframe');
        if (!previewIframe) {
          previewIframe = el('iframe');
          previewIframe.style.cssText = 'width: 1200px; height: 900px; transform: scale(0.2); transform-origin: top left; border: none;';
          previewIframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
          preview.appendChild(previewIframe);
        }

        const doctype = document.doctype ? '<!DOCTYPE ' + document.doctype.name + '>' : '';
        const cleanedHTML = document.documentElement.outerHTML
          .replace(/<nuxt-error-overlay[^>]*>.*?<\\/nuxt-error-overlay>/gs, '')
          .replace(/<script[^>]*>.*?<\\/script>/gs, '');

        const iframeDoc = previewIframe.contentDocument || previewIframe.contentWindow.document;
        iframeDoc.open();
        iframeDoc.write(doctype + cleanedHTML);
        iframeDoc.close();
      } catch (err) {
        console.error('Failed to update preview:', err);
      }
    };

    // =========================
    // View toggling
    // =========================
    const toggleView = () => {
      if (isMinimized()) {
        updatePreview();
        setMinimized(false);
        liveRegion.textContent = 'Showing detailed error view';
        setTimeout(() => { 
          try { 
            iframe.contentWindow.focus();
          } catch {}
        }, 100);
      } else {
        setMinimized(true);
        liveRegion.textContent = 'Showing error page';
        repaintToDock();
        void iframe.offsetWidth;
      }
      updateUI();
    };

    // =========================
    // Dragging (unified, rAF throttled)
    // =========================
    let drag = null;
    let rafId = null;
    let suppressToggleClick = false;
    let suppressRestoreClick = false;

    const beginDrag = (e) => {
      if (drag) 
        return;

      if (!dock.edge || dock.offset == null) {
        const def = cornerDefaultDock();
        dock.edge = def.edge;
        dock.offset = def.offset;
        updateDockAlignment(previewSize());
      }

      const isRestoreTarget = e.currentTarget === pipRestoreButton;

      drag = {
        kind: isRestoreTarget ? 'restore' : (isMinimized() ? 'pip' : 'preview'),
        pointerId: e.pointerId,
        startX: e.clientX,
        startY: e.clientY,
        lastX: e.clientX,
        lastY: e.clientY,
        moved: false,
        target: e.currentTarget
      };

      drag.target.setPointerCapture(e.pointerId);

      if (drag.kind === 'restore')
        host.classList.add('dragging-restore');
      else 
        host.classList.add(drag.kind === 'pip' ? 'dragging' : 'dragging-preview');

      e.preventDefault();
    };

    const moveDrag = (e) => {
      if (!drag || drag.pointerId !== e.pointerId)
        return;

      drag.lastX = e.clientX;
      drag.lastY = e.clientY;
      
      const dx = drag.lastX - drag.startX;
      const dy = drag.lastY - drag.startY;

      if (!drag.moved && (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD)) {
        drag.moved = true;
      }

      if (!drag.moved)
        return;
      if (rafId)
        return;

      rafId = requestAnimationFrame(() => {
        rafId = null;

        const edge = nearestEdgeAt(drag.lastX, drag.lastY);
        const size = sizeForTarget(drag.target);

        let offset;
        if (edge === 'left' || edge === 'right') {
          const top = drag.lastY - (size.h / 2);
          offset = clampOffset(edge, Math.round(top), size);
        } else {
          const left = drag.lastX - (size.w / 2);
          offset = clampOffset(edge, Math.round(left), size);
        }

        dock.edge = edge;
        dock.offset = offset;
        updateDockAlignment(size);

        const origin = currentTransformOrigin();
        setVar('--error-pip-origin', origin || 'bottom right');

        applyDockAll({ persist: false });
      });
    };

    const endDrag = (e) => {
      if (!drag || drag.pointerId !== e.pointerId)
        return;

      const endedKind = drag.kind;
      drag.target.releasePointerCapture(e.pointerId);

      if (endedKind === 'restore')
        host.classList.remove('dragging-restore');
      else 
        host.classList.remove(endedKind === 'pip' ? 'dragging' : 'dragging-preview');

      const didMove = drag.moved;
      drag = null;

      if (didMove) {
        persistDock();
        if (endedKind === 'restore')
          suppressRestoreClick = true;
        else 
          suppressToggleClick = true;
        e.preventDefault();
        e.stopPropagation();
      }
    };

    const bindDragTarget = (node) => {
      on(node, 'pointerdown', beginDrag);
      on(node, 'pointermove', moveDrag);
      on(node, 'pointerup', endDrag);
      on(node, 'pointercancel', endDrag);
    };

    bindDragTarget(toggle);
    bindDragTarget(pipRestoreButton);

    // =========================
    // Events (toggle / close / restore)
    // =========================
    on(toggle, 'click', (e) => {
      if (suppressToggleClick) {
        e.preventDefault();
        suppressToggleClick = false;
        return;
      }
      toggleView();
    });

    on(toggle, 'keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleView();
      }
    });

    on(pipCloseButton, 'click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (isMinimized())
        setPrettyHidden(true);
      else
        setPreviewHidden(true);
    });

    on(pipCloseButton, 'pointerdown', (e) => {
      e.stopPropagation();
    });

    on(pipRestoreButton, 'click', (e) => {
      if (suppressRestoreClick) {
        e.preventDefault();
        suppressRestoreClick = false;
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      if (isMinimized()) 
        setPrettyHidden(false);
      else 
        setPreviewHidden(false);
    });

    // =========================
    // Lifecycle: load / sync / repaint
    // =========================
    const loadState = () => {
      loadDock();
      loadHidden();

      if (isPrettyHidden && !isMinimized())
        setMinimized(true);

      updateUI();
      repaintToDock();
    };

    loadState();

    on(window, 'storage-ready', () => {
      storageReady = true;
      loadState();
    });

    const onViewportChange = () => repaintToDock();

    on(window, 'resize', onViewportChange);

    if (window.visualViewport) {
      on(window.visualViewport, 'resize', onViewportChange);
      on(window.visualViewport, 'scroll', onViewportChange);
    }

    // initial preview
    setTimeout(updatePreview, 100);

    // initial minimized option
    if (${startMinimized}) {
      setMinimized(true);
      repaintToDock();
      void iframe.offsetWidth;
      updateUI();
    }
  } catch (err) {
    console.error('Failed to initialize Nuxt error overlay:', err);
  }
})();
`
}

export function generateErrorOverlayHTML (html: string, options?: { startMinimized?: boolean }) {
  const nonce = Array.from(crypto.getRandomValues(new Uint8Array(16)), b => b.toString(16).padStart(2, '0')).join('')
  const errorPage = html.replace('<head>', `<head><script>${iframeStorageBridge(nonce)}</script>`)
  const base64HTML = Buffer.from(errorPage, 'utf8').toString('base64')
  return `
    <script>${parentStorageBridge(nonce)}</script>
    <nuxt-error-overlay></nuxt-error-overlay>
    <script>${webComponentScript(base64HTML, options?.startMinimized ?? false)}</script>
  `
}
</file>

<file path="packages/nitro-server/src/runtime/utils/error.ts">
import { getRequestHeader } from 'h3'
import type { H3Event } from 'h3'

/**
 * Nitro internal functions extracted from https://github.com/nitrojs/nitro/blob/v2/src/runtime/internal/utils.ts
 */

export function isJsonRequest (event: H3Event): boolean {
  // If the client specifically requests HTML, then avoid classifying as JSON.
  if (hasReqHeader(event, 'accept', 'text/html')) {
    return false
  }
  return (
    hasReqHeader(event, 'accept', 'application/json') ||
    hasReqHeader(event, 'user-agent', 'curl/') ||
    hasReqHeader(event, 'user-agent', 'httpie/') ||
    hasReqHeader(event, 'sec-fetch-mode', 'cors') ||
    event.path.startsWith('/api/') ||
    event.path.endsWith('.json')
  )
}

export function hasReqHeader (event: H3Event, name: string, includes: string) {
  const value = getRequestHeader(event, name)
  return (
    value && typeof value === 'string' && value.toLowerCase().includes(includes)
  )
}
</file>

<file path="packages/nitro-server/src/runtime/utils/paths.ts">
import { joinRelativeURL } from 'ufo'
import { useRuntimeConfig } from 'nitropack/runtime'

export function baseURL (): string {
  // TODO: support passing event to `useRuntimeConfig`
  return useRuntimeConfig().app.baseURL
}

export function buildAssetsDir (): string {
  // TODO: support passing event to `useRuntimeConfig`
  return useRuntimeConfig().app.buildAssetsDir as string
}

export function buildAssetsURL (...path: string[]): string {
  return joinRelativeURL(publicAssetsURL(), buildAssetsDir(), ...path)
}

export function publicAssetsURL (...path: string[]): string {
  // TODO: support passing event to `useRuntimeConfig`
  const app = useRuntimeConfig().app
  const publicBase = app.cdnURL as string || app.baseURL
  return path.length ? joinRelativeURL(publicBase, ...path) : publicBase
}
</file>

<file path="packages/nitro-server/src/augments.ts">
import type {} from 'nitropack/types'

import type { H3Event } from 'h3'
import type { LogObject } from 'consola'
import type { NuxtIslandContext, NuxtIslandResponse, NuxtRenderHTMLContext } from 'nuxt/app'
import type { RuntimeConfig } from 'nuxt/schema'

declare module 'nitropack' {
  interface NitroRuntimeConfigApp {
    buildAssetsDir: string
    cdnURL: string
  }
  interface NitroRouteRules {
    ssr?: boolean
    noScripts?: boolean
    /** @deprecated Use `noScripts` instead */
    experimentalNoScripts?: boolean
    appMiddleware?: Record<string, boolean>
    appLayout?: string | false
  }
}

declare module 'nitropack/types' {
  interface NitroRuntimeConfigApp {
    buildAssetsDir: string
    cdnURL: string
  }
  interface NitroRouteRules {
    ssr?: boolean
    noScripts?: boolean
    /** @deprecated Use `noScripts` instead */
    experimentalNoScripts?: boolean
    appMiddleware?: Record<string, boolean>
    appLayout?: string | false
  }
}

// Note: Keep in sync with packages/nuxt/src/core/templates.ts
declare module 'nitropack' {
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  interface NitroRuntimeConfig extends RuntimeConfig {}
  interface NitroRouteConfig {
    ssr?: boolean
    noScripts?: boolean
    /** @deprecated Use `noScripts` instead */
    experimentalNoScripts?: boolean
  }
  interface NitroRuntimeHooks {
    'dev:ssr-logs': (ctx: { logs: LogObject[], path: string }) => void | Promise<void>
    'render:html': (htmlContext: NuxtRenderHTMLContext, context: { event: H3Event }) => void | Promise<void>
    'render:island': (islandResponse: NuxtIslandResponse, context: { event: H3Event, islandContext: NuxtIslandContext }) => void | Promise<void>
  }
}
declare module 'nitropack/types' {
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  interface NitroRuntimeConfig extends RuntimeConfig {}
  interface NitroRouteConfig {
    ssr?: boolean
    noScripts?: boolean
    /** @deprecated Use `noScripts` instead */
    experimentalNoScripts?: boolean
  }
  interface NitroRuntimeHooks {
    'dev:ssr-logs': (ctx: { logs: LogObject[], path: string }) => void | Promise<void>
    'render:html': (htmlContext: NuxtRenderHTMLContext, context: { event: H3Event }) => void | Promise<void>
    'render:island': (islandResponse: NuxtIslandResponse, context: { event: H3Event, islandContext: NuxtIslandContext }) => void | Promise<void>
  }
}

export {}
</file>

<file path="packages/nitro-server/src/index.ts">
import { pathToFileURL } from 'node:url'
import { existsSync, promises as fsp, readFileSync } from 'node:fs'
import { cpus } from 'node:os'
import process from 'node:process'
import { mkdir, readFile, writeFile } from 'node:fs/promises'
import { randomUUID } from 'node:crypto'
import type { Nuxt, NuxtOptions } from '@nuxt/schema'
import { addRoute, createRouter as createRou3Router, findAllRoutes } from 'rou3'
import { compileRouterToString } from 'rou3/compiler'
import { join, relative, resolve } from 'pathe'
import { readPackageJSON } from 'pkg-types'
import { joinURL, withTrailingSlash } from 'ufo'
import { hash } from 'ohash'
import { build, copyPublicAssets, createDevServer, createNitro, prepare, prerender, scanHandlers, writeTypes } from 'nitropack'
import type { Nitro, NitroConfig, NitroRouteRules } from 'nitropack/types'
import { addPlugin, addTemplate, addVitePlugin, createIsIgnored, findPath, getDirectory, getLayerDirectories, logger, resolveAlias, resolveIgnorePatterns, resolveNuxtModule } from '@nuxt/kit'
import escapeRE from 'escape-string-regexp'
import { defu } from 'defu'
import { defineEventHandler, dynamicEventHandler } from 'h3'
import { isWindows } from 'std-env'
import { ImpoundPlugin } from 'impound'
import { resolveModulePath } from 'exsolve'
import './augments.ts'

import nitroBuilder from '../package.json' with { type: 'json' }
import { distDir, toArray } from './utils.ts'
import { template as defaultSpaLoadingTemplate } from '../../ui-templates/dist/templates/spa-loading-icon.ts'
// TODO: figure out a good way to share this
import { createImportProtectionPatterns } from '../../nuxt/src/core/plugins/import-protection.ts'
import { nitroSchemaTemplate } from './templates.ts'

const logLevelMapReverse = {
  silent: 0,
  info: 3,
  verbose: 3,
} satisfies Record<NuxtOptions['logLevel'], NitroConfig['logLevel']>

const NODE_MODULES_RE = /(?<=\/)node_modules\/(.+)$/
const PNPM_NODE_MODULES_RE = /\.pnpm\/.+\/node_modules\/(.+)$/
export async function bundle (nuxt: Nuxt & { _nitro?: Nitro }): Promise<void> {
  // Resolve config
  const layerDirs = getLayerDirectories(nuxt)
  const excludePaths: string[] = []
  for (const dirs of layerDirs) {
    const paths = [
      dirs.root.match(NODE_MODULES_RE)?.[1]?.replace(/\/$/, ''),
      dirs.root.match(PNPM_NODE_MODULES_RE)?.[1]?.replace(/\/$/, ''),
    ]
    for (const dir of paths) {
      if (dir) {
        excludePaths.push(escapeRE(dir))
      }
    }
  }

  const layerPublicAssetsDirs: Array<{ dir: string }> = []
  for (const dirs of layerDirs) {
    if (existsSync(dirs.public)) {
      layerPublicAssetsDirs.push({ dir: dirs.public })
    }
  }

  const excludePattern = excludePaths.length
    ? [new RegExp(`node_modules\\/(?!${excludePaths.join('|')})`)]
    : [/node_modules/]

  const rootDirWithSlash = withTrailingSlash(nuxt.options.rootDir)

  const moduleEntryPaths: string[] = []
  for (const m of nuxt.options._installedModules) {
    const path = m.meta?.rawPath || m.entryPath
    if (path) {
      moduleEntryPaths.push(getDirectory(path))
    }
  }

  const modules = await resolveNuxtModule(rootDirWithSlash, moduleEntryPaths)

  addTemplate(nitroSchemaTemplate)

  const sharedDirs = new Set<string>()
  if (nuxt.options.nitro.imports !== false && nuxt.options.imports.scan !== false) {
    for (const layer of nuxt.options._layers) {
      // Layer disabled scanning for itself
      if (layer.config?.imports?.scan === false) {
        continue
      }

      sharedDirs.add(resolve(layer.config.rootDir, layer.config.dir?.shared ?? 'shared', 'utils'))
      sharedDirs.add(resolve(layer.config.rootDir, layer.config.dir?.shared ?? 'shared', 'types'))
    }
  }

  // Resolve aliases in user-provided input - so `~/server/test` will work
  nuxt.options.nitro.plugins ||= []
  nuxt.options.nitro.plugins = nuxt.options.nitro.plugins.map(plugin => plugin ? resolveAlias(plugin, nuxt.options.alias) : plugin)

  if (nuxt.options.dev && nuxt.options.features.devLogs) {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/dev-server-logs'))
    nuxt.options.nitro.plugins.push(resolve(distDir, 'runtime/plugins/dev-server-logs'))
    nuxt.options.nitro.externals = defu(nuxt.options.nitro.externals, {
      inline: [/#internal\/dev-server-logs-options/],
    })
    nuxt.options.nitro.virtual = defu(nuxt.options.nitro.virtual, {
      '#internal/dev-server-logs-options': () => `export const rootDir = ${JSON.stringify(nuxt.options.rootDir)};`,
    })
  }

  if (nuxt.options.experimental.componentIslands) {
    // sync conditions with /packages/nuxt/src/core/templates.ts#L539
    nuxt.options.nitro.virtual ||= {}
    nuxt.options.nitro.virtual['#internal/nuxt/island-renderer.mjs'] = () => {
      if (nuxt.options.dev || nuxt.options.experimental.componentIslands !== 'auto' || nuxt.apps.default?.pages?.some(p => p.mode === 'server') || nuxt.apps.default?.components?.some(c => c.mode === 'server' && !nuxt.apps.default?.components.some(other => other.pascalName === c.pascalName && other.mode === 'client'))) {
        return `export { default } from '${resolve(distDir, 'runtime/handlers/island')}'`
      }
      return `import { defineEventHandler } from 'h3'; export default defineEventHandler(() => {});`
    }
    nuxt.options.nitro.handlers ||= []
    nuxt.options.nitro.handlers.push({
      route: '/__nuxt_island/**',
      handler: '#internal/nuxt/island-renderer.mjs',
    })

    if (!nuxt.options.ssr && nuxt.options.experimental.componentIslands !== 'auto') {
      nuxt.options.ssr = true
      nuxt.options.nitro.routeRules ||= {}
      nuxt.options.nitro.routeRules['/**'] = defu(nuxt.options.nitro.routeRules['/**'], { ssr: false })
    }
  }

  const mockProxy = resolveModulePath('mocked-exports/proxy', { from: import.meta.url })
  const { version: nuxtVersion } = await readPackageJSON('nuxt', { from: import.meta.url })

  const nitroConfig: NitroConfig = defu(nuxt.options.nitro, {
    debug: nuxt.options.debug ? nuxt.options.debug.nitro : false,
    rootDir: nuxt.options.rootDir,
    workspaceDir: nuxt.options.workspaceDir,
    srcDir: nuxt.options.serverDir,
    dev: nuxt.options.dev,
    buildDir: nuxt.options.buildDir,
    experimental: {
      asyncContext: nuxt.options.experimental.asyncContext,
      typescriptBundlerResolution: nuxt.options.future.typescriptBundlerResolution || nuxt.options.typescript?.tsConfig?.compilerOptions?.moduleResolution?.toLowerCase() === 'bundler' || nuxt.options.nitro.typescript?.tsConfig?.compilerOptions?.moduleResolution?.toLowerCase() === 'bundler',
    },
    framework: {
      name: 'nuxt',
      version: nuxtVersion || nitroBuilder.version,
    },
    imports: {
      autoImport: nuxt.options.imports.autoImport as boolean,
      dirs: [...sharedDirs],
      imports: [
        {
          as: '__buildAssetsURL',
          name: 'buildAssetsURL',
          from: resolve(distDir, 'runtime/utils/paths'),
        },
        {
          as: '__publicAssetsURL',
          name: 'publicAssetsURL',
          from: resolve(distDir, 'runtime/utils/paths'),
        },
        {
          // TODO: Remove after https://github.com/nitrojs/nitro/issues/1049
          as: 'defineAppConfig',
          name: 'defineAppConfig',
          from: resolve(distDir, 'runtime/utils/config'),
          priority: -1,
        },
      ],
      exclude: [...excludePattern, /[\\/]\.git[\\/]/],
    },
    esbuild: {
      options: { exclude: excludePattern },
    },
    analyze: !nuxt.options.test && nuxt.options.build.analyze && (nuxt.options.build.analyze === true || nuxt.options.build.analyze.enabled)
      ? {
          template: 'treemap',
          projectRoot: nuxt.options.rootDir,
          filename: join(nuxt.options.analyzeDir, '{name}.html'),
        }
      : false,
    scanDirs: layerDirs.map(dirs => dirs.server),
    renderer: resolve(distDir, 'runtime/handlers/renderer'),
    nodeModulesDirs: nuxt.options.modulesDir,
    handlers: nuxt.options.serverHandlers,
    devHandlers: [],
    baseURL: nuxt.options.app.baseURL,
    virtual: {
      '#internal/nuxt.config.mjs': () => nuxt.vfs['#build/nuxt.config.mjs'] || '',
      '#internal/nuxt/app-config': () => nuxt.vfs['#build/app.config.mjs']?.replace(/\/\*\* client \*\*\/[\s\S]*\/\*\* client-end \*\*\//, '') || '',
      '#spa-template': async () => `export const template = ${JSON.stringify(await spaLoadingTemplate(nuxt))}`,
      // this will be overridden in vite plugin
      '#internal/entry-chunk.mjs': () => `export const entryFileName = undefined`,
      '#internal/nuxt/entry-ids.mjs': () => `export default []`,
      '#internal/nuxt/nitro-config.mjs': () => {
        const hasCachedRoutes = Object.values(nitro.options.routeRules).some(r => r.isr || r.cache)
        return [
          `export const NUXT_NO_SSR = ${nuxt.options.ssr === false}`,
          `export const NUXT_EARLY_HINTS = ${nuxt.options.experimental.writeEarlyHints !== false}`,
          `export const NUXT_NO_SCRIPTS = ${nuxt.options.features.noScripts === 'all' || (!!nuxt.options.features.noScripts && !nuxt.options.dev)}`,
          `export const NUXT_INLINE_STYLES = ${!!nuxt.options.features.inlineStyles}`,
          `export const PARSE_ERROR_DATA = ${!!nuxt.options.experimental.parseErrorData}`,
          `export const NUXT_JSON_PAYLOADS = ${!!nuxt.options.experimental.renderJsonPayloads}`,
          `export const NUXT_ASYNC_CONTEXT = ${!!nuxt.options.experimental.asyncContext}`,
          `export const NUXT_SHARED_DATA = ${!!nuxt.options.experimental.sharedPrerenderData}`,
          `export const NUXT_PAYLOAD_EXTRACTION = ${!!nuxt.options.experimental.payloadExtraction}`,
          `export const NUXT_RUNTIME_PAYLOAD_EXTRACTION = ${hasCachedRoutes}`,
        ].join('\n')
      },
    },
    routeRules: {
      '/__nuxt_error': { cache: false },
    },
    appConfig: nuxt.options.appConfig,
    appConfigFiles: layerDirs.map(dirs => join(dirs.app, 'app.config')),
    typescript: {
      strict: true,
      generateTsConfig: true,
      tsconfigPath: 'tsconfig.server.json',
      tsConfig: {
        compilerOptions: {
          lib: ['esnext', 'webworker', 'dom.iterable'],
          skipLibCheck: true,
          noUncheckedIndexedAccess: true,
        },
        include: [
          join(nuxt.options.buildDir, 'types/nitro-nuxt.d.ts'),
          ...modules.flatMap((m) => {
            const moduleDir = relativeWithDot(nuxt.options.buildDir, m)
            return [
              join(moduleDir, 'runtime/server'),
              join(moduleDir, 'dist/runtime/server'),
            ]
          }),
          ...layerDirs.map(dirs => relativeWithDot(nuxt.options.buildDir, join(dirs.server, '**/*'))),
          ...layerDirs.map(dirs => relativeWithDot(nuxt.options.buildDir, join(dirs.shared, '**/*.d.ts'))),
        ],
        exclude: [
          ...nuxt.options.modulesDir.map(m => relativeWithDot(nuxt.options.buildDir, m)),
          relativeWithDot(nuxt.options.buildDir, resolve(nuxt.options.rootDir, 'dist')),
        ],
      },
    },
    publicAssets: [
      nuxt.options.dev
        ? { dir: resolve(nuxt.options.buildDir, 'dist/client') }
        : {
            dir: join(nuxt.options.buildDir, 'dist/client', nuxt.options.app.buildAssetsDir),
            maxAge: 31536000 /* 1 year */,
            baseURL: nuxt.options.app.buildAssetsDir,
          },
      ...layerPublicAssetsDirs,
    ],
    prerender: {
      ignoreUnprefixedPublicAssets: true,
      failOnError: true,
      concurrency: cpus().length * 4 || 4,
      routes: ([] as string[])
        // @ts-expect-error TODO: remove in nuxt v5
        .concat(nuxt.options.generate.routes),
    },
    sourceMap: nuxt.options.sourcemap.server,
    externals: {
      inline: [
        ...(nuxt.options.dev
          ? []
          : [
              ...nuxt.options.experimental.externalVue ? [] : ['vue', '@vue/'],
              '@nuxt/',
              nuxt.options.buildDir,
            ]),
        ...nuxt.options.build.transpile.filter((i): i is string => typeof i === 'string'),
        'nuxt/dist',
        'nuxt3/dist',
        'nuxt-nightly/dist',
        distDir,
        // Ensure app config files have auto-imports injected even if they are pure .js files
        ...layerDirs.map(dirs => join(dirs.app, 'app.config')),
      ],
      traceInclude: [
        // force include files used in generated code from the runtime-compiler
        ...(nuxt.options.vue.runtimeCompiler && !nuxt.options.experimental.externalVue)
          ? [
              ...nuxt.options.modulesDir.reduce<string[]>((targets, path) => {
                const serverRendererPath = resolve(path, 'vue/server-renderer/index.js')
                if (existsSync(serverRendererPath)) { targets.push(serverRendererPath) }
                return targets
              }, []),
            ]
          : [],
      ],
    },
    alias: {
      // Vue 3 mocks
      ...nuxt.options.vue.runtimeCompiler || nuxt.options.experimental.externalVue
        ? {}
        : {
            'estree-walker': mockProxy,
            '@babel/parser': mockProxy,
            '@vue/compiler-core': mockProxy,
            '@vue/compiler-dom': mockProxy,
            '@vue/compiler-ssr': mockProxy,
          },
      '@vue/devtools-api': 'vue-devtools-stub',

      // Nuxt aliases
      ...nuxt.options.alias,

      // Paths
      '#internal/nuxt/paths': resolve(distDir, 'runtime/utils/paths'),
    },
    replace: {
      '__VUE_PROD_DEVTOOLS__': String(false),
    },
    rollupConfig: {
      output: {
        generatedCode: {
          symbols: true, // temporary fix for https://github.com/vuejs/core/issues/8351
        },
      },
      plugins: [],
    },
    logLevel: logLevelMapReverse[nuxt.options.logLevel],
  } satisfies NitroConfig)

  // eslint-disable-next-line @typescript-eslint/no-deprecated
  if (nuxt.options.experimental.serverAppConfig && nitroConfig.imports) {
    nitroConfig.imports.imports ||= []
    nitroConfig.imports.imports.push({
      name: 'useAppConfig',
      from: resolve(distDir, 'runtime/utils/app-config'),
      priority: -1,
    })
  }

  // add error handler
  if (!nitroConfig.errorHandler && (nuxt.options.dev || !nuxt.options.experimental.noVueServer)) {
    nitroConfig.errorHandler = resolve(distDir, 'runtime/handlers/error')
  }

  // Resolve user-provided paths
  nitroConfig.srcDir = resolve(nuxt.options.rootDir, nuxt.options.srcDir, nitroConfig.srcDir!)
  nitroConfig.ignore ||= []
  nitroConfig.ignore.push(
    ...resolveIgnorePatterns(nitroConfig.srcDir),
    `!${join(nuxt.options.buildDir, 'dist/client', nuxt.options.app.buildAssetsDir, '**/*')}`,
  )

  const validManifestKeys = ['prerender', 'redirect', 'appMiddleware', 'appLayout']

  function getRouteRulesRouter () {
    const routeRulesRouter = createRou3Router<NitroRouteRules>()
    if (nuxt._nitro) {
      for (const [route, rules] of Object.entries(nuxt._nitro.options.routeRules)) {
        if (route === '/__nuxt_error') { continue }
        if (validManifestKeys.every(key => !(key in rules))) { continue }
        addRoute(routeRulesRouter, undefined, route, rules)
      }
    }
    return routeRulesRouter
  }

  const cachedMatchers: Record<string, string> = {}
  addTemplate({
    filename: 'route-rules.mjs',
    getContents () {
      const key = hash(nuxt._nitro?.options.routeRules || {})
      if (cachedMatchers[key]) {
        return cachedMatchers[key]
      }
      const matcher = compileRouterToString(getRouteRulesRouter(), '', {
        matchAll: true,
        serialize (routeRules) {
          return `{${Object.entries(routeRules)
            .filter(([name, value]) => value !== undefined && validManifestKeys.includes(name))
            .map(([name, value]) => {
              if (name === 'redirect') {
                const redirectOptions = value as NitroRouteRules['redirect']
                value = typeof redirectOptions === 'string' ? redirectOptions : redirectOptions!.to
              }
              if (name === 'appMiddleware') {
                const appMiddlewareOptions = value as NitroRouteRules['appMiddleware']
                if (typeof appMiddlewareOptions === 'string') {
                  value = { [appMiddlewareOptions]: true }
                } else if (Array.isArray(appMiddlewareOptions)) {
                  const normalizedRules: Record<string, boolean> = {}
                  for (const middleware of appMiddlewareOptions) {
                    normalizedRules[middleware] = true
                  }
                  value = normalizedRules
                }
              }
              if (name === 'cache' || name === 'isr') {
                name = 'payload'
                value = Boolean(value)
              }
              return `${name}: ${JSON.stringify(value)}`
            }).join(',')
          }}`
        },
      })
      return cachedMatchers[key] = `
      import { defu } from 'defu'
      const matcher = ${matcher}
      export default (path) => defu({}, ...matcher('', path).map(r => r.data).reverse())
      `
    },
  })

  if (nuxt.options.experimental.payloadExtraction) {
    if (nuxt.options.dev) {
      nuxt.hook('nitro:config', (nitroConfig) => {
        nitroConfig.prerender ||= {}
        nitroConfig.prerender.routes ||= []
        nitroConfig.routeRules ||= {}
        for (const route of nitroConfig.prerender.routes) {
          if (!route) { continue }
          nitroConfig.routeRules[route] = defu(nitroConfig.routeRules[route], { prerender: true })
        }
      })
    }
    nuxt.hook('nitro:init', (nitro) => {
      nitro.hooks.hook('build:before', (nitro) => {
        for (const [route, value] of Object.entries(nitro.options.routeRules)) {
          if (!route.endsWith('*') && !route.endsWith('/_payload.json')) {
            if ((value.isr || value.cache) || (value.prerender && nuxt.options.dev)) {
              const payloadKey = route + '/_payload.json'
              const defaults = {} as Record<string, any>
              for (const key of ['isr', 'cache', ...nuxt.options.dev ? ['prerender'] : []]) {
                if (key in value) {
                  defaults[key] = value[key as keyof typeof value]
                }
              }
              nitro.options.routeRules[payloadKey] = defu(nitro.options.routeRules[payloadKey], defaults)
            }
          }
        }
      })
    })
  }

  // Add app manifest handler and prerender configuration
  if (nuxt.options.experimental.appManifest) {
    const buildId = nuxt.options.runtimeConfig.app.buildId ||= nuxt.options.buildId
    const buildTimestamp = Date.now()

    const manifestPrefix = joinURL(nuxt.options.app.buildAssetsDir, 'builds')
    const tempDir = join(nuxt.options.buildDir, 'manifest')

    nitroConfig.prerender ||= {}
    nitroConfig.prerender.ignore ||= []
    nitroConfig.prerender.ignore.push(joinURL(nuxt.options.app.baseURL, manifestPrefix))

    nitroConfig.publicAssets!.unshift(
      // build manifest
      {
        dir: join(tempDir, 'meta'),
        maxAge: 31536000 /* 1 year */,
        baseURL: joinURL(manifestPrefix, 'meta'),
      },
      // latest build
      {
        dir: tempDir,
        maxAge: 1,
        baseURL: manifestPrefix,
      },
    )

    nuxt.options.alias['#app-manifest'] = join(tempDir, `meta/${buildId}.json`)

    // write stub manifest before build so external import of #app-manifest can be resolved
    if (!nuxt.options.dev) {
      nuxt.hook('build:before', async () => {
        await fsp.mkdir(join(tempDir, 'meta'), { recursive: true })
        await fsp.writeFile(join(tempDir, `meta/${buildId}.json`), JSON.stringify({}))
      })
    }

    nuxt.hook('nitro:config', (config) => {
      config.alias ||= {}
      config.alias['#app-manifest'] = join(tempDir, `meta/${buildId}.json`)
    })

    nuxt.hook('nitro:init', (nitro) => {
      nitro.hooks.hook('rollup:before', async (nitro) => {
        // Add pages prerendered but not covered by route rules
        const prerenderedRoutes = new Set<string>()
        const routeRulesMatcher = getRouteRulesRouter()
        if (nitro._prerenderedRoutes?.length) {
          const payloadSuffix = nuxt.options.experimental.renderJsonPayloads ? '/_payload.json' : '/_payload.js'
          for (const route of nitro._prerenderedRoutes) {
            if (!route.error && route.route.endsWith(payloadSuffix)) {
              const url = route.route.slice(0, -payloadSuffix.length) || '/'
              const rules = defu({}, ...findAllRoutes(routeRulesMatcher, undefined, url).reverse()) as Record<string, any>
              if (!rules.prerender) {
                prerenderedRoutes.add(url)
              }
            }
          }
        }

        const manifest = {
          id: buildId,
          timestamp: buildTimestamp,
          prerendered: nuxt.options.dev ? [] : [...prerenderedRoutes],
        }

        await fsp.mkdir(join(tempDir, 'meta'), { recursive: true })
        await fsp.writeFile(join(tempDir, 'latest.json'), JSON.stringify({
          id: buildId,
          timestamp: buildTimestamp,
        }))
        await fsp.writeFile(join(tempDir, `meta/${buildId}.json`), JSON.stringify(manifest))
      })
    })
  }

  // add stub alias to allow vite to resolve import
  if (!nuxt.options.experimental.appManifest) {
    nuxt.options.alias['#app-manifest'] = mockProxy
  }

  // Add fallback server for `ssr: false`
  const FORWARD_SLASH_RE = /\//g
  if (!nuxt.options.ssr) {
    nitroConfig.virtual!['#build/dist/server/server.mjs'] = 'export default () => {}'
    // In case a non-normalized absolute path is called for on Windows
    if (process.platform === 'win32') {
      nitroConfig.virtual!['#build/dist/server/server.mjs'.replace(FORWARD_SLASH_RE, '\\')] = 'export default () => {}'
    }
  }

  if (nuxt.options.dev) {
    nitroConfig.virtual!['#build/dist/server/styles.mjs'] = 'export default {}'
    // In case a non-normalized absolute path is called for on Windows
    if (process.platform === 'win32') {
      nitroConfig.virtual!['#build/dist/server/styles.mjs'.replace(FORWARD_SLASH_RE, '\\')] = 'export default {}'
    }
  }

  // Register nuxt protection patterns
  nitroConfig.rollupConfig!.plugins = await nitroConfig.rollupConfig!.plugins || []
  nitroConfig.rollupConfig!.plugins = toArray(nitroConfig.rollupConfig!.plugins)

  const sharedDir = withTrailingSlash(resolve(nuxt.options.rootDir, nuxt.options.dir.shared))
  const relativeSharedDir = withTrailingSlash(relative(nuxt.options.rootDir, resolve(nuxt.options.rootDir, nuxt.options.dir.shared)))
  const sharedPatterns = [/^#shared\//, new RegExp('^' + escapeRE(sharedDir)), new RegExp('^' + escapeRE(relativeSharedDir))]
  nitroConfig.rollupConfig!.plugins!.push(
    ImpoundPlugin.rollup({
      cwd: nuxt.options.rootDir,
      include: sharedPatterns,
      patterns: createImportProtectionPatterns(nuxt, { context: 'shared' }),
    }),
    ImpoundPlugin.rollup({
      cwd: nuxt.options.rootDir,
      patterns: createImportProtectionPatterns(nuxt, { context: 'nitro-app' }),
      exclude: [/node_modules[\\/]nitro(?:pack)?(?:-nightly)?[\\/]|(packages|@nuxt)[\\/]nitro-server(?:-nightly)?[\\/](src|dist)[\\/]runtime[\\/]/, ...sharedPatterns],
    }),
  )

  // Apply Nuxt's ignore configuration to the root and src unstorage mounts
  // created by Nitro. This ensures that the unstorage watcher will use the
  // same ignore list as Nuxt's watcher and can reduce unnecessary file handles.
  const isIgnored = createIsIgnored(nuxt)
  nitroConfig.devStorage ??= {}
  nitroConfig.devStorage.root ??= {
    driver: 'fs',
    readOnly: true,
    base: nitroConfig.rootDir,
    watchOptions: {
      ignored: [isIgnored],
    },
  }
  nitroConfig.devStorage.src ??= {
    driver: 'fs',
    readOnly: true,
    base: nitroConfig.srcDir,
    watchOptions: {
      ignored: [isIgnored],
    },
  }

  // Extend nitro config with hook
  await nuxt.callHook('nitro:config', nitroConfig)

  if (nitroConfig.static && nuxt.options.dev) {
    nitroConfig.routeRules ||= {}
    nitroConfig.routeRules['/**'] = defu(nitroConfig.routeRules['/**'], { prerender: true })
  }

  // TODO: extract to shared utility?
  const excludedAlias = [/^@vue\/.*$/, 'vue', /vue-router/, 'vite/client', '#imports', 'vue-demi', /^#app/, '~', '@', '~~', '@@']
  const basePath = nitroConfig.typescript!.tsConfig!.compilerOptions?.baseUrl ? resolve(nuxt.options.buildDir, nitroConfig.typescript!.tsConfig!.compilerOptions?.baseUrl) : nuxt.options.buildDir
  const aliases = nitroConfig.alias!
  const tsConfig = nitroConfig.typescript!.tsConfig!
  tsConfig.compilerOptions ||= {}
  tsConfig.compilerOptions.paths ||= {}
  for (const _alias in aliases) {
    const alias = _alias as keyof typeof aliases
    if (excludedAlias.some(pattern => typeof pattern === 'string' ? alias === pattern : pattern.test(alias))) {
      continue
    }
    if (alias in tsConfig.compilerOptions.paths) {
      continue
    }

    const absolutePath = resolve(basePath, aliases[alias]!)
    const isDirectory = aliases[alias]!.endsWith('/') || await fsp.stat(absolutePath).then(r => r.isDirectory()).catch(() => null /* file does not exist */)
    // note - nitro will check + remove the file extension as required
    tsConfig.compilerOptions.paths[alias] = [absolutePath]
    if (isDirectory) {
      tsConfig.compilerOptions.paths[`${alias}/*`] = [`${absolutePath}/*`]
    }
  }

  // Init nitro
  const nitro = await createNitro(nitroConfig, {
    compatibilityDate: nuxt.options.compatibilityDate,
    dotenv: nuxt.options._loadOptions?.dotenv,
  })

  // Trigger Nitro reload when SPA loading template changes
  const spaLoadingTemplateFilePath = await spaLoadingTemplatePath(nuxt)
  nuxt.hook('builder:watch', async (_event, relativePath) => {
    const path = resolve(nuxt.options.srcDir, relativePath)
    if (path === spaLoadingTemplateFilePath) {
      await nitro.hooks.callHook('rollup:reload')
    }
  })

  const cacheDir = resolve(nuxt.options.buildDir, 'cache/nitro/prerender')
  const cacheDriverPath = join(distDir, 'runtime/utils/cache-driver.js')
  await fsp.rm(cacheDir, { recursive: true, force: true }).catch(() => {})
  nitro.options._config.storage = defu(nitro.options._config.storage, {
    'internal:nuxt:prerender': {
      // TODO: resolve upstream where file URLs are not being resolved/inlined correctly
      driver: isWindows ? pathToFileURL(cacheDriverPath).href : cacheDriverPath,
      base: cacheDir,
    },
  })

  // Expose nitro to modules and kit
  nuxt._nitro = nitro
  await nuxt.callHook('nitro:init', nitro)

  // Connect vfs storages
  nitro.vfs = nuxt.vfs = nitro.vfs || nuxt.vfs || {}

  // Connect hooks
  nuxt.hook('close', () => nitro.hooks.callHook('close'))
  nitro.hooks.hook('prerender:routes', (routes) => {
    return nuxt.callHook('prerender:routes', { routes })
  })

  // Enable runtime compiler client side
  if (nuxt.options.vue.runtimeCompiler) {
    addVitePlugin({
      name: 'nuxt:vue:runtime-compiler',
      applyToEnvironment: environment => environment.name === 'client',
      enforce: 'pre',
      resolveId (id, importer) {
        if (id === 'vue') {
          return this.resolve('vue/dist/vue.esm-bundler', importer, { skipSelf: true })
        }
      },
    })
    for (const hook of ['webpack:config', 'rspack:config'] as const) {
      nuxt.hook(hook, (configuration) => {
        const clientConfig = configuration.find(config => config.name === 'client')
        if (!clientConfig!.resolve) { clientConfig!.resolve!.alias = {} }
        if (Array.isArray(clientConfig!.resolve!.alias)) {
          clientConfig!.resolve!.alias.push({
            name: 'vue',
            alias: 'vue/dist/vue.esm-bundler',
          })
        } else {
          clientConfig!.resolve!.alias!.vue = 'vue/dist/vue.esm-bundler'
        }
      })
    }
  }

  // Setup handlers
  const devMiddlewareHandler = dynamicEventHandler()
  nitro.options.devHandlers.unshift({ handler: devMiddlewareHandler })
  nitro.options.devHandlers.push(...nuxt.options.devServerHandlers)
  nitro.options.handlers.unshift({
    route: '/__nuxt_error',
    lazy: true,
    handler: resolve(distDir, 'runtime/handlers/renderer'),
  })

  // TODO: refactor into a module when this is more full-featured
  // add Chrome devtools integration
  if (nuxt.options.experimental.chromeDevtoolsProjectSettings) {
    const cacheDir = resolve(nuxt.options.rootDir, 'node_modules/.cache/nuxt')
    let projectConfiguration = await readFile(join(cacheDir, 'chrome-workspace.json'), 'utf-8')
      .then(r => JSON.parse(r))
      .catch(() => null)

    if (!projectConfiguration) {
      projectConfiguration = { uuid: randomUUID() }
      await mkdir(cacheDir, { recursive: true })
      await writeFile(join(cacheDir, 'chrome-workspace.json'), JSON.stringify(projectConfiguration), 'utf-8')
    }

    nitro.options.devHandlers.push({
      route: '/.well-known/appspecific/com.chrome.devtools.json',
      handler: defineEventHandler(() => ({
        workspace: {
          ...projectConfiguration,
          root: nuxt.options.rootDir,
        },
      })),
    })
  }

  if (!nuxt.options.dev && nuxt.options.experimental.noVueServer) {
    nitro.hooks.hook('rollup:before', (nitro) => {
      if (nitro.options.preset === 'nitro-prerender') {
        nitro.options.errorHandler = resolve(distDir, 'runtime/handlers/error')
        return
      }
      const nuxtErrorHandler = nitro.options.handlers.findIndex(h => h.route === '/__nuxt_error')
      if (nuxtErrorHandler >= 0) {
        nitro.options.handlers.splice(nuxtErrorHandler, 1)
      }

      nitro.options.renderer = undefined
    })
  }

  // ensure Nitro types only apply to server directory and not the whole root directory
  nitro.hooks.hook('types:extend', (types) => {
    types.tsConfig ||= {}
    const rootDirGlob = relativeWithDot(nuxt.options.buildDir, join(nuxt.options.rootDir, '**/*'))
    types.tsConfig.include = types.tsConfig.include?.filter(i => i !== rootDirGlob)
  })

  // Add typed route responses
  nuxt.hook('prepare:types', async (opts) => {
    if (!nuxt.options.dev) {
      await scanHandlers(nitro)
      await writeTypes(nitro)
    }
    // Exclude nitro output dir from typescript
    opts.tsConfig.exclude ||= []
    opts.tsConfig.exclude.push(relative(nuxt.options.buildDir, resolve(nuxt.options.rootDir, nitro.options.output.dir)))
    opts.tsConfig.exclude.push(relative(nuxt.options.buildDir, resolve(nuxt.options.rootDir, nuxt.options.serverDir)))
    opts.references.push({ path: resolve(nuxt.options.buildDir, 'types/nitro.d.ts') })

    // ensure aliases shared between nuxt + nitro are included in shared tsconfig
    opts.sharedTsConfig.compilerOptions ||= {}
    opts.sharedTsConfig.compilerOptions.paths ||= {}
    for (const key in nuxt.options.alias) {
      if (nitro.options.alias[key] && nitro.options.alias[key] === nuxt.options.alias[key]) {
        const dirKey = join(key, '*')
        if (opts.tsConfig.compilerOptions?.paths[key]) {
          opts.sharedTsConfig.compilerOptions.paths[key] = opts.tsConfig.compilerOptions.paths[key]
        }
        if (opts.tsConfig.compilerOptions?.paths[dirKey]) {
          opts.sharedTsConfig.compilerOptions.paths[dirKey] = opts.tsConfig.compilerOptions.paths[dirKey]
        }
      }
    }
  })

  if (nitro.options.static) {
    nitro.hooks.hook('prerender:routes', (routes) => {
      for (const route of ['/200.html', '/404.html']) {
        routes.add(route)
      }
      if (!nuxt.options.ssr) {
        routes.add('/index.html')
      }
    })
  }

  // Copy public assets after prerender so app manifest can be present
  if (!nuxt.options.dev) {
    nitro.hooks.hook('rollup:before', async (nitro) => {
      await copyPublicAssets(nitro)
      await nuxt.callHook('nitro:build:public-assets', nitro)
    })
  }

  async function symlinkDist () {
    if (nitro.options.static) {
      const distDir = resolve(nuxt.options.rootDir, 'dist')
      if (!existsSync(distDir)) {
        await fsp.symlink(nitro.options.output.publicDir, distDir, 'junction').catch(() => {})
      }
    }
  }

  // nuxt build/dev
  nuxt.hook('build:done', async () => {
    await nuxt.callHook('nitro:build:before', nitro)
    await prepare(nitro)
    if (nuxt.options.dev) {
      return build(nitro)
    }

    await prerender(nitro)

    logger.restoreAll()
    await build(nitro)
    logger.wrapAll()

    await symlinkDist()
  })

  // nuxt dev
  if (nuxt.options.dev) {
    for (const builder of ['webpack', 'rspack'] as const) {
      nuxt.hook(`${builder}:compile`, ({ name, compiler }) => {
        if (name === 'server') {
          const memfs = compiler.outputFileSystem as typeof import('node:fs')
          nitro.options.virtual['#build/dist/server/server.mjs'] = () => memfs.readFileSync(join(nuxt.options.buildDir, 'dist/server/server.mjs'), 'utf-8')
        }
      })
      nuxt.hook(`${builder}:compiled`, () => { nuxt.server.reload() })
    }
    nuxt.hook('vite:compiled', () => { nuxt.server.reload() })

    nuxt.hook('server:devHandler', (h) => { devMiddlewareHandler.set(h) })
    nuxt.server = createDevServer(nitro)

    const waitUntilCompile = new Promise<void>(resolve => nitro.hooks.hook('compiled', () => resolve()))
    nuxt.hook('build:done', () => waitUntilCompile)
  }
}

const RELATIVE_RE = /^([^.])/
function relativeWithDot (from: string, to: string) {
  return relative(from, to).replace(RELATIVE_RE, './$1') || '.'
}

async function spaLoadingTemplatePath (nuxt: Nuxt) {
  if (typeof nuxt.options.spaLoadingTemplate === 'string') {
    return resolve(nuxt.options.srcDir, nuxt.options.spaLoadingTemplate)
  }

  const possiblePaths = nuxt.options._layers.map(layer => resolve(layer.config.srcDir, layer.config.dir?.app || 'app', 'spa-loading-template.html'))

  return await findPath(possiblePaths) ?? resolve(nuxt.options.srcDir, nuxt.options.dir?.app || 'app', 'spa-loading-template.html')
}

async function spaLoadingTemplate (nuxt: Nuxt) {
  if (nuxt.options.spaLoadingTemplate === false) { return '' }

  const spaLoadingTemplate = await spaLoadingTemplatePath(nuxt)

  try {
    if (existsSync(spaLoadingTemplate)) {
      return readFileSync(spaLoadingTemplate, 'utf-8').trim()
    }
  } catch {
    // fall through if we have issues reading the file
  }

  if (nuxt.options.spaLoadingTemplate === true) {
    return defaultSpaLoadingTemplate()
  }

  if (nuxt.options.spaLoadingTemplate) {
    logger.warn(`Could not load custom \`spaLoadingTemplate\` path as it does not exist: \`${nuxt.options.spaLoadingTemplate}\`.`)
  }

  return ''
}
</file>

<file path="packages/nitro-server/src/templates.ts">
import type { NuxtTemplate, TSReference } from 'nuxt/schema'
import { isAbsolute, join, relative } from 'pathe'

export const nitroSchemaTemplate: NuxtTemplate = {
  filename: 'types/nitro-nuxt.d.ts',
  async getContents ({ nuxt }) {
    const references = [] as TSReference[]
    const declarations = [] as string[]
    await nuxt.callHook('nitro:prepare:types', { references, declarations })

    const sourceDir = join(nuxt.options.buildDir, 'types')
    const lines = [
      ...references.map((ref) => {
        if ('path' in ref && isAbsolute(ref.path)) {
          ref.path = relative(sourceDir, ref.path)
        }
        return `/// <reference ${renderAttrs(ref)} />`
      }),
      ...declarations,
    ]

    return /* typescript */`
${lines.join('\n')}

import type { RuntimeConfig } from 'nuxt/schema'
import type { H3Event } from 'h3'
import type { LogObject } from 'consola'
import type { NuxtIslandContext, NuxtIslandResponse, NuxtRenderHTMLContext } from 'nuxt/app'

declare module 'nitropack' {
  interface NitroRuntimeConfigApp {
    buildAssetsDir: string
    cdnURL: string
  }
  interface NitroRuntimeConfig extends RuntimeConfig {}
  interface NitroRouteConfig {
    ssr?: boolean
    noScripts?: boolean
    /** @deprecated Use \`noScripts\` instead */
    experimentalNoScripts?: boolean
  }
  interface NitroRouteRules {
    ssr?: boolean
    noScripts?: boolean
    /** @deprecated Use \`noScripts\` instead */
    experimentalNoScripts?: boolean
    appMiddleware?: Record<string, boolean>
    appLayout?: string | false
  }
  interface NitroRuntimeHooks {
    'dev:ssr-logs': (ctx: { logs: LogObject[], path: string }) => void | Promise<void>
    'render:html': (htmlContext: NuxtRenderHTMLContext, context: { event: H3Event }) => void | Promise<void>
    'render:island': (islandResponse: NuxtIslandResponse, context: { event: H3Event, islandContext: NuxtIslandContext }) => void | Promise<void>
  }
}
declare module 'nitropack/types' {
  interface NitroRuntimeConfigApp {
    buildAssetsDir: string
    cdnURL: string
  }
  interface NitroRuntimeConfig extends RuntimeConfig {}
  interface NitroRouteConfig {
    ssr?: boolean
    noScripts?: boolean
    /** @deprecated Use \`noScripts\` instead */
    experimentalNoScripts?: boolean
  }
  interface NitroRouteRules {
    ssr?: boolean
    noScripts?: boolean
    /** @deprecated Use \`noScripts\` instead */
    experimentalNoScripts?: boolean
    appMiddleware?: Record<string, boolean>
    appLayout?: string | false
  }
  interface NitroRuntimeHooks {
    'dev:ssr-logs': (ctx: { logs: LogObject[], path: string }) => void | Promise<void>
    'render:html': (htmlContext: NuxtRenderHTMLContext, context: { event: H3Event }) => void | Promise<void>
    'render:island': (islandResponse: NuxtIslandResponse, context: { event: H3Event, islandContext: NuxtIslandContext }) => void | Promise<void>
  }
}
`
  },
}
function renderAttr (key: string, value?: string) {
  return value ? `${key}="${value}"` : ''
}

function renderAttrs (obj: Record<string, string>) {
  const attrs: string[] = []
  for (const key in obj) {
    attrs.push(renderAttr(key, obj[key]))
  }
  return attrs.join(' ')
}
</file>

<file path="packages/nitro-server/src/utils.ts">
import { fileURLToPath } from 'node:url'
import { dirname } from 'pathe'

export function toArray<T> (value: T | T[]): T[] {
  return Array.isArray(value) ? value : [value]
}

let _distDir = dirname(fileURLToPath(import.meta.url))
if (/(?:chunks|shared)$/.test(_distDir)) { _distDir = dirname(_distDir) }

export const distDir = _distDir
</file>

<file path="packages/nitro-server/.attw.json">
{
  "ignoreRules": ["cjs-resolves-to-esm"]
}
</file>

<file path="packages/nitro-server/.gitignore">
src/runtime/templates/error-500.ts
src/runtime/templates/error-dev.ts
</file>

<file path="packages/nitro-server/build.config.ts">
import { defineBuildConfig } from 'unbuild'
import { addRollupTimingsPlugin } from '../../debug/build-config.ts'

export default defineBuildConfig({
  declaration: true,
  entries: [
    'src/index',
    { input: 'src/runtime/', outDir: 'dist/runtime', ext: 'js' },
  ],
  hooks: {
    'rollup:options' (ctx, options) {
      addRollupTimingsPlugin(options)
    },
  },
  externals: [
    '@nuxt/schema',
    'nuxt',
    'nitropack',
  ],
})
</file>

<file path="packages/nitro-server/package.json">
{
  "name": "@nuxt/nitro-server",
  "version": "4.2.2",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nuxt/nuxt.git",
    "directory": "packages/nitro-server"
  },
  "description": "Nitro server integration for Nuxt",
  "homepage": "https://nuxt.com",
  "license": "MIT",
  "type": "module",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": "./dist/index.mjs"
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "prepack": "unbuild",
    "build:stub": "unbuild --stub",
    "test:attw": "attw --pack"
  },
  "dependencies": {
    "@nuxt/devalue": "^2.0.2",
    "@nuxt/kit": "workspace:*",
    "@unhead/vue": "^2.1.1",
    "@vue/shared": "^3.5.26",
    "consola": "^3.4.2",
    "defu": "^6.1.4",
    "destr": "^2.0.5",
    "devalue": "^5.6.1",
    "errx": "^0.1.0",
    "escape-string-regexp": "^5.0.0",
    "exsolve": "^1.0.8",
    "h3": "^1.15.4",
    "impound": "^1.0.0",
    "klona": "^2.0.6",
    "mocked-exports": "^0.1.1",
    "nitropack": "^2.12.9",
    "ohash": "^2.0.11",
    "pathe": "^2.0.3",
    "pkg-types": "^2.3.0",
    "rou3": "^0.7.12",
    "std-env": "^3.10.0",
    "ufo": "^1.6.1",
    "unctx": "^2.5.0",
    "unstorage": "^1.17.3",
    "vue": "^3.5.26",
    "vue-bundle-renderer": "^2.2.0",
    "vue-devtools-stub": "^0.1.0"
  },
  "peerDependencies": {
    "nuxt": "workspace:^"
  },
  "devDependencies": {
    "@nuxt/schema": "workspace:*",
    "nuxt": "workspace:*",
    "unbuild": "3.6.1",
    "vitest": "3.2.4"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="packages/nuxi/README.md">
# Nuxt CLI

⚡️ Next Generation CLI Experience for [Nuxt](https://nuxt.com/).

- 👉 View on GitHub at https://github.com/nuxt/cli
</file>

<file path="packages/nuxt/bin/nuxt.mjs">
#!/usr/bin/env node
import '@nuxt/cli/cli'
</file>

<file path="packages/nuxt/src/app/compat/capi.ts">
export * from 'vue'

export const install = (): void => {}

export function set<T> (target: any, key: string | number | symbol, val: T): T {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key as number)
    target.splice(key as number, 1, val)
    return val
  }
  target[key] = val
  return val
}

export function del (target: any, key: string | number | symbol): void {
  if (Array.isArray(target)) {
    target.splice(key as number, 1)
    return
  }
  delete target[key]
}
</file>

<file path="packages/nuxt/src/app/compat/idle-callback.ts">
// Polyfills for Safari support
// https://caniuse.com/requestidlecallback
export const requestIdleCallback: Window['requestIdleCallback'] = import.meta.server
  ? (() => {}) as any
  : (globalThis.requestIdleCallback || ((cb) => {
      const start = Date.now()
      const idleDeadline = {
        didTimeout: false,
        timeRemaining: () => Math.max(0, 50 - (Date.now() - start)),
      }
      return setTimeout(() => { cb(idleDeadline) }, 1)
    }))

export const cancelIdleCallback: Window['cancelIdleCallback'] = import.meta.server
  ? (() => {}) as any
  : (globalThis.cancelIdleCallback || ((id) => { clearTimeout(id) }))
</file>

<file path="packages/nuxt/src/app/compat/interval.ts">
import { createError } from '../composables/error'

const intervalError = '[nuxt] `setInterval` should not be used on the server. Consider wrapping it with an `onNuxtReady`, `onBeforeMount` or `onMounted` lifecycle hook, or ensure you only call it in the browser by checking `import.meta.client`.'

export const setInterval: typeof globalThis.setInterval = import.meta.client
  ? globalThis.setInterval
  : (() => {
      if (import.meta.dev) {
        throw createError({
          status: 500,
          message: intervalError,
        })
      }

      console.error(intervalError)
    }) as any
</file>

<file path="packages/nuxt/src/app/compat/vue-demi.ts">
export * from './capi'

export const Vue2 = undefined
export const isVue2 = false
export const isVue3 = true
</file>

<file path="packages/nuxt/src/app/components/client-fallback.client.ts">
import { createElementBlock, defineComponent, onMounted, shallowRef, useId } from 'vue'
import { useState } from '../composables/state'

export default defineComponent({
  name: 'NuxtClientFallback',
  inheritAttrs: false,
  props: {
    fallbackTag: {
      type: String,
      default: () => 'div',
    },
    fallback: {
      type: String,
      default: () => '',
    },
    placeholder: {
      type: String,
    },
    placeholderTag: {
      type: String,
    },
    keepFallback: {
      type: Boolean,
      default: () => false,
    },
  },
  emits: ['ssr-error'],
  setup (props, ctx) {
    const mounted = shallowRef(false)
    const ssrFailed = useState(useId())

    if (ssrFailed.value) {
      onMounted(() => { mounted.value = true })
    }

    return () => {
      if (ssrFailed.value) {
        if (!mounted.value || props.keepFallback) {
          const slot = ctx.slots.placeholder || ctx.slots.fallback
          if (slot) { return slot() }
          const fallbackStr = props.placeholder || props.fallback
          const fallbackTag = props.placeholderTag || props.fallbackTag
          return createElementBlock(fallbackTag, null, fallbackStr)
        }
      }
      return ctx.slots.default?.()
    }
  },
})
</file>

<file path="packages/nuxt/src/app/components/client-fallback.server.ts">
import { defineComponent, getCurrentInstance, onErrorCaptured, shallowRef, useId } from 'vue'
import { ssrRenderAttrs, ssrRenderSlot, ssrRenderVNode } from 'vue/server-renderer'

import { isPromise } from '@vue/shared'
import { useState } from '../composables/state'
import { createBuffer } from './utils'

const NuxtClientFallbackServer = defineComponent({
  name: 'NuxtClientFallback',
  inheritAttrs: false,
  props: {
    fallbackTag: {
      type: String,
      default: () => 'div',
    },
    fallback: {
      type: String,
      default: () => '',
    },
    placeholder: {
      type: String,
    },
    placeholderTag: {
      type: String,
    },
    keepFallback: {
      type: Boolean,
      default: () => false,
    },
  },
  emits: {
    'ssr-error' (_error: unknown) {
      return true
    },
  },
  async setup (_, ctx) {
    const vm = getCurrentInstance()
    const ssrFailed = shallowRef(false)
    const error = useState<boolean | undefined>(useId())

    onErrorCaptured((err) => {
      error.value = true
      ssrFailed.value = true
      ctx.emit('ssr-error', err)
      return false
    })

    try {
      const defaultSlot = ctx.slots.default?.()
      const ssrVNodes = createBuffer()

      if (defaultSlot) {
        for (let i = 0; i < defaultSlot.length; i++) {
          ssrRenderVNode(ssrVNodes.push, defaultSlot[i]!, vm!)
        }
      }

      const buffer = ssrVNodes.getBuffer()
      if (buffer.hasAsync) {
        await Promise.all(buffer.filter(isPromise))
      }

      return { ssrFailed, ssrVNodes }
    } catch (ssrError) {
      // catch in dev
      error.value = true
      ctx.emit('ssr-error', ssrError)
      return { ssrFailed: true, ssrVNodes: [] }
    }
  },
  ssrRender (ctx: any, push: any, parent: any) {
    if (ctx.ssrFailed) {
      const { fallback, placeholder } = ctx.$slots
      if (fallback || placeholder) {
        ssrRenderSlot(ctx.$slots, fallback ? 'fallback' : 'placeholder', {}, null, push, parent)
      } else {
        const content = ctx.placeholder || ctx.fallback
        const tag = ctx.placeholderTag || ctx.fallbackTag
        push(`<${tag}${ssrRenderAttrs(ctx.$attrs)}>${content}</${tag}>`)
      }
    } else {
      // push Fragment markup
      push('<!--[-->')
      push(ctx.ssrVNodes.getBuffer())
      push('<!--]-->')
    }
  },
})

export default NuxtClientFallbackServer
</file>

<file path="packages/nuxt/src/app/components/client-only.ts">
import { cloneVNode, createElementBlock, defineComponent, getCurrentInstance, h, onMounted, provide, shallowRef } from 'vue'
import type { ComponentInternalInstance, ComponentOptions, InjectionKey, SlotsType, VNode } from 'vue'
import { isPromise } from '@vue/shared'
import { useNuxtApp } from '../nuxt'
import ServerPlaceholder from './server-placeholder'
import { elToStaticVNode } from './utils'

export const clientOnlySymbol: InjectionKey<boolean> = Symbol.for('nuxt:client-only')

const STATIC_DIV = '<div></div>'

export default defineComponent({
  name: 'ClientOnly',
  inheritAttrs: false,
  props: ['fallback', 'placeholder', 'placeholderTag', 'fallbackTag'],
  ...(import.meta.dev && {
    slots: Object as SlotsType<{
      default?: () => VNode[]

      /**
       * Specify a content to be rendered on the server and displayed until `<ClientOnly>` is mounted in the browser.
       */
      fallback?: () => VNode[]
      placeholder?: () => VNode[]
    }>,
  }),
  setup (props, { slots, attrs }) {
    const mounted = shallowRef(false)
    onMounted(() => { mounted.value = true })
    // Bail out of checking for pages/layouts as they might be included under `<ClientOnly>` 🤷‍♂️
    if (import.meta.dev) {
      const nuxtApp = useNuxtApp()
      nuxtApp._isNuxtPageUsed = true
      nuxtApp._isNuxtLayoutUsed = true
    }
    const vm = getCurrentInstance()
    if (vm) {
      vm._nuxtClientOnly = true
    }
    provide(clientOnlySymbol, true)
    return () => {
      if (mounted.value) {
        const vnodes = slots.default?.()
        if (vnodes && vnodes.length === 1) {
          return [cloneVNode(vnodes[0]!, attrs)]
        }
        return vnodes
      }
      const slot = slots.fallback || slots.placeholder
      if (slot) { return h(slot) }
      const fallbackStr = props.fallback || props.placeholder || ''
      const fallbackTag = props.fallbackTag || props.placeholderTag || 'span'
      return createElementBlock(fallbackTag, attrs, fallbackStr)
    }
  },
})

const cache = new WeakMap()

/* @__NO_SIDE_EFFECTS__ */
export function createClientOnly<T extends ComponentOptions> (component: T) {
  if (import.meta.server) {
    return ServerPlaceholder
  }
  if (cache.has(component)) {
    return cache.get(component)
  }

  const clone = { ...component }

  if (clone.render) {
    // override the component render (non script setup component) or dev mode
    clone.render = (ctx: any, cache: any, $props: any, $setup: any, $data: any, $options: any) => {
      if ($setup.mounted$ ?? ctx.mounted$) {
        const res = component.render?.bind(ctx)(ctx, cache, $props, $setup, $data, $options)
        return (res.children === null || typeof res.children === 'string')
          ? cloneVNode(res)
          : h(res)
      }
      return elToStaticVNode(ctx._.vnode.el, STATIC_DIV)
    }
  } else {
    // handle runtime-compiler template
    clone.template &&= `
      <template v-if="mounted$">${component.template}</template>
      <template v-else>${STATIC_DIV}</template>
    `
  }

  clone.setup = (props, ctx) => {
    const nuxtApp = useNuxtApp()
    const mounted$ = shallowRef(nuxtApp.isHydrating === false)
    const instance = getCurrentInstance()!

    if (nuxtApp.isHydrating) {
      const attrs = { ...instance.attrs }
      // remove existing directives during hydration
      const directives = extractDirectives(instance)
      // prevent attrs inheritance since a staticVNode is rendered before hydration
      for (const key in attrs) {
        delete instance.attrs[key]
      }

      onMounted(() => {
        Object.assign(instance.attrs, attrs)
        instance.vnode.dirs = directives
      })
    }

    onMounted(() => {
      mounted$.value = true
    })
    const setupState = component.setup?.(props, ctx) || {}

    if (isPromise(setupState)) {
      return Promise.resolve(setupState).then((setupState) => {
        if (typeof setupState !== 'function') {
          setupState ||= {}
          setupState.mounted$ = mounted$
          return setupState
        }
        return (...args: any[]) => {
          if (mounted$.value || !nuxtApp.isHydrating) {
            const res = setupState(...args)
            return (res.children === null || typeof res.children === 'string')
              ? cloneVNode(res)
              : h(res)
          }
          return elToStaticVNode(instance?.vnode.el, STATIC_DIV)
        }
      })
    } else {
      if (typeof setupState === 'function') {
        return (...args: any[]) => {
          if (mounted$.value) {
            const res = setupState(...args)
            const attrs = clone.inheritAttrs !== false ? ctx.attrs : undefined

            return (res.children === null || typeof res.children === 'string')
              ? cloneVNode(res, attrs)
              : h(res, attrs)
          }
          return elToStaticVNode(instance?.vnode.el, STATIC_DIV)
        }
      }
      return Object.assign(setupState, { mounted$ })
    }
  }

  cache.set(component, clone)

  return clone
}

function extractDirectives (instance: ComponentInternalInstance | null) {
  if (!instance || !instance.vnode.dirs) { return null }
  const directives = instance.vnode.dirs
  instance.vnode.dirs = null
  return directives
}
</file>

<file path="packages/nuxt/src/app/components/dev-only.ts">
import { defineComponent } from 'vue'
import type { SlotsType, VNode } from 'vue'

export default defineComponent({
  name: 'DevOnly',
  inheritAttrs: false,
  ...(import.meta.dev && {
    slots: Object as SlotsType<{
      default?: () => VNode[]

      /**
       * If you ever require to have a replacement during production.
       */
      fallback?: () => VNode[]
    }>,
  }),
  setup (_, props) {
    if (import.meta.dev) {
      return () => props.slots.default?.()
    }
    return () => props.slots.fallback?.()
  },
})
</file>

<file path="packages/nuxt/src/app/components/index.ts">
// defineNuxtLink
export { defineNuxtLink } from './nuxt-link'
export type { NuxtLinkOptions, NuxtLinkProps } from './nuxt-link'

export type { NuxtTimeProps } from './nuxt-time.vue'
</file>

<file path="packages/nuxt/src/app/components/injections.ts">
import type { InjectionKey } from 'vue'
import type { RouteLocationNormalizedLoaded } from 'vue-router'

export interface LayoutMeta {
  isCurrent: (route: RouteLocationNormalizedLoaded) => boolean
}

export const LayoutMetaSymbol: InjectionKey<LayoutMeta> = Symbol('layout-meta')

export const PageRouteSymbol: InjectionKey<RouteLocationNormalizedLoaded> = Symbol('route')
</file>

<file path="packages/nuxt/src/app/components/island-renderer.ts">
import type { defineAsyncComponent } from 'vue'
import { createVNode, defineComponent, onErrorCaptured } from 'vue'

import { injectHead } from '../composables/head'
import { createError } from '../composables/error'

// @ts-expect-error virtual file
import { islandComponents } from '#build/components.islands.mjs'

export default defineComponent({
  name: 'IslandRenderer',
  props: {
    context: {
      type: Object as () => { name: string, props?: Record<string, any> },
      required: true,
    },
  },
  setup (props) {
    // reset head - we don't want to have any head tags from plugin or anywhere else.
    const head = injectHead()
    head.entries.clear()

    const component = islandComponents[props.context.name] as ReturnType<typeof defineAsyncComponent>

    if (!component) {
      throw createError({
        status: 404,
        statusText: `Island component not found: ${props.context.name}`,
      })
    }

    onErrorCaptured((e) => {
      console.log(e)
    })

    return () => createVNode(component || 'span', { ...props.context.props, 'data-island-uid': '' })
  },
})
</file>

<file path="packages/nuxt/src/app/components/nuxt-error-boundary.vue">
<template>
  <slot
    v-if="error"
    v-bind="{ error, clearError }"
    name="error"
  />

  <slot
    v-else
    name="default"
  />
</template>

<script setup lang="ts">
import { onErrorCaptured, shallowRef } from 'vue'
import { useNuxtApp } from '../nuxt'
import { onNuxtReady } from '../composables/ready'

defineOptions({
  name: 'NuxtErrorBoundary',
  inheritAttrs: false,
})

const emit = defineEmits<{
  error: [error: Error]
}>()

defineSlots<{
  error(props: { error: Error, clearError: () => void }): any
  default(): any
}>()

const error = shallowRef<Error | null>(null)

function clearError () {
  error.value = null
}

if (import.meta.client) {
  const nuxtApp = useNuxtApp()

  function handleError (...args: Parameters<Parameters<typeof onErrorCaptured<Error>>[0]>) {
    const [err, instance, info] = args

    emit('error', err)

    nuxtApp.hooks.callHook('vue:error', err, instance, info)

    error.value = err
  }

  onErrorCaptured((err, instance, info) => {
    if (!nuxtApp.isHydrating) {
      handleError(err, instance, info)
    } else {
      onNuxtReady(() => handleError(err, instance, info))
    }

    return false
  })
}

defineExpose({ error, clearError })
</script>
</file>

<file path="packages/nuxt/src/app/components/nuxt-error-page.vue">
<template>
  <ErrorTemplate v-bind="{ status, statusText, statusCode: status, statusMessage: statusText, description, stack }" />
</template>

<script setup>
import { defineAsyncComponent } from 'vue'
// eslint-disable-next-line vue/prefer-import-from-vue
import { escapeHtml } from '@vue/shared'

const props = defineProps({
  error: Object,
})

// Deliberately prevent reactive update when error is cleared
const _error = props.error

// TODO: extract to a separate utility
const stacktrace = import.meta.dev && _error.stack
  ? _error.stack
      .split('\n')
      .splice(1)
      .map((line) => {
        const text = line
          .replace('webpack:/', '')
          .replace('.vue', '.js') // TODO: Support sourcemap
          .trim()
        return {
          text,
          internal: (line.includes('node_modules') && !line.includes('.cache')) ||
          line.includes('internal') ||
          line.includes('new Promise'),
        }
      }).map(i => `<span class="stack${i.internal ? ' internal' : ''}">${escapeHtml(i.text)}</span>`).join('\n')
  : ''

// Error page props
const status = Number(_error.statusCode || 500)
const is404 = status === 404

const statusText = _error.statusMessage ?? (is404 ? 'Page Not Found' : 'Internal Server Error')
const description = _error.message || _error.toString()
const stack = import.meta.dev && !is404 ? _error.description || `<pre>${stacktrace}</pre>` : undefined

// TODO: Investigate side-effect issue with imports
const _Error404 = defineAsyncComponent(() => import('./error-404.vue'))
const _Error = defineAsyncComponent(() => import('./error-500.vue'))

const ErrorTemplate = is404 ? _Error404 : _Error
</script>
</file>

<file path="packages/nuxt/src/app/components/nuxt-island.ts">
import type { Component, PropType, RendererNode, VNode } from 'vue'
import { Fragment, Teleport, computed, createStaticVNode, createVNode, defineComponent, getCurrentInstance, h, nextTick, onBeforeUnmount, onMounted, ref, shallowRef, toRaw, watch, withMemo } from 'vue'
import { debounce } from 'perfect-debounce'
import { hash } from 'ohash'
import { appendResponseHeader } from 'h3'
import type { ActiveHeadEntry, SerializableHead } from '@unhead/vue'
import { randomUUID } from 'uncrypto'
import { joinURL, withQuery } from 'ufo'

import type { NuxtIslandResponse } from '../types'
import { useNuxtApp, useRuntimeConfig } from '../nuxt'
import { createError } from '../composables/error'
import { prerenderRoutes, useRequestEvent } from '../composables/ssr'
import { injectHead } from '../composables/head'
import { getFragmentHTML, isEndFragment, isStartFragment } from './utils'

// @ts-expect-error virtual file
import { appBaseURL, remoteComponentIslands, selectiveClient } from '#build/nuxt.config.mjs'

const pKey = '_islandPromises'
const SSR_UID_RE = /data-island-uid="([^"]*)"/
const DATA_ISLAND_UID_RE = /data-island-uid(="")?(?!="[^"])/g
const SLOTNAME_RE = /data-island-slot="([^"]*)"/g
const SLOT_FALLBACK_RE = / data-island-slot="([^"]*)"[^>]*>/g
const ISLAND_SCOPE_ID_RE = /^<[^> ]*/

let id = 1
const getId = import.meta.client ? () => (id++).toString() : randomUUID

const components = import.meta.client ? new Map<string, Component>() : undefined

async function loadComponents (source = appBaseURL, paths: NuxtIslandResponse['components']) {
  if (!paths) { return }

  const promises: Array<Promise<void>> = []

  for (const [component, item] of Object.entries(paths)) {
    if (!(components!.has(component))) {
      promises.push((async () => {
        const chunkSource = joinURL(source, item.chunk)
        const c = await import(/* @vite-ignore */ chunkSource).then(m => m.default || m)
        components!.set(component, c)
      })())
    }
  }

  await Promise.all(promises)
}

export default defineComponent({
  name: 'NuxtIsland',
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      required: true,
    },
    lazy: Boolean,
    props: {
      type: Object,
      default: () => undefined,
    },
    context: {
      type: Object,
      default: () => ({}),
    },
    scopeId: {
      type: String as PropType<string | undefined | null>,
      default: () => undefined,
    },
    source: {
      type: String,
      default: () => undefined,
    },
    dangerouslyLoadClientComponents: {
      type: Boolean,
      default: false,
    },
  },
  emits: ['error'],
  async setup (props, { slots, expose, emit }) {
    let canTeleport = import.meta.server
    const teleportKey = shallowRef(0)
    const key = shallowRef(0)
    const canLoadClientComponent = computed(() => selectiveClient && (props.dangerouslyLoadClientComponents || !props.source))
    const error = ref<unknown>(null)
    const config = useRuntimeConfig()
    const nuxtApp = useNuxtApp()
    const filteredProps = computed(() => props.props ? Object.fromEntries(Object.entries(props.props).filter(([key]) => !key.startsWith('data-v-'))) : {})
    const hashId = computed(() => hash([props.name, filteredProps.value, props.context, props.source]).replace(/[-_]/g, ''))
    const instance = getCurrentInstance()!
    const event = useRequestEvent()

    let activeHead: ActiveHeadEntry<SerializableHead>

    const eventFetch = import.meta.server ? event!.fetch : globalThis.fetch
    const mounted = shallowRef(false)
    onMounted(() => { mounted.value = true; teleportKey.value++ })
    onBeforeUnmount(() => { if (activeHead) { activeHead.dispose() } })
    function setPayload (key: string, result: NuxtIslandResponse) {
      const toRevive: Partial<NuxtIslandResponse> = {}
      if (result.props) { toRevive.props = result.props }
      if (result.slots) { toRevive.slots = result.slots }
      if (result.components) { toRevive.components = result.components }
      if (result.head) { toRevive.head = result.head }
      nuxtApp.payload.data[key] = {
        __nuxt_island: {
          key,
          ...(import.meta.server && import.meta.prerender)
            ? {}
            : { params: { ...props.context, props: props.props ? JSON.stringify(props.props) : undefined } },
          result: toRevive,
        },
        ...result,
      }
    }

    const payloads: Partial<Pick<NuxtIslandResponse, 'slots' | 'components'>> = {}

    if (instance.vnode.el) {
      const slots = toRaw(nuxtApp.payload.data[`${props.name}_${hashId.value}`])?.slots
      if (slots) { payloads.slots = slots }
      if (selectiveClient) {
        const components = toRaw(nuxtApp.payload.data[`${props.name}_${hashId.value}`])?.components
        if (components) { payloads.components = components }
      }
    }

    const ssrHTML = ref<string>('')

    if (import.meta.client && instance.vnode?.el) {
      if (import.meta.dev) {
        let currentEl = instance.vnode.el
        let startEl: RendererNode | null = null
        let isFirstElement = true

        while (currentEl) {
          if (isEndFragment(currentEl)) {
            if (startEl !== currentEl.previousSibling) {
              console.warn(`[\`Server components(and islands)\`] "${props.name}" must have a single root element. (HTML comments are considered elements as well.)`)
            }
            break
          } else if (!isStartFragment(currentEl) && isFirstElement) {
            // find first non-comment node
            isFirstElement = false
            if (currentEl.nodeType === 1) {
              startEl = currentEl
            }
          }
          currentEl = currentEl.nextSibling
        }
      }
      ssrHTML.value = getFragmentHTML(instance.vnode.el, true)?.join('') || ''
      const key = `${props.name}_${hashId.value}`
      nuxtApp.payload.data[key] ||= {}
      // clear all data-island-uid to avoid conflicts when saving into payloads
      nuxtApp.payload.data[key].html = ssrHTML.value.replaceAll(new RegExp(`data-island-uid="${ssrHTML.value.match(SSR_UID_RE)?.[1] || ''}"`, 'g'), `data-island-uid=""`)
    }

    const uid = ref<string>(ssrHTML.value.match(SSR_UID_RE)?.[1] || getId())

    const currentSlots = new Set(Object.keys(slots))
    const availableSlots = computed(() => new Set([...ssrHTML.value.matchAll(SLOTNAME_RE)].map(m => m[1])))
    const html = computed(() => {
      let html = ssrHTML.value

      if (props.scopeId) {
        html = html.replace(ISLAND_SCOPE_ID_RE, full => full + ' ' + props.scopeId)
      }

      if (import.meta.client && !canLoadClientComponent.value) {
        for (const [key, value] of Object.entries(payloads.components || {})) {
          html = html.replace(new RegExp(` data-island-uid="${uid.value}" data-island-component="${key}"[^>]*>`), (full) => {
            return full + value.html
          })
        }
      }

      if (payloads.slots) {
        return html.replaceAll(SLOT_FALLBACK_RE, (full, slotName) => {
          if (!currentSlots.has(slotName)) {
            return full + (payloads.slots?.[slotName]?.fallback || '')
          }
          return full
        })
      }
      return html
    })

    const head = injectHead()

    async function _fetchComponent (force = false) {
      const key = `${props.name}_${hashId.value}`

      if (!force && nuxtApp.payload.data[key]?.html) { return nuxtApp.payload.data[key] }

      const url = remoteComponentIslands && props.source ? joinURL(props.source, `/__nuxt_island/${key}.json`) : `/__nuxt_island/${key}.json`
      if (import.meta.server && import.meta.prerender) {
        // Hint to Nitro to prerender the island component
        nuxtApp.runWithContext(() => prerenderRoutes(url))
      }
      // TODO: Validate response
      // $fetch handles the app.baseURL in dev
      const r = await eventFetch(withQuery(((import.meta.dev && import.meta.client) || props.source) ? url : joinURL(config.app.baseURL ?? '', url), {
        ...props.context,
        props: props.props ? JSON.stringify(props.props) : undefined,
      }))
      if (!r.ok) {
        throw createError({ status: r.status, statusText: r.statusText })
      }
      try {
        const result = await r.json()
        // TODO: support passing on more headers
        if (import.meta.server && import.meta.prerender) {
          const hints = r.headers.get('x-nitro-prerender')
          if (hints) {
            appendResponseHeader(event!, 'x-nitro-prerender', hints)
          }
        }
        setPayload(key, result)
        return result
      } catch (e: any) {
        if (r.status !== 200) {
          throw new Error(e.toString(), { cause: r })
        }
        throw e
      }
    }

    async function fetchComponent (force = false) {
      nuxtApp[pKey] ||= {}
      nuxtApp[pKey][uid.value] ||= _fetchComponent(force).finally(() => {
        delete nuxtApp[pKey]![uid.value]
      })
      try {
        const res: NuxtIslandResponse = await nuxtApp[pKey][uid.value]

        ssrHTML.value = res.html.replaceAll(DATA_ISLAND_UID_RE, `data-island-uid="${uid.value}"`)
        key.value++
        error.value = null
        payloads.slots = res.slots || {}
        payloads.components = res.components || {}

        if (selectiveClient && import.meta.client) {
          if (canLoadClientComponent.value && res.components) {
            await loadComponents(props.source, res.components)
          }
        }

        if (res?.head) {
          if (activeHead) {
            activeHead.patch(res.head)
          } else {
            activeHead = head.push(res.head)
          }
        }

        if (import.meta.client) {
          // must await next tick for Teleport to work correctly with static node re-rendering
          nextTick(() => {
            canTeleport = true
            teleportKey.value++
          })
        }
      } catch (e) {
        error.value = e
        emit('error', e)
      }
    }

    expose({
      refresh: () => fetchComponent(true),
    })

    if (import.meta.hot) {
      import.meta.hot.on(`nuxt-server-component:${props.name}`, () => {
        fetchComponent(true)
      })
    }

    if (import.meta.client) {
      watch(props, debounce(() => fetchComponent(), 100), { deep: true })
    }

    if (import.meta.client && !instance.vnode.el && props.lazy) {
      fetchComponent()
    } else if (import.meta.server || !instance.vnode.el || !nuxtApp.payload.serverRendered) {
      await fetchComponent()
    } else if (selectiveClient && canLoadClientComponent.value) {
      await loadComponents(props.source, payloads.components)
    }

    return (_ctx: any, _cache: any) => {
      if (!html.value || error.value) {
        return [slots.fallback?.({ error: error.value }) ?? createVNode('div')]
      }
      return [
        withMemo([key.value], () => {
          return createVNode(Fragment, { key: key.value }, [h(createStaticVNode(html.value || '<div></div>', 1))])
        }, _cache, 0),

        // should away be triggered ONE tick after re-rendering the static node
        withMemo([teleportKey.value], () => {
          const teleports: Array<VNode> = []
          // this is used to force trigger Teleport when vue makes the diff between old and new node
          const isKeyOdd = teleportKey.value === 0 || !!(teleportKey.value && !(teleportKey.value % 2))

          if (uid.value && html.value && (import.meta.server || props.lazy ? canTeleport : (mounted.value || instance.vnode?.el))) {
            for (const slot in slots) {
              if (availableSlots.value.has(slot)) {
                teleports.push(createVNode(Teleport,
                  // use different selectors for even and odd teleportKey to force trigger the teleport
                  { to: import.meta.client ? `${isKeyOdd ? 'div' : ''}[data-island-uid="${uid.value}"][data-island-slot="${slot}"]` : `uid=${uid.value};slot=${slot}` },
                  { default: () => (payloads.slots?.[slot]?.props?.length ? payloads.slots[slot].props : [{}]).map((data: any) => slots[slot]?.(data)) }),
                )
              }
            }
            if (selectiveClient) {
              if (import.meta.server) {
                if (payloads.components) {
                  for (const [id, info] of Object.entries(payloads.components)) {
                    const { html, slots } = info
                    let replaced = html.replaceAll('data-island-uid', `data-island-uid="${uid.value}"`)
                    for (const slot in slots) {
                      replaced = replaced.replaceAll(`data-island-slot="${slot}">`, full => full + slots[slot])
                    }
                    teleports.push(createVNode(Teleport, { to: `uid=${uid.value};client=${id}` }, {
                      default: () => [createStaticVNode(replaced, 1)],
                    }))
                  }
                }
              } else if (canLoadClientComponent.value && payloads.components) {
                for (const [id, info] of Object.entries(payloads.components)) {
                  const { props, slots } = info
                  const component = components!.get(id)!
                  // use different selectors for even and odd teleportKey to force trigger the teleport
                  const vnode = createVNode(Teleport, { to: `${isKeyOdd ? 'div' : ''}[data-island-uid='${uid.value}'][data-island-component="${id}"]` }, {
                    default: () => {
                      return [h(component, props, Object.fromEntries(Object.entries(slots || {}).map(([k, v]) => ([k, () => createStaticVNode(`<div style="display: contents" data-island-uid data-island-slot="${k}">${v}</div>`, 1),
                      ]))))]
                    },
                  })
                  teleports.push(vnode)
                }
              }
            }
          }

          return h(Fragment, teleports)
        }, _cache, 1),
      ]
    }
  },
})
</file>

<file path="packages/nuxt/src/app/components/nuxt-layout.ts">
import type { DefineComponent, ExtractPublicPropTypes, MaybeRef, PropType, VNode } from 'vue'
import { Suspense, computed, defineComponent, h, inject, mergeProps, nextTick, onMounted, provide, shallowReactive, shallowRef, unref } from 'vue'
import type { RouteLocationNormalizedLoaded } from 'vue-router'
import type { NitroRouteRules } from 'nitropack/types'

import type { PageMeta } from '../../pages/runtime/composables'

import { useRoute, useRouter } from '../composables/router'
import { useNuxtApp } from '../nuxt'
import { _wrapInTransition } from './utils'
import { LayoutMetaSymbol, PageRouteSymbol } from './injections'

// @ts-expect-error virtual file
import { useRoute as useVueRouterRoute } from '#build/pages'
// @ts-expect-error virtual file
import layouts from '#build/layouts'
// @ts-expect-error virtual file
import { appLayoutTransition as defaultLayoutTransition } from '#build/nuxt.config.mjs'
// @ts-expect-error virtual file
import _routeRulesMatcher from '#build/route-rules.mjs'

const routeRulesMatcher = _routeRulesMatcher as (path: string) => NitroRouteRules

const LayoutLoader = defineComponent({
  name: 'LayoutLoader',
  inheritAttrs: false,
  props: {
    name: String,
    layoutProps: Object,
  },
  setup (props, context) {
    // This is a deliberate hack - this component must always be called with an explicit key to ensure
    // that setup reruns when the name changes.
    return () => h(layouts[props.name], props.layoutProps, context.slots)
  },
})

// props are moved outside of defineComponent to later explicitly assert the prop types
// this avoids type loss/simplification resulting in things like MaybeRef<string | false>, keeping type hints for layout names
const nuxtLayoutProps = {
  name: {
    type: [String, Boolean, Object] as PropType<unknown extends PageMeta['layout'] ? MaybeRef<string | false> : PageMeta['layout']>,
    default: null,
  },
  fallback: {
    type: [String, Object] as PropType<unknown extends PageMeta['layout'] ? MaybeRef<string> : PageMeta['layout']>,
    default: null,
  },
}

export default defineComponent({
  name: 'NuxtLayout',
  inheritAttrs: false,
  props: nuxtLayoutProps,
  setup (props, context) {
    const nuxtApp = useNuxtApp()
    // Need to ensure (if we are not a child of `<NuxtPage>`) that we use synchronous route (not deferred)
    const injectedRoute = inject(PageRouteSymbol)
    const shouldUseEagerRoute = !injectedRoute /* this should never be true */
      || injectedRoute === useRoute() /* this is only true if we are not within `<NuxtPage>` */
    const route = shouldUseEagerRoute ? useVueRouterRoute() as ReturnType<typeof useRoute> : injectedRoute

    const layout = computed(() => {
      let layout = unref(props.name) ?? route?.meta.layout as string ?? routeRulesMatcher(route?.path).appLayout ?? 'default'
      if (layout && !(layout in layouts)) {
        if (import.meta.dev && layout !== 'default') {
          console.warn(`Invalid layout \`${layout}\` selected.`)
        }
        if (props.fallback) {
          layout = unref(props.fallback)
        }
      }
      return layout
    })

    const layoutRef = shallowRef()
    context.expose({ layoutRef })

    const done = nuxtApp.deferHydration()
    if (import.meta.client && nuxtApp.isHydrating) {
      const removeErrorHook = nuxtApp.hooks.hookOnce('app:error', done)
      useRouter().beforeEach(removeErrorHook)
    }

    if (import.meta.dev) {
      nuxtApp._isNuxtLayoutUsed = true
    }

    let lastLayout: string | boolean | undefined

    return () => {
      const hasLayout = layout.value && layout.value in layouts
      const transitionProps = route?.meta.layoutTransition ?? defaultLayoutTransition

      const previouslyRenderedLayout = lastLayout
      lastLayout = layout.value

      // We avoid rendering layout transition if there is no layout to render
      return _wrapInTransition(hasLayout && transitionProps, {
        default: () => h(Suspense, { suspensible: true, onResolve: () => { nextTick(done) } }, {
          default: () => h(
            LayoutProvider,
            {
              layoutProps: mergeProps(context.attrs, route.meta.layoutProps ?? {}, { ref: layoutRef }),
              key: layout.value || undefined,
              name: layout.value,
              shouldProvide: !props.name,
              isRenderingNewLayout: (name?: string | boolean) => {
                return (name !== previouslyRenderedLayout && name === layout.value)
              },
              hasTransition: !!transitionProps,
            }, context.slots),
        }),
      }).default()
    }
  },
}) as DefineComponent<ExtractPublicPropTypes<typeof nuxtLayoutProps>>

const LayoutProvider = defineComponent({
  name: 'NuxtLayoutProvider',
  inheritAttrs: false,
  props: {
    name: {
      type: [String, Boolean] as unknown as () => string | false,
    },
    layoutProps: {
      type: Object,
    },
    hasTransition: {
      type: Boolean,
    },
    shouldProvide: {
      type: Boolean,
    },
    isRenderingNewLayout: {
      type: Function as unknown as () => (name?: string | boolean) => boolean,
      required: true,
    },
  },
  setup (props, context) {
    // Prevent reactivity when the page will be rerendered in a different suspense fork

    const name = props.name
    if (props.shouldProvide) {
      provide(LayoutMetaSymbol, {
        isCurrent: (route: RouteLocationNormalizedLoaded) => name === (route.meta.layout ?? routeRulesMatcher(route.path).appLayout ?? 'default'),
      })
    }

    // this route waits to update until the page has finished changing
    const injectedRoute = inject(PageRouteSymbol)
    const isNotWithinNuxtPage = injectedRoute && injectedRoute === useRoute()

    if (isNotWithinNuxtPage) {
      // this route updates immediately
      const vueRouterRoute = useVueRouterRoute() as ReturnType<typeof useRoute>
      const reactiveChildRoute = {} as RouteLocationNormalizedLoaded
      for (const _key in vueRouterRoute) {
        const key = _key as keyof RouteLocationNormalizedLoaded
        Object.defineProperty(reactiveChildRoute, key, {
          enumerable: true,
          get: () => {
            // we want to use the eager route if we are rendering a layout for the first time
            // and only swap back to the lazy route if the route has already changed from the first render
            return props.isRenderingNewLayout(props.name) ? vueRouterRoute[key] : injectedRoute[key]
          },
        })
      }
      provide(PageRouteSymbol, shallowReactive(reactiveChildRoute))
    }

    let vnode: VNode | undefined
    if (import.meta.dev && import.meta.client) {
      onMounted(() => {
        nextTick(() => {
          if (['#comment', '#text'].includes(vnode?.el?.nodeName)) {
            if (name) {
              console.warn(`[nuxt] \`${name}\` layout does not have a single root node and will cause errors when navigating between routes.`)
            } else {
              console.warn('[nuxt] `<NuxtLayout>` needs to be passed a single root node in its default slot.')
            }
          }
        })
      })
    }

    return () => {
      if (!name || (typeof name === 'string' && !(name in layouts))) {
        if (import.meta.dev && import.meta.client && props.hasTransition) {
          vnode = context.slots.default?.() as VNode | undefined
          return vnode
        }
        return context.slots.default?.()
      }

      if (import.meta.dev && import.meta.client && props.hasTransition) {
        vnode = h(
          LayoutLoader,
          { key: name, layoutProps: props.layoutProps, name },
          context.slots,
        )

        return vnode
      }

      return h(
        LayoutLoader,
        { key: name, layoutProps: props.layoutProps, name },
        context.slots,
      )
    }
  },
})
</file>

<file path="packages/nuxt/src/app/components/nuxt-link.ts">
import type {
  AllowedComponentProps,
  AnchorHTMLAttributes,
  ComputedRef,
  DefineSetupFnComponent,
  InjectionKey,
  PropType,
  SlotsType,
  UnwrapRef,
  VNode,
  VNodeProps,
} from 'vue'
import { computed, defineComponent, h, inject, onBeforeUnmount, onMounted, provide, ref, resolveComponent, shallowRef } from 'vue'
import type { RouteLocation, RouteLocationRaw, Router, RouterLink, RouterLinkProps, UseLinkReturn, useLink } from 'vue-router'
import { hasProtocol, joinURL, parseQuery, withTrailingSlash, withoutTrailingSlash } from 'ufo'
import { preloadRouteComponents } from '../composables/preload'
import { onNuxtReady } from '../composables/ready'
import { navigateTo, resolveRouteObject, useRouter } from '../composables/router'
import { useNuxtApp, useRuntimeConfig } from '../nuxt'
import type { NuxtApp } from '../nuxt'
import { cancelIdleCallback, requestIdleCallback } from '../compat/idle-callback'

// @ts-expect-error virtual file
import { nuxtLinkDefaults } from '#build/nuxt.config.mjs'

import { hashMode } from '#build/router.options.mjs'

const firstNonUndefined = <T> (...args: (T | undefined)[]) => args.find(arg => arg !== undefined)

const NuxtLinkDevKeySymbol: InjectionKey<boolean> = Symbol('nuxt-link-dev-key')

/**
 * `<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag.
 * @see https://nuxt.com/docs/4.x/api/components/nuxt-link
 */
export interface NuxtLinkProps<CustomProp extends boolean = false> extends Omit<RouterLinkProps, 'to'> {
  custom?: CustomProp
  /**
   * Route Location the link should navigate to when clicked on.
   */
  to?: RouteLocationRaw // need to manually type to avoid breaking typedPages
  /**
   * An alias for `to`. If used with `to`, `href` will be ignored
   */
  href?: NuxtLinkProps['to']
  /**
   * Forces the link to be considered as external (true) or internal (false). This is helpful to handle edge-cases
   */
  external?: boolean
  /**
   * Where to display the linked URL, as the name for a browsing context.
   */
  target?: '_blank' | '_parent' | '_self' | '_top' | (string & {}) | null
  /**
   * A rel attribute value to apply on the link. Defaults to "noopener noreferrer" for external links.
   */
  rel?: 'noopener' | 'noreferrer' | 'nofollow' | 'sponsored' | 'ugc' | (string & {}) | null
  /**
   * If set to true, no rel attribute will be added to the link
   */
  noRel?: boolean
  /**
   * A class to apply to links that have been prefetched.
   */
  prefetchedClass?: string
  /**
   * When enabled will prefetch middleware, layouts and payloads of links in the viewport.
   */
  prefetch?: boolean
  /**
   * Allows controlling when to prefetch links. By default, prefetch is triggered only on visibility.
   */
  prefetchOn?: 'visibility' | 'interaction' | Partial<{
    visibility: boolean
    interaction: boolean
  }>
  /**
   * Escape hatch to disable `prefetch` attribute.
   */
  noPrefetch?: boolean
  /**
   * An option to either add or remove trailing slashes in the `href` for this specific link.
   * Overrides the global `trailingSlash` option if provided.
   */
  trailingSlash?: 'append' | 'remove'
}

/**
 * Create a NuxtLink component with given options as defaults.
 * @see https://nuxt.com/docs/4.x/api/components/nuxt-link
 */
export interface NuxtLinkOptions extends
  Partial<Pick<RouterLinkProps, 'activeClass' | 'exactActiveClass'>>,
  Partial<Pick<NuxtLinkProps, 'prefetch' | 'prefetchedClass'>> {
  /**
   * The name of the component.
   * @default "NuxtLink"
   */
  componentName?: string
  /**
   * A default `rel` attribute value applied on external links. Defaults to `"noopener noreferrer"`. Set it to `""` to disable.
   */
  externalRelAttribute?: string | null
  /**
   * An option to either add or remove trailing slashes in the `href`.
   * If unset or not matching the valid values `append` or `remove`, it will be ignored.
   */
  trailingSlash?: 'append' | 'remove'

  /**
   * Allows controlling default setting for when to prefetch links. By default, prefetch is triggered only on visibility.
   */
  prefetchOn?: Exclude<NuxtLinkProps['prefetchOn'], string>
}

type NuxtLinkDefaultSlotProps<CustomProp extends boolean = false> = CustomProp extends true
  ? {
      href: string
      navigate: (e?: MouseEvent) => Promise<void>
      prefetch: (nuxtApp?: NuxtApp) => Promise<void>
      route: (RouteLocation & { href: string }) | undefined
      rel: string | null
      target: '_blank' | '_parent' | '_self' | '_top' | (string & {}) | null
      isExternal: boolean
      isActive: false
      isExactActive: false
    }
  : UnwrapRef<UseLinkReturn>

type NuxtLinkSlots<CustomProp extends boolean = false> = {
  default?: (props: NuxtLinkDefaultSlotProps<CustomProp>) => VNode[]
}

/* @__NO_SIDE_EFFECTS__ */
export function defineNuxtLink (options: NuxtLinkOptions) {
  const componentName = options.componentName || 'NuxtLink'

  function checkPropConflicts (props: NuxtLinkProps, main: keyof NuxtLinkProps, sub: keyof NuxtLinkProps): void {
    if (import.meta.dev && props[main] !== undefined && props[sub] !== undefined) {
      console.warn(`[${componentName}] \`${main}\` and \`${sub}\` cannot be used together. \`${sub}\` will be ignored.`)
    }
  }

  function isHashLinkWithoutHashMode (link: unknown): boolean {
    return !hashMode && typeof link === 'string' && link.startsWith('#')
  }

  function resolveTrailingSlashBehavior (to: string, resolve: Router['resolve'], trailingSlash?: NuxtLinkOptions['trailingSlash']): string
  function resolveTrailingSlashBehavior (to: RouteLocationRaw, resolve: Router['resolve'], trailingSlash?: NuxtLinkOptions['trailingSlash']): Exclude<RouteLocationRaw, string>
  function resolveTrailingSlashBehavior (to: RouteLocationRaw | undefined, resolve: Router['resolve'], trailingSlash?: NuxtLinkOptions['trailingSlash']): RouteLocationRaw | RouteLocation | undefined {
    const effectiveTrailingSlash = trailingSlash ?? options.trailingSlash
    if (!to || (effectiveTrailingSlash !== 'append' && effectiveTrailingSlash !== 'remove')) {
      return to
    }

    if (typeof to === 'string') {
      return applyTrailingSlashBehavior(to, effectiveTrailingSlash)
    }

    const path = 'path' in to && to.path !== undefined ? to.path : resolve(to).path

    const resolvedPath = {
      ...to,
      name: undefined, // named routes would otherwise always override trailing slash behavior
      path: applyTrailingSlashBehavior(path, effectiveTrailingSlash),
    }

    return resolvedPath
  }

  function useNuxtLink (props: NuxtLinkProps) {
    const router = useRouter()
    const config = useRuntimeConfig()

    const hasTarget = computed(() => !!props.target && props.target !== '_self')

    // Lazily check whether to.value has a protocol
    const isAbsoluteUrl = computed(() => {
      const path = props.to || props.href || ''
      return typeof path === 'string' && hasProtocol(path, { acceptRelative: true })
    })

    const builtinRouterLink = resolveComponent('RouterLink') as string | typeof RouterLink
    const useBuiltinLink = builtinRouterLink && typeof builtinRouterLink !== 'string' ? builtinRouterLink.useLink : undefined

    // Resolving link type
    const isExternal = computed<boolean>(() => {
      // External prop is explicitly set
      if (props.external) {
        return true
      }

      const path = props.to || props.href || ''

      // When `to` is a route object then it's an internal link
      if (typeof path === 'object') {
        return false
      }

      return path === '' || isAbsoluteUrl.value
    })

    // Resolving `to` value from `to` and `href` props
    const to: ComputedRef<RouteLocationRaw> = computed(() => {
      checkPropConflicts(props, 'to', 'href')
      const path = props.to || props.href || '' // Defaults to empty string (won't render any `href` attribute)
      if (isExternal.value) { return path }
      return resolveTrailingSlashBehavior(path, router.resolve, props.trailingSlash)
    })

    const link = isExternal.value ? undefined : useBuiltinLink?.({ ...props, to })

    // Resolves `to` value if it's a route location object
    const href = computed(() => {
      const effectiveTrailingSlash = props.trailingSlash ?? options.trailingSlash
      if (!to.value || isAbsoluteUrl.value || isHashLinkWithoutHashMode(to.value)) {
        return to.value as string
      }

      if (isExternal.value) {
        const path = typeof to.value === 'object' && 'path' in to.value ? resolveRouteObject(to.value) : to.value
        // separately resolve route objects with a 'name' property and without 'path'
        const href = typeof path === 'object' ? router.resolve(path).href : path
        return applyTrailingSlashBehavior(href, effectiveTrailingSlash)
      }

      if (typeof to.value === 'object') {
        return router.resolve(to.value)?.href ?? null
      }

      return applyTrailingSlashBehavior(joinURL(config.app.baseURL, to.value), effectiveTrailingSlash)
    })

    return {
      to,
      hasTarget,
      isAbsoluteUrl,
      isExternal,
      //
      href,
      isActive: link?.isActive ?? computed(() => to.value === router.currentRoute.value.path),
      isExactActive: link?.isExactActive ?? computed(() => to.value === router.currentRoute.value.path),
      route: link?.route ?? computed(() => router.resolve(to.value)),
      async navigate (_e?: MouseEvent) {
        await navigateTo(href.value, { replace: props.replace, external: isExternal.value || hasTarget.value })
      },
    } satisfies ReturnType<typeof useLink> & {
      to: ComputedRef<RouteLocationRaw>
      hasTarget: ComputedRef<boolean | null | undefined>
      isAbsoluteUrl: ComputedRef<boolean>
      isExternal: ComputedRef<boolean>
    }
  }

  return defineComponent({
    name: componentName,
    props: {
      // Routing
      to: {
        type: [String, Object] as PropType<RouteLocationRaw>,
        default: undefined,
        required: false,
      },
      href: {
        type: [String, Object] as PropType<RouteLocationRaw>,
        default: undefined,
        required: false,
      },

      // Attributes
      target: {
        type: String as PropType<NuxtLinkProps['target']>,
        default: undefined,
        required: false,
      },
      rel: {
        type: String as PropType<NuxtLinkProps['rel']>,
        default: undefined,
        required: false,
      },
      noRel: {
        type: Boolean as PropType<NuxtLinkProps['noRel']>,
        default: undefined,
        required: false,
      },

      // Prefetching
      prefetch: {
        type: Boolean as PropType<NuxtLinkProps['prefetch']>,
        default: undefined,
        required: false,
      },
      prefetchOn: {
        type: [String, Object] as PropType<NuxtLinkProps['prefetchOn']>,
        default: undefined,
        required: false,
      },
      noPrefetch: {
        type: Boolean as PropType<NuxtLinkProps['noPrefetch']>,
        default: undefined,
        required: false,
      },

      // Styling
      activeClass: {
        type: String as PropType<NuxtLinkProps['activeClass']>,
        default: undefined,
        required: false,
      },
      exactActiveClass: {
        type: String as PropType<NuxtLinkProps['exactActiveClass']>,
        default: undefined,
        required: false,
      },
      prefetchedClass: {
        type: String as PropType<NuxtLinkProps['prefetchedClass']>,
        default: undefined,
        required: false,
      },

      // Vue Router's `<RouterLink>` additional props
      replace: {
        type: Boolean as PropType<NuxtLinkProps['replace']>,
        default: undefined,
        required: false,
      },
      ariaCurrentValue: {
        type: String as PropType<NuxtLinkProps['ariaCurrentValue']>,
        default: undefined,
        required: false,
      },

      // Edge cases handling
      external: {
        type: Boolean as PropType<NuxtLinkProps['external']>,
        default: undefined,
        required: false,
      },

      // Slot API
      custom: {
        type: Boolean as PropType<NuxtLinkProps['custom']>,
        default: undefined,
        required: false,
      },
      // Behavior
      trailingSlash: {
        type: String as PropType<NuxtLinkProps['trailingSlash']>,
        default: undefined,
        required: false,
      },
    },
    useLink: useNuxtLink,
    setup (props, { slots }) {
      const router = useRouter()

      const { to, href, navigate, isExternal, hasTarget, isAbsoluteUrl } = useNuxtLink(props)

      // Prefetching
      const prefetched = shallowRef(false)
      const el = import.meta.server ? undefined : ref<HTMLElement | null>(null)
      const elRef = import.meta.server ? undefined : (ref: any) => { el!.value = props.custom ? ref?.$el?.nextElementSibling : ref?.$el }

      function shouldPrefetch (mode: 'visibility' | 'interaction') {
        if (import.meta.server) { return }
        return !prefetched.value && (typeof props.prefetchOn === 'string' ? props.prefetchOn === mode : (props.prefetchOn?.[mode] ?? options.prefetchOn?.[mode])) && (props.prefetch ?? options.prefetch) !== false && props.noPrefetch !== true && props.target !== '_blank' && !isSlowConnection()
      }

      async function prefetch (nuxtApp = useNuxtApp()) {
        if (import.meta.server) { return }

        if (prefetched.value) { return }

        prefetched.value = true

        const path = typeof to.value === 'string'
          ? to.value
          : isExternal.value ? resolveRouteObject(to.value) : router.resolve(to.value).fullPath
        const normalizedPath = isExternal.value ? new URL(path, window.location.href).href : path
        await Promise.all([
          nuxtApp.hooks.callHook('link:prefetch', normalizedPath).catch(() => {}),
          !isExternal.value && !hasTarget.value && preloadRouteComponents(to.value as string, router).catch(() => {}),
        ])
      }

      if (import.meta.client) {
        checkPropConflicts(props, 'noPrefetch', 'prefetch')
        if (shouldPrefetch('visibility')) {
          const nuxtApp = useNuxtApp()
          let idleId: number
          let unobserve: (() => void) | null = null
          onMounted(() => {
            const observer = useObserver()
            onNuxtReady(() => {
              idleId = requestIdleCallback(() => {
                if (el?.value?.tagName) {
                  unobserve = observer!.observe(el.value as HTMLElement, async () => {
                    unobserve?.()
                    unobserve = null
                    await prefetch(nuxtApp)
                  })
                }
              })
            })
          })
          onBeforeUnmount(() => {
            if (idleId) { cancelIdleCallback(idleId) }
            unobserve?.()
            unobserve = null
          })
        }
      }

      if (import.meta.dev && import.meta.server && !props.custom) {
        const isNuxtLinkChild = inject(NuxtLinkDevKeySymbol, false)
        if (isNuxtLinkChild) {
          console.log('[nuxt] [NuxtLink] You can\'t nest one <a> inside another <a>. This will cause a hydration error on client-side. You can pass the `custom` prop to take full control of the markup.')
        } else {
          provide(NuxtLinkDevKeySymbol, true)
        }
      }

      return () => {
        if (!isExternal.value && !hasTarget.value && !isHashLinkWithoutHashMode(to.value)) {
          const routerLinkProps: RouterLinkProps & VNodeProps & AllowedComponentProps & AnchorHTMLAttributes = {
            ref: elRef,
            to: to.value,
            activeClass: props.activeClass || options.activeClass,
            exactActiveClass: props.exactActiveClass || options.exactActiveClass,
            replace: props.replace,
            ariaCurrentValue: props.ariaCurrentValue,
            custom: props.custom,
          }

          // `custom` API cannot support fallthrough attributes as the slot
          // may render fragment or text root nodes (#14897, #19375)
          if (!props.custom) {
            if (import.meta.client) {
              if (shouldPrefetch('interaction')) {
                routerLinkProps.onPointerenter = prefetch.bind(null, undefined)
                routerLinkProps.onFocus = prefetch.bind(null, undefined)
              }
              if (prefetched.value) {
                routerLinkProps.class = props.prefetchedClass || options.prefetchedClass
              }
            }
            routerLinkProps.rel = props.rel || undefined
          }

          // Internal link
          return h(
            resolveComponent('RouterLink'),
            routerLinkProps,
            slots.default,
          )
        }

        // Resolves `target` value
        const target = props.target || null

        // Resolves `rel`
        checkPropConflicts(props, 'noRel', 'rel')
        const rel = firstNonUndefined<string | null>(
          // converts `""` to `null` to prevent the attribute from being added as empty (`rel=""`)
          props.noRel ? '' : props.rel,
          options.externalRelAttribute,
          /*
          * A fallback rel of `noopener noreferrer` is applied for external links or links that open in a new tab.
          * This solves a reverse tabnapping security flaw in browsers pre-2021 as well as improving privacy.
          */
          (isAbsoluteUrl.value || hasTarget.value) ? 'noopener noreferrer' : '',
        ) || null

        // https://router.vuejs.org/api/interfaces/routerlinkprops#custom-
        if (props.custom) {
          if (!slots.default) {
            return null
          }

          return slots.default({
            href: href.value,
            navigate,
            prefetch,
            get route () {
              if (!href.value) { return undefined }

              const url = new URL(href.value, import.meta.client ? window.location.href : 'http://localhost')
              return {
                path: url.pathname,
                fullPath: url.pathname,
                get query () { return parseQuery(url.search) },
                hash: url.hash,
                params: {},
                name: undefined,
                matched: [],
                redirectedFrom: undefined,
                meta: {},
                href: href.value,
              } satisfies RouteLocation & { href: string }
            },
            rel,
            target,
            isExternal: isExternal.value || hasTarget.value,
            isActive: false,
            isExactActive: false,
          } satisfies NuxtLinkDefaultSlotProps<true>)
        }

        return h('a', {
          ref: el,
          href: href.value || null, // converts `""` to `null` to prevent the attribute from being added as empty (`href=""`)
          rel,
          target,
          onClick: (event) => {
            if (isExternal.value || hasTarget.value) {
              return
            }

            event.preventDefault()

            return props.replace
              ? router.replace(href.value)
              : router.push(href.value)
          },
        }, slots.default?.())
      }
    },
  }) as unknown as (new<CustomProp extends boolean = false>(props: NuxtLinkProps<CustomProp> & VNodeProps & AllowedComponentProps & Omit<AnchorHTMLAttributes, keyof NuxtLinkProps<CustomProp>>) => InstanceType<DefineSetupFnComponent<
    NuxtLinkProps<CustomProp> & VNodeProps & AllowedComponentProps & Omit<AnchorHTMLAttributes, keyof NuxtLinkProps<CustomProp>>,
    [],
    SlotsType<NuxtLinkSlots<CustomProp>>
  >>) & Record<string, any>
}

export default defineNuxtLink(nuxtLinkDefaults)

// -- NuxtLink utils --
function applyTrailingSlashBehavior (to: string, trailingSlash: NuxtLinkOptions['trailingSlash']): string {
  const normalizeFn = trailingSlash === 'append' ? withTrailingSlash : withoutTrailingSlash
  // Until https://github.com/unjs/ufo/issues/189 is resolved
  const hasProtocolDifferentFromHttp = hasProtocol(to) && !to.startsWith('http')
  if (hasProtocolDifferentFromHttp) {
    return to
  }
  return normalizeFn(to, true)
}

// --- Prefetching utils ---
type CallbackFn = () => void
type ObserveFn = (element: Element, callback: CallbackFn) => () => void

function useObserver (): { observe: ObserveFn } | undefined {
  if (import.meta.server) { return }

  const nuxtApp = useNuxtApp()
  if (nuxtApp._observer) {
    return nuxtApp._observer
  }

  let observer: IntersectionObserver | null = null

  const callbacks = new Map<Element, CallbackFn>()

  const observe: ObserveFn = (element, callback) => {
    observer ||= new IntersectionObserver((entries) => {
      for (const entry of entries) {
        const callback = callbacks.get(entry.target)
        const isVisible = entry.isIntersecting || entry.intersectionRatio > 0
        if (isVisible && callback) { callback() }
      }
    })
    callbacks.set(element, callback)
    observer.observe(element)
    return () => {
      callbacks.delete(element)
      observer?.unobserve(element)
      if (callbacks.size === 0) {
        observer?.disconnect()
        observer = null
      }
    }
  }

  const _observer = nuxtApp._observer = {
    observe,
  }

  return _observer
}

const IS_2G_RE = /2g/
function isSlowConnection () {
  if (import.meta.server) { return }

  // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/connection
  const cn = (navigator as any).connection as { saveData: boolean, effectiveType: string } | null
  if (cn && (cn.saveData || IS_2G_RE.test(cn.effectiveType))) { return true }
  return false
}
</file>

<file path="packages/nuxt/src/app/components/nuxt-loading-indicator.ts">
import { defineComponent, h } from 'vue'
import { useLoadingIndicator } from '../composables/loading-indicator'

export default defineComponent({
  name: 'NuxtLoadingIndicator',
  props: {
    throttle: {
      type: Number,
      default: 200,
    },
    duration: {
      type: Number,
      default: 2000,
    },
    hideDelay: {
      type: Number,
      default: 500,
    },
    resetDelay: {
      type: Number,
      default: 400,
    },
    height: {
      type: Number,
      default: 3,
    },
    color: {
      type: [String, Boolean],
      default: 'repeating-linear-gradient(to right,#00dc82 0%,#34cdfe 50%,#0047e1 100%)',
    },
    errorColor: {
      type: String,
      default: 'repeating-linear-gradient(to right,#f87171 0%,#ef4444 100%)',
    },
    estimatedProgress: {
      type: Function as unknown as () => (duration: number, elapsed: number) => number,
      required: false,
    },
  },
  setup (props, { slots, expose }) {
    const { progress, isLoading, error, start, finish, clear } = useLoadingIndicator({
      duration: props.duration,
      throttle: props.throttle,
      hideDelay: props.hideDelay,
      resetDelay: props.resetDelay,
      estimatedProgress: props.estimatedProgress,
    })

    expose({
      progress, isLoading, error, start, finish, clear,
    })

    return () => h('div', {
      class: 'nuxt-loading-indicator',
      style: {
        position: 'fixed',
        top: 0,
        right: 0,
        left: 0,
        pointerEvents: 'none',
        width: 'auto',
        height: `${props.height}px`,
        opacity: isLoading.value ? 1 : 0,
        background: error.value ? props.errorColor : props.color || undefined,
        backgroundSize: `${progress.value > 0 ? (100 / progress.value) * 100 : 0}% auto`,
        transform: `scaleX(${progress.value}%)`,
        transformOrigin: 'left',
        transition: 'transform 0.1s, height 0.4s, opacity 0.4s',
        zIndex: 999999,
      },
    }, slots)
  },
})
</file>

<file path="packages/nuxt/src/app/components/nuxt-root.vue">
<template>
  <Suspense @resolve="onResolve">
    <div v-if="abortRender" />
    <ErrorComponent
      v-else-if="error"
      :error="error"
    />
    <IslandRenderer
      v-else-if="islandContext"
      :context="islandContext"
    />
    <component
      :is="SingleRenderer"
      v-else-if="SingleRenderer"
    />
    <AppComponent v-else />
  </Suspense>
</template>

<script setup>
import { defineAsyncComponent, onErrorCaptured, onServerPrefetch, provide } from 'vue'
import { useNuxtApp } from '../nuxt'
import { isNuxtError, showError, useError } from '../composables/error'
import { useRoute, useRouter } from '../composables/router'
import { PageRouteSymbol } from '../components/injections'
import AppComponent from '#build/app-component.mjs'
import ErrorComponent from '#build/error-component.mjs'
// @ts-expect-error virtual file
import { componentIslands } from '#build/nuxt.config.mjs'

const IslandRenderer = import.meta.server && componentIslands
  ? defineAsyncComponent(() => import('./island-renderer').then(r => r.default || r))
  : () => null

const nuxtApp = useNuxtApp()
const onResolve = nuxtApp.deferHydration()
if (import.meta.client && nuxtApp.isHydrating) {
  const removeErrorHook = nuxtApp.hooks.hookOnce('app:error', onResolve)
  useRouter().beforeEach(removeErrorHook)
}

const url = import.meta.server ? nuxtApp.ssrContext.url : window.location.pathname
const SingleRenderer = import.meta.test && import.meta.dev && import.meta.server && url.startsWith('/__nuxt_component_test__/') && defineAsyncComponent(() => import('#build/test-component-wrapper.mjs')
  .then(r => r.default(import.meta.server ? url : window.location.href)))

// Inject default route (outside of pages) as active route
provide(PageRouteSymbol, useRoute())

// vue:setup hook
const results = nuxtApp.hooks.callHookWith(hooks => hooks.map(hook => hook()), 'vue:setup')
if (import.meta.dev && results && results.some(i => i && 'then' in i)) {
  console.error('[nuxt] Error in `vue:setup`. Callbacks must be synchronous.')
}

// error handling
const error = useError()
// render an empty <div> when plugins have thrown an error but we're not yet rendering the error page
const abortRender = import.meta.server && error.value && !nuxtApp.ssrContext.error
const BOT_RE = /bot\b|chrome-lighthouse|facebookexternalhit|google\b/i
onErrorCaptured((err, target, info) => {
  nuxtApp.hooks.callHook('vue:error', err, target, info).catch(hookError => console.error('[nuxt] Error in `vue:error` hook', hookError))
  if (import.meta.client && BOT_RE.test(navigator.userAgent)) {
    nuxtApp.hooks.callHook('app:error', err)
    console.error(`[nuxt] Not rendering error page for bot with user agent \`${navigator.userAgent}\`:`, err)
    return false
  }
  if (import.meta.server || (isNuxtError(err) && (err.fatal || err.unhandled))) {
    const p = nuxtApp.runWithContext(() => showError(err))
    onServerPrefetch(() => p)
    return false // suppress error from breaking render
  }
})

// Component islands context
const islandContext = import.meta.server && nuxtApp.ssrContext.islandContext
</script>
</file>

<file path="packages/nuxt/src/app/components/nuxt-route-announcer.ts">
import { defineComponent, h } from 'vue'
import type { Politeness } from 'nuxt/app'
import { useRouteAnnouncer } from '../composables/route-announcer'

export default defineComponent({
  name: 'NuxtRouteAnnouncer',
  props: {
    atomic: {
      type: Boolean,
      default: false,
    },
    politeness: {
      type: String as () => Politeness,
      default: 'polite',
    },
  },
  setup (props, { slots, expose }) {
    const { set, polite, assertive, message, politeness } = useRouteAnnouncer({ politeness: props.politeness })

    expose({
      set, polite, assertive, message, politeness,
    })

    return () => h('span', {
      class: 'nuxt-route-announcer',
      style: {
        position: 'absolute',
      },
    }, h('span', {
      'role': 'alert',
      'aria-live': politeness.value,
      'aria-atomic': props.atomic,
      'style': {
        'border': '0',
        'clip': 'rect(0 0 0 0)',
        'clip-path': 'inset(50%)',
        'height': '1px',
        'width': '1px',
        'overflow': 'hidden',
        'position': 'absolute',
        'white-space': 'nowrap',
        'word-wrap': 'normal',
        'margin': '-1px',
        'padding': '0',
      },
    }, slots.default ? slots.default({ message: message.value }) : message.value))
  },
})
</file>

<file path="packages/nuxt/src/app/components/nuxt-stubs.ts">
import { createError } from '../composables/error'

function renderStubMessage (name: string): never {
  throw createError({
    fatal: true,
    status: 500,
    statusText: `${name} is provided by @nuxt/image. Check your console to install it or run 'npx nuxt module add @nuxt/image'`,
  })
}

export const NuxtImg = {
  setup: () => renderStubMessage('<NuxtImg>'),
}

export const NuxtPicture = {
  setup: () => renderStubMessage('<NuxtPicture>'),
}
</file>

<file path="packages/nuxt/src/app/components/nuxt-teleport-island-component.ts">
import type { Component, InjectionKey } from 'vue'
import { Teleport, defineComponent, h, inject, provide, useId } from 'vue'
import { useNuxtApp } from '../nuxt'
// @ts-expect-error virtual file
import paths from '#build/component-chunk'
// @ts-expect-error virtual file
import { buildAssetsURL } from '#internal/nuxt/paths'

type ExtendedComponent = Component & {
  __file: string
  __name: string
}

export const NuxtTeleportIslandSymbol = Symbol('NuxtTeleportIslandComponent') as InjectionKey<false | string>

/**
 * component only used with componentsIsland
 * this teleport the component in SSR only if it needs to be hydrated on client
 */
/* @__PURE__ */
export default defineComponent({
  name: 'NuxtTeleportIslandComponent',
  inheritAttrs: false,
  props: {
    nuxtClient: {
      type: Boolean,
      default: false,
    },
  },
  setup (props, { slots }) {
    const nuxtApp = useNuxtApp()
    const to = useId()

    // if there's already a teleport parent, we don't need to teleport or to render the wrapped component client side
    if (!nuxtApp.ssrContext?.islandContext || !props.nuxtClient || inject(NuxtTeleportIslandSymbol, false)) { return () => slots.default?.() }

    provide(NuxtTeleportIslandSymbol, to)
    const islandContext = nuxtApp.ssrContext!.islandContext!

    return () => {
      const slot = slots.default!()[0]!
      const slotType = slot.type as ExtendedComponent
      const name = (slotType.__name || slotType.name) as string

      islandContext.components[to] = {
        chunk: import.meta.dev ? buildAssetsURL(paths[name]) : paths[name],
        props: slot.props || {},
      }

      return [h('div', {
        'style': 'display: contents;',
        'data-island-uid': '',
        'data-island-component': to,
      }, []), h(Teleport, { to }, slot)]
    }
  },
})
</file>

<file path="packages/nuxt/src/app/components/nuxt-teleport-island-slot.ts">
import type { VNode } from 'vue'
import { Teleport, createVNode, defineComponent, h, inject } from 'vue'
import { useNuxtApp } from '../nuxt'
import { NuxtTeleportIslandSymbol } from './nuxt-teleport-island-component'

/**
 * component only used within islands for slot teleport
 */
/* @__PURE__ */
export default defineComponent({
  name: 'NuxtTeleportIslandSlot',
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      required: true,
    },
    /**
     * must be an array to handle v-for
     */
    props: {
      type: Object as () => Array<any>,
    },
  },
  setup (props, { slots }) {
    const nuxtApp = useNuxtApp()
    const islandContext = nuxtApp.ssrContext?.islandContext
    if (!islandContext) {
      return () => slots.default?.()[0]
    }

    const componentName = inject(NuxtTeleportIslandSymbol, false)
    islandContext.slots[props.name] = {
      props: (props.props || []) as unknown[],
    }

    return () => {
      const vnodes: VNode[] = []

      if (nuxtApp.ssrContext?.islandContext && slots.default) {
        vnodes.push(h('div', {
          'style': 'display: contents;',
          'data-island-uid': '',
          'data-island-slot': props.name,
        }, {
          // Teleport in slot to not be hydrated client-side with the staticVNode
          default: () => [createVNode(Teleport, { to: `island-slot=${componentName};${props.name}` }, slots.default?.())],
        }))
      } else {
        vnodes.push(h('div', {
          'style': 'display: contents;',
          'data-island-uid': '',
          'data-island-slot': props.name,
        }))
      }

      if (slots.fallback) {
        vnodes.push(h(Teleport, { to: `island-fallback=${props.name}` }, slots.fallback()))
      }

      return vnodes
    }
  },
})
</file>

<file path="packages/nuxt/src/app/components/nuxt-time.vue">
<script setup lang="ts">
import { computed, getCurrentInstance, onBeforeUnmount, ref } from 'vue'
import { onPrehydrate } from '../composables/ssr'
import { useNuxtApp } from '../nuxt'

export interface NuxtTimeProps {
  locale?: string
  datetime: string | number | Date
  localeMatcher?: 'best fit' | 'lookup'
  weekday?: 'long' | 'short' | 'narrow'
  era?: 'long' | 'short' | 'narrow'
  year?: 'numeric' | '2-digit'
  month?: 'numeric' | '2-digit' | 'long' | 'short' | 'narrow'
  day?: 'numeric' | '2-digit'
  hour?: 'numeric' | '2-digit'
  minute?: 'numeric' | '2-digit'
  second?: 'numeric' | '2-digit'
  timeZoneName?: 'short' | 'long' | 'shortOffset' | 'longOffset' | 'shortGeneric' | 'longGeneric'
  formatMatcher?: 'best fit' | 'basic'
  hour12?: boolean
  timeZone?: string

  calendar?: string
  dayPeriod?: 'narrow' | 'short' | 'long'
  numberingSystem?: string

  dateStyle?: 'full' | 'long' | 'medium' | 'short'
  timeStyle?: 'full' | 'long' | 'medium' | 'short'
  hourCycle?: 'h11' | 'h12' | 'h23' | 'h24'

  relative?: boolean
  numeric?: 'always' | 'auto'
  relativeStyle?: 'long' | 'short' | 'narrow'

  title?: boolean | string
}

const props = withDefaults(defineProps<NuxtTimeProps>(), {
  hour12: undefined,
})

const el = getCurrentInstance()?.vnode.el
const renderedDate = el?.getAttribute('datetime')
const _locale = el?.getAttribute('data-locale')

const nuxtApp = useNuxtApp()

const date = computed(() => {
  const date = props.datetime
  if (renderedDate && nuxtApp.isHydrating) { return new Date(renderedDate) }
  if (!props.datetime) { return new Date() }
  return new Date(date)
})

const now = ref(import.meta.client && nuxtApp.isHydrating && window._nuxtTimeNow ? new Date(window._nuxtTimeNow) : new Date())
if (import.meta.client && props.relative) {
  const handler = () => {
    now.value = new Date()
  }
  const interval = setInterval(handler, 1000)
  onBeforeUnmount(() => clearInterval(interval))
}

const formatter = computed(() => {
  const { locale: propsLocale, relative, relativeStyle, ...rest } = props
  if (relative) {
    return new Intl.RelativeTimeFormat(_locale ?? propsLocale, { ...rest, style: relativeStyle })
  }
  return new Intl.DateTimeFormat(_locale ?? propsLocale, rest)
})

const formattedDate = computed(() => {
  if (!props.relative) {
    return (formatter.value as Intl.DateTimeFormat).format(date.value)
  }

  const diffInSeconds = (date.value.getTime() - now.value.getTime()) / 1000

  const units: Array<{
    unit: Intl.RelativeTimeFormatUnit
    seconds: number
    threshold: number
  }> = [
    { unit: 'second', seconds: 1, threshold: 60 }, // 60 seconds → minute
    { unit: 'minute', seconds: 60, threshold: 60 }, // 60 minutes → hour
    { unit: 'hour', seconds: 3600, threshold: 24 }, // 24 hours → day
    { unit: 'day', seconds: 86400, threshold: 30 }, // ~30 days → month
    { unit: 'month', seconds: 2592000, threshold: 12 }, // 12 months → year
    { unit: 'year', seconds: 31536000, threshold: Infinity },
  ]

  const { unit, seconds } = units.find(({ seconds, threshold }) => Math.abs(diffInSeconds / seconds) < threshold) || units[units.length - 1]!

  const value = diffInSeconds / seconds
  return (formatter.value as Intl.RelativeTimeFormat).format(Math.round(value), unit)
})

const isoDate = computed(() => date.value.toISOString())
const title = computed(() => props.title === true ? isoDate.value : typeof props.title === 'string' ? props.title : undefined)
const dataset: Record<string, string | number | boolean | Date | undefined> = {}

if (import.meta.server) {
  for (const prop in props) {
    if (prop !== 'datetime') {
      const value = props?.[prop as keyof typeof props]
      if (value) {
        const propInKebabCase = prop.split(/(?=[A-Z])/).join('-')
        dataset[`data-${propInKebabCase}`] = props?.[prop as keyof typeof props]
      }
    }
  }
  onPrehydrate((el) => {
    const now = window._nuxtTimeNow ||= Date.now()
    const toCamelCase = (name: string, index: number) => {
      if (index > 0) {
        return name[0]!.toUpperCase() + name.slice(1)
      }
      return name
    }

    const date = new Date(el.getAttribute('datetime')!)
    const options: Intl.DateTimeFormatOptions & Intl.RelativeTimeFormatOptions & { locale?: Intl.LocalesArgument, relative?: boolean } = {}
    for (const name of el.getAttributeNames()) {
      if (name.startsWith('data-')) {
        let optionName = name.slice(5).split('-').map(toCamelCase).join('') as keyof (Intl.DateTimeFormatOptions & Intl.RelativeTimeFormatOptions)

        if ((optionName as string) === 'relativeStyle') {
          optionName = 'style'
        }

        options[optionName] = el.getAttribute(name) as any
      }
    }

    if (options.relative) {
      const diffInSeconds = (date.getTime() - now) / 1000
      const units: Array<{
        unit: Intl.RelativeTimeFormatUnit
        seconds: number
        threshold: number
      }> = [
        { unit: 'second', seconds: 1, threshold: 60 }, // 60 seconds → minute
        { unit: 'minute', seconds: 60, threshold: 60 }, // 60 minutes → hour
        { unit: 'hour', seconds: 3600, threshold: 24 }, // 24 hours → day
        { unit: 'day', seconds: 86400, threshold: 30 }, // ~30 days → month
        { unit: 'month', seconds: 2592000, threshold: 12 }, // 12 months → year
        { unit: 'year', seconds: 31536000, threshold: Infinity },
      ]
      const { unit, seconds } = units.find(({ seconds, threshold }) => Math.abs(diffInSeconds / seconds) < threshold) || units[units.length - 1]!
      const value = diffInSeconds / seconds
      const formatter = new Intl.RelativeTimeFormat(options.locale, options)
      el.textContent = formatter.format(Math.round(value), unit)
    } else {
      const formatter = new Intl.DateTimeFormat(options.locale, options)
      el.textContent = formatter.format(date)
    }
  })
}

declare global {
  interface Window {
    _nuxtTimeNow?: number
  }
}
</script>

<template>
  <time
    v-bind="dataset"
    :datetime="isoDate"
    :title="title"
  >{{ formattedDate }}</time>
</template>
</file>

<file path="packages/nuxt/src/app/components/route-provider.ts">
import { defineComponent, h, nextTick, onMounted, provide, shallowReactive } from 'vue'
import type { Ref, VNode } from 'vue'
import type { RouteLocationNormalizedLoaded } from 'vue-router'
import { PageRouteSymbol } from './injections'

export const defineRouteProvider = (name = 'RouteProvider') => defineComponent({
  name,
  props: {
    route: {
      type: Object as () => RouteLocationNormalizedLoaded,
      required: true,
    },
    vnode: Object as () => VNode,
    vnodeRef: Object as () => Ref<any>,
    renderKey: String,
    trackRootNodes: Boolean,
  },
  setup (props) {
    // Prevent reactivity when the page will be rerendered in a different suspense fork
    const previousKey = props.renderKey
    const previousRoute = props.route

    // Provide a reactive route within the page
    const route = {} as RouteLocationNormalizedLoaded
    for (const key in props.route) {
      Object.defineProperty(route, key, {
        get: () => previousKey === props.renderKey ? props.route[key as keyof RouteLocationNormalizedLoaded] : previousRoute[key as keyof RouteLocationNormalizedLoaded],
        enumerable: true,
      })
    }

    provide(PageRouteSymbol, shallowReactive(route))

    let vnode: VNode
    if (import.meta.dev && import.meta.client && props.trackRootNodes) {
      onMounted(() => {
        nextTick(() => {
          if (['#comment', '#text'].includes(vnode?.el?.nodeName)) {
            const filename = (vnode?.type as any)?.__file
            console.warn(`[nuxt] \`${filename}\` does not have a single root node and will cause errors when navigating between routes.`)
          }
        })
      })
    }

    return () => {
      if (!props.vnode) {
        return props.vnode
      }
      if (import.meta.dev && import.meta.client) {
        vnode = h(props.vnode, { ref: props.vnodeRef })
        return vnode
      }

      return h(props.vnode, { ref: props.vnodeRef })
    }
  },
})

export const RouteProvider = defineRouteProvider()
</file>

<file path="packages/nuxt/src/app/components/server-placeholder.ts">
import { createElementBlock, defineComponent } from 'vue'

export default defineComponent({
  name: 'ServerPlaceholder',
  render () {
    return createElementBlock('div')
  },
})
</file>

<file path="packages/nuxt/src/app/components/test-component-wrapper.ts">
import { defineComponent, h } from 'vue'
import { parseQuery } from 'vue-router'
import { resolve } from 'pathe'
import destr from 'destr'
// @ts-expect-error virtual file
import { devRootDir } from '#build/nuxt.config.mjs'

export default (url: string) => defineComponent({
  name: 'NuxtTestComponentWrapper',
  inheritAttrs: false,
  async setup (props, { attrs }) {
    const query = parseQuery(new URL(url, 'http://localhost').search)
    const urlProps = query.props ? destr<Record<string, any>>(query.props as string) : {}
    const path = resolve(query.path as string)
    if (!path.startsWith(devRootDir)) {
      throw new Error(`[nuxt] Cannot access path outside of project root directory: \`${path}\`.`)
    }
    const comp = await import(/* @vite-ignore */ path as string).then(r => r.default)
    return () => [
      h('div', 'Component Test Wrapper for ' + path),
      h('div', { id: 'nuxt-component-root' }, [
        h(comp, { ...attrs, ...props, ...urlProps }),
      ]),
    ]
  },
})
</file>

<file path="packages/nuxt/src/app/components/utils.ts">
import { Transition, createStaticVNode, h } from 'vue'
import type { RendererNode, VNode } from 'vue'
// eslint-disable-next-line
import { isString, isPromise, isArray, isObject } from '@vue/shared'
import type { RouteLocationNormalized } from 'vue-router'
// @ts-expect-error virtual file
import { START_LOCATION } from '#build/pages'

/**
 * Internal utility
 * @private
 */
export const _wrapInTransition = (props: any, children: any) => {
  return { default: () => import.meta.client && props ? h(Transition, props === true ? {} : props, children) : children.default?.() }
}

const ROUTE_KEY_PARENTHESES_RE = /(:\w+)\([^)]+\)/g
const ROUTE_KEY_SYMBOLS_RE = /(:\w+)[?+*]/g
const ROUTE_KEY_NORMAL_RE = /:\w+/g
// TODO: consider refactoring into single utility
// See https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/pages/runtime/utils.ts#L8-L19
function generateRouteKey (route: RouteLocationNormalized) {
  const source = route?.meta.key ?? route.path
    .replace(ROUTE_KEY_PARENTHESES_RE, '$1')
    .replace(ROUTE_KEY_SYMBOLS_RE, '$1')
    .replace(ROUTE_KEY_NORMAL_RE, r => route.params[r.slice(1)]?.toString() || '')
  return typeof source === 'function' ? source(route) : source
}

/**
 * Utility used within router guards
 * return true if the route has been changed with a page change during navigation
 */
export function isChangingPage (to: RouteLocationNormalized, from: RouteLocationNormalized) {
  if (to === from || from === START_LOCATION) { return false }

  // If route keys are different then it will result in a rerender
  if (generateRouteKey(to) !== generateRouteKey(from)) { return true }

  const areComponentsSame = to.matched.every((comp, index) =>
    comp.components && comp.components.default === from.matched[index]?.components?.default,
  )
  if (areComponentsSame) {
    return false
  }
  return true
}

export type SSRBuffer = SSRBufferItem[] & { hasAsync?: boolean }
export type SSRBufferItem = string | SSRBuffer | Promise<SSRBuffer>

/**
 * create buffer retrieved from @vue/server-renderer
 * @see https://github.com/vuejs/core/blob/9617dd4b2abc07a5dc40de6e5b759e851b4d0da1/packages/server-renderer/src/render.ts#L57
 * @private
 */
export function createBuffer () {
  let appendable = false
  const buffer: SSRBuffer = []
  return {
    getBuffer (): SSRBuffer {
      return buffer
    },
    push (item: SSRBufferItem) {
      const isStringItem = isString(item)
      if (appendable && isStringItem) {
        buffer[buffer.length - 1] += item as string
      } else {
        buffer.push(item)
      }
      appendable = isStringItem
      if (isPromise(item) || (isArray(item) && item.hasAsync)) {
        buffer.hasAsync = true
      }
    },
  }
}

/**
 * helper for NuxtIsland to generate a correct array for scoped data
 */
export function vforToArray (source: any): any[] {
  if (isArray(source)) {
    return source
  } else if (isString(source)) {
    return source.split('')
  } else if (typeof source === 'number') {
    if (import.meta.dev && !Number.isInteger(source)) {
      console.warn(`The v-for range expect an integer value but got ${source}.`)
    }
    const array: number[] = []
    for (let i = 0; i < source; i++) {
      array[i] = i
    }
    return array
  } else if (isObject(source)) {
    if (source[Symbol.iterator as any]) {
      return Array.from(source as Iterable<any>, item =>
        item,
      )
    } else {
      const keys = Object.keys(source)
      const array = new Array(keys.length)
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i]!
        array[i] = source[key]
      }
      return array
    }
  }
  return []
}

/**
 * Retrieve the HTML content from an element
 * Handles `<!--[-->` Fragment elements
 * @param element the element to retrieve the HTML
 * @param withoutSlots purge all slots from the HTML string retrieved
 * @returns {string[]|undefined} An array of string which represent the content of each element. Use `.join('')` to retrieve a component vnode.el HTML
 */
export function getFragmentHTML (element: RendererNode | null, withoutSlots = false): string[] | undefined {
  if (element) {
    if (element.nodeName === '#comment' && element.nodeValue === '[') {
      return getFragmentChildren(element, [], withoutSlots)
    }
    if (withoutSlots) {
      const clone = element.cloneNode(true)
      clone.querySelectorAll('[data-island-slot]').forEach((n: Element) => { n.innerHTML = '' })
      return [clone.outerHTML]
    }
    return [element.outerHTML]
  }
}

function getFragmentChildren (element: RendererNode | null, blocks: string[] = [], withoutSlots = false) {
  if (element && element.nodeName) {
    if (isEndFragment(element)) {
      return blocks
    } else if (!isStartFragment(element)) {
      const clone = element.cloneNode(true) as Element
      if (withoutSlots) {
        clone.querySelectorAll?.('[data-island-slot]').forEach((n) => { n.innerHTML = '' })
      }
      blocks.push(clone.outerHTML)
    }

    getFragmentChildren(element.nextSibling, blocks, withoutSlots)
  }
  return blocks
}

/**
 * Return a static vnode from an element
 * Default to a div if the element is not found and if a fallback is not provided
 * @param el renderer node retrieved from the component internal instance
 * @param staticNodeFallback fallback string to use if the element is not found. Must be a valid HTML string
 */
export function elToStaticVNode (el: RendererNode | null, staticNodeFallback?: string): VNode {
  const fragment: string[] | undefined = el ? getFragmentHTML(el) : staticNodeFallback ? [staticNodeFallback] : undefined
  if (fragment) {
    return createStaticVNode(fragment.join(''), fragment.length)
  }
  return h('div')
}

export function isStartFragment (element: RendererNode) {
  return element.nodeName === '#comment' && element.nodeValue === '['
}

export function isEndFragment (element: RendererNode) {
  return element.nodeName === '#comment' && element.nodeValue === ']'
}
</file>

<file path="packages/nuxt/src/app/composables/asyncContext.ts">
// @ts-expect-error withAsyncContext is internal API
import { getCurrentInstance, withAsyncContext as withVueAsyncContext } from 'vue'

/** @since 3.8.0 */
export function withAsyncContext (fn: () => PromiseLike<unknown>) {
  return withVueAsyncContext(() => {
    const nuxtApp = getCurrentInstance()?.appContext.app.$nuxt
    return nuxtApp ? nuxtApp.runWithContext(fn) : fn()
  })
}
</file>

<file path="packages/nuxt/src/app/composables/asyncData.ts">
import { computed, getCurrentInstance, getCurrentScope, inject, isShallow, nextTick, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, queuePostFlushCb, ref, shallowRef, toRef, toValue, unref, watch } from 'vue'
import type { MaybeRefOrGetter, MultiWatchSources, Ref } from 'vue'
import { debounce } from 'perfect-debounce'
import { hash } from 'ohash'
import type { NuxtApp } from '../nuxt'
import { useNuxtApp } from '../nuxt'
import { getUserCaller, toArray } from '../utils'
import { clientOnlySymbol } from '../components/client-only'
import type { NuxtError } from './error'
import { createError } from './error'
import { onNuxtReady } from './ready'

// @ts-expect-error virtual file
import { asyncDataDefaults, granularCachedData, pendingWhenIdle, purgeCachedData } from '#build/nuxt.config.mjs'

export type AsyncDataRequestStatus = 'idle' | 'pending' | 'success' | 'error'

export type _Transform<Input = any, Output = any> = (input: Input) => Output | Promise<Output>

export type AsyncDataHandler<ResT> = (nuxtApp: NuxtApp, options: { signal: AbortSignal }) => Promise<ResT>

export type PickFrom<T, K extends Array<string>> = T extends Array<any>
  ? T
  : T extends Record<string, any>
    ? keyof T extends K[number]
      ? T // Exact same keys as the target, skip Pick
      : K[number] extends never
        ? T
        : Pick<T, K[number]>
    : T

export type KeysOf<T> = Array<
  T extends T // Include all keys of union types, not just common keys
    ? keyof T extends string
      ? keyof T
      : never
    : never
>

export type KeyOfRes<Transform extends _Transform> = KeysOf<ReturnType<Transform>>

export type { MultiWatchSources }

export type NoInfer<T> = [T][T extends any ? 0 : never]

export type AsyncDataRefreshCause = 'initial' | 'refresh:hook' | 'refresh:manual' | 'watch'

export interface AsyncDataOptions<
  ResT,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> {
  /**
   * Whether to fetch on the server side.
   * @default true
   */
  server?: boolean
  /**
   * Whether to resolve the async function after loading the route, instead of blocking client-side navigation
   * @default false
   */
  lazy?: boolean
  /**
   * a factory function to set the default value of the data, before the async function resolves - useful with the `lazy: true` or `immediate: false` options
   */
  default?: () => DefaultT | Ref<DefaultT>
  /**
   * Provide a function which returns cached data.
   * An `undefined` return value will trigger a fetch.
   * Default is `key => nuxt.isHydrating ? nuxt.payload.data[key] : nuxt.static.data[key]` which only caches data when payloadExtraction is enabled.
   */
  getCachedData?: (key: string, nuxtApp: NuxtApp, context: { cause: AsyncDataRefreshCause }) => NoInfer<DataT> | undefined
  /**
   * A function that can be used to alter handler function result after resolving.
   * Do not use it along with the `pick` option.
   */
  transform?: _Transform<ResT, DataT>
  /**
   * Only pick specified keys in this array from the handler function result.
   * Do not use it along with the `transform` option.
   */
  pick?: PickKeys
  /**
   * Watch reactive sources to auto-refresh when changed
   */
  watch?: MultiWatchSources
  /**
   * When set to false, will prevent the request from firing immediately
   * @default true
   */
  immediate?: boolean
  /**
   * Return data in a deep ref object (it is false by default). It can be set to false to return data in a shallow ref object, which can improve performance if your data does not need to be deeply reactive.
   */
  deep?: boolean
  /**
   * Avoid fetching the same key more than once at a time
   * @default 'cancel'
   */
  dedupe?: 'cancel' | 'defer'
  /**
   * A timeout in milliseconds after which the request will be aborted if it has not resolved yet.
   */
  timeout?: number
}

export interface AsyncDataExecuteOptions {
  /**
   * Force a refresh, even if there is already a pending request. Previous requests will
   * not be cancelled, but their result will not affect the data/pending state - and any
   * previously awaited promises will not resolve until this new request resolves.
   */
  dedupe?: 'cancel' | 'defer'

  cause?: AsyncDataRefreshCause

  /** @internal */
  cachedData?: any

  signal?: AbortSignal

  timeout?: number
}

export interface _AsyncData<DataT, ErrorT> {
  data: Ref<DataT>
  pending: Ref<boolean>
  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>
  execute: (opts?: AsyncDataExecuteOptions) => Promise<void>
  clear: () => void
  error: Ref<ErrorT | undefined>
  status: Ref<AsyncDataRequestStatus>
}

export type AsyncData<Data, Error> = _AsyncData<Data, Error> & Promise<_AsyncData<Data, Error>>

/**
 * Provides access to data that resolves asynchronously in an SSR-friendly composable.
 * See {@link https://nuxt.com/docs/4.x/api/composables/use-async-data}
 * @since 3.0.0
 * @param handler An asynchronous function that must return a truthy value (for example, it should not be `undefined` or `null`) or the request may be duplicated on the client side.
 * @param options customize the behavior of useAsyncData
 */
export function useAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (
  handler: AsyncDataHandler<ResT>,
  options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>
export function useAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = DataT,
> (
  handler: AsyncDataHandler<ResT>,
  options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>
/**
 * Provides access to data that resolves asynchronously in an SSR-friendly composable.
 * See {@link https://nuxt.com/docs/4.x/api/composables/use-async-data}
 * @param key A unique key to ensure that data fetching can be properly de-duplicated across requests.
 * @param handler An asynchronous function that must return a truthy value (for example, it should not be `undefined` or `null`) or the request may be duplicated on the client side.
 * @param options customize the behavior of useAsyncData
 */
export function useAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (
  key: MaybeRefOrGetter<string>,
  handler: AsyncDataHandler<ResT>,
  options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>
export function useAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = DataT,
> (
  key: MaybeRefOrGetter<string>,
  handler: AsyncDataHandler<ResT>,
  options?: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>
export function useAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (...args: any[]): AsyncData<PickFrom<DataT, PickKeys>, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined> {
  const autoKey = typeof args[args.length - 1] === 'string' ? args.pop() : undefined
  if (_isAutoKeyNeeded(args[0], args[1])) { args.unshift(autoKey) }

  // eslint-disable-next-line prefer-const
  let [_key, _handler, options = {}] = args as [string, AsyncDataHandler<ResT>, AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>]
  let keyChanging = false

  // Validate arguments
  const key = computed(() => toValue(_key)!)
  if (typeof key.value !== 'string') {
    throw new TypeError('[nuxt] [useAsyncData] key must be a string.')
  }
  if (typeof _handler !== 'function') {
    throw new TypeError('[nuxt] [useAsyncData] handler must be a function.')
  }

  // Setup nuxt instance payload
  const nuxtApp = useNuxtApp()

  // Apply defaults
  options.server ??= true
  options.default ??= getDefault as () => DefaultT
  options.getCachedData ??= getDefaultCachedData

  options.lazy ??= false
  options.immediate ??= true
  options.deep ??= asyncDataDefaults.deep
  options.dedupe ??= 'cancel'

  // @ts-expect-error private property
  const functionName = options._functionName || 'useAsyncData'

  // check and warn if different defaults/fetcher are provided
  const currentData = nuxtApp._asyncData[key.value]
  if (import.meta.dev && currentData) {
    const warnings: string[] = []
    const values = createHash(_handler, options)
    if (values.handler !== currentData._hash?.handler) {
      warnings.push(`different handler`)
    }
    for (const opt of ['transform', 'pick', 'getCachedData'] as const) {
      if (values[opt] !== currentData._hash![opt]) {
        warnings.push(`different \`${opt}\` option`)
      }
    }
    if (currentData._default.toString() !== options.default.toString()) {
      warnings.push(`different \`default\` value`)
    }
    if (options.deep && isShallow(currentData.data)) {
      warnings.push(`mismatching \`deep\` option`)
    }
    if (warnings.length) {
      const caller = getUserCaller()
      const explanation = caller ? ` (used at ${caller.source}:${caller.line}:${caller.column})` : ''
      console.warn(`[nuxt] [${functionName}] Incompatible options detected for "${key.value}"${explanation}:\n${warnings.map(w => `- ${w}`).join('\n')}\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`)
    }
  }

  // Create or use a shared asyncData entity
  function createInitialFetch () {
    const initialFetchOptions: AsyncDataExecuteOptions = { cause: 'initial', dedupe: options.dedupe }
    if (!nuxtApp._asyncData[key.value]?._init) {
      initialFetchOptions.cachedData = options.getCachedData!(key.value, nuxtApp, { cause: 'initial' })
      nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData)
    }
    return () => nuxtApp._asyncData[key.value]!.execute(initialFetchOptions)
  }

  const initialFetch = createInitialFetch()
  const asyncData = nuxtApp._asyncData[key.value]!

  asyncData._deps++

  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered

  // Server side
  if (import.meta.server && fetchOnServer && options.immediate) {
    const promise = initialFetch()
    if (getCurrentInstance()) {
      onServerPrefetch(() => promise)
    } else {
      nuxtApp.hook('app:created', async () => { await promise })
    }
  }

  // Client side
  if (import.meta.client) {
    // Setup hook callbacks once per instance
    const instance = getCurrentInstance()

    // @ts-expect-error - instance.sp is an internal vue property
    if (instance && fetchOnServer && options.immediate && !instance.sp) {
      // @ts-expect-error - internal vue property. This force vue to mark the component as async boundary client-side to avoid useId hydration issue since we treeshake onServerPrefetch
      instance.sp = []
    }
    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware /* internal flag */ && (!instance || instance?.isMounted)) {
      console.warn(`[nuxt] [${functionName}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/4.x/getting-started/data-fetching`)
    }
    if (instance && !instance._nuxtOnBeforeMountCbs) {
      instance._nuxtOnBeforeMountCbs = []
      const cbs = instance._nuxtOnBeforeMountCbs
      onBeforeMount(() => {
        cbs.forEach((cb) => { cb() })
        cbs.splice(0, cbs.length)
      })
      onUnmounted(() => cbs.splice(0, cbs.length))
    }

    const isWithinClientOnly = instance && (instance._nuxtClientOnly || inject(clientOnlySymbol, false))

    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || asyncData.data.value !== undefined)) {
      // 1. Hydration (server: true): no fetch
      if (pendingWhenIdle) {
        asyncData.pending.value = false
      }
      asyncData.status.value = asyncData.error.value ? 'error' : 'success'
    } else if (instance && ((!isWithinClientOnly && nuxtApp.payload.serverRendered && nuxtApp.isHydrating) || options.lazy) && options.immediate) {
      // 2. Initial load (server: false): fetch on mounted
      // 3. Initial load or navigation (lazy: true): fetch on mounted
      instance._nuxtOnBeforeMountCbs.push(initialFetch)
    } else if (options.immediate && asyncData.status.value !== 'success') {
      // 4. Navigation (lazy: false) - or plugin usage: await fetch
      initialFetch()
    }

    function unregister (key: string) {
      const data = nuxtApp._asyncData[key]
      if (data?._deps) {
        data._deps--
        // clean up memory when it no longer is needed
        if (data._deps === 0) {
          data?._off()
        }
      }
    }

    // setup watchers/instance
    const hasScope = getCurrentScope()
    // Key watcher: react immediately to key changes to remount/migrate the async data container deterministically.
    const unsubKeyWatcher = watch(key, (newKey, oldKey) => {
      if ((newKey || oldKey) && newKey !== oldKey) {
        keyChanging = true

        const hadData = nuxtApp._asyncData[oldKey]?.data.value !== undefined
        const wasRunning = nuxtApp._asyncDataPromises[oldKey] !== undefined

        const initialFetchOptions: AsyncDataExecuteOptions = { cause: 'initial', dedupe: options.dedupe }

        // Ensure destination container exists; read/migrate value BEFORE unregistering the old key.
        if (!nuxtApp._asyncData[newKey]?._init) {
          let initialValue: NoInfer<DataT> | undefined

          if (oldKey && hadData) {
            initialValue = nuxtApp._asyncData[oldKey]!.data.value as NoInfer<DataT>
          } else {
            initialValue = options.getCachedData!(newKey, nuxtApp, { cause: 'initial' })
            initialFetchOptions.cachedData = initialValue
          }

          nuxtApp._asyncData[newKey] = createAsyncData(nuxtApp, newKey, _handler, options, initialValue)
        }

        nuxtApp._asyncData[newKey]._deps++

        // Now it's safe to drop the old container.
        if (oldKey) {
          unregister(oldKey)
        }

        // Trigger the fetch for the new key if needed.
        if (options.immediate || hadData || wasRunning) {
          nuxtApp._asyncData[newKey].execute(initialFetchOptions)
        }

        // Release the guard after the current flush to avoid overlapping executes.
        queuePostFlushCb(() => {
          keyChanging = false
        })
      }
    }, { flush: 'sync' })

    // Params/deps watcher: keep default (pre) flush to batch multiple mutations into a single execute.
    // This preserves the "non synchronous" behavior covered by tests.
    const unsubParamsWatcher = options.watch
      ? watch(options.watch, () => {
          if (keyChanging) { return } // avoid double execute while the key switch is being processed
          nuxtApp._asyncData[key.value]?._execute({ cause: 'watch', dedupe: options.dedupe })
        })
      : () => {}

    if (hasScope) {
      onScopeDispose(() => {
        unsubKeyWatcher()
        unsubParamsWatcher()
        unregister(key.value)
      })
    }
  }

  const asyncReturn: _AsyncData<ResT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>)> = {
    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data as Ref<ResT>),
    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending as Ref<boolean>),
    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status as Ref<AsyncDataRequestStatus>),
    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error as Ref<NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>>),
    refresh: (...args) => {
      if (!nuxtApp._asyncData[key.value]?._init) {
        const initialFetch = createInitialFetch()
        return initialFetch()
      }
      return nuxtApp._asyncData[key.value]!.execute(...args)
    },
    execute: (...args) => asyncReturn.refresh(...args),
    clear: () => {
      const entry = nuxtApp._asyncData[key.value]
      if (entry?._abortController) {
        try {
          entry._abortController.abort(new DOMException('AsyncData aborted by user.', 'AbortError'))
        } finally {
          entry._abortController = undefined
        }
      }
      clearNuxtDataByKey(nuxtApp, key.value)
    },
  }

  // Allow directly awaiting on asyncData
  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn) as AsyncData<ResT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>)>
  Object.assign(asyncDataPromise, asyncReturn)

  return asyncDataPromise as AsyncData<PickFrom<DataT, PickKeys>, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>)>
}

function writableComputedRef<T> (getter: () => Ref<T>) {
  return computed({
    get () {
      return getter()?.value
    },
    set (value) {
      const ref = getter()
      if (ref) {
        ref.value = value
      }
    },
  })
}

/**
 * Provides access to data that resolves asynchronously in an SSR-friendly composable.
 * See {@link https://nuxt.com/docs/4.x/api/composables/use-lazy-async-data}
 * @since 3.0.0
 * @param handler An asynchronous function that must return a truthy value (for example, it should not be `undefined` or `null`) or the request may be duplicated on the client side.
 * @param options customize the behavior of useLazyAsyncData
 */
export function useLazyAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (
  handler: AsyncDataHandler<ResT>,
  options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>
export function useLazyAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = DataT,
> (
  handler: AsyncDataHandler<ResT>,
  options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>
/**
 * Provides access to data that resolves asynchronously in an SSR-friendly composable.
 * See {@link https://nuxt.com/docs/4.x/api/composables/use-lazy-async-data}
 * @param key A unique key to ensure that data fetching can be properly de-duplicated across requests.
 * @param handler An asynchronous function that must return a truthy value (for example, it should not be `undefined` or `null`) or the request may be duplicated on the client side.
 * @param options customize the behavior of useLazyAsyncData
 */
export function useLazyAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (
  key: MaybeRefOrGetter<string>,
  handler: AsyncDataHandler<ResT>,
  options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>
export function useLazyAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = DataT,
> (
  key: MaybeRefOrGetter<string>,
  handler: AsyncDataHandler<ResT>,
  options?: Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'lazy'>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined>

export function useLazyAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (...args: any[]): AsyncData<PickFrom<DataT, PickKeys>, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>) | undefined> {
  const autoKey = typeof args[args.length - 1] === 'string' ? args.pop() : undefined
  if (_isAutoKeyNeeded(args[0], args[1])) { args.unshift(autoKey) }
  const [key, handler, options = {}] = args as [string, AsyncDataHandler<ResT>, AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>]

  if (import.meta.dev) {
    // @ts-expect-error private property
    options._functionName ||= 'useLazyAsyncData'
  }

  // @ts-expect-error we pass an extra argument to prevent a key being injected
  return useAsyncData(key, handler, { ...options, lazy: true }, null)
}

function _isAutoKeyNeeded (keyOrFetcher: string | MaybeRefOrGetter<string> | (() => any), fetcher: () => any): boolean {
  // string key
  if (typeof keyOrFetcher === 'string') {
    return false
  }
  // ref or computed key
  if (typeof keyOrFetcher === 'object' && keyOrFetcher !== null) {
    return false
  }
  // getter key only if it's followed by a getter function
  if (typeof keyOrFetcher === 'function' && typeof fetcher === 'function') {
    return false
  }
  return true
}

/** @since 3.1.0 */
export function useNuxtData<DataT = any> (key: string): { data: Ref<DataT | undefined> } {
  const nuxtApp = useNuxtApp()

  // Initialize value when key is not already set
  if (!(key in nuxtApp.payload.data)) {
    nuxtApp.payload.data[key] = undefined
  }

  if (nuxtApp._asyncData[key]) {
    const data = nuxtApp._asyncData[key]
    data._deps++
    if (getCurrentScope()) {
      onScopeDispose(() => {
        data._deps--
        // clean up memory when it no longer is needed
        if (data._deps === 0) {
          data?._off()
        }
      })
    }
  }

  return {
    data: computed({
      get () {
        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key]
      },
      set (value) {
        if (nuxtApp._asyncData[key]) {
          nuxtApp._asyncData[key]!.data.value = value
        } else {
          nuxtApp.payload.data[key] = value
        }
      },
    }),
  }
}

/** @since 3.0.0 */
export async function refreshNuxtData (keys?: string | string[]): Promise<void> {
  if (import.meta.server) {
    return Promise.resolve()
  }

  await new Promise<void>(resolve => onNuxtReady(resolve))

  const _keys = keys ? toArray(keys) : undefined
  await useNuxtApp().hooks.callHookParallel('app:data:refresh', _keys)
}

/** @since 3.0.0 */
export function clearNuxtData (keys?: string | string[] | ((key: string) => boolean)): void {
  const nuxtApp = useNuxtApp()
  const _allKeys = Object.keys(nuxtApp.payload.data)
  const _keys: string[] = !keys
    ? _allKeys
    : typeof keys === 'function'
      ? _allKeys.filter(keys)
      : toArray(keys)

  for (const key of _keys) {
    clearNuxtDataByKey(nuxtApp, key)
  }
}

function clearNuxtDataByKey (nuxtApp: NuxtApp, key: string): void {
  if (key in nuxtApp.payload.data) {
    nuxtApp.payload.data[key] = undefined
  }

  if (key in nuxtApp.payload._errors) {
    nuxtApp.payload._errors[key] = undefined
  }

  if (nuxtApp._asyncData[key]) {
    nuxtApp._asyncData[key]!.data.value = unref(nuxtApp._asyncData[key]!._default())
    nuxtApp._asyncData[key]!.error.value = undefined
    if (pendingWhenIdle) {
      nuxtApp._asyncData[key]!.pending.value = false
    }
    nuxtApp._asyncData[key]!.status.value = 'idle'
  }

  if (key in nuxtApp._asyncDataPromises) {
    nuxtApp._asyncDataPromises[key] = undefined
  }
}

function pick (obj: Record<string, any>, keys: string[]) {
  const newObj = {}
  for (const key of keys) {
    (newObj as any)[key] = obj[key]
  }
  return newObj
}

export type CreatedAsyncData<ResT, NuxtErrorDataT = unknown, DataT = ResT, DefaultT = undefined> = Omit<_AsyncData<DataT | DefaultT, (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>)>, 'clear' | 'refresh'> & { _off: () => void, _hash?: Record<string, string | undefined>, _default: () => unknown, _init: boolean, _deps: number, _execute: (opts?: AsyncDataExecuteOptions) => Promise<void>, _abortController?: AbortController }

function createAsyncData<
  ResT,
  NuxtErrorDataT = unknown,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (nuxtApp: NuxtApp, key: string, _handler: AsyncDataHandler<ResT>, options: AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, initialCachedData?: NoInfer<DataT>): CreatedAsyncData<ResT, NuxtErrorDataT, DataT, DefaultT> {
  nuxtApp.payload._errors[key] ??= undefined

  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData

  // When prerendering, share payload data automatically between requests
  const handler: AsyncDataHandler<ResT> = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?.['~sharedPrerenderCache']
    ? _handler
    : (nuxtApp, options) => {
        const value = nuxtApp.ssrContext!['~sharedPrerenderCache']!.get(key)
        if (value) { return value as Promise<ResT> }

        const promise = Promise.resolve().then(() => nuxtApp.runWithContext(() => _handler(nuxtApp, options)))

        nuxtApp.ssrContext!['~sharedPrerenderCache']!.set(key, promise)
        return promise
      }

  const _ref = options.deep ? ref : shallowRef
  const hasCachedData = initialCachedData !== undefined
  const unsubRefreshAsyncData = nuxtApp.hook('app:data:refresh', async (keys) => {
    if (!keys || keys.includes(key)) {
      await asyncData.execute({ cause: 'refresh:hook' })
    }
  })
  const asyncData: CreatedAsyncData<ResT, NuxtErrorDataT, DataT, DefaultT> = {
    data: _ref(hasCachedData ? initialCachedData : options.default!()) as any,
    pending: pendingWhenIdle ? shallowRef(!hasCachedData) : computed(() => asyncData.status.value === 'pending'),
    error: toRef(nuxtApp.payload._errors, key) as any,
    status: shallowRef('idle'),
    execute: (...args) => {
      const [_opts, newValue = undefined] = args
      const opts = _opts && newValue === undefined && typeof _opts === 'object' ? _opts : {}
      if (import.meta.dev && newValue !== undefined && (!_opts || typeof _opts !== 'object')) {
        // @ts-expect-error private property
        console.warn(`[nuxt] [${options._functionName}] Do not pass \`execute\` directly to \`watch\`. Instead, use an inline function, such as \`watch(q, () => execute())\`.`)
      }
      if (nuxtApp._asyncDataPromises[key]) {
        if ((opts.dedupe ?? options.dedupe) === 'defer') {
        // Avoid fetching same key more than once at a time
          return nuxtApp._asyncDataPromises[key]!
        }
      }
      // Avoid fetching same key that is already fetched
      if (granularCachedData || opts.cause === 'initial' || nuxtApp.isHydrating) {
        const cachedData = 'cachedData' in opts ? opts.cachedData : options.getCachedData!(key, nuxtApp, { cause: opts.cause ?? 'refresh:manual' })
        if (cachedData !== undefined) {
          nuxtApp.payload.data[key] = asyncData.data.value = cachedData as DataT
          asyncData.error.value = undefined
          asyncData.status.value = 'success'
          return Promise.resolve(cachedData)
        }
      }
      if (pendingWhenIdle) {
        asyncData.pending.value = true
      }
      if (asyncData._abortController) {
        asyncData._abortController.abort(new DOMException('AsyncData request cancelled by deduplication', 'AbortError'))
      }
      asyncData._abortController = new AbortController()
      asyncData.status.value = 'pending'
      const cleanupController = new AbortController()
      const promise: Promise<ResT | void> = new Promise<ResT>(
        (resolve, reject) => {
          try {
            const timeout = opts.timeout ?? options.timeout
            const mergedSignal = mergeAbortSignals([asyncData._abortController?.signal, opts?.signal], cleanupController.signal, timeout)
            if (mergedSignal.aborted) {
              const reason = mergedSignal.reason
              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? 'Aborted'), 'AbortError'))
              return
            }
            mergedSignal.addEventListener('abort', () => {
              const reason = mergedSignal.reason
              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? 'Aborted'), 'AbortError'))
            }, { once: true, signal: cleanupController.signal })

            return Promise.resolve(handler(nuxtApp, { signal: mergedSignal })).then(resolve, reject)
          } catch (err) {
            reject(err)
          }
        })
        .then(async (_result) => {
          let result = _result as unknown as DataT
          if (options.transform) {
            result = await options.transform(_result)
          }
          if (options.pick) {
            result = pick(result as any, options.pick) as DataT
          }

          if (import.meta.dev && import.meta.server && typeof result === 'undefined') {
            const caller = getUserCaller()
            const explanation = caller ? ` (used at ${caller.source}:${caller.line}:${caller.column})` : ''
            // @ts-expect-error private property
            console.warn(`[nuxt] \`${options._functionName || 'useAsyncData'}${explanation}\` must return a value (it should not be \`undefined\`) or the request may be duplicated on the client side.`)
          }

          nuxtApp.payload.data[key] = result

          asyncData.data.value = result
          asyncData.error.value = undefined
          asyncData.status.value = 'success'
        })
        .catch((error: any) => {
          // If the promise was replaced by another one, we do not update the asyncData
          if (nuxtApp._asyncDataPromises[key] && nuxtApp._asyncDataPromises[key] !== promise) {
            return nuxtApp._asyncDataPromises[key]
          }

          // If the asyncData was explicitly aborted internally (dedupe or clear), we do not update the asyncData
          if (asyncData._abortController?.signal.aborted) {
            return nuxtApp._asyncDataPromises[key]
          }

          // if the asyncData was explicitly aborted by user, we set it back to idle state
          if (typeof DOMException !== 'undefined' && error instanceof DOMException && error.name === 'AbortError') {
            asyncData.status.value = 'idle'
            return nuxtApp._asyncDataPromises[key]
          }

          asyncData.error.value = createError<NuxtErrorDataT>(error) as (NuxtErrorDataT extends Error | NuxtError ? NuxtErrorDataT : NuxtError<NuxtErrorDataT>)
          asyncData.data.value = unref(options.default!())
          asyncData.status.value = 'error'
        })
        .finally(() => {
          if (pendingWhenIdle) {
            asyncData.pending.value = false
          }
          cleanupController.abort()

          delete nuxtApp._asyncDataPromises[key]
        })
      nuxtApp._asyncDataPromises[key] = promise
      return nuxtApp._asyncDataPromises[key]!
    },
    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),
    _default: options.default!,
    _deps: 0,
    _init: true,
    _hash: import.meta.dev ? createHash(_handler, options) : undefined,
    _off: () => {
      unsubRefreshAsyncData()
      if (nuxtApp._asyncData[key]?._init) {
        nuxtApp._asyncData[key]._init = false
      }
      // TODO: disable in v4 in favour of custom caching strategies
      if (purgeCachedData && !hasCustomGetCachedData) {
        nextTick(() => {
          if (!nuxtApp._asyncData[key]?._init) {
            clearNuxtDataByKey(nuxtApp, key)
            asyncData.execute = () => Promise.resolve()
          }
        })
      }
    },
  }

  return asyncData
}

// Used to get default values
const getDefault = () => undefined
const getDefaultCachedData: AsyncDataOptions<any>['getCachedData'] = (key, nuxtApp, ctx) => {
  if (nuxtApp.isHydrating) {
    return nuxtApp.payload.data[key]
  }

  if (ctx.cause !== 'refresh:manual' && ctx.cause !== 'refresh:hook') {
    return nuxtApp.static.data[key]
  }
}

function createHash (_handler: AsyncDataHandler<unknown>, options: Partial<Record<keyof AsyncDataOptions<any>, unknown>>) {
  return {
    handler: hash(_handler),
    transform: options.transform ? hash(options.transform) : undefined,
    pick: options.pick ? hash(options.pick) : undefined,
    getCachedData: options.getCachedData ? hash(options.getCachedData) : undefined,
  }
}
function mergeAbortSignals (signals: Array<AbortSignal | null | undefined>, cleanupSignal: AbortSignal, timeout?: number): AbortSignal {
  const list = signals.filter(s => !!s)
  if (typeof timeout === 'number' && timeout >= 0) {
    const timeoutSignal = AbortSignal.timeout?.(timeout)
    if (timeoutSignal) { list.push(timeoutSignal) }
  }

  // Use native if available
  if (AbortSignal.any) {
    return AbortSignal.any(list)
  }

  // Polyfill
  const controller = new AbortController()

  for (const sig of list) {
    if (sig.aborted) {
      const reason = sig.reason ?? new DOMException('Aborted', 'AbortError')
      try {
        controller.abort(reason)
      } catch {
        controller.abort()
      }
      return controller.signal
    }
  }

  const onAbort = () => {
    const abortedSignal = list.find(s => s.aborted)
    const reason = abortedSignal?.reason ?? new DOMException('Aborted', 'AbortError')
    try {
      controller.abort(reason)
    } catch {
      controller.abort()
    }
  }

  for (const sig of list) {
    sig.addEventListener?.('abort', onAbort, { once: true, signal: cleanupSignal })
  }

  return controller.signal
}
</file>

<file path="packages/nuxt/src/app/composables/chunk.ts">
import destr from 'destr'
import { useNuxtApp } from '../nuxt'

export interface ReloadNuxtAppOptions {
  /**
   * Number of milliseconds in which to ignore future reload requests
   * @default {10000}
   */
  ttl?: number
  /**
   * Force a reload even if one has occurred within the previously specified TTL.
   * @default {false}
   */
  force?: boolean
  /**
   * Whether to dump the current Nuxt state to sessionStorage (as `nuxt:reload:state`).
   * @default {false}
   */
  persistState?: boolean
  /**
   * The path to reload. If this is different from the current window location it will
   * trigger a navigation and add an entry in the browser history.
   * @default {window.location.pathname}
   */
  path?: string
}

/** @since 3.3.0 */
export function reloadNuxtApp (options: ReloadNuxtAppOptions = {}) {
  if (import.meta.server) { return }
  const path = options.path || window.location.pathname

  let handledPath: Record<string, any> = {}
  try {
    handledPath = destr(sessionStorage.getItem('nuxt:reload') || '{}')
  } catch {
    // fail gracefully if we can't access sessionStorage
  }

  if (options.force || handledPath?.path !== path || handledPath?.expires < Date.now()) {
    try {
      sessionStorage.setItem('nuxt:reload', JSON.stringify({ path, expires: Date.now() + (options.ttl ?? 10000) }))
    } catch {
      // fail gracefully if we can't access sessionStorage
    }

    if (options.persistState) {
      try {
        // TODO: handle serializing/deserializing complex states as JSON: https://github.com/nuxt/nuxt/pull/19205
        sessionStorage.setItem('nuxt:reload:state', JSON.stringify({ state: useNuxtApp().payload.state }))
      } catch {
        // fail gracefully if we can't access sessionStorage
      }
    }

    if (window.location.pathname !== path) {
      window.location.href = path
    } else {
      window.location.reload()
    }
  }
}
</file>

<file path="packages/nuxt/src/app/composables/component.ts">
import { computed, getCurrentInstance } from 'vue'
import type { DefineComponent, defineComponent } from 'vue'
import { hash } from 'ohash'
import type { NuxtApp } from '../nuxt'
import { getNuxtAppCtx, useNuxtApp } from '../nuxt'
import { useHead } from './head'
import { useAsyncData } from './asyncData'
import { useRoute } from './router'
import { createError } from './error'

export const NuxtComponentIndicator = '__nuxt_component'

/* @__NO_SIDE_EFFECTS__ */
function getFetchKey () {
  const vm = getCurrentInstance()!
  const route = useRoute()
  const { _fetchKeyBase } = vm.proxy!.$options
  return hash([
    _fetchKeyBase,
    route.path,
    route.query,
    route.matched.findIndex(r => Object.values(r.components || {}).includes(vm.type)),
  ])
}

async function runLegacyAsyncData (res: Record<string, any> | Promise<Record<string, any>>, fn: (nuxtApp: NuxtApp) => Promise<Record<string, any>>) {
  const nuxtApp = useNuxtApp()
  const { fetchKey } = getCurrentInstance()!.proxy!.$options
  const key = (typeof fetchKey === 'function' ? fetchKey(() => '') : fetchKey) || getFetchKey()
  const { data, error } = await useAsyncData(`options:asyncdata:${key}`, () => import.meta.server ? nuxtApp.runWithContext(() => fn(nuxtApp)) : fn(nuxtApp))
  if (error.value) {
    throw createError(error.value)
  }
  if (data.value && typeof data.value === 'object') {
    const _res = await res
    for (const key in data.value) {
      _res[key] = computed({
        get: () => data.value?.[key],
        set (v) {
          data.value ||= {}
          data.value[key] = v
        },
      })
    }
  } else if (import.meta.dev) {
    console.warn('[nuxt] asyncData should return an object', data)
  }
}

/** @since 3.0.0 */
/* @__NO_SIDE_EFFECTS__ */
export const defineNuxtComponent: typeof defineComponent =
  function defineNuxtComponent (...args: any[]): any {
    const [options, key] = args
    const { setup } = options as DefineComponent

    // Avoid wrapping if no options api is used
    if (!setup && !options.asyncData && !options.head) {
      return {
        [NuxtComponentIndicator]: true,
        ...options,
      }
    }

    return {
      [NuxtComponentIndicator]: true,
      _fetchKeyBase: key,
      ...options,
      setup (props, ctx) {
        const nuxtApp = useNuxtApp()

        let res = {}
        if (setup) {
          const fn = (): Promise<Record<string, any>> => Promise.resolve(setup(props, ctx)).then((r: any) => r || {})
          const nuxtAppCtx = getNuxtAppCtx(nuxtApp._id)
          if (import.meta.server) {
            res = nuxtAppCtx.callAsync(nuxtApp, fn)
          } else {
            nuxtAppCtx.set(nuxtApp)
            res = fn()
          }
        }

        const promises: Promise<any>[] = []
        if (options.asyncData) {
          promises.push(runLegacyAsyncData(res, options.asyncData))
        }

        if (options.head) {
          useHead(typeof options.head === 'function' ? () => options.head(nuxtApp) : options.head)
        }

        return Promise.resolve(res)
          .then(() => Promise.all(promises))
          .then(() => res)
          .finally(() => {
            promises.length = 0
          })
      },
    } as DefineComponent
  }
</file>

<file path="packages/nuxt/src/app/composables/cookie.ts">
import type { Ref } from 'vue'
import { customRef, getCurrentScope, nextTick, onScopeDispose, ref, watch } from 'vue'
import type { CookieParseOptions, CookieSerializeOptions } from 'cookie-es'
import { parse, serialize } from 'cookie-es'
import { deleteCookie, getCookie, getRequestHeader, setCookie } from 'h3'
import type { H3Event } from 'h3'
import destr from 'destr'
import { isEqual } from 'ohash'
import { klona } from 'klona'
import { useNuxtApp } from '../nuxt'
import { useRequestEvent } from './ssr'

// @ts-expect-error virtual import
import { cookieStore } from '#build/nuxt.config.mjs'

type _CookieOptions = Omit<CookieSerializeOptions & CookieParseOptions, 'decode' | 'encode'>

export interface CookieOptions<T = any> extends _CookieOptions {
  decode?(value: string): T
  encode?(value: T): string
  default?: () => T | Ref<T>
  watch?: boolean | 'shallow'
  readonly?: boolean
}

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface CookieRef<T> extends Ref<T> {}

const CookieDefaults = {
  path: '/',
  watch: true,
  decode: (val) => {
    const decoded = decodeURIComponent(val)
    const parsed = destr(decoded)
    // destr can return Infinity or precision-loss numbers - keep original string
    if (typeof parsed === 'number' && (!Number.isFinite(parsed) || String(parsed) !== decoded)) {
      return decoded
    }
    return parsed
  },
  encode: val => encodeURIComponent(typeof val === 'string' ? val : JSON.stringify(val)),
} satisfies CookieOptions<any>

// we use globalThis to avoid crashes in web workers
const store = import.meta.client && cookieStore ? globalThis.cookieStore : undefined

/** @since 3.0.0 */
export function useCookie<T = string | null | undefined> (name: string, _opts?: CookieOptions<T> & { readonly?: false }): CookieRef<T>
export function useCookie<T = string | null | undefined> (name: string, _opts: CookieOptions<T> & { readonly: true }): Readonly<CookieRef<T>>
export function useCookie<T = string | null | undefined> (name: string, _opts?: CookieOptions<T>): CookieRef<T> {
  const opts = { ...CookieDefaults, ..._opts }
  opts.filter ??= key => key === name
  const cookies = readRawCookies(opts) || {}

  let delay: number | undefined

  if (opts.maxAge !== undefined) {
    delay = opts.maxAge * 1000 // convert to ms for setTimeout
  } else if (opts.expires) {
    // getTime() already returns time in ms
    delay = opts.expires.getTime() - Date.now()
  }

  const hasExpired = delay !== undefined && delay <= 0
  const shouldSetInitialClientCookie = import.meta.client && (hasExpired || cookies[name] === undefined || cookies[name] === null)
  const cookieValue = klona(hasExpired ? undefined : (cookies[name] as any) ?? opts.default?.())

  // use a custom ref to expire the cookie on client side otherwise use basic ref
  const cookie = import.meta.client && delay && !hasExpired
    ? cookieRef<T | undefined>(cookieValue, delay, opts.watch && opts.watch !== 'shallow')
    : ref<T | undefined>(cookieValue)

  if (import.meta.dev && hasExpired) {
    console.warn(`[nuxt] not setting cookie \`${name}\` as it has already expired.`)
  }

  if (import.meta.client) {
    let channel: null | BroadcastChannel = null
    try {
      if (!store && typeof BroadcastChannel !== 'undefined') {
        channel = new BroadcastChannel(`nuxt:cookies:${name}`)
      }
    } catch {
      // BroadcastChannel will fail in certain situations when cookies are disabled
      // or running in an iframe: see https://github.com/nuxt/nuxt/issues/26338
    }
    const callback = (force = false) => {
      if (!force) {
        if (opts.readonly || isEqual(cookie.value, cookies[name])) { return }
      }
      writeClientCookie(name, cookie.value, opts as CookieSerializeOptions)

      cookies[name] = klona(cookie.value)
      channel?.postMessage({ value: opts.encode(cookie.value as T) })
    }

    const handleChange = (data: { value?: any, refresh?: boolean }) => {
      const value = data.refresh ? readRawCookies(opts)?.[name] : opts.decode(data.value)
      watchPaused = true
      cookie.value = value
      cookies[name] = klona(value)
      nextTick(() => { watchPaused = false })
    }

    let watchPaused = false

    const hasScope = !!getCurrentScope()

    if (hasScope) {
      onScopeDispose(() => {
        watchPaused = true
        callback()
        channel?.close()
      })
    }

    if (store) {
      /* event is of type CookieChangeEvent */
      const changeHandler = (event: any) => {
        const changedCookie = event.changed.find((c: any) => c.name === name)
        const removedCookie = event.deleted.find((c: any) => c.name === name)

        if (changedCookie) {
          handleChange({ value: changedCookie.value })
        }

        if (removedCookie) {
          handleChange({ value: null })
        }
      }
      store.addEventListener('change', changeHandler)
      if (hasScope) {
        onScopeDispose(() => store.removeEventListener('change', changeHandler))
      }
    } else if (channel) {
      channel.onmessage = ({ data }) => handleChange(data)
    }

    if (opts.watch) {
      watch(cookie, () => {
        if (watchPaused) { return }
        callback()
      },
      { deep: opts.watch !== 'shallow' })
    }

    if (shouldSetInitialClientCookie) {
      callback(shouldSetInitialClientCookie)
    }
  } else if (import.meta.server) {
    const nuxtApp = useNuxtApp()
    const writeFinalCookieValue = () => {
      if (opts.readonly || isEqual(cookie.value, cookies[name])) { return }
      nuxtApp._cookies ||= {}
      if (name in nuxtApp._cookies) {
        // do not append a second `set-cookie` header
        if (isEqual(cookie.value, nuxtApp._cookies[name])) { return }
        // warn in dev mode
        if (import.meta.dev) {
          console.warn(`[nuxt] cookie \`${name}\` was previously set to \`${opts.encode(nuxtApp._cookies[name] as any)}\` and is being overridden to \`${opts.encode(cookie.value as any)}\`. This may cause unexpected issues.`)
        }
      }
      nuxtApp._cookies[name] = cookie.value
      writeServerCookie(useRequestEvent(nuxtApp)!, name, cookie.value, opts as CookieOptions<any>)
    }
    const unhook = nuxtApp.hooks.hookOnce('app:rendered', writeFinalCookieValue)
    nuxtApp.hooks.hookOnce('app:error', () => {
      unhook() // don't write cookie subsequently when app:rendered is called
      return writeFinalCookieValue()
    })
  }

  return cookie as CookieRef<T>
}
/** @since 3.10.0 */
export function refreshCookie (name: string) {
  if (import.meta.server || store || typeof BroadcastChannel === 'undefined') { return }

  new BroadcastChannel(`nuxt:cookies:${name}`)?.postMessage({ refresh: true })
}

function readRawCookies (opts: CookieOptions = {}): Record<string, unknown> | undefined {
  if (import.meta.server) {
    return parse(getRequestHeader(useRequestEvent()!, 'cookie') || '', opts)
  } else if (import.meta.client) {
    return parse(document.cookie, opts)
  }
}

function serializeCookie (name: string, value: any, opts: CookieSerializeOptions = {}) {
  if (value === null || value === undefined) {
    return serialize(name, value, { ...opts, maxAge: -1 })
  }
  return serialize(name, value, opts)
}

function writeClientCookie (name: string, value: any, opts: CookieSerializeOptions = {}) {
  if (import.meta.client) {
    document.cookie = serializeCookie(name, value, opts)
  }
}

function writeServerCookie (event: H3Event, name: string, value: any, opts: CookieSerializeOptions = {}) {
  if (event) {
    // update if value is set
    if (value !== null && value !== undefined) {
      return setCookie(event, name, value, opts)
    }

    // delete if cookie exists in browser and value is null/undefined
    if (getCookie(event, name) !== undefined) {
      return deleteCookie(event, name, opts)
    }

    // else ignore if cookie doesn't exist in browser and value is null/undefined
  }
}

/**
 * The maximum value allowed on a timeout delay.
 *
 * Reference: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout#maximum_delay_value
 */
const MAX_TIMEOUT_DELAY = 2_147_483_647

// custom ref that will update the value to undefined if the cookie expires
function cookieRef<T> (value: T | undefined, delay: number, shouldWatch: boolean) {
  let timeout: NodeJS.Timeout
  let unsubscribe: (() => void) | undefined
  let elapsed = 0
  const internalRef = shouldWatch ? ref(value) : { value }
  if (getCurrentScope()) {
    onScopeDispose(() => {
      unsubscribe?.()
      clearTimeout(timeout)
    })
  }

  return customRef((track, trigger) => {
    if (shouldWatch) { unsubscribe = watch(internalRef, trigger) }

    function createExpirationTimeout () {
      elapsed = 0
      clearTimeout(timeout)
      const timeRemaining = delay - elapsed
      const timeoutLength = timeRemaining < MAX_TIMEOUT_DELAY ? timeRemaining : MAX_TIMEOUT_DELAY
      timeout = setTimeout(() => {
        elapsed += timeoutLength
        if (elapsed < delay) { return createExpirationTimeout() }

        internalRef.value = undefined
        trigger()
      }, timeoutLength)
    }

    return {
      get () {
        track()
        return internalRef.value
      },
      set (newValue) {
        createExpirationTimeout()

        internalRef.value = newValue
        trigger()
      },
    }
  })
}
</file>

<file path="packages/nuxt/src/app/composables/error.ts">
import type { H3Error } from 'h3'
import { createError as createH3Error } from 'h3'
import { toRef } from 'vue'
import type { Ref } from 'vue'
import { useNuxtApp } from '../nuxt'
import type { NuxtPayload } from '../nuxt'
import { useRouter } from './router'

export const NUXT_ERROR_SIGNATURE = '__nuxt_error'

/** @since 3.0.0 */
/* @__NO_SIDE_EFFECTS__ */
export const useError = (): Ref<NuxtPayload['error']> => toRef(useNuxtApp().payload, 'error')

export interface NuxtError<DataT = unknown> extends Omit<H3Error<DataT>, 'statusCode' | 'statusMessage'> {
  error?: true
  status?: number
  statusText?: string
  /** @deprecated Use `status` */
  statusCode?: H3Error<DataT>['statusCode']
  /** @deprecated Use `statusText` */
  statusMessage?: H3Error<DataT>['statusMessage']
}

/** @since 3.0.0 */
export const showError = <DataT = unknown>(
  error: string | Error | (Partial<NuxtError<DataT>> & {
    status?: number
    statusText?: string
  }),
) => {
  const nuxtError = createError<DataT>(error)

  try {
    const error = useError()

    if (import.meta.client) {
      const nuxtApp = useNuxtApp()
      nuxtApp.hooks.callHook('app:error', nuxtError)
    }

    error.value ||= nuxtError
  } catch {
    throw nuxtError
  }

  return nuxtError
}

/** @since 3.0.0 */
export const clearError = async (options: { redirect?: string } = {}) => {
  const nuxtApp = useNuxtApp()
  const error = useError()

  nuxtApp.callHook('app:error:cleared', options)

  if (options.redirect) {
    await useRouter().replace(options.redirect)
  }

  error.value = undefined
}

/** @since 3.0.0 */
export const isNuxtError = <DataT = unknown>(
  error: unknown,
): error is NuxtError<DataT> => !!error && typeof error === 'object' && NUXT_ERROR_SIGNATURE in error

/** @since 3.0.0 */
export const createError = <DataT = unknown>(error: string | Error | Partial<NuxtError<DataT>>) => {
  if (typeof error !== 'string' && (error as Partial<NuxtError<DataT>>).statusText) {
    error.message ??= (error as Partial<NuxtError<DataT>>).statusText
  }

  const nuxtError: NuxtError<DataT> = createH3Error<DataT>(error)

  Object.defineProperty(nuxtError, NUXT_ERROR_SIGNATURE, {
    value: true,
    configurable: false,
    writable: false,
  })

  return nuxtError
}
</file>

<file path="packages/nuxt/src/app/composables/fetch.ts">
import type { FetchError, FetchOptions, ResponseType as _ResponseType } from 'ofetch'
import type { $Fetch, H3Event$Fetch, NitroFetchRequest, TypedInternalResponse, AvailableRouterMethod as _AvailableRouterMethod } from 'nitropack/types'
import type { MaybeRef, MaybeRefOrGetter, Ref } from 'vue'
import { computed, reactive, toValue, watch } from 'vue'
import { hash } from 'ohash'

import { isPlainObject } from '@vue/shared'
import { useRequestFetch } from './ssr'
import type { AsyncData, AsyncDataOptions, KeysOf, MultiWatchSources, PickFrom } from './asyncData'
import { useAsyncData } from './asyncData'

// @ts-expect-error virtual file
import { alwaysRunFetchOnKeyChange, fetchDefaults } from '#build/nuxt.config.mjs'

// support uppercase methods, detail: https://github.com/nuxt/nuxt/issues/22313
type AvailableRouterMethod<R extends NitroFetchRequest> = _AvailableRouterMethod<R> | Uppercase<_AvailableRouterMethod<R>>

export type FetchResult<ReqT extends NitroFetchRequest, M extends AvailableRouterMethod<ReqT>> = TypedInternalResponse<ReqT, unknown, Lowercase<M>>

type ComputedOptions<T extends Record<string, any>> = {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  [K in keyof T]: T[K] extends Function ? T[K] : ComputedOptions<T[K]> | Ref<T[K]> | T[K]
}

interface NitroFetchOptions<R extends NitroFetchRequest, M extends AvailableRouterMethod<R> = AvailableRouterMethod<R>, DataT = any> extends FetchOptions<_ResponseType, DataT> {
  method?: M
}

type ComputedFetchOptions<R extends NitroFetchRequest, M extends AvailableRouterMethod<R>, DataT = any> = ComputedOptions<NitroFetchOptions<R, M, DataT>>

export interface UseFetchOptions<
  ResT,
  DataT = ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
  R extends NitroFetchRequest = string & {},
  M extends AvailableRouterMethod<R> = AvailableRouterMethod<R>,
> extends Omit<AsyncDataOptions<ResT, DataT, PickKeys, DefaultT>, 'watch'>, Omit<ComputedFetchOptions<R, M, DataT>, 'timeout'> {
  key?: MaybeRefOrGetter<string>
  $fetch?: typeof globalThis.$fetch
  watch?: MultiWatchSources | false
}

/**
 * Fetch data from an API endpoint with an SSR-friendly composable.
 * See {@link https://nuxt.com/docs/4.x/api/composables/use-fetch}
 * @since 3.0.0
 * @param request The URL to fetch
 * @param opts extends $fetch options and useAsyncData options
 */
export function useFetch<
  ResT = void,
  ErrorT = FetchError,
  ReqT extends NitroFetchRequest = NitroFetchRequest,
  Method extends AvailableRouterMethod<ReqT> = ResT extends void ? 'get' extends AvailableRouterMethod<ReqT> ? 'get' : AvailableRouterMethod<ReqT> : AvailableRouterMethod<ReqT>,
  _ResT = ResT extends void ? FetchResult<ReqT, Method> : ResT,
  DataT = _ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (
  request: Ref<ReqT> | ReqT | (() => ReqT),
  opts?: UseFetchOptions<_ResT, DataT, PickKeys, DefaultT, ReqT, Method>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, ErrorT | undefined>
export function useFetch<
  ResT = void,
  ErrorT = FetchError,
  ReqT extends NitroFetchRequest = NitroFetchRequest,
  Method extends AvailableRouterMethod<ReqT> = ResT extends void ? 'get' extends AvailableRouterMethod<ReqT> ? 'get' : AvailableRouterMethod<ReqT> : AvailableRouterMethod<ReqT>,
  _ResT = ResT extends void ? FetchResult<ReqT, Method> : ResT,
  DataT = _ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = DataT,
> (
  request: Ref<ReqT> | ReqT | (() => ReqT),
  opts?: UseFetchOptions<_ResT, DataT, PickKeys, DefaultT, ReqT, Method>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, ErrorT | undefined>
export function useFetch<
  ResT = void,
  ErrorT = FetchError,
  ReqT extends NitroFetchRequest = NitroFetchRequest,
  Method extends AvailableRouterMethod<ReqT> = ResT extends void ? 'get' extends AvailableRouterMethod<ReqT> ? 'get' : AvailableRouterMethod<ReqT> : AvailableRouterMethod<ReqT>,
  _ResT = ResT extends void ? FetchResult<ReqT, Method> : ResT,
  DataT = _ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (
  request: Ref<ReqT> | ReqT | (() => ReqT),
  arg1?: string | UseFetchOptions<_ResT, DataT, PickKeys, DefaultT, ReqT, Method>,
  arg2?: string,
) {
  const [opts = {}, autoKey] = typeof arg1 === 'string' ? [{}, arg1] : [arg1, arg2]

  const _request = computed(() => toValue(request))

  const key = computed(() => toValue(opts.key) || ('$f' + hash([autoKey, typeof _request.value === 'string' ? _request.value : '', ...generateOptionSegments(opts)])))

  if (!opts.baseURL && typeof _request.value === 'string' && (_request.value[0] === '/' && _request.value[1] === '/')) {
    throw new Error('[nuxt] [useFetch] the request URL must not start with "//".')
  }

  const {
    server,
    lazy,
    default: defaultFn,
    transform,
    pick,
    watch: watchSources,
    immediate,
    getCachedData,
    deep,
    dedupe,
    timeout,
    ...fetchOptions
  } = opts

  const _fetchOptions = reactive<typeof fetchOptions>({
    ...fetchDefaults,
    ...fetchOptions,
    cache: typeof opts.cache === 'boolean' ? undefined : opts.cache,
  })

  const _asyncDataOptions: AsyncDataOptions<_ResT, DataT, PickKeys, DefaultT> = {
    server,
    lazy,
    default: defaultFn,
    transform,
    pick,
    immediate,
    getCachedData,
    deep,
    dedupe,
    timeout,
    watch: watchSources === false ? [] : [...(watchSources || []), _fetchOptions],
  }

  if (import.meta.dev) {
    // @ts-expect-error private property
    _asyncDataOptions._functionName ||= 'useFetch'
  }

  if (alwaysRunFetchOnKeyChange && !immediate) {
    // ensure that updates to watched sources trigger an update
    function setImmediate () {
      _asyncDataOptions.immediate = true
    }
    watch(key, setImmediate, { flush: 'sync', once: true })
    watch([...watchSources || [], _fetchOptions], setImmediate, { flush: 'sync', once: true })
  }

  const asyncData = useAsyncData<_ResT, ErrorT, DataT, PickKeys, DefaultT>(watchSources === false ? key.value : key, (_, { signal }) => {
    let _$fetch: H3Event$Fetch | $Fetch<unknown, NitroFetchRequest> = opts.$fetch || globalThis.$fetch

    // Use fetch with request context and headers for server direct API calls
    if (import.meta.server && !opts.$fetch) {
      const isLocalFetch = typeof _request.value === 'string' && _request.value[0] === '/' && (!toValue(opts.baseURL) || toValue(opts.baseURL)![0] === '/')
      if (isLocalFetch) {
        _$fetch = useRequestFetch()
      }
    }

    return _$fetch(_request.value, { signal, ..._fetchOptions } as any) as Promise<_ResT>
  }, _asyncDataOptions)

  return asyncData
}

/**
 * Fetch data from an API endpoint with an SSR-friendly composable.
 * See {@link https://nuxt.com/docs/4.x/api/composables/use-lazy-fetch}
 * @since 3.0.0
 * @param request The URL to fetch
 * @param opts extends $fetch options and useAsyncData options
 */
export function useLazyFetch<
  ResT = void,
  ErrorT = FetchError,
  ReqT extends NitroFetchRequest = NitroFetchRequest,
  Method extends AvailableRouterMethod<ReqT> = ResT extends void ? 'get' extends AvailableRouterMethod<ReqT> ? 'get' : AvailableRouterMethod<ReqT> : AvailableRouterMethod<ReqT>,
  _ResT = ResT extends void ? FetchResult<ReqT, Method> : ResT,
  DataT = _ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (
  request: Ref<ReqT> | ReqT | (() => ReqT),
  opts?: Omit<UseFetchOptions<_ResT, DataT, PickKeys, DefaultT, ReqT, Method>, 'lazy'>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, ErrorT | undefined>
export function useLazyFetch<
  ResT = void,
  ErrorT = FetchError,
  ReqT extends NitroFetchRequest = NitroFetchRequest,
  Method extends AvailableRouterMethod<ReqT> = ResT extends void ? 'get' extends AvailableRouterMethod<ReqT> ? 'get' : AvailableRouterMethod<ReqT> : AvailableRouterMethod<ReqT>,
  _ResT = ResT extends void ? FetchResult<ReqT, Method> : ResT,
  DataT = _ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = DataT,
> (
  request: Ref<ReqT> | ReqT | (() => ReqT),
  opts?: Omit<UseFetchOptions<_ResT, DataT, PickKeys, DefaultT, ReqT, Method>, 'lazy'>,
): AsyncData<PickFrom<DataT, PickKeys> | DefaultT, ErrorT | undefined>
export function useLazyFetch<
  ResT = void,
  ErrorT = FetchError,
  ReqT extends NitroFetchRequest = NitroFetchRequest,
  Method extends AvailableRouterMethod<ReqT> = ResT extends void ? 'get' extends AvailableRouterMethod<ReqT> ? 'get' : AvailableRouterMethod<ReqT> : AvailableRouterMethod<ReqT>,
  _ResT = ResT extends void ? FetchResult<ReqT, Method> : ResT,
  DataT = _ResT,
  PickKeys extends KeysOf<DataT> = KeysOf<DataT>,
  DefaultT = undefined,
> (
  request: Ref<ReqT> | ReqT | (() => ReqT),
  arg1?: string | Omit<UseFetchOptions<_ResT, DataT, PickKeys, DefaultT, ReqT, Method>, 'lazy'>,
  arg2?: string,
) {
  const [opts = {}, autoKey] = typeof arg1 === 'string' ? [{}, arg1] : [arg1, arg2]

  if (import.meta.dev) {
    // @ts-expect-error private property
    opts._functionName ||= 'useLazyFetch'
  }

  return useFetch<ResT, ErrorT, ReqT, Method, _ResT, DataT, PickKeys, DefaultT>(request, {
    ...opts,
    lazy: true,
  },
  // @ts-expect-error we pass an extra argument with the resolved auto-key to prevent another from being injected
  autoKey)
}

function generateOptionSegments<_ResT, DataT, DefaultT> (opts: UseFetchOptions<_ResT, DataT, any, DefaultT, any, any>) {
  const segments: Array<string | undefined | Record<string, string>> = [
    toValue(opts.method as MaybeRef<string | undefined> | undefined)?.toUpperCase() || 'GET',
    toValue(opts.baseURL),
  ]
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  for (const _obj of [opts.query || opts.params]) {
    const obj = toValue(_obj)
    if (!obj) { continue }

    const unwrapped: Record<string, string> = {}
    for (const [key, value] of Object.entries(obj)) {
      unwrapped[toValue(key)] = toValue(value)
    }
    segments.push(unwrapped)
  }
  if (opts.body) {
    const value = toValue(opts.body)
    if (!value) {
      segments.push(hash(value))
    } else if (value instanceof ArrayBuffer) {
      segments.push(hash(Object.fromEntries([...new Uint8Array(value).entries()].map(([k, v]) => [k, v.toString()]))))
    } else if (value instanceof FormData) {
      const obj: Record<string, string> = {}
      for (const entry of value.entries()) {
        const [key, val] = entry
        obj[key] = val instanceof File ? val.name : val
      }
      segments.push(hash(obj))
    } else if (isPlainObject(value)) {
      segments.push(hash(reactive(value)))
    } else {
      try {
        segments.push(hash(value))
      } catch {
        console.warn('[useFetch] Failed to hash body', value)
      }
    }
  }
  return segments
}
</file>

<file path="packages/nuxt/src/app/composables/head.ts">
// eslint-disable-next-line @typescript-eslint/no-deprecated
export { injectHead, useHead, useServerHead, useSeoMeta, useServerSeoMeta, useHeadSafe, useServerHeadSafe } from '#unhead/composables'
</file>

<file path="packages/nuxt/src/app/composables/hydrate.ts">
import { useNuxtApp } from '../nuxt'
import type { NuxtPayload } from '../nuxt'

/**
 * Allows full control of the hydration cycle to set and receive data from the server.
 * @param key a unique key to identify the data in the Nuxt payload
 * @param get a function that returns the value to set the initial data
 * @param set a function that will receive the data on the client-side
 * @since 3.0.0
 */
export const useHydration = <K extends keyof NuxtPayload, T = NuxtPayload[K]> (key: K, get: () => T, set: (value: T) => void) => {
  const nuxtApp = useNuxtApp()

  if (import.meta.server) {
    nuxtApp.hooks.hook('app:rendered', () => {
      nuxtApp.payload[key] = get()
    })
  }

  if (import.meta.client) {
    nuxtApp.hooks.hook('app:created', () => {
      set(nuxtApp.payload[key] as T)
    })
  }
}
</file>

<file path="packages/nuxt/src/app/composables/id.ts">
import { useId as _useId } from 'vue'

/** @deprecated Use `useId` from `vue` */
export const useId = _useId
</file>

<file path="packages/nuxt/src/app/composables/index.ts">
export { defineNuxtComponent } from './component'
export { useAsyncData, useLazyAsyncData, useNuxtData, refreshNuxtData, clearNuxtData } from './asyncData'
export type { AsyncDataOptions, AsyncData, AsyncDataRequestStatus } from './asyncData'
export { useHydration } from './hydrate'
export { callOnce } from './once'
export { useState, clearNuxtState } from './state'
export { clearError, createError, isNuxtError, showError, useError } from './error'
export type { NuxtError } from './error'
export { useFetch, useLazyFetch } from './fetch'
export type { FetchResult, UseFetchOptions } from './fetch'
export { useCookie, refreshCookie } from './cookie'
export type { CookieOptions, CookieRef } from './cookie'
// eslint-disable-next-line @typescript-eslint/no-deprecated
export { onPrehydrate, prerenderRoutes, useRequestHeaders, useRequestEvent, useRequestFetch, setResponseStatus, useResponseHeader } from './ssr'
export { onNuxtReady } from './ready'
export { abortNavigation, addRouteMiddleware, defineNuxtRouteMiddleware, onBeforeRouteLeave, onBeforeRouteUpdate, setPageLayout, navigateTo, useRoute, useRouter } from './router'
export type { AddRouteMiddlewareOptions, RouteMiddleware } from './router'
export { preloadComponents, prefetchComponents, preloadRouteComponents } from './preload'
export { isPrerendered, loadPayload, preloadPayload, definePayloadReducer, definePayloadReviver } from './payload'
// eslint-disable-next-line @typescript-eslint/no-deprecated
export { getAppManifest, getRouteRules } from './manifest'
export type { NuxtAppManifest, NuxtAppManifestMeta } from './manifest'
export type { ReloadNuxtAppOptions } from './chunk'
export { reloadNuxtApp } from './chunk'
export { useRequestURL } from './url'
export { usePreviewMode } from './preview'
// eslint-disable-next-line @typescript-eslint/no-deprecated
export { useId } from './id'
export { useRouteAnnouncer } from './route-announcer'
export type { Politeness } from './route-announcer'
export { useRuntimeHook } from './runtime-hook'
// eslint-disable-next-line @typescript-eslint/no-deprecated
export { injectHead, useHead, useHeadSafe, useSeoMeta, useServerHead, useServerHeadSafe, useServerSeoMeta } from './head'
</file>

<file path="packages/nuxt/src/app/composables/lazy-hydration.ts">
import type { AsyncComponentLoader, Component, ComponentPublicInstance, DefineComponent } from 'vue'

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
type LazyHydrationComponent<T extends Component, Props> = T & DefineComponent<Props, {}, {}, {}, {}, {}, {}, { hydrated: () => void }>

export function defineLazyHydrationComponent<T extends Component = { new (): ComponentPublicInstance }> (strategy: 'visible', source: AsyncComponentLoader<T>): LazyHydrationComponent<T, { hydrateOnVisible?: IntersectionObserverInit | true }>
export function defineLazyHydrationComponent<T extends Component = { new (): ComponentPublicInstance }> (strategy: 'idle', source: AsyncComponentLoader<T>): LazyHydrationComponent<T, { hydrateOnIdle?: number | true }>
export function defineLazyHydrationComponent<T extends Component = { new (): ComponentPublicInstance }> (strategy: 'interaction', source: AsyncComponentLoader<T>): LazyHydrationComponent<T, { hydrateOnInteraction?: keyof HTMLElementEventMap | Array<keyof HTMLElementEventMap> }>
export function defineLazyHydrationComponent<T extends Component = { new (): ComponentPublicInstance }> (strategy: 'mediaQuery', source: AsyncComponentLoader<T>): LazyHydrationComponent<T, { hydrateOnMediaQuery: string }>
export function defineLazyHydrationComponent<T extends Component = { new (): ComponentPublicInstance }> (strategy: 'if', source: AsyncComponentLoader<T>): LazyHydrationComponent<T, { hydrateWhen: boolean }>
export function defineLazyHydrationComponent<T extends Component = { new (): ComponentPublicInstance }> (strategy: 'time', source: AsyncComponentLoader<T>): LazyHydrationComponent<T, { hydrateAfter: number | true }>
export function defineLazyHydrationComponent<T extends Component = { new (): ComponentPublicInstance }> (strategy: 'never', source: AsyncComponentLoader<T>): LazyHydrationComponent<T, { hydrateNever?: true }>

export function defineLazyHydrationComponent (_strategy: string, _source: AsyncComponentLoader<any>): any {}
</file>

<file path="packages/nuxt/src/app/composables/loading-indicator.ts">
import { computed, getCurrentScope, onScopeDispose, shallowRef } from 'vue'
import type { Ref } from 'vue'
import { useNuxtApp } from '../nuxt'

export type LoadingIndicatorOpts = {
  /** @default 2000 */
  duration: number
  /** @default 200 */
  throttle: number
  /** @default 500 */
  hideDelay: number
  /** @default 400 */
  resetDelay: number
  /**
   * You can provide a custom function to customize the progress estimation,
   * which is a function that receives the duration of the loading bar (above)
   * and the elapsed time. It should return a value between 0 and 100.
   */
  estimatedProgress?: (duration: number, elapsed: number) => number
}

export type LoadingIndicator = {
  _cleanup: () => void
  progress: Ref<number>
  isLoading: Ref<boolean>
  error: Ref<boolean>
  start: (opts?: { force?: boolean }) => void
  set: (value: number, opts?: { force?: boolean }) => void
  finish: (opts?: { force?: boolean, error?: boolean }) => void
  clear: () => void
}

function defaultEstimatedProgress (duration: number, elapsed: number): number {
  const completionPercentage = elapsed / duration * 100
  return (2 / Math.PI * 100) * Math.atan(completionPercentage / 50)
}

function createLoadingIndicator (opts: Partial<LoadingIndicatorOpts> = {}) {
  const { duration = 2000, throttle = 200, hideDelay = 500, resetDelay = 400 } = opts
  const getProgress = opts.estimatedProgress || defaultEstimatedProgress
  const nuxtApp = useNuxtApp()
  const progress = shallowRef(0)
  const isLoading = shallowRef(false)
  const error = shallowRef(false)
  let done = false
  let rafId: number

  let throttleTimeout: number | NodeJS.Timeout
  let hideTimeout: number | NodeJS.Timeout
  let resetTimeout: number | NodeJS.Timeout

  const start = (opts: { force?: boolean } = {}) => {
    _clearTimeouts()
    error.value = false
    set(0, opts)
  }

  function set (at = 0, opts: { force?: boolean } = {}) {
    if (nuxtApp.isHydrating) {
      return
    }
    if (at >= 100) { return finish({ force: opts.force }) }
    clear()
    progress.value = at < 0 ? 0 : at
    const throttleTime = opts.force ? 0 : throttle
    if (throttleTime && import.meta.client) {
      throttleTimeout = setTimeout(() => {
        isLoading.value = true
        _startProgress()
      }, throttleTime)
    } else {
      isLoading.value = true
      _startProgress()
    }
  }

  function _hide () {
    if (import.meta.client) {
      hideTimeout = setTimeout(() => {
        isLoading.value = false
        resetTimeout = setTimeout(() => { progress.value = 0 }, resetDelay)
      }, hideDelay)
    }
  }

  function finish (opts: { force?: boolean, error?: boolean } = {}) {
    progress.value = 100
    done = true
    clear()
    _clearTimeouts()
    if (opts.error) {
      error.value = true
    }
    if (opts.force) {
      progress.value = 0
      isLoading.value = false
    } else {
      _hide()
    }
  }

  function _clearTimeouts () {
    if (import.meta.client) {
      clearTimeout(hideTimeout)
      clearTimeout(resetTimeout)
    }
  }

  function clear () {
    if (import.meta.client) {
      clearTimeout(throttleTimeout)
      cancelAnimationFrame(rafId)
    }
  }

  function _startProgress () {
    done = false
    let startTimeStamp: number

    function step (timeStamp: number): void {
      if (done) { return }

      startTimeStamp ??= timeStamp
      const elapsed = timeStamp - startTimeStamp
      progress.value = Math.max(0, Math.min(100, getProgress(duration, elapsed)))
      if (import.meta.client) {
        rafId = requestAnimationFrame(step)
      }
    }

    if (import.meta.client) {
      rafId = requestAnimationFrame(step)
    }
  }

  let _cleanup = () => {}
  if (import.meta.client) {
    const unsubLoadingStartHook = nuxtApp.hook('page:loading:start', () => {
      start()
    })
    const unsubLoadingFinishHook = nuxtApp.hook('page:loading:end', () => {
      finish()
    })
    const unsubError = nuxtApp.hook('vue:error', () => finish())

    _cleanup = () => {
      unsubError()
      unsubLoadingStartHook()
      unsubLoadingFinishHook()
      clear()
    }
  }

  return {
    _cleanup,
    progress: computed(() => progress.value),
    isLoading: computed(() => isLoading.value),
    error: computed(() => error.value),
    start,
    set,
    finish,
    clear,
  }
}

/**
 * composable to handle the loading state of the page
 * @since 3.9.0
 */
export function useLoadingIndicator (opts: Partial<LoadingIndicatorOpts> = {}): Omit<LoadingIndicator, '_cleanup'> {
  const nuxtApp = useNuxtApp()

  // Initialise global loading indicator if it doesn't exist already
  const indicator = nuxtApp._loadingIndicator ||= createLoadingIndicator(opts)
  if (import.meta.client && getCurrentScope()) {
    nuxtApp._loadingIndicatorDeps ||= 0
    nuxtApp._loadingIndicatorDeps++
    onScopeDispose(() => {
      nuxtApp._loadingIndicatorDeps!--
      if (nuxtApp._loadingIndicatorDeps === 0) {
        indicator._cleanup()
        delete nuxtApp._loadingIndicator
      }
    })
  }

  return indicator
}
</file>

<file path="packages/nuxt/src/app/composables/manifest.ts">
import type { H3Event } from 'h3'
import type { NitroRouteRules } from 'nitropack/types'
import { useNuxtApp, useRuntimeConfig } from '../nuxt'
// @ts-expect-error virtual file
import { appManifest as isAppManifestEnabled } from '#build/nuxt.config.mjs'
// @ts-expect-error virtual file
import { buildAssetsURL } from '#internal/nuxt/paths'
// @ts-expect-error virtual file
import _routeRulesMatcher from '#build/route-rules.mjs'

const routeRulesMatcher = _routeRulesMatcher as (path: string) => NitroRouteRules

export interface NuxtAppManifestMeta {
  id: string
  timestamp: number
}

export interface NuxtAppManifest extends NuxtAppManifestMeta {
  prerendered: string[]
}

let manifest: Promise<NuxtAppManifest>

function fetchManifest () {
  if (!isAppManifestEnabled) {
    throw new Error('[nuxt] app manifest should be enabled with `experimental.appManifest`')
  }
  if (import.meta.server) {
    // @ts-expect-error virtual file
    manifest = import(/* webpackIgnore: true */ /* @vite-ignore */ '#app-manifest')
  } else {
    manifest = $fetch<NuxtAppManifest>(buildAssetsURL(`builds/meta/${useRuntimeConfig().app.buildId}.json`), {
      responseType: 'json',
    })
  }
  manifest.catch((e) => {
    console.error('[nuxt] Error fetching app manifest.', e)
  })
  return manifest
}

/** @since 3.7.4 */
export function getAppManifest (): Promise<NuxtAppManifest> {
  if (!isAppManifestEnabled) {
    throw new Error('[nuxt] app manifest should be enabled with `experimental.appManifest`')
  }
  if (import.meta.server) {
    useNuxtApp().ssrContext!['~preloadManifest'] = true
  }
  return manifest || fetchManifest()
}

/** @since 3.7.4 */
export function getRouteRules (event: H3Event): NitroRouteRules
export function getRouteRules (options: { path: string }): Record<string, any>
/** @deprecated use `getRouteRules({ path })` instead */
export function getRouteRules (url: string): Record<string, any>
export function getRouteRules (arg: string | H3Event | { path: string }) {
  const path = typeof arg === 'string' ? arg : arg.path
  try {
    return routeRulesMatcher(path)
  } catch (e) {
    console.error('[nuxt] Error matching route rules.', e)
    return {}
  }
}
</file>

<file path="packages/nuxt/src/app/composables/once.ts">
import { useRouter } from './router'
import { useNuxtApp } from '../nuxt'

type CallOnceOptions = {
  mode?: 'navigation' | 'render'
}

let _isHmrUpdating = false

/**
 * An SSR-friendly utility to call a method once
 * @param key a unique key ensuring the function can be properly de-duplicated across requests
 * @param fn a function to call
 * @param options Setup the mode, e.g. to re-execute on navigation
 * @see https://nuxt.com/docs/4.x/api/utils/call-once
 * @since 3.9.0
 */
export function callOnce (key?: string, fn?: (() => any | Promise<any>), options?: CallOnceOptions): Promise<void>
export function callOnce (fn?: (() => any | Promise<any>), options?: CallOnceOptions): Promise<void>
export async function callOnce (...args: any[]): Promise<void> {
  const autoKey = typeof args[args.length - 1] === 'string' ? args.pop() : undefined
  if (typeof args[0] !== 'string') { args.unshift(autoKey) }
  const [_key, fn, options] = args as [string, (() => any | Promise<any>), CallOnceOptions | undefined]
  if (!_key || typeof _key !== 'string') {
    throw new TypeError('[nuxt] [callOnce] key must be a string: ' + _key)
  }
  if (fn !== undefined && typeof fn !== 'function') {
    throw new Error('[nuxt] [callOnce] fn must be a function: ' + fn)
  }
  const nuxtApp = useNuxtApp()

  if (options?.mode === 'navigation') {
    const cleanups: Array<() => void> = []
    function callback () {
      nuxtApp.payload.once.delete(_key)
      for (const cleanup of cleanups) {
        cleanup()
      }
    }
    cleanups.push(nuxtApp.hooks.hook('page:start', callback), useRouter().beforeResolve(callback))
  }

  // If key already ran
  if (nuxtApp.payload.once.has(_key)) {
    // Allow re-execution during HMR
    if (!import.meta.dev || !_isHmrUpdating) {
      return
    }
  }

  nuxtApp._once ||= {}
  nuxtApp._once[_key] ||= fn() || true
  await nuxtApp._once[_key]
  nuxtApp.payload.once.add(_key)
  delete nuxtApp._once[_key]
}

if (import.meta.hot) {
  import.meta.hot.on('vite:beforeUpdate', (payload) => {
    if (payload.updates.some((u: any) => u.type === 'js-update')) {
      _isHmrUpdating = true
    }
  })

  import.meta.hot.on('vite:afterUpdate', (payload) => {
    if (payload.updates.some((u: any) => u.type === 'js-update')) {
      _isHmrUpdating = false
    }
  })
}
</file>

<file path="packages/nuxt/src/app/composables/payload.ts">
import { hasProtocol, joinURL } from 'ufo'
import { parse } from 'devalue'
import { getCurrentInstance, onServerPrefetch, reactive } from 'vue'
import { useNuxtApp, useRuntimeConfig } from '../nuxt'
import type { NuxtPayload } from '../nuxt'
import { useHead } from './head'

import { useRoute } from './router'
import { getAppManifest, getRouteRules } from './manifest'

// @ts-expect-error virtual import
import { appId, appManifest, multiApp, payloadExtraction, renderJsonPayloads } from '#build/nuxt.config.mjs'

interface LoadPayloadOptions {
  fresh?: boolean
  hash?: string
}

/** @since 3.0.0 */
export async function loadPayload (url: string, opts: LoadPayloadOptions = {}): Promise<Record<string, any> | null> {
  if (import.meta.server || !payloadExtraction) { return null }
  if (await shouldLoadPayload(url)) {
    const payloadURL = await _getPayloadURL(url, opts)
    return await _importPayload(payloadURL) || null
  }
  return null
}
let linkRelType: string | undefined
function detectLinkRelType () {
  if (import.meta.server) { return 'preload' }
  if (linkRelType) { return linkRelType }
  const relList = document.createElement('link').relList
  linkRelType = relList && relList.supports && relList.supports('prefetch') ? 'prefetch' : 'preload'
  return linkRelType
}
/** @since 3.0.0 */
export function preloadPayload (url: string, opts: LoadPayloadOptions = {}): Promise<void> {
  const nuxtApp = useNuxtApp()
  const promise = _getPayloadURL(url, opts).then((payloadURL) => {
    const link = renderJsonPayloads
      ? { rel: detectLinkRelType(), as: 'fetch', crossorigin: 'anonymous', href: payloadURL } as const
      : { rel: 'modulepreload', crossorigin: '', href: payloadURL } as const

    if (import.meta.server) {
      nuxtApp.runWithContext(() => useHead({ link: [link] }))
    } else {
      const linkEl = document.createElement('link')
      for (const key of Object.keys(link) as Array<keyof typeof link>) {
        linkEl[key === 'crossorigin' ? 'crossOrigin' : key] = link[key]!
      }
      document.head.appendChild(linkEl)
      return new Promise<void>((resolve, reject) => {
        linkEl.addEventListener('load', () => resolve())
        linkEl.addEventListener('error', () => reject())
      })
    }
  })
  if (import.meta.server) {
    onServerPrefetch(() => promise)
  }
  return promise
}

// --- Internal ---

const filename = renderJsonPayloads ? '_payload.json' : '_payload.js'
async function _getPayloadURL (url: string, opts: LoadPayloadOptions = {}) {
  const u = new URL(url, 'http://localhost')
  if (u.host !== 'localhost' || hasProtocol(u.pathname, { acceptRelative: true })) {
    throw new Error('Payload URL must not include hostname: ' + url)
  }
  const config = useRuntimeConfig()
  const hash = opts.hash || (opts.fresh ? Date.now() : config.app.buildId)
  const cdnURL = config.app.cdnURL
  const baseOrCdnURL = cdnURL && await isPrerendered(url) ? cdnURL : config.app.baseURL
  return joinURL(baseOrCdnURL, u.pathname, filename + (hash ? `?${hash}` : ''))
}

async function _importPayload (payloadURL: string) {
  if (import.meta.server || !payloadExtraction) { return null }
  const payloadPromise = renderJsonPayloads
    ? fetch(payloadURL, { cache: 'force-cache' }).then(res => res.text().then(parsePayload))
    : import(/* webpackIgnore: true */ /* @vite-ignore */ payloadURL).then(r => r.default || r)

  try {
    return await payloadPromise
  } catch (err) {
    console.warn('[nuxt] Cannot load payload ', payloadURL, err)
  }
  return null
}

function _shouldLoadPrerenderedPayload (rules: Record<string, any>) {
  if (rules.redirect) {
    return false
  }
  if (rules.prerender) {
    return true
  }
}

async function _isPrerenderedInManifest (url: string) {
  // Note: Alternative for server is checking x-nitro-prerender header
  if (!appManifest) {
    return false
  }
  url = url === '/' ? url : url.replace(/\/$/, '')
  const manifest = await getAppManifest()
  return manifest.prerendered.includes(url)
}

/**
 * @internal
 */
export async function shouldLoadPayload (url = useRoute().path) {
  const rules = getRouteRules({ path: url })
  const res = _shouldLoadPrerenderedPayload(rules)
  if (res !== undefined) {
    return res
  }

  if (rules.payload) {
    return true
  }

  return await _isPrerenderedInManifest(url)
}

/** @since 3.0.0 */
export async function isPrerendered (url = useRoute().path) {
  const res = _shouldLoadPrerenderedPayload(getRouteRules({ path: url }))
  if (res !== undefined) {
    return res
  }

  return await _isPrerenderedInManifest(url)
}

let payloadCache: NuxtPayload | null = null

/** @since 3.4.0 */
export async function getNuxtClientPayload () {
  if (import.meta.server) {
    return null
  }
  if (payloadCache) {
    return payloadCache
  }

  const el = multiApp ? document.querySelector(`[data-nuxt-data="${appId}"]`) as HTMLElement : document.getElementById('__NUXT_DATA__')
  if (!el) {
    return {} as Partial<NuxtPayload>
  }

  const inlineData = await parsePayload(el.textContent || '')

  const externalData = el.dataset.src ? await _importPayload(el.dataset.src) : undefined

  payloadCache = {
    ...inlineData,
    ...externalData,
    ...(multiApp ? window.__NUXT__?.[appId] : window.__NUXT__),
  }

  if (payloadCache!.config?.public) {
    payloadCache!.config.public = reactive(payloadCache!.config.public)
  }

  return payloadCache
}

export async function parsePayload (payload: string) {
  return await parse(payload, useNuxtApp()._payloadRevivers)
}

/**
 * This is an experimental function for configuring passing rich data from server -> client.
 * @since 3.4.0
 */
export function definePayloadReducer (
  name: string,
  reduce: (data: any) => any,
) {
  if (import.meta.server) {
    useNuxtApp().ssrContext!['~payloadReducers'][name] = reduce
  }
}

/**
 * This is an experimental function for configuring passing rich data from server -> client.
 *
 * This function _must_ be called in a Nuxt plugin that is `unshift`ed to the beginning of the Nuxt plugins array.
 * @since 3.4.0
 */
export function definePayloadReviver (
  name: string,
  revive: (data: any) => any | undefined,
) {
  if (import.meta.dev && getCurrentInstance()) {
    console.warn('[nuxt] [definePayloadReviver] This function must be called in a Nuxt plugin that is `unshift`ed to the beginning of the Nuxt plugins array.')
  }
  if (import.meta.client) {
    useNuxtApp()._payloadRevivers[name] = revive
  }
}
</file>

<file path="packages/nuxt/src/app/composables/preload.ts">
import type { Component } from 'vue'
import type { RouteLocationRaw, Router } from 'vue-router'
import { useNuxtApp } from '../nuxt'
import { toArray } from '../utils'
import { useRouter } from './router'

/**
 * Preload a component or components that have been globally registered.
 * @param components Pascal-cased name or names of components to prefetch
 * @since 3.0.0
 */
export const preloadComponents = async (components: string | string[]) => {
  if (import.meta.server) { return }
  const nuxtApp = useNuxtApp()

  components = toArray(components)
  await Promise.all(components.map((name) => {
    const component = nuxtApp.vueApp._context.components[name]
    if (component) {
      return _loadAsyncComponent(component)
    }
  }))
}

/**
 * Prefetch a component or components that have been globally registered.
 * @param components Pascal-cased name or names of components to prefetch
 * @since 3.0.0
 */
export const prefetchComponents = (components: string | string[]) => {
  if (import.meta.server) { return }

  // TODO
  return preloadComponents(components)
}

// --- Internal ---

export function _loadAsyncComponent (component: Component) {
  if ((component as any)?.__asyncLoader && !(component as any).__asyncResolved) {
    return (component as any).__asyncLoader()
  }
}

/** @since 3.0.0 */
export async function preloadRouteComponents (to: RouteLocationRaw, router: Router & { _routePreloaded?: Set<string>, _preloadPromises?: Array<Promise<unknown>> } = useRouter()): Promise<void> {
  if (import.meta.server) { return }

  const { path, matched } = router.resolve(to)

  if (!matched.length) { return }
  router._routePreloaded ||= new Set()
  if (router._routePreloaded.has(path)) { return }

  const promises = router._preloadPromises ||= []

  if (promises.length > 4) {
    // Defer adding new preload requests until the existing ones have resolved
    return Promise.all(promises).then(() => preloadRouteComponents(to, router))
  }

  router._routePreloaded.add(path)

  for (const route of matched) {
    const component = route.components?.default
    if (typeof component !== 'function') {
      continue
    }
    const promise = Promise.resolve((component as () => unknown)())
      .catch(() => {})
      .finally(() => promises.splice(promises.indexOf(promise)))
    promises.push(promise)
  }

  await Promise.all(promises)
}
</file>

<file path="packages/nuxt/src/app/composables/preview.ts">
import { toRef, watch } from 'vue'

import { useState } from './state'
import { refreshNuxtData } from './asyncData'
import { useRoute, useRouter } from './router'

interface Preview {
  enabled: boolean
  state: Record<any, unknown>
  _initialized?: boolean
}

/**
 * Options for configuring preview mode.
 */
interface PreviewModeOptions<S> {
  /**
   * A function that determines whether preview mode should be enabled based on the current state.
   * @param {Record<any, unknown>} state - The state of the preview.
   * @returns {boolean} A boolean indicating whether the preview mode is enabled.
   */
  shouldEnable?: (state: Preview['state']) => boolean
  /**
   * A function that retrieves the current state.
   * The `getState` function will append returned values to current state, so be careful not to accidentally overwrite important state.
   * @param {Record<any, unknown>} state - The preview state.
   * @returns {Record<any, unknown>} The preview state.
   */
  getState?: (state: Preview['state']) => S
  /**
   * A function to be called when the preview mode is enabled.
   */
  onEnable?: () => void
  /**
   * A function to be called when the preview mode is disabled.
   */
  onDisable?: () => void
}

type EnteredState = Record<any, unknown> | null | undefined | void

let unregisterRefreshHook: (() => any) | undefined

/** @since 3.11.0 */
export function usePreviewMode<S extends EnteredState> (options: PreviewModeOptions<S> = {}) {
  const preview = useState<Preview>('_preview-state', () => ({
    enabled: false,
    state: {},
  }))

  if (preview.value._initialized) {
    return {
      enabled: toRef(preview.value, 'enabled'),
      state: preview.value.state as S extends void ? Preview['state'] : (NonNullable<S> & Preview['state']),
    }
  }

  if (import.meta.client) {
    preview.value._initialized = true
  }

  if (!preview.value.enabled) {
    const shouldEnable = options.shouldEnable ?? defaultShouldEnable
    const result = shouldEnable(preview.value.state)

    if (typeof result === 'boolean') { preview.value.enabled = result }
  }

  watch(() => preview.value.enabled, (value) => {
    if (value) {
      const getState = options.getState ?? getDefaultState
      const newState = getState(preview.value.state)

      if (newState !== preview.value.state) {
        Object.assign(preview.value.state, newState)
      }

      if (import.meta.client && !unregisterRefreshHook) {
        const onEnable = options.onEnable ?? refreshNuxtData
        onEnable()

        unregisterRefreshHook = options.onDisable ?? useRouter().afterEach(() => refreshNuxtData())
      }
    } else if (unregisterRefreshHook) {
      unregisterRefreshHook()

      unregisterRefreshHook = undefined
    }
  }, { immediate: true, flush: 'sync' })

  return {
    enabled: toRef(preview.value, 'enabled'),
    state: preview.value.state as S extends void ? Preview['state'] : (NonNullable<S> & Preview['state']),
  }
}

function defaultShouldEnable () {
  const route = useRoute()
  const previewQueryName = 'preview'

  return route.query[previewQueryName] === 'true'
}

function getDefaultState (state: Preview['state']) {
  if (state.token !== undefined) {
    return state
  }

  const route = useRoute()

  state.token = Array.isArray(route.query.token) ? route.query.token[0] : route.query.token

  return state
}
</file>

<file path="packages/nuxt/src/app/composables/ready.ts">
import { useNuxtApp } from '../nuxt'
import { requestIdleCallback } from '../compat/idle-callback'

/** @since 3.1.0 */
export const onNuxtReady = (callback: () => any) => {
  if (import.meta.server) { return }

  const nuxtApp = useNuxtApp()
  if (nuxtApp.isHydrating) {
    nuxtApp.hooks.hookOnce('app:suspense:resolve', () => { requestIdleCallback(() => callback()) })
  } else {
    requestIdleCallback(() => callback())
  }
}
</file>

<file path="packages/nuxt/src/app/composables/route-announcer.ts">
import type { Ref } from 'vue'
import { getCurrentScope, onScopeDispose, shallowRef } from 'vue'
import { useNuxtApp } from '../nuxt'
import { injectHead } from './head'

export type Politeness = 'assertive' | 'polite' | 'off'

export type NuxtRouteAnnouncerOpts = {
  /** @default 'polite' */
  politeness?: Politeness
}

export type RouteAnnouncer = {
  message: Ref<string>
  politeness: Ref<Politeness>
  set: (message: string, politeness: Politeness) => void
  polite: (message: string) => void
  assertive: (message: string) => void
  _cleanup: () => void
}

function createRouteAnnouncer (opts: NuxtRouteAnnouncerOpts = {}) {
  const message = shallowRef('')
  const politeness = shallowRef<Politeness>(opts.politeness || 'polite')
  const activeHead = injectHead()

  function set (messageValue: string = '', politenessSetting: Politeness = 'polite') {
    message.value = messageValue
    politeness.value = politenessSetting
  }

  function polite (message: string) {
    return set(message, 'polite')
  }

  function assertive (message: string) {
    return set(message, 'assertive')
  }

  function _updateMessageWithPageHeading () {
    set(document?.title?.trim(), politeness.value)
  }

  function _cleanup () {
    activeHead?.hooks?.removeHook('dom:rendered', _updateMessageWithPageHeading)
  }

  _updateMessageWithPageHeading()

  activeHead?.hooks?.hook('dom:rendered', () => {
    _updateMessageWithPageHeading()
  })

  return {
    _cleanup,
    message,
    politeness,
    set,
    polite,
    assertive,
  }
}

/**
 * composable to handle the route announcer
 * @since 3.12.0
 */
export function useRouteAnnouncer (opts: Partial<NuxtRouteAnnouncerOpts> = {}): Omit<RouteAnnouncer, '_cleanup'> {
  const nuxtApp = useNuxtApp()

  // Initialise global route announcer if it doesn't exist already
  const announcer = nuxtApp._routeAnnouncer ||= createRouteAnnouncer(opts)
  if (opts.politeness !== announcer.politeness.value) {
    announcer.politeness.value = opts.politeness || 'polite'
  }
  if (import.meta.client && getCurrentScope()) {
    nuxtApp._routeAnnouncerDeps ||= 0
    nuxtApp._routeAnnouncerDeps++
    onScopeDispose(() => {
      nuxtApp._routeAnnouncerDeps!--
      if (nuxtApp._routeAnnouncerDeps === 0) {
        announcer._cleanup()
        delete nuxtApp._routeAnnouncer
      }
    })
  }

  return announcer
}
</file>

<file path="packages/nuxt/src/app/composables/router.ts">
import { getCurrentInstance, hasInjectionContext, inject, onScopeDispose } from 'vue'
import type { Ref } from 'vue'
import type { NavigationFailure, NavigationGuard, RouteLocationNormalized, RouteLocationRaw, Router, useRoute as _useRoute, useRouter as _useRouter } from 'vue-router'
import { sanitizeStatusCode } from 'h3'
import { hasProtocol, isScriptProtocol, joinURL, parseQuery, parseURL, withQuery } from 'ufo'

import type { NuxtLayouts, PageMeta } from '../../pages/runtime/composables'

import { useNuxtApp, useRuntimeConfig } from '../nuxt'
import { PageRouteSymbol } from '../components/injections'
import type { NuxtError } from './error'
import { createError, showError } from './error'
import { getUserTrace } from '../utils'
import type { MakeSerializableObject } from '../../pages/runtime/utils'

/** @since 3.0.0 */
export const useRouter: typeof _useRouter = () => {
  return useNuxtApp()?.$router as Router
}

/** @since 3.0.0 */
export const useRoute: typeof _useRoute = () => {
  if (import.meta.dev && !getCurrentInstance() && isProcessingMiddleware()) {
    const middleware = useNuxtApp()._processingMiddleware
    const trace = getUserTrace().map(({ source, line, column }) => `at ${source}:${line}:${column}`).join('\n')
    console.warn(`[nuxt] \`useRoute\` was called within middleware${typeof middleware === 'string' ? ` (\`${middleware}\`)` : ''}. This may lead to misleading results. Instead, use the (to, from) arguments passed to the middleware to access the new and old routes. Learn more: https://nuxt.com/docs/4.x/directory-structure/app/middleware#accessing-route-in-middleware` + ('\n' + trace))
  }
  if (hasInjectionContext()) {
    return inject(PageRouteSymbol, useNuxtApp()._route)
  }
  return useNuxtApp()._route
}

/** @since 3.0.0 */
export const onBeforeRouteLeave = (guard: NavigationGuard) => {
  const unsubscribe = useRouter().beforeEach((to, from, next) => {
    if (to === from) { return }
    return guard(to, from, next)
  })
  onScopeDispose(unsubscribe)
}

/** @since 3.0.0 */
export const onBeforeRouteUpdate = (guard: NavigationGuard) => {
  const unsubscribe = useRouter().beforeEach(guard)
  onScopeDispose(unsubscribe)
}

export interface RouteMiddleware {
  (to: RouteLocationNormalized, from: RouteLocationNormalized): ReturnType<NavigationGuard>
}

/** @since 3.0.0 */
/* @__NO_SIDE_EFFECTS__ */
export function defineNuxtRouteMiddleware (middleware: RouteMiddleware) {
  return middleware
}

export interface AddRouteMiddlewareOptions {
  global?: boolean
}

interface AddRouteMiddleware {
  (name: string, middleware: RouteMiddleware, options?: AddRouteMiddlewareOptions): void
  (middleware: RouteMiddleware): void
}

/** @since 3.0.0 */
export const addRouteMiddleware: AddRouteMiddleware = (name: string | RouteMiddleware, middleware?: RouteMiddleware, options: AddRouteMiddlewareOptions = {}) => {
  const nuxtApp = useNuxtApp()
  const global = options.global || typeof name !== 'string'
  const mw = typeof name !== 'string' ? name : middleware
  if (!mw) {
    console.warn('[nuxt] No route middleware passed to `addRouteMiddleware`.', name)
    return
  }
  if (global) {
    nuxtApp._middleware.global.push(mw)
  } else {
    nuxtApp._middleware.named[name] = mw
  }
}

/** @since 3.0.0 */
const isProcessingMiddleware = () => {
  try {
    if (useNuxtApp()._processingMiddleware) {
      return true
    }
  } catch {
    return false
  }
  return false
}

// Conditional types, either one or other
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never }
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U

export type OpenWindowFeatures = {
  popup?: boolean
  noopener?: boolean
  noreferrer?: boolean
} & XOR<{ width?: number }, { innerWidth?: number }>
  & XOR<{ height?: number }, { innerHeight?: number }>
  & XOR<{ left?: number }, { screenX?: number }>
  & XOR<{ top?: number }, { screenY?: number }>

export type OpenOptions = {
  target: '_blank' | '_parent' | '_self' | '_top' | (string & {})
  windowFeatures?: OpenWindowFeatures
}

export interface NavigateToOptions {
  /**
   * Whether or not the given route should replace the current route in the navigation history, rather than push it.
   */
  replace?: boolean
  /**
   * The status code to emit with the navigation. Defaults to `302 Found` when used on server side redirects.
   */
  redirectCode?: number
  /**
   * Whether or not the given route is a website/resource from a different origin. By default, navigating to external resources without setting `external: true` would result in an error.
   */
  external?: boolean
  open?: OpenOptions
}

const URL_QUOTE_RE = /"/g
/**
 * A helper that aids in programmatic navigation within your Nuxt application.
 *
 * Can be called on the server and on the client, within pages, route middleware, plugins, and more.
 * @param {RouteLocationRaw | undefined | null} [to] - The route to navigate to. Accepts a route object, string path, `undefined`, or `null`. Defaults to '/'.
 * @param {NavigateToOptions} [options] - Optional customization for controlling the behavior of the navigation.
 * @returns {Promise<void | NavigationFailure | false> | false | void | RouteLocationRaw} The navigation result, which varies depending on context and options.
 * @see https://nuxt.com/docs/4.x/api/utils/navigate-to
 * @since 3.0.0
 */
export const navigateTo = (to: RouteLocationRaw | undefined | null, options?: NavigateToOptions): Promise<void | NavigationFailure | false> | false | void | RouteLocationRaw => {
  to ||= '/'

  const toPath = typeof to === 'string' ? to : 'path' in to ? resolveRouteObject(to) : useRouter().resolve(to).href

  // Early open handler
  if (import.meta.client && options?.open) {
    const { target = '_blank', windowFeatures = {} } = options.open

    const features: string[] = []
    for (const [feature, value] of Object.entries(windowFeatures)) {
      if (value !== undefined) {
        features.push(`${feature.toLowerCase()}=${value}`)
      }
    }

    open(toPath, target, features.join(', '))
    return Promise.resolve()
  }

  const isExternalHost = hasProtocol(toPath, { acceptRelative: true })
  const isExternal = options?.external || isExternalHost
  if (isExternal) {
    if (!options?.external) {
      throw new Error('Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.')
    }
    const { protocol } = new URL(toPath, import.meta.client ? window.location.href : 'http://localhost')
    if (protocol && isScriptProtocol(protocol)) {
      throw new Error(`Cannot navigate to a URL with '${protocol}' protocol.`)
    }
  }

  const inMiddleware = isProcessingMiddleware()

  // Early redirect on client-side
  if (import.meta.client && !isExternal && inMiddleware) {
    if (options?.replace) {
      if (typeof to === 'string') {
        const { pathname, search, hash } = parseURL(to)
        return {
          path: pathname,
          ...(search && { query: parseQuery(search) }),
          ...(hash && { hash }),
          replace: true,
        }
      }
      return { ...to, replace: true }
    }
    return to
  }

  const router = useRouter()

  const nuxtApp = useNuxtApp()

  if (import.meta.server) {
    if (nuxtApp.ssrContext) {
      const fullPath = typeof to === 'string' || isExternal ? toPath : router.resolve(to).fullPath || '/'
      const location = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath)

      const redirect = async function (response: any) {
        // TODO: consider deprecating in favour of `app:rendered` and removing
        await nuxtApp.callHook('app:redirected')
        const encodedLoc = location.replace(URL_QUOTE_RE, '%22')
        const encodedHeader = encodeURL(location, isExternalHost)

        nuxtApp.ssrContext!['~renderResponse'] = {
          statusCode: sanitizeStatusCode(options?.redirectCode || 302, 302),
          body: `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${encodedLoc}"></head></html>`,
          headers: { location: encodedHeader },
        }
        return response
      }

      // We wait to perform the redirect last in case any other middleware will intercept the redirect
      // and redirect somewhere else instead.
      if (!isExternal && inMiddleware) {
        router.afterEach(final => final.fullPath === fullPath ? redirect(false) : undefined)
        return to
      }
      return redirect(!inMiddleware ? undefined : /* abort route navigation */ false)
    }
  }

  // Client-side redirection using vue-router
  if (isExternal) {
    // Run any cleanup steps for the current scope, like ending BroadcastChannel
    nuxtApp._scope.stop()
    if (options?.replace) {
      location.replace(toPath)
    } else {
      location.href = toPath
    }
    // Within in a Nuxt route middleware handler
    if (inMiddleware) {
      // Abort navigation when app is hydrated
      if (!nuxtApp.isHydrating) {
        return false
      }
      // When app is hydrating (i.e. on page load), we don't want to abort navigation as
      // it would lead to a 404 error / page that's blinking before location changes.
      return new Promise(() => {})
    }
    return Promise.resolve()
  }

  return options?.replace ? router.replace(to) : router.push(to)
}

/**
 * This will abort navigation within a Nuxt route middleware handler.
 * @since 3.0.0
 */
export const abortNavigation = (err?: string | Partial<NuxtError>) => {
  if (import.meta.dev && !isProcessingMiddleware()) {
    throw new Error('abortNavigation() is only usable inside a route middleware handler.')
  }

  if (!err) { return false }

  err = createError(err)

  if (err.fatal) {
    useNuxtApp().runWithContext(() => showError(err as NuxtError))
  }

  throw err
}

/**
 * Sets the layout for the current page.
 * @since 3.0.0
 */
export const setPageLayout = <Layout extends keyof NuxtLayouts>(layout: unknown extends Layout ? string : Layout, props?: typeof layout extends Layout ? MakeSerializableObject<NuxtLayouts[Layout]> : never) => {
  const nuxtApp = useNuxtApp()
  if (import.meta.server) {
    if (import.meta.dev && getCurrentInstance() && nuxtApp.payload.state._layout !== layout) {
      console.warn('[warn] [nuxt] `setPageLayout` should not be called to change the layout on the server within a component as this will cause hydration errors.')
    }
    nuxtApp.payload.state._layout = layout
    nuxtApp.payload.state._layoutProps = props
  }
  if (import.meta.dev && nuxtApp.isHydrating && nuxtApp.payload.serverRendered && nuxtApp.payload.state._layout !== layout) {
    console.warn('[warn] [nuxt] `setPageLayout` should not be called to change the layout during hydration as this will cause hydration errors.')
  }
  const inMiddleware = isProcessingMiddleware()
  if (inMiddleware || import.meta.server || nuxtApp.isHydrating) {
    const unsubscribe = useRouter().beforeResolve((to) => {
      to.meta.layout = layout as Exclude<PageMeta['layout'], Ref | false>
      to.meta.layoutProps = props
      unsubscribe()
    })
  }
  if (!inMiddleware) {
    const route = useRoute()
    route.meta.layout = layout as Exclude<PageMeta['layout'], Ref | false>
    route.meta.layoutProps = props
  }
}

/**
 * @internal
 */
export function resolveRouteObject (to: Exclude<RouteLocationRaw, string>) {
  return withQuery(to.path || '', to.query || {}) + (to.hash || '')
}

/**
 * @internal
 */
export function encodeURL (location: string, isExternalHost = false) {
  const url = new URL(location, 'http://localhost')
  if (!isExternalHost) {
    return url.pathname + url.search + url.hash
  }
  if (location.startsWith('//')) {
    return url.toString().replace(url.protocol, '')
  }
  return url.toString()
}
</file>

<file path="packages/nuxt/src/app/composables/runtime-hook.ts">
import { onScopeDispose } from 'vue'
import type { HookCallback } from 'hookable'
import { useNuxtApp } from '../nuxt'
import type { RuntimeNuxtHooks } from '../nuxt'

/**
 * Registers a runtime hook in a Nuxt application and ensures it is properly disposed of when the scope is destroyed.
 * @param name - The name of the hook to register.
 * @param fn - The callback function to be executed when the hook is triggered.
 * @since 3.14.0
 */
export function useRuntimeHook<THookName extends keyof RuntimeNuxtHooks> (
  name: THookName,
  fn: RuntimeNuxtHooks[THookName] extends HookCallback ? RuntimeNuxtHooks[THookName] : never,
): void {
  const nuxtApp = useNuxtApp()

  const unregister = nuxtApp.hook(name, fn)

  onScopeDispose(unregister)
}
</file>

<file path="packages/nuxt/src/app/composables/script-stubs.ts">
import type { UseScriptInput } from '@unhead/vue/scripts'
import { createError } from './error'

function renderStubMessage (name: string) {
  const message = `\`${name}\` is provided by @nuxt/scripts. Check your console to install it or run 'npx nuxt module add @nuxt/scripts' to install it.`
  if (import.meta.client) {
    throw createError({
      fatal: true,
      status: 500,
      statusText: message,
    })
  }
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScript<T extends Record<string | symbol, any>> (input: UseScriptInput, options?: Record<string, unknown>) {
  renderStubMessage('useScript')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptTriggerElement (...args: unknown[]) {
  renderStubMessage('useScriptTriggerElement')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptTriggerConsent (...args: unknown[]) {
  renderStubMessage('useScriptTriggerConsent')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptEventPage (...args: unknown[]) {
  renderStubMessage('useScriptEventPage')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptGoogleAnalytics (...args: unknown[]) {
  renderStubMessage('useScriptGoogleAnalytics')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptPlausibleAnalytics (...args: unknown[]) {
  renderStubMessage('useScriptPlausibleAnalytics')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptCloudflareWebAnalytics (...args: unknown[]) {
  renderStubMessage('useScriptCloudflareWebAnalytics')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptCrisp (...args: unknown[]) {
  renderStubMessage('useScriptCrisp')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptFathomAnalytics (...args: unknown[]) {
  renderStubMessage('useScriptFathomAnalytics')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptMatomoAnalytics (...args: unknown[]) {
  renderStubMessage('useScriptMatomoAnalytics')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptGoogleTagManager (...args: unknown[]) {
  renderStubMessage('useScriptGoogleTagManager')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptSegment (...args: unknown[]) {
  renderStubMessage('useScriptSegment')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptClarity (...args: unknown[]) {
  renderStubMessage('useScriptClarity')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptMetaPixel (...args: unknown[]) {
  renderStubMessage('useScriptMetaPixel')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptXPixel (...args: unknown[]) {
  renderStubMessage('useScriptXPixel')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptIntercom (...args: unknown[]) {
  renderStubMessage('useScriptIntercom')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptHotjar (...args: unknown[]) {
  renderStubMessage('useScriptHotjar')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptStripe (...args: unknown[]) {
  renderStubMessage('useScriptStripe')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptLemonSqueezy (...args: unknown[]) {
  renderStubMessage('useScriptLemonSqueezy')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptVimeoPlayer (...args: unknown[]) {
  renderStubMessage('useScriptVimeoPlayer')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptYouTubeIframe (...args: unknown[]) {
  renderStubMessage('useScriptYouTubeIframe')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptGoogleMaps (...args: unknown[]) {
  renderStubMessage('useScriptGoogleMaps')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptNpm (...args: unknown[]) {
  renderStubMessage('useScriptNpm')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptGoogleAdsense (...args: unknown[]) {
  renderStubMessage('useScriptGoogleAdsense')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptYouTubePlayer (...args: unknown[]) {
  renderStubMessage('useScriptYouTubePlayer')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptUmamiAnalytics (...args: unknown[]) {
  renderStubMessage('useScriptUmamiAnalytics')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptSnapchatPixel (...args: unknown[]) {
  renderStubMessage('useScriptSnapchatPixel')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptRybbitAnalytics (...args: unknown[]) {
  renderStubMessage('useScriptRybbitAnalytics')
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptDatabuddyAnalytics (...args: unknown[]) {
  renderStubMessage('useScriptDatabuddyAnalytics')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptRedditPixel (...args: unknown[]) {
  renderStubMessage('useScriptRedditPixel')
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function useScriptPayPal (...args: unknown[]) {
  renderStubMessage('useScriptPayPal')
}
</file>

<file path="packages/nuxt/src/app/composables/ssr.ts">
import type { H3Event } from 'h3'
import { setResponseStatus as _setResponseStatus, appendHeader, getRequestHeader, getRequestHeaders, getResponseHeader, removeResponseHeader, setResponseHeader } from 'h3'
import { computed, getCurrentInstance, ref } from 'vue'
import type { H3Event$Fetch } from 'nitropack/types'

import type { NuxtApp } from '../nuxt'
import { useNuxtApp } from '../nuxt'
import { toArray } from '../utils'
import { useHead } from './head'

/** @since 3.0.0 */
export function useRequestEvent (nuxtApp?: NuxtApp) {
  if (import.meta.client) { return }
  nuxtApp ||= useNuxtApp()
  return nuxtApp.ssrContext?.event
}

/** @since 3.0.0 */
export function useRequestHeaders<K extends string = string> (include: K[]): { [key in Lowercase<K>]?: string }
export function useRequestHeaders (): Readonly<Record<string, string>>
export function useRequestHeaders (include?: any[]) {
  if (import.meta.client) { return {} }
  const event = useRequestEvent()
  const _headers = event ? getRequestHeaders(event) : {}
  if (!include || !event) { return _headers }
  const headers = Object.create(null)
  for (const _key of include) {
    const key = _key.toLowerCase()
    const header = _headers[key]
    if (header) {
      headers[key] = header
    }
  }
  return headers
}

/** @since 3.9.0 */
export function useRequestHeader (header: string) {
  if (import.meta.client) { return undefined }
  const event = useRequestEvent()
  return event ? getRequestHeader(event, header) : undefined
}

/** @since 3.2.0 */
export function useRequestFetch (): H3Event$Fetch | typeof globalThis.$fetch {
  if (import.meta.client) {
    return globalThis.$fetch
  }
  return useRequestEvent()?.$fetch || globalThis.$fetch
}

/** @since 3.0.0 */
export function setResponseStatus (event: H3Event, code?: number, message?: string): void
/** @deprecated Pass `event` as first option. */
export function setResponseStatus (code: number, message?: string): void
export function setResponseStatus (arg1: H3Event | number | undefined, arg2?: number | string, arg3?: string) {
  if (import.meta.client) { return }
  if (arg1 && typeof arg1 !== 'number') {
    return _setResponseStatus(arg1, arg2 as number | undefined, arg3)
  }
  const event = useRequestEvent()
  if (event) {
    return _setResponseStatus(event, arg1, arg2 as string | undefined)
  }
}

/** @since 3.14.0 */
export function useResponseHeader (header: string) {
  if (import.meta.client) {
    if (import.meta.dev) {
      return computed({
        get: () => undefined,
        set: () => console.warn('[nuxt] Setting response headers is not supported in the browser.'),
      })
    }
    return ref()
  }

  const event = useRequestEvent()!

  return computed({
    get () {
      return getResponseHeader(event, header)
    },
    set (newValue) {
      if (!newValue) {
        return removeResponseHeader(event, header)
      }

      return setResponseHeader(event, header, newValue)
    },
  })
}

/** @since 3.8.0 */
export function prerenderRoutes (path: string | string[]) {
  if (!import.meta.server || !import.meta.prerender) { return }

  const paths = toArray(path)
  appendHeader(useRequestEvent()!, 'x-nitro-prerender', paths.map(p => encodeURIComponent(p)).join(', '))
}

const PREHYDRATE_ATTR_KEY = 'data-prehydrate-id'

/**
 * `onPrehydrate` is a composable lifecycle hook that allows you to run a callback on the client immediately before
 * Nuxt hydrates the page. This is an advanced feature.
 *
 * The callback will be stringified and inlined in the HTML so it should not have any external
 * dependencies (such as auto-imports) or refer to variables defined outside the callback.
 *
 * The callback will run before Nuxt runtime initializes so it should not rely on the Nuxt or Vue context.
 * @since 3.12.0
 */
export function onPrehydrate (callback: (el: HTMLElement) => void): void
export function onPrehydrate (callback: string | ((el: HTMLElement) => void), key?: string): undefined | string {
  if (import.meta.client) { return }

  if (typeof callback !== 'string') {
    throw new TypeError('[nuxt] To transform a callback into a string, `onPrehydrate` must be processed by the Nuxt build pipeline. If it is called in a third-party library, make sure to add the library to `build.transpile`.')
  }

  const vm = getCurrentInstance()
  if (vm && key) {
    vm.attrs[PREHYDRATE_ATTR_KEY] ||= ''
    key = ':' + key + ':'
    if (!(vm.attrs[PREHYDRATE_ATTR_KEY] as string).includes(key)) {
      vm.attrs[PREHYDRATE_ATTR_KEY] += key
    }
  }
  const code = vm && key
    ? `document.querySelectorAll('[${PREHYDRATE_ATTR_KEY}*=${JSON.stringify(key)}]').forEach` + callback
    : (callback + '()')

  useHead({
    script: [{
      key: vm && key ? key : undefined,
      tagPosition: 'bodyClose',
      tagPriority: 'critical',
      innerHTML: code,
    }],
  })

  return vm && key ? vm.attrs[PREHYDRATE_ATTR_KEY] as string : undefined
}
</file>

<file path="packages/nuxt/src/app/composables/state.ts">
import { isRef, toRef } from 'vue'
import type { Ref } from 'vue'
import { useNuxtApp } from '../nuxt'
import { toArray } from '../utils'

const useStateKeyPrefix = '$s'
/**
 * Create a global reactive ref that will be hydrated but not shared across ssr requests
 * @since 3.0.0
 * @param key a unique key ensuring that data fetching can be properly de-duplicated across requests
 * @param init a function that provides initial value for the state when it's not initiated
 */
export function useState<T> (key?: string, init?: (() => T | Ref<T>)): Ref<T>
export function useState<T> (init?: (() => T | Ref<T>)): Ref<T>
export function useState<T> (...args: any): Ref<T> {
  const autoKey = typeof args[args.length - 1] === 'string' ? args.pop() : undefined
  if (typeof args[0] !== 'string') { args.unshift(autoKey) }
  const [_key, init] = args as [string, (() => T | Ref<T>)]
  if (!_key || typeof _key !== 'string') {
    throw new TypeError('[nuxt] [useState] key must be a string: ' + _key)
  }
  if (init !== undefined && typeof init !== 'function') {
    throw new Error('[nuxt] [useState] init must be a function: ' + init)
  }
  const key = useStateKeyPrefix + _key

  const nuxtApp = useNuxtApp()
  const state = toRef(nuxtApp.payload.state, key)
  if (state.value === undefined && init) {
    const initialValue = init()
    if (isRef(initialValue)) {
      // vue will unwrap the ref for us
      nuxtApp.payload.state[key] = initialValue
      return initialValue as Ref<T>
    }
    state.value = initialValue
  }
  return state
}

/** @since 3.6.0 */
export function clearNuxtState (
  keys?: string | string[] | ((key: string) => boolean),
): void {
  const nuxtApp = useNuxtApp()
  const _allKeys = Object.keys(nuxtApp.payload.state)
    .map(key => key.substring(useStateKeyPrefix.length))

  const _keys: string[] = !keys
    ? _allKeys
    : typeof keys === 'function'
      ? _allKeys.filter(keys)
      : toArray(keys)

  for (const _key of _keys) {
    const key = useStateKeyPrefix + _key
    if (key in nuxtApp.payload.state) {
      nuxtApp.payload.state[key] = undefined
    }
  }
}
</file>

<file path="packages/nuxt/src/app/composables/url.ts">
import { getRequestURL } from 'h3'
import { useRequestEvent } from './ssr'

/** @since 3.5.0 */
export function useRequestURL (opts?: Parameters<typeof getRequestURL>[1]) {
  if (import.meta.server) {
    return getRequestURL(useRequestEvent()!, opts)
  }
  // we use globalThis to avoid crashes in web workers
  return new URL(globalThis.location.href)
}
</file>

<file path="packages/nuxt/src/app/middleware/route-rules.ts">
import { hasProtocol } from 'ufo'
import { defineNuxtRouteMiddleware } from '../composables/router'
import { getRouteRules } from '../composables/manifest'

export default defineNuxtRouteMiddleware((to) => {
  if (import.meta.server || import.meta.test) { return }
  const rules = getRouteRules({ path: to.path })
  if (rules.redirect) {
    const path = rules.redirect.includes('#') ? rules.redirect : (rules.redirect + to.hash)
    if (hasProtocol(path, { acceptRelative: true })) {
      window.location.href = path
      return false
    }
    return path
  }
})
</file>

<file path="packages/nuxt/src/app/plugins/browser-devtools-timing.client.ts">
import { defineNuxtPlugin } from '../nuxt'

export default defineNuxtPlugin({
  name: 'nuxt:browser-devtools-timing',
  enforce: 'pre',
  setup (nuxtApp) {
    nuxtApp.hooks.beforeEach((event) => {
      // @ts-expect-error __startTime is not a public API
      event.__startTime = performance.now()
    })

    // After each
    nuxtApp.hooks.afterEach((event) => {
      performance.measure(event.name, {
        // @ts-expect-error __startTime is not a public API
        start: event.__startTime,
        detail: {
          devtools: {
            dataType: 'track-entry',
            track: 'nuxt',
            color: 'tertiary-dark',
          } satisfies ExtensionTrackEntryPayload,
        },
      })
    })
  },
})

type DevToolsColor =
  'primary' | 'primary-light' | 'primary-dark' |
  'secondary' | 'secondary-light' | 'secondary-dark' |
  'tertiary' | 'tertiary-light' | 'tertiary-dark' |
  'error'

interface ExtensionTrackEntryPayload {
  dataType?: 'track-entry' // Defaults to "track-entry"
  color?: DevToolsColor // Defaults to "primary"
  track: string // Required: Name of the custom track
  trackGroup?: string // Optional: Group for organizing tracks
  properties?: [string, string][] // Key-value pairs for detailed view
  tooltipText?: string // Short description for tooltip
}
</file>

<file path="packages/nuxt/src/app/plugins/check-if-layout-used.ts">
import { nextTick } from 'vue'
import { defineNuxtPlugin } from '../nuxt'
import { onNuxtReady } from '../composables/ready'
import { useError } from '../composables/error'

// @ts-expect-error virtual file
import layouts from '#build/layouts'

export default defineNuxtPlugin({
  name: 'nuxt:checkIfLayoutUsed',
  setup (nuxtApp) {
    const error = useError()

    function checkIfLayoutUsed () {
      if (!error.value && !nuxtApp._isNuxtLayoutUsed && Object.keys(layouts).length > 0) {
        console.warn('[nuxt] Your project has layouts but the `<NuxtLayout />` component has not been used.')
      }
    }
    if (import.meta.server) {
      nuxtApp.hook('app:rendered', ({ renderResult }) => {
        if (renderResult?.html) {
          nextTick(checkIfLayoutUsed)
        }
      })
    } else {
      onNuxtReady(checkIfLayoutUsed)
    }
  },
  env: {
    islands: false,
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/check-outdated-build.client.ts">
import type { FetchError } from 'ofetch'
import { defineNuxtPlugin } from '../nuxt'
import { getAppManifest } from '../composables/manifest'
import type { NuxtAppManifestMeta } from '../composables/manifest'
import { onNuxtReady } from '../composables/ready'
// @ts-expect-error virtual file
import { buildAssetsURL } from '#internal/nuxt/paths'
// @ts-expect-error virtual file
import { outdatedBuildInterval } from '#build/nuxt.config.mjs'

export default defineNuxtPlugin((nuxtApp) => {
  if (import.meta.test) { return }

  let timeout: ReturnType<typeof setTimeout>

  async function getLatestManifest () {
    let currentManifest: NuxtAppManifestMeta | undefined
    try {
      currentManifest = await getAppManifest()
    } catch (e) {
      const err = e as FetchError | Error
      // The build is already outdated but the manifest was not cached
      if (!('status' in err && (err.status === 404 || err.status === 403))) {
        throw err
      }
    }
    if (timeout) { clearTimeout(timeout) }
    timeout = setTimeout(getLatestManifest, outdatedBuildInterval)
    try {
      const meta = await $fetch<NuxtAppManifestMeta>(buildAssetsURL('builds/latest.json') + `?${Date.now()}`)
      if (meta.id !== currentManifest?.id) {
        // There is a newer build which we will let the user handle
        nuxtApp.hooks.callHook('app:manifest:update', meta)
        if (timeout) { clearTimeout(timeout) }
      }
    } catch {
      // fail gracefully on network issue
    }
  }

  onNuxtReady(() => { timeout = setTimeout(getLatestManifest, outdatedBuildInterval) })
})
</file>

<file path="packages/nuxt/src/app/plugins/chunk-reload-immediate.client.ts">
import type { RouteLocationNormalized } from 'vue-router'
import { joinURL } from 'ufo'
import { defineNuxtPlugin, useRuntimeConfig } from '../nuxt'
import { reloadNuxtApp } from '../composables/chunk'
import { addRouteMiddleware } from '../composables/router'

// See https://github.com/nuxt/nuxt/issues/23612 for more context
export default defineNuxtPlugin({
  name: 'nuxt:chunk-reload-immediate',
  setup (nuxtApp) {
    // Remember `to.path` when navigating to a new path: A `chunkError` may occur during navigation, we then want to then reload at `to.path`
    let currentlyNavigationTo: RouteLocationNormalized | null = null

    addRouteMiddleware((to) => {
      currentlyNavigationTo = to
    })

    const config = useRuntimeConfig()

    function reloadAppAtPath (to: RouteLocationNormalized) {
      const path = joinURL(config.app.baseURL, to.fullPath)

      reloadNuxtApp({ path, persistState: true })
    }

    // Reload when a `chunkError` is thrown
    nuxtApp.hook('app:chunkError', () => reloadAppAtPath(currentlyNavigationTo ?? nuxtApp._route))

    // Reload when the app manifest updates
    nuxtApp.hook('app:manifest:update', () => reloadAppAtPath(nuxtApp._route))
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/chunk-reload.client.ts">
import { joinURL } from 'ufo'
import type { RouteLocationNormalized } from 'vue-router'
import { defineNuxtPlugin, useRuntimeConfig } from '../nuxt'
import { useRouter } from '../composables/router'
import { reloadNuxtApp } from '../composables/chunk'

export default defineNuxtPlugin({
  name: 'nuxt:chunk-reload',
  setup (nuxtApp) {
    const router = useRouter()
    const config = useRuntimeConfig()

    const chunkErrors = new Set<Error>()

    router.beforeEach(() => { chunkErrors.clear() })

    nuxtApp.hook('app:chunkError', ({ error }) => { chunkErrors.add(error) })

    function reloadAppAtPath (to: RouteLocationNormalized) {
      const path = joinURL(config.app.baseURL, to.fullPath)

      reloadNuxtApp({ path, persistState: true })
    }

    nuxtApp.hook('app:manifest:update', () => {
      router.beforeResolve(reloadAppAtPath)
    })

    router.onError((error, to) => {
      if (chunkErrors.has(error)) {
        reloadAppAtPath(to)
      }
    })
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/cross-origin-prefetch.client.ts">
import { ref } from 'vue'
import { defineNuxtPlugin } from '../nuxt'
import { useHead } from '../composables/head'

const SUPPORTED_PROTOCOLS = new Set(['http:', 'https:'])

export default defineNuxtPlugin({
  name: 'nuxt:cross-origin-prefetch',
  setup (nuxtApp) {
    const externalURLs = ref(new Set<string>())
    function generateRules () {
      return {
        type: 'speculationrules',
        key: 'speculationrules',
        innerHTML: JSON.stringify({
          prefetch: [
            {
              source: 'list',
              urls: [...externalURLs.value],
              requires: ['anonymous-client-ip-when-cross-origin'],
            },
          ],
        }),
      }
    }
    const head = useHead({
      script: [generateRules()],
    })
    nuxtApp.hook('link:prefetch', (url) => {
      for (const protocol of SUPPORTED_PROTOCOLS) {
        if (url.startsWith(protocol) && SUPPORTED_PROTOCOLS.has(new URL(url).protocol)) {
          externalURLs.value.add(url)
          head?.patch({ script: [generateRules()] })
          return
        }
      }
    })
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/debug-hooks.ts">
import { createDebugger } from 'hookable'
import { defineNuxtPlugin } from '../nuxt'

export default defineNuxtPlugin({
  name: 'nuxt:debug:hooks',
  enforce: 'pre',
  setup (nuxtApp) {
    createDebugger(nuxtApp.hooks, { tag: 'nuxt-app' })
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/dev-server-logs.ts">
import { createConsola } from 'consola'
import type { LogObject } from 'consola'
import { parse } from 'devalue'
import type { ParsedTrace } from 'errx'

import { h } from 'vue'
import { defineNuxtPlugin } from '../nuxt'

// @ts-expect-error virtual file
import { devLogs, devRootDir } from '#build/nuxt.config.mjs'

const devRevivers: Record<string, (data: any) => any> = import.meta.server
  ? {}
  : {
      VNode: data => h(data.type, data.props),
      URL: data => new URL(data),
    }

export default defineNuxtPlugin(async (nuxtApp) => {
  if (import.meta.test) { return }

  if (import.meta.server) {
    nuxtApp.ssrContext!.event.context['~payloadReducers'] = nuxtApp.ssrContext!['~payloadReducers']
    return
  }

  // Show things in console
  if (devLogs !== 'silent') {
    const logger = createConsola({
      formatOptions: {
        colors: true,
        date: true,
      },
    })
    nuxtApp.hook('dev:ssr-logs', (logs) => {
      for (const log of logs) {
        logger.log(normalizeServerLog({ ...log }))
      }
    })
  }

  if (typeof window !== 'undefined') {
    const nuxtLogsElement = document.querySelector(`[data-nuxt-logs="${nuxtApp._id}"]`)
    const content = nuxtLogsElement?.textContent
    const logs = content ? parse(content, { ...devRevivers, ...nuxtApp._payloadRevivers }) as LogObject[] : []
    await nuxtApp.hooks.callHook('dev:ssr-logs', logs)
  }
})

function normalizeFilenames (stack?: ParsedTrace[]) {
  if (!stack) {
    return ''
  }
  let message = ''
  for (const item of stack) {
    const source = item.source.replace(`${devRootDir}/`, '')
    if (item.function) {
      message += `  at ${item.function} (${source})\n`
    } else {
      message += `  at ${source}\n`
    }
  }
  return message
}

function normalizeServerLog (log: LogObject) {
  log.additional = normalizeFilenames(log.stack as ParsedTrace[])
  log.tag = 'ssr'
  delete log.stack
  return log
}
</file>

<file path="packages/nuxt/src/app/plugins/navigation-repaint.client.ts">
import { defineNuxtPlugin } from '../nuxt'
import { onNuxtReady } from '../composables/ready'
import { useRouter } from '../composables/router'

export default defineNuxtPlugin(() => {
  const router = useRouter()
  onNuxtReady(() => {
    router.beforeResolve(async () => {
      /**
       * This gives an opportunity for the browser to repaint, acknowledging user interaction.
       * It can reduce INP when navigating on prerendered routes.
       *
       * @see https://github.com/nuxt/nuxt/issues/26271#issuecomment-2178582037
       * @see https://vercel.com/blog/demystifying-inp-new-tools-and-actionable-insights
       */
      await new Promise((resolve) => {
        // Ensure we always resolve, even if the animation frame never fires
        setTimeout(resolve, 100)
        requestAnimationFrame(() => { setTimeout(resolve, 0) })
      })
    })
  })
})
</file>

<file path="packages/nuxt/src/app/plugins/payload.client.ts">
import { defineNuxtPlugin } from '../nuxt'
import { loadPayload } from '../composables/payload'
import { onNuxtReady } from '../composables/ready'
import { useRouter } from '../composables/router'
import { getAppManifest } from '../composables/manifest'

// @ts-expect-error virtual file
import { appManifest as isAppManifestEnabled, purgeCachedData } from '#build/nuxt.config.mjs'

export default defineNuxtPlugin({
  name: 'nuxt:payload',
  setup (nuxtApp) {
    // Load payload after middleware & once final route is resolved
    const staticKeysToRemove = new Set<string>()
    useRouter().beforeResolve(async (to, from) => {
      if (to.path === from.path) { return }
      const payload = await loadPayload(to.path)
      if (!payload) { return }
      if (purgeCachedData) {
        for (const key of staticKeysToRemove) {
          delete nuxtApp.static.data[key]
        }
      }
      for (const key in payload.data) {
        if (purgeCachedData) {
          if (!(key in nuxtApp.static.data)) {
            staticKeysToRemove.add(key)
          }
        }
        nuxtApp.static.data[key] = payload.data[key]
      }
    })

    onNuxtReady(() => {
      // Load payload into cache
      nuxtApp.hooks.hook('link:prefetch', async (url) => {
        const { hostname } = new URL(url, window.location.href)
        if (hostname === window.location.hostname) {
          // TODO: use preloadPayload instead once we can support preloading islands too
          await loadPayload(url).catch(() => { console.warn('[nuxt] Error preloading payload for', url) })
        }
      })
      if (isAppManifestEnabled && navigator.connection?.effectiveType !== 'slow-2g') {
        setTimeout(getAppManifest, 1000)
      }
    })
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/preload.server.ts">
import { defineNuxtPlugin } from '../nuxt'

export default defineNuxtPlugin({
  name: 'nuxt:webpack-preload',
  setup (nuxtApp) {
    nuxtApp.vueApp.mixin({
      beforeCreate () {
        const { modules } = this.$nuxt.ssrContext
        const { __moduleIdentifier } = this.$options
        if (__moduleIdentifier) {
          modules.add(__moduleIdentifier)
        }
      },
    })
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/restore-state.client.ts">
import destr from 'destr'
import { defineNuxtPlugin, useNuxtApp } from '../nuxt'

export default defineNuxtPlugin({
  name: 'nuxt:restore-state',
  hooks: {
    'app:mounted' () {
      const nuxtApp = useNuxtApp()
      try {
        const state = sessionStorage.getItem('nuxt:reload:state')
        if (state) {
          sessionStorage.removeItem('nuxt:reload:state')
          Object.assign(nuxtApp.payload.state, destr<Record<string, any>>(state)?.state)
        }
      } catch {
        // don't throw an error if we have issues reading sessionStorage
      }
    },
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/revive-payload.client.ts">
import { reactive, ref, shallowReactive, shallowRef } from 'vue'
import destr from 'destr'
import { definePayloadReviver, getNuxtClientPayload } from '../composables/payload'
import { createError } from '../composables/error'
import { defineNuxtPlugin, useNuxtApp } from '../nuxt'

// @ts-expect-error Virtual file.
import { componentIslands } from '#build/nuxt.config.mjs'

const revivers: [string, (data: any) => any][] = [
  ['NuxtError', data => createError(data)],
  ['EmptyShallowRef', data => shallowRef(data === '_' ? undefined : data === '0n' ? BigInt(0) : destr(data))],
  ['EmptyRef', data => ref(data === '_' ? undefined : data === '0n' ? BigInt(0) : destr(data))],
  ['ShallowRef', data => shallowRef(data)],
  ['ShallowReactive', data => shallowReactive(data)],
  ['Ref', data => ref(data)],
  ['Reactive', data => reactive(data)],
]

if (componentIslands) {
  revivers.push(['Island', ({ key, params, result }: any) => {
    const nuxtApp = useNuxtApp()
    if (!nuxtApp.isHydrating) {
      nuxtApp.payload.data[key] ||= $fetch(`/__nuxt_island/${key}.json`, {
        responseType: 'json',
        ...params ? { params } : {},
      }).then((r) => {
        nuxtApp.payload.data[key] = r
        return r
      })
    }
    return {
      html: '',
      ...result,
    }
  }])
}

export default defineNuxtPlugin({
  name: 'nuxt:revive-payload:client',
  order: -30,
  async setup (nuxtApp) {
    for (const [reviver, fn] of revivers) {
      definePayloadReviver(reviver, fn)
    }
    Object.assign(nuxtApp.payload, await nuxtApp.runWithContext(getNuxtClientPayload))
    delete window.__NUXT__
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/revive-payload.server.ts">
import { isReactive, isRef, isShallow, toRaw } from 'vue'
import { definePayloadReducer } from '../composables/payload'
import { isNuxtError } from '../composables/error'
import { defineNuxtPlugin } from '../nuxt'

// @ts-expect-error Virtual file.
import { componentIslands } from '#build/nuxt.config.mjs'
import { isValidIslandKey } from './utils'

const reducers: [string, (data: any) => any][] = [
  ['NuxtError', data => isNuxtError(data) && data.toJSON()],
  ['EmptyShallowRef', data => isRef(data) && isShallow(data) && !data.value && (typeof data.value === 'bigint' ? '0n' : (JSON.stringify(data.value) || '_'))],
  ['EmptyRef', data => isRef(data) && !data.value && (typeof data.value === 'bigint' ? '0n' : (JSON.stringify(data.value) || '_'))],
  ['ShallowRef', data => isRef(data) && isShallow(data) && data.value],
  ['ShallowReactive', data => isReactive(data) && isShallow(data) && toRaw(data)],
  ['Ref', data => isRef(data) && data.value],
  ['Reactive', data => isReactive(data) && toRaw(data)],
]

if (componentIslands) {
  reducers.push(['Island', data => data && data?.__nuxt_island && isValidIslandKey(data.__nuxt_island.key) && data.__nuxt_island])
}

export default defineNuxtPlugin({
  name: 'nuxt:revive-payload:server',
  setup () {
    for (const [reducer, fn] of reducers) {
      definePayloadReducer(reducer, fn)
    }
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/router.ts">
import type { Ref } from 'vue'
import { computed, defineComponent, h, isReadonly, reactive } from 'vue'
import { isEqual, joinURL, parseQuery, stringifyParsedURL, stringifyQuery, withoutBase } from 'ufo'
import { createError } from 'h3'
import { defineNuxtPlugin, useRuntimeConfig } from '../nuxt'
import { getRouteRules } from '../composables/manifest'
import { clearError, showError } from '../composables/error'
import { navigateTo } from '../composables/router'

// @ts-expect-error virtual file
import { globalMiddleware } from '#build/middleware'

interface Route {
  /** Percentage encoded pathname section of the URL. */
  path: string
  /** The whole location including the `search` and `hash`. */
  fullPath: string
  /** Object representation of the `search` property of the current location. */
  query: Record<string, any>
  /** Hash of the current location. If present, starts with a `#`. */
  hash: string
  /** Name of the matched record */
  name: string | null | undefined
  /** Object of decoded params extracted from the `path`. */
  params: Record<string, any>
  /**
   * The location we were initially trying to access before ending up
   * on the current location.
   */
  redirectedFrom: Route | undefined
  /** Merged `meta` properties from all of the matched route records. */
  meta: Record<string, any>
  /** compatibility type for vue-router */
  matched: never[]
}

function getRouteFromPath (fullPath: string | Partial<Route>) {
  const route = fullPath && typeof fullPath === 'object' ? fullPath : {}

  if (typeof fullPath === 'object') {
    fullPath = stringifyParsedURL({
      pathname: fullPath.path || '',
      search: stringifyQuery(fullPath.query || {}),
      hash: fullPath.hash || '',
    })
  }

  const url = new URL(fullPath.toString(), import.meta.client ? window.location.href : 'http://localhost')
  return {
    path: url.pathname,
    fullPath,
    query: parseQuery(url.search),
    hash: url.hash,
    // stub properties for compat with vue-router
    params: route.params || {},
    name: undefined,
    matched: route.matched || [],
    redirectedFrom: undefined,
    meta: route.meta || {},
    href: fullPath,
  }
}

type RouteGuardReturn = void | Error | string | boolean

interface RouteGuard {
  (to: Route, from: Route): RouteGuardReturn | Promise<RouteGuardReturn>
}

interface RouterHooks {
  'resolve:before': (to: Route, from: Route) => RouteGuardReturn | Promise<RouteGuardReturn>
  'navigate:before': (to: Route, from: Route) => RouteGuardReturn | Promise<RouteGuardReturn>
  'navigate:after': (to: Route, from: Route) => void | Promise<void>
  'error': (err: any) => void | Promise<void>
}

interface Router {
  currentRoute: Ref<Route>
  isReady: () => Promise<void>
  options: Record<string, unknown>
  install: () => Promise<void>
  // Navigation
  push: (url: string) => Promise<void>
  replace: (url: string) => Promise<void>
  back: () => void
  go: (delta: number) => void
  forward: () => void
  // Guards
  beforeResolve: (guard: RouterHooks['resolve:before']) => () => void
  beforeEach: (guard: RouterHooks['navigate:before']) => () => void
  afterEach: (guard: RouterHooks['navigate:after']) => () => void
  onError: (handler: RouterHooks['error']) => () => void
  // Routes
  resolve: (url: string | Partial<Route>) => Route
  addRoute: (parentName: string, route: Route) => void
  getRoutes: () => any[]
  hasRoute: (name: string) => boolean
  removeRoute: (name: string) => void
}

export default defineNuxtPlugin<{ route: Route, router: Router }>({
  name: 'nuxt:router',
  enforce: 'pre',
  setup (nuxtApp) {
    const initialURL = import.meta.client
      ? withoutBase(window.location.pathname, useRuntimeConfig().app.baseURL) + window.location.search + window.location.hash
      : nuxtApp.ssrContext!.url

    const routes: Route[] = []

    const hooks: { [key in keyof RouterHooks]: RouterHooks[key][] } = {
      'navigate:before': [],
      'resolve:before': [],
      'navigate:after': [],
      'error': [],
    }

    const registerHook = <T extends keyof RouterHooks> (hook: T, guard: RouterHooks[T]) => {
      hooks[hook].push(guard)
      return () => hooks[hook].splice(hooks[hook].indexOf(guard), 1)
    }
    const baseURL = useRuntimeConfig().app.baseURL

    const route: Route = reactive(getRouteFromPath(initialURL))
    async function handleNavigation (url: string | Partial<Route>, replace?: boolean): Promise<void> {
      try {
        // Resolve route
        const to = getRouteFromPath(url)

        // Run beforeEach hooks
        for (const middleware of hooks['navigate:before']) {
          const result = await middleware(to, route)
          // Cancel navigation
          if (result === false || result instanceof Error) { return }
          // Redirect
          if (typeof result === 'string' && result.length) { return handleNavigation(result, true) }
        }

        for (const handler of hooks['resolve:before']) {
          await handler(to, route)
        }
        // Perform navigation
        Object.assign(route, to)
        if (import.meta.client) {
          window.history[replace ? 'replaceState' : 'pushState']({}, '', joinURL(baseURL, to.fullPath))
          if (!nuxtApp.isHydrating) {
            // Clear any existing errors
            await nuxtApp.runWithContext(clearError)
          }
        }
        // Run afterEach hooks
        for (const middleware of hooks['navigate:after']) {
          await middleware(to, route)
        }
      } catch (err) {
        if (import.meta.dev && !hooks.error.length) {
          console.warn('No error handlers registered to handle middleware errors. You can register an error handler with `router.onError()`', err)
        }
        for (const handler of hooks.error) {
          await handler(err)
        }
      }
    }

    const currentRoute = computed(() => route)

    const router: Router = {
      currentRoute,
      isReady: () => Promise.resolve(),
      // These options provide a similar API to vue-router but have no effect
      options: {},
      install: () => Promise.resolve(),
      // Navigation
      push: (url: string) => handleNavigation(url, false),
      replace: (url: string) => handleNavigation(url, true),
      back: () => window.history.go(-1),
      go: (delta: number) => window.history.go(delta),
      forward: () => window.history.go(1),
      // Guards
      beforeResolve: (guard: RouterHooks['resolve:before']) => registerHook('resolve:before', guard),
      beforeEach: (guard: RouterHooks['navigate:before']) => registerHook('navigate:before', guard),
      afterEach: (guard: RouterHooks['navigate:after']) => registerHook('navigate:after', guard),
      onError: (handler: RouterHooks['error']) => registerHook('error', handler),
      // Routes
      resolve: getRouteFromPath,
      addRoute: (parentName: string, route: Route) => { routes.push(route) },
      getRoutes: () => routes,
      hasRoute: (name: string) => routes.some(route => route.name === name),
      removeRoute: (name: string) => {
        const index = routes.findIndex(route => route.name === name)
        if (index !== -1) {
          routes.splice(index, 1)
        }
      },
    }

    nuxtApp.vueApp.component('RouterLink', defineComponent({
      functional: true,
      props: {
        to: {
          type: String,
          required: true,
        },
        custom: Boolean,
        replace: Boolean,
        // Not implemented
        activeClass: String,
        exactActiveClass: String,
        ariaCurrentValue: String,
      },
      setup: (props, { slots }) => {
        const navigate = () => handleNavigation(props.to!, props.replace)
        return () => {
          const route = router.resolve(props.to!)
          return props.custom
            ? slots.default?.({ href: props.to, navigate, route })
            : h('a', { href: props.to, onClick: (e: MouseEvent) => { e.preventDefault(); return navigate() } }, slots)
        }
      },
    }))

    if (import.meta.client) {
      window.addEventListener('popstate', (event) => {
        const location = (event.target as Window).location
        router.replace(location.href.replace(location.origin, ''))
      })
    }

    // @ts-expect-error vue-router types diverge from our Route type above
    nuxtApp._route = route

    // Handle middleware
    nuxtApp._middleware ||= {
      global: [],
      named: {},
    }

    const initialLayout = nuxtApp.payload.state._layout
    const initialLayoutProps = nuxtApp.payload.state._layoutProps
    nuxtApp.hooks.hookOnce('app:created', async () => {
      router.beforeEach(async (to, from) => {
        to.meta = reactive(to.meta || {})
        if (nuxtApp.isHydrating && initialLayout && !isReadonly(to.meta.layout)) {
          to.meta.layout = initialLayout
          to.meta.layoutProps = initialLayoutProps
        }
        nuxtApp._processingMiddleware = true

        if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {
          const middlewareEntries = new Set<RouteGuard>([...globalMiddleware, ...nuxtApp._middleware.global])

          const routeRules = getRouteRules({ path: to.path })
          if (routeRules.appMiddleware) {
            for (const key in routeRules.appMiddleware) {
              const guard = nuxtApp._middleware.named[key] as RouteGuard | undefined
              if (!guard) { continue }

              if (routeRules.appMiddleware[key]) {
                middlewareEntries.add(guard)
              } else {
                middlewareEntries.delete(guard)
              }
            }
          }

          for (const middleware of middlewareEntries) {
            if (import.meta.dev) {
              nuxtApp._processingMiddleware = (middleware as any)._path || true
            }
            const result = await nuxtApp.runWithContext(() => middleware(to, from))
            if (import.meta.server) {
              if (result === false || result instanceof Error) {
                const error = result || createError({
                  status: 404,
                  statusText: `Page Not Found: ${initialURL}`,
                  data: {
                    path: initialURL,
                  },
                })
                delete nuxtApp._processingMiddleware
                return nuxtApp.runWithContext(() => showError(error))
              }
            }
            if (result === true) { continue }
            if (result || result === false) { return result }
          }
        }
      })

      router.afterEach(() => { delete nuxtApp._processingMiddleware })

      await router.replace(initialURL)
      if (!isEqual(route.fullPath, initialURL)) {
        await nuxtApp.runWithContext(() => navigateTo(route.fullPath))
      }
    })

    return {
      provide: {
        route,
        router,
      },
    }
  },
})
</file>

<file path="packages/nuxt/src/app/plugins/utils.ts">
const VALID_ISLAND_KEY_RE = /^[a-z][a-z\d-]*_[a-z\d]+$/i
/* @__PURE__ */
export function isValidIslandKey (key: string): boolean {
  return typeof key === 'string' && VALID_ISLAND_KEY_RE.test(key) && key.length <= 100
}
</file>

<file path="packages/nuxt/src/app/plugins/view-transitions.client.ts">
import { isChangingPage } from '../components/utils'
import { useRouter } from '../composables/router'
import { defineNuxtPlugin } from '../nuxt'
// @ts-expect-error virtual file
import { appViewTransition as defaultViewTransition } from '#build/nuxt.config.mjs'

export default defineNuxtPlugin((nuxtApp) => {
  if (!document.startViewTransition) {
    return
  }

  let transition: undefined | ViewTransition
  let hasUAVisualTransition = false
  let finishTransition: undefined | (() => void)
  let abortTransition: undefined | (() => void)

  const resetTransitionState = () => {
    transition = undefined
    hasUAVisualTransition = false
    abortTransition = undefined
    finishTransition = undefined
  }

  window.addEventListener('popstate', (event) => {
    hasUAVisualTransition = event.hasUAVisualTransition
    if (hasUAVisualTransition) { transition?.skipTransition() }
  })

  const router = useRouter()

  router.beforeResolve(async (to, from) => {
    const viewTransitionMode = to.meta.viewTransition ?? defaultViewTransition
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches
    const prefersNoTransition = prefersReducedMotion && viewTransitionMode !== 'always'

    if (
      viewTransitionMode === false ||
      prefersNoTransition ||
      hasUAVisualTransition ||
      !isChangingPage(to, from)
    ) {
      return
    }

    const promise = new Promise<void>((resolve, reject) => {
      finishTransition = resolve
      abortTransition = reject
    })

    let changeRoute: () => void
    const ready = new Promise<void>(resolve => (changeRoute = resolve))

    transition = document.startViewTransition!(() => {
      changeRoute()
      return promise
    })

    transition.finished.then(resetTransitionState)

    await nuxtApp.callHook('page:view-transition:start', transition)

    return ready
  })

  nuxtApp.hook('vue:error', () => {
    abortTransition?.()
    resetTransitionState()
  })

  nuxtApp.hook('page:finish', () => {
    finishTransition?.()
    resetTransitionState()
  })
})
</file>

<file path="packages/nuxt/src/app/plugins/warn.dev.server.ts">
import { defineNuxtPlugin } from '../nuxt'

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.config.warnHandler ??= (msg, _instance, trace) => {
    console.warn(`[Vue warn]: ${msg}`, trace)
  }
})
</file>

<file path="packages/nuxt/src/app/types/augments.ts">
import type { UseHeadInput } from '@unhead/vue/types'
import type { NuxtApp, useNuxtApp } from '../nuxt'

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace NodeJS {
    interface Process {
      /** @deprecated Use `import.meta.browser` instead. This may be removed in Nuxt v5 or a future major version. */
      browser: boolean
      /** @deprecated Use `import.meta.client` instead. This may be removed in Nuxt v5 or a future major version. */
      client: boolean
      /** @deprecated Use `import.meta.dev` instead. This may be removed in Nuxt v5 or a future major version. */
      dev: boolean
      /** @deprecated Use `import.meta.server` instead. This may be removed in Nuxt v5 or a future major version. */
      server: boolean
      /** @deprecated Use `import.meta.test` instead. This may be removed in Nuxt v5 or a future major version. */
      test: boolean
    }
  }

  interface ImportMeta {
    browser: boolean
    client: boolean
    dev: boolean
    server: boolean
    test: boolean
  }

  interface Window {
    __NUXT__?: Record<string, any> | Record<string, Record<string, any>>
    useNuxtApp?: typeof useNuxtApp
  }
}

declare module 'vue' {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  interface App<HostElement> {
    $nuxt: NuxtApp
  }
  interface ComponentCustomProperties {
    $nuxt: NuxtApp
  }
  interface ComponentInternalInstance {
    _nuxtOnBeforeMountCbs: Array<() => void | Promise<void>>
    _nuxtIdIndex?: Record<string, number>
    _nuxtClientOnly?: boolean
  }
  interface ComponentCustomOptions {
    /**
     * Available exclusively for `defineNuxtComponent`.
     * It will not be executed when using `defineComponent`.
     */
    head?(nuxtApp: NuxtApp): UseHeadInput
  }
}
</file>

<file path="packages/nuxt/src/app/config.ts">
import { reactive } from 'vue'
import { klona } from 'klona'
import { useNuxtApp } from './nuxt'
import type { AppConfig } from 'nuxt/schema'
// @ts-expect-error virtual file
import __appConfig from '#build/app.config.mjs'

// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
type DeepPartial<T> = T extends Function ? T : T extends Record<string, any> ? { [P in keyof T]?: DeepPartial<T[P]> } : T

// Workaround for vite HMR with virtual modules
export const _getAppConfig = () => __appConfig as AppConfig

function isPojoOrArray (val: unknown): val is object {
  return (
    Array.isArray(val) ||
    (!!val &&
      typeof val === 'object' &&
      val.constructor?.name === 'Object')
  )
}

function deepDelete (obj: any, newObj: any) {
  if (Array.isArray(obj) && Array.isArray(newObj)) {
    obj.length = 0
    obj.push(...newObj)
    return
  }

  for (const key in obj) {
    const val = newObj[key]
    if (!(key in newObj)) {
      delete (obj as any)[key]
    }

    if (isPojoOrArray(val)) {
      deepDelete(obj[key], newObj[key])
    }
  }
}

function deepAssign (obj: any, newObj: any) {
  for (const key in newObj) {
    if (key === '__proto__' || key === 'constructor') { continue }
    const val = newObj[key]
    if (isPojoOrArray(val)) {
      const defaultVal = Array.isArray(val) ? [] : {}
      if (Array.isArray(obj[key]) !== Array.isArray(val)) {
        obj[key] = defaultVal
      } else {
        obj[key] ??= defaultVal
      }

      deepAssign(obj[key], val)
    } else {
      obj[key] = val
    }
  }
}

export function useAppConfig (): AppConfig {
  const nuxtApp = useNuxtApp()
  nuxtApp._appConfig ||= (import.meta.server ? klona(__appConfig) : reactive(__appConfig)) as AppConfig
  return nuxtApp._appConfig
}

export function _replaceAppConfig (newConfig: AppConfig): void {
  const appConfig = useAppConfig()

  deepAssign(appConfig, newConfig)
  deepDelete(appConfig, newConfig)
}

/**
 * Deep assign the current appConfig with the new one.
 *
 * Will preserve existing properties.
 */
export function updateAppConfig (appConfig: DeepPartial<AppConfig>): void {
  const _appConfig = useAppConfig()
  deepAssign(_appConfig, appConfig)
}

// HMR Support
if (import.meta.dev) {
  // Vite
  if (import.meta.hot) {
    import.meta.hot.accept((newModule) => {
      const newConfig = newModule?._getAppConfig()
      if (newConfig) {
        _replaceAppConfig(newConfig)
      }
    })
  }

  // webpack
  if (import.meta.webpackHot) {
    import.meta.webpackHot.accept('#build/app.config.mjs', () => {
      _replaceAppConfig(__appConfig)
    })
  }
}
</file>

<file path="packages/nuxt/src/app/entry-spa.ts">
export default (): void => {}
</file>

<file path="packages/nuxt/src/app/entry.async.ts">
import type { Entry } from './entry'

const entry: Entry | (() => Promise<Entry>) = import.meta.server
  ? ctx => import('#app/entry').then(m => m.default(ctx))
  : () => import('#app/entry').then(m => m.default)

if (import.meta.client) {
  entry()
}

export default entry
</file>

<file path="packages/nuxt/src/app/entry.ts">
import { createApp, createSSRApp, nextTick } from 'vue'
import type { App } from 'vue'

// This file must be imported first as we set globalThis.$fetch via this import
// @ts-expect-error virtual file
import '#build/fetch.mjs'
// @ts-expect-error virtual file
import '#build/global-polyfills.mjs'

import { applyPlugins, createNuxtApp } from './nuxt'
import type { CreateOptions, NuxtSSRContext } from './nuxt'

import { createError } from './composables/error'

// @ts-expect-error virtual file
import '#build/css'
// @ts-expect-error virtual file
import plugins from '#build/plugins'
// @ts-expect-error virtual file
import RootComponent from '#build/root-component.mjs'
// @ts-expect-error virtual file
import { appId, appSpaLoaderAttrs, multiApp, spaLoadingTemplateOutside, vueAppRootContainer } from '#build/nuxt.config.mjs'

export type Entry = (ssrContext?: NuxtSSRContext) => Promise<App<Element>>

let entry: Entry

if (import.meta.server) {
  entry = async function createNuxtAppServer (ssrContext: CreateOptions['ssrContext']) {
    const vueApp = createApp(RootComponent)

    const nuxt = createNuxtApp({ vueApp, ssrContext })

    try {
      await applyPlugins(nuxt, plugins)
      await nuxt.hooks.callHook('app:created', vueApp)
    } catch (error) {
      await nuxt.hooks.callHook('app:error', error)
      nuxt.payload.error ||= createError(error as any)
    }
    // TODO: remove _renderResponse in nuxt v5
    if (ssrContext && (ssrContext['~renderResponse'] || ssrContext._renderResponse)) { throw new Error('skipping render') }

    return vueApp
  }
}

if (import.meta.client) {
  // TODO: temporary webpack 5 HMR fix
  // https://github.com/webpack/webpack-hot-middleware/issues/390
  if (import.meta.dev && import.meta.webpackHot) {
    import.meta.webpackHot.accept()
  }

  // eslint-disable-next-line prefer-const
  let vueAppPromise: Promise<App<Element>>

  entry = async function initApp () {
    if (vueAppPromise) { return vueAppPromise }

    const isSSR = Boolean(
      (multiApp ? window.__NUXT__?.[appId] : window.__NUXT__)?.serverRendered ??
      (multiApp ? document.querySelector(`[data-nuxt-data="${appId}"]`) as HTMLElement : document.getElementById('__NUXT_DATA__'))?.dataset.ssr === 'true',
    )
    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent)

    const nuxt = createNuxtApp({ vueApp })

    async function handleVueError (error: any) {
      await nuxt.callHook('app:error', error)
      nuxt.payload.error ||= createError(error as any)
    }

    vueApp.config.errorHandler = handleVueError
    // If the errorHandler is not overridden by the user, we unset it after the app is hydrated
    nuxt.hook('app:suspense:resolve', () => {
      if (vueApp.config.errorHandler === handleVueError) { vueApp.config.errorHandler = undefined }
    })

    if (spaLoadingTemplateOutside && !isSSR && appSpaLoaderAttrs.id) {
      // Remove spa loader if present
      nuxt.hook('app:suspense:resolve', () => {
        document.getElementById(appSpaLoaderAttrs.id)?.remove()
      })
    }

    try {
      await applyPlugins(nuxt, plugins)
    } catch (err) {
      handleVueError(err)
    }

    try {
      await nuxt.hooks.callHook('app:created', vueApp)
      await nuxt.hooks.callHook('app:beforeMount', vueApp)
      vueApp.mount(vueAppRootContainer)
      await nuxt.hooks.callHook('app:mounted', vueApp)
      await nextTick()
    } catch (err) {
      handleVueError(err)
    }

    return vueApp
  }

  vueAppPromise = entry().catch((error: unknown) => {
    console.error('Error while mounting app:', error)
    throw error
  })
}

export default (ssrContext => entry(ssrContext)) as Entry
</file>

<file path="packages/nuxt/src/app/index.ts">
import '../../dist/app/types/augments'

export { applyPlugin, applyPlugins, callWithNuxt, createNuxtApp, defineAppConfig, defineNuxtPlugin, definePayloadPlugin, isNuxtPlugin, registerPluginHooks, tryUseNuxtApp, useNuxtApp, useRuntimeConfig } from './nuxt'
export type { CreateOptions, NuxtApp, NuxtPayload, NuxtPluginIndicator, NuxtSSRContext, ObjectPlugin, Plugin, PluginEnvContext, PluginMeta, ResolvedPluginMeta, RuntimeNuxtHooks } from './nuxt'

// eslint-disable-next-line @typescript-eslint/no-deprecated
export { defineNuxtComponent, useAsyncData, useLazyAsyncData, useNuxtData, refreshNuxtData, clearNuxtData, useHydration, callOnce, useState, clearNuxtState, clearError, createError, isNuxtError, showError, useError, useFetch, useLazyFetch, useCookie, refreshCookie, onPrehydrate, prerenderRoutes, useRequestHeaders, useRequestEvent, useRequestFetch, setResponseStatus, useResponseHeader, onNuxtReady, abortNavigation, addRouteMiddleware, defineNuxtRouteMiddleware, onBeforeRouteLeave, onBeforeRouteUpdate, setPageLayout, navigateTo, useRoute, useRouter, preloadComponents, prefetchComponents, preloadRouteComponents, isPrerendered, loadPayload, preloadPayload, definePayloadReducer, definePayloadReviver, getAppManifest, getRouteRules, reloadNuxtApp, useRequestURL, usePreviewMode, useId, useRouteAnnouncer, useHead, useHeadSafe, useServerSeoMeta, useServerHeadSafe, useServerHead, useSeoMeta, injectHead, useRuntimeHook } from './composables/index'
export type { AddRouteMiddlewareOptions, AsyncData, AsyncDataOptions, AsyncDataRequestStatus, CookieOptions, CookieRef, FetchResult, NuxtAppManifest, NuxtAppManifestMeta, NuxtError, Politeness, ReloadNuxtAppOptions, RouteMiddleware, UseFetchOptions } from './composables/index'

export { defineNuxtLink } from './components/index'
export type { NuxtLinkOptions, NuxtLinkProps, NuxtTimeProps } from './components/index'
export { _getAppConfig, updateAppConfig, useAppConfig } from './config'
export { cancelIdleCallback, requestIdleCallback } from './compat/idle-callback'
export type { NuxtAppLiterals, NuxtIslandContext, NuxtIslandResponse, NuxtRenderHTMLContext, PageMeta, NuxtPageProps, NuxtLayouts } from './types'

export const isVue2 = false
export const isVue3 = true
</file>

<file path="packages/nuxt/src/app/nuxt.ts">
import { effectScope, getCurrentInstance, getCurrentScope, hasInjectionContext, reactive, shallowReactive } from 'vue'
import type { App, EffectScope, Ref, VNode, onErrorCaptured } from 'vue'
import type { RouteLocationNormalizedLoaded } from 'vue-router'
import type { HookCallback, Hookable } from 'hookable'
import { createHooks } from 'hookable'
import { getContext } from 'unctx'
import type { UseContext } from 'unctx'
import type { SSRContext, createRenderer } from 'vue-bundle-renderer/runtime'
import type { EventHandlerRequest, H3Event } from 'h3'
import type { RenderResponse } from 'nitropack/types'
import type { LogObject } from 'consola'
import type { VueHeadClient } from '@unhead/vue/types'

import type { NuxtAppLiterals } from 'nuxt/app'

import type { NuxtIslandContext } from './types'
import type { RouteMiddleware } from './composables/router'
import type { NuxtError } from './composables/error'
import type { AsyncDataExecuteOptions, AsyncDataRequestStatus } from './composables/asyncData'
import type { NuxtAppManifestMeta } from './composables/manifest'
import type { LoadingIndicator } from './composables/loading-indicator'
import type { RouteAnnouncer } from './composables/route-announcer'
import type { AppConfig, AppConfigInput, RuntimeConfig } from 'nuxt/schema'

// @ts-expect-error virtual file
import { appId, chunkErrorEvent, multiApp } from '#build/nuxt.config.mjs'

export function getNuxtAppCtx (id: string = appId || 'nuxt-app'): UseContext<NuxtApp> {
  return getContext<NuxtApp>(id, {
    asyncContext: !!__NUXT_ASYNC_CONTEXT__ && import.meta.server,
  })
}

type HookResult = Promise<void> | void

type AppRenderedContext = { ssrContext: NuxtApp['ssrContext'], renderResult: null | Awaited<ReturnType<ReturnType<typeof createRenderer>['renderToString']>> }
export interface RuntimeNuxtHooks {
  'app:created': (app: App<Element>) => HookResult
  'app:beforeMount': (app: App<Element>) => HookResult
  'app:mounted': (app: App<Element>) => HookResult
  'app:rendered': (ctx: AppRenderedContext) => HookResult
  'app:redirected': () => HookResult
  'app:suspense:resolve': (Component?: VNode) => HookResult
  'app:error': (err: any) => HookResult
  'app:error:cleared': (options: { redirect?: string }) => HookResult
  'app:chunkError': (options: { error: any }) => HookResult
  'app:data:refresh': (keys?: string[]) => HookResult
  'app:manifest:update': (meta?: NuxtAppManifestMeta) => HookResult
  'dev:ssr-logs': (logs: LogObject[]) => HookResult
  'link:prefetch': (link: string) => HookResult
  'page:start': (Component?: VNode) => HookResult
  'page:finish': (Component?: VNode) => HookResult
  'page:transition:finish': (Component?: VNode) => HookResult
  'page:view-transition:start': (transition: ViewTransition) => HookResult
  'page:loading:start': () => HookResult
  'page:loading:end': () => HookResult
  'vue:setup': () => void
  'vue:error': (...args: Parameters<Parameters<typeof onErrorCaptured>[0]>) => HookResult
}

export interface NuxtSSRContext extends SSRContext {
  url: string
  event: H3Event
  runtimeConfig: RuntimeConfig
  noSSR: boolean
  /** whether we are rendering an SSR error */
  error?: boolean
  nuxt: _NuxtApp
  payload: Partial<NuxtPayload>
  head: VueHeadClient
  /** This is used solely to render runtime config with SPA renderer. */
  config?: Pick<RuntimeConfig, 'public' | 'app'>
  teleports?: Record<string, string>
  islandContext?: NuxtIslandContext
  /** @internal */
  ['~renderResponse']?: Partial<RenderResponse>
  /** @internal */
  ['~payloadReducers']: Record<string, (data: any) => any>
  /** @internal */
  ['~sharedPrerenderCache']?: {
    get<T = unknown> (key: string): Promise<T> | undefined
    set<T> (key: string, value: Promise<T>): Promise<void>
  }
  /** @internal */
  ['~preloadManifest']?: boolean
}

export interface NuxtPayload {
  path?: string
  serverRendered?: boolean
  prerenderedAt?: number
  data: Record<string, any>
  state: Record<string, any>
  once: Set<string>
  config?: Pick<RuntimeConfig, 'public' | 'app'>
  error?: NuxtError | undefined
  _errors: Record<string, NuxtError | undefined>
  [key: string]: unknown
}

interface _NuxtApp {
  vueApp: App<Element>
  versions: Record<string, string>

  hooks: Hookable<RuntimeNuxtHooks>
  hook: _NuxtApp['hooks']['hook']
  callHook: _NuxtApp['hooks']['callHook']

  runWithContext: <T extends () => any>(fn: T) => ReturnType<T> | Promise<Awaited<ReturnType<T>>>

  [key: string]: unknown

  /** @internal */
  _cookies?: Record<string, unknown>
  /**
   * The id of the Nuxt application.
   * @internal */
  _id: string
  /** @internal */
  _scope: EffectScope
  /** @internal */
  _asyncDataPromises: Record<string, Promise<any> | undefined>
  /** @internal */
  _asyncData: Record<string, {
    data: Ref<unknown>
    pending: Ref<boolean>
    error: Ref<Error | undefined>
    status: Ref<AsyncDataRequestStatus>
    execute: (opts?: AsyncDataExecuteOptions) => Promise<void>
    /** @internal */
    _default: () => unknown
    /** @internal */
    _deps: number
    /** @internal */
    _off: () => void
    /** @internal */
    _init: boolean
    /** @internal */
    _execute: (opts?: AsyncDataExecuteOptions) => Promise<void>
    /** @internal */
    _hash?: Record<string, string | undefined>
    /** @internal */
    _abortController?: AbortController
  } | undefined>

  /** @internal */
  _loadingIndicator?: LoadingIndicator
  /** @internal */
  _loadingIndicatorDeps?: number

  /** @internal */
  _middleware: {
    global: RouteMiddleware[]
    named: Record<string, RouteMiddleware>
  }

  /** @internal */
  _processingMiddleware?: string | boolean

  /** @internal */
  _once: {
    [key: string]: Promise<any>
  }

  /** @internal */
  _observer?: { observe: (element: Element, callback: () => void) => () => void }

  /** @internal */
  _appConfig: AppConfig
  /** @internal */
  _route: RouteLocationNormalizedLoaded & {
    sync?: () => void
  }

  /** @internal */
  _islandPromises?: Record<string, Promise<any>>

  /** @internal */
  _payloadRevivers: Record<string, (data: any) => any>

  /** @internal */
  _routeAnnouncer?: RouteAnnouncer
  /** @internal */
  _routeAnnouncerDeps?: number

  // Nuxt injections
  $config: RuntimeConfig

  isHydrating?: boolean
  deferHydration: () => () => void | Promise<void>

  ssrContext?: NuxtSSRContext
  payload: NuxtPayload
  static: {
    data: Record<string, any>
  }

  provide: (name: string, value: any) => void
}

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface NuxtApp extends _NuxtApp {}

export const NuxtPluginIndicator = '__nuxt_plugin'

export interface PluginMeta {
  name?: string
  enforce?: 'pre' | 'default' | 'post'
  /**
   * Await for other named plugins to finish before running this plugin.
   */
  dependsOn?: NuxtAppLiterals['pluginName'][]
  /**
   * This allows more granular control over plugin order and should only be used by advanced users.
   * It overrides the value of `enforce` and is used to sort plugins.
   */
  order?: number
}

export interface PluginEnvContext {
  /**
   * This enable the plugin for islands components.
   * Require `experimental.componentsIslands`.
   * @default true
   */
  islands?: boolean
}

export interface ResolvedPluginMeta {
  name?: string
  parallel?: boolean
}

export interface Plugin<Injections extends Record<string, unknown> = Record<string, unknown>> {
  (nuxt: _NuxtApp): Promise<void> | Promise<{ provide?: Injections }> | void | { provide?: Injections }
  [NuxtPluginIndicator]?: true
  meta?: ResolvedPluginMeta
}

export interface ObjectPlugin<Injections extends Record<string, unknown> = Record<string, unknown>> extends PluginMeta {
  hooks?: Partial<RuntimeNuxtHooks>
  setup?: Plugin<Injections>
  env?: PluginEnvContext
  /**
   * Execute plugin in parallel with other parallel plugins.
   * @default false
   */
  parallel?: boolean
  /**
   * @internal
   */
  _name?: string
}

/** @deprecated Use `ObjectPlugin` */
export type ObjectPluginInput<Injections extends Record<string, unknown> = Record<string, unknown>> = ObjectPlugin<Injections>

export interface CreateOptions {
  vueApp: NuxtApp['vueApp']
  ssrContext?: NuxtApp['ssrContext']
  /**
   * The id of the Nuxt application, overrides the default id specified in the Nuxt config (default: `nuxt-app`).
   */
  id?: NuxtApp['_id']
}

/** @since 3.0.0 */
export function createNuxtApp (options: CreateOptions): NuxtApp {
  let hydratingCount = 0
  const nuxtApp: NuxtApp = {
    _id: options.id || appId || 'nuxt-app',
    _scope: effectScope(),
    provide: undefined,
    versions: {
      get nuxt () { return __NUXT_VERSION__ },
      get vue () { return nuxtApp.vueApp.version },
    },
    payload: shallowReactive({
      ...options.ssrContext?.payload || {},
      data: shallowReactive({}),
      state: reactive({}),
      once: new Set<string>(),
      _errors: shallowReactive({}),
    }),
    static: {
      data: {},
    },
    runWithContext <T>(fn: () => T) {
      if (nuxtApp._scope.active && !getCurrentScope()) {
        return nuxtApp._scope.run(() => callWithNuxt(nuxtApp, fn))
      }
      return callWithNuxt(nuxtApp, fn)
    },
    isHydrating: import.meta.client,
    deferHydration () {
      if (!nuxtApp.isHydrating) { return () => {} }

      hydratingCount++
      let called = false

      return () => {
        if (called) { return }

        called = true
        hydratingCount--

        if (hydratingCount === 0) {
          nuxtApp.isHydrating = false
          return nuxtApp.callHook('app:suspense:resolve')
        }
      }
    },
    _asyncDataPromises: {},
    _asyncData: shallowReactive({}),
    _payloadRevivers: {},
    ...options,
  } as any as NuxtApp

  if (import.meta.server) {
    nuxtApp.payload.serverRendered = true
  }

  if (import.meta.server && nuxtApp.ssrContext) {
    nuxtApp.payload.path = nuxtApp.ssrContext.url

    // Expose nuxt to the renderContext
    nuxtApp.ssrContext.nuxt = nuxtApp
    nuxtApp.ssrContext.payload = nuxtApp.payload

    // Expose client runtime-config to the payload
    nuxtApp.ssrContext.config = {
      public: nuxtApp.ssrContext.runtimeConfig.public,
      app: nuxtApp.ssrContext.runtimeConfig.app,
    }
  }

  if (import.meta.client) {
    const __NUXT__ = multiApp ? window.__NUXT__?.[nuxtApp._id] : window.__NUXT__
    // TODO: remove/refactor in https://github.com/nuxt/nuxt/issues/25336
    if (__NUXT__) {
      for (const key in __NUXT__) {
        switch (key) {
          case 'data':
          case 'state':
          case '_errors':
            // Preserve reactivity for non-rich payload support
            Object.assign(nuxtApp.payload[key], __NUXT__[key])
            break

          default:
            nuxtApp.payload[key] = __NUXT__[key]
        }
      }
    }
  }

  nuxtApp.hooks = createHooks<RuntimeNuxtHooks>()
  nuxtApp.hook = nuxtApp.hooks.hook

  if (import.meta.server) {
    const contextCaller = async function (hooks: HookCallback[], args: any[]) {
      for (const hook of hooks) {
        await nuxtApp.runWithContext(() => hook(...args))
      }
    }
    // Patch callHook to preserve NuxtApp context on server
    // TODO: Refactor after https://github.com/unjs/hookable/issues/74
    nuxtApp.hooks.callHook = (name: any, ...args: any[]) => nuxtApp.hooks.callHookWith(contextCaller, name, ...args)
  }

  nuxtApp.callHook = nuxtApp.hooks.callHook

  nuxtApp.provide = (name: string, value: any) => {
    const $name = '$' + name
    defineGetter(nuxtApp, $name, value)
    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value)
  }

  // Inject $nuxt
  defineGetter(nuxtApp.vueApp, '$nuxt', nuxtApp)
  defineGetter(nuxtApp.vueApp.config.globalProperties, '$nuxt', nuxtApp)

  if (import.meta.client) {
    // Listen to chunk load errors
    if (chunkErrorEvent) {
      window.addEventListener(chunkErrorEvent, (event) => {
        nuxtApp.callHook('app:chunkError', { error: (event as Event & { payload: Error }).payload })
        if (event.payload.message.includes('Unable to preload CSS')) {
          event.preventDefault()
        }
      })
    }
    window.useNuxtApp ||= useNuxtApp

    // Log errors captured when running plugins, in the `app:created` and `app:beforeMount` hooks
    // as well as when mounting the app.
    const unreg = nuxtApp.hook('app:error', (...args) => { console.error('[nuxt] error caught during app initialization', ...args) })
    nuxtApp.hook('app:mounted', unreg)
  }

  // Expose runtime config
  const runtimeConfig = import.meta.server ? options.ssrContext!.runtimeConfig : nuxtApp.payload.config!
  nuxtApp.provide('config', import.meta.client && import.meta.dev ? wrappedConfig(runtimeConfig) : runtimeConfig)

  return nuxtApp
}

/** @since 3.12.0 */
export function registerPluginHooks (nuxtApp: NuxtApp, plugin: Plugin & ObjectPlugin<any>): void {
  if (plugin.hooks) {
    nuxtApp.hooks.addHooks(plugin.hooks)
  }
}

/** @since 3.0.0 */
export async function applyPlugin (nuxtApp: NuxtApp, plugin: Plugin & ObjectPlugin<any>): Promise<void> {
  if (typeof plugin === 'function') {
    const { provide } = await nuxtApp.runWithContext(() => plugin(nuxtApp)) || {}
    if (provide && typeof provide === 'object') {
      for (const key in provide) {
        nuxtApp.provide(key, provide[key])
      }
    }
  }
}

/** @since 3.0.0 */
export async function applyPlugins (nuxtApp: NuxtApp, plugins: Array<Plugin & ObjectPlugin<any>>): Promise<void> {
  const resolvedPlugins: Set<string> = new Set()
  const unresolvedPlugins: [Set<string>, Plugin & ObjectPlugin<any>][] = []
  const parallels: Promise<any>[] = []
  let error: Error | undefined = undefined
  let promiseDepth = 0

  async function executePlugin (plugin: Plugin & ObjectPlugin<any>) {
    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter(name => plugins.some(p => p._name === name) && !resolvedPlugins.has(name)) ?? []
    if (unresolvedPluginsForThisPlugin.length > 0) {
      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin])
    } else {
      const promise = applyPlugin(nuxtApp, plugin).then(async () => {
        if (plugin._name) {
          resolvedPlugins.add(plugin._name)
          await Promise.all(unresolvedPlugins.map(async ([dependsOn, unexecutedPlugin]) => {
            if (dependsOn.has(plugin._name!)) {
              dependsOn.delete(plugin._name!)
              if (dependsOn.size === 0) {
                promiseDepth++
                await executePlugin(unexecutedPlugin)
              }
            }
          }))
        }
      }).catch((e) => {
        // short circuit if we are not rendering `error.vue`
        if (!plugin.parallel && !nuxtApp.payload.error) {
          throw e
        }
        error ||= e
      })

      if (plugin.parallel) {
        parallels.push(promise)
      } else {
        await promise
      }
    }
  }

  for (const plugin of plugins) {
    if (import.meta.server && nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) { continue }
    registerPluginHooks(nuxtApp, plugin)
  }

  for (const plugin of plugins) {
    if (import.meta.server && nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) { continue }
    await executePlugin(plugin)
  }

  await Promise.all(parallels)
  if (promiseDepth) {
    for (let i = 0; i < promiseDepth; i++) {
      await Promise.all(parallels)
    }
  }

  if (error) { throw nuxtApp.payload.error || error }
}

/** @since 3.0.0 */
/* @__NO_SIDE_EFFECTS__ */
export function defineNuxtPlugin<T extends Record<string, unknown>> (plugin: Plugin<T> | ObjectPlugin<T>): Plugin<T> & ObjectPlugin<T> {
  if (typeof plugin === 'function') { return plugin }

  const _name = plugin._name || plugin.name
  delete plugin.name
  return Object.assign(plugin.setup || (() => {}), plugin, { [NuxtPluginIndicator]: true, _name } as const)
}

/* @__NO_SIDE_EFFECTS__ */
export const definePayloadPlugin: typeof defineNuxtPlugin = defineNuxtPlugin

/** @since 3.0.0 */
export function isNuxtPlugin (plugin: unknown): plugin is Plugin {
  return typeof plugin === 'function' && NuxtPluginIndicator in plugin
}

/**
 * Ensures that the setup function passed in has access to the Nuxt instance via `useNuxtApp`.
 * @param nuxt A Nuxt instance
 * @param setup The function to call
 * @since 3.0.0
 */
export function callWithNuxt<T extends (...args: any[]) => any> (nuxt: NuxtApp | _NuxtApp, setup: T, args?: Parameters<T>): Promise<ReturnType<T>> {
  const fn: () => ReturnType<T> = () => args ? setup(...args as Parameters<T>) : setup()
  const nuxtAppCtx = getNuxtAppCtx(nuxt._id)
  if (import.meta.server) {
    return nuxt.vueApp.runWithContext(() => nuxtAppCtx.callAsync(nuxt as NuxtApp, fn))
  } else {
    // In client side we could assume nuxt app is singleton
    nuxtAppCtx.set(nuxt as NuxtApp)
    return nuxt.vueApp.runWithContext(fn)
  }
}

/* @__NO_SIDE_EFFECTS__ */
/**
 * Returns the current Nuxt instance.
 *
 * Returns `null` if Nuxt instance is unavailable.
 * @since 3.10.0
 */
export function tryUseNuxtApp (): NuxtApp | null
export function tryUseNuxtApp (id?: string): NuxtApp | null {
  let nuxtAppInstance
  if (hasInjectionContext()) {
    nuxtAppInstance = getCurrentInstance()?.appContext.app.$nuxt
  }

  nuxtAppInstance ||= getNuxtAppCtx(id).tryUse()

  return nuxtAppInstance || null
}

/* @__NO_SIDE_EFFECTS__ */
/**
 * Returns the current Nuxt instance.
 *
 * Throws an error if Nuxt instance is unavailable.
 * @since 3.0.0
 */
export function useNuxtApp (): NuxtApp
export function useNuxtApp (id?: string): NuxtApp {
  // @ts-expect-error internal usage of id
  const nuxtAppInstance = tryUseNuxtApp(id)

  if (!nuxtAppInstance) {
    if (import.meta.dev) {
      throw new Error('[nuxt] A composable that requires access to the Nuxt instance was called outside of a plugin, Nuxt hook, Nuxt middleware, or Vue setup function. This is probably not a Nuxt bug. Find out more at `https://nuxt.com/docs/4.x/guide/concepts/auto-imports#vue-and-nuxt-composables`.')
    } else {
      throw new Error('[nuxt] instance unavailable')
    }
  }

  return nuxtAppInstance
}

/** @since 3.0.0 */
/* @__NO_SIDE_EFFECTS__ */
export function useRuntimeConfig (_event?: H3Event<EventHandlerRequest>): RuntimeConfig {
  return useNuxtApp().$config
}

function defineGetter<K extends string | number | symbol, V> (obj: Record<K, V>, key: K, val: V) {
  Object.defineProperty(obj, key, { get: () => val })
}

/** @since 3.0.0 */
export function defineAppConfig<C extends AppConfigInput> (config: C): C {
  return config
}

/**
 * Configure error getter on runtime secret property access that doesn't exist on the client side
 */
const loggedKeys = new Set<string>()
function wrappedConfig (runtimeConfig: Record<string, unknown>) {
  if (!import.meta.dev || import.meta.server) { return runtimeConfig }
  const keys: string[] = []
  for (const key in runtimeConfig) {
    keys.push(`\`${key}\``)
  }
  const lastKey = keys.pop()
  return new Proxy(runtimeConfig, {
    get (target, p, receiver) {
      if (typeof p === 'string' && p !== 'public' && !(p in target) && !p.startsWith('__v') /* vue check for reactivity, e.g. `__v_isRef` */) {
        if (!loggedKeys.has(p)) {
          loggedKeys.add(p)
          console.warn(`[nuxt] Could not access \`${p}\`. The only available runtime config keys on the client side are ${keys.join(', ')} and ${lastKey}. See https://nuxt.com/docs/4.x/guide/going-further/runtime-config for more information.`)
        }
      }
      return Reflect.get(target, p, receiver)
    },
  })
}
</file>

<file path="packages/nuxt/src/app/types.ts">
import type { SerializableHead } from '@unhead/vue'

export type { PageMeta, NuxtPageProps, NuxtLayouts } from '../pages/runtime/index'

export interface NuxtAppLiterals {
  [key: string]: string
}

export interface NuxtIslandSlotResponse {
  props: Array<unknown>
  fallback?: string
}

export interface NuxtIslandClientResponse {
  html: string
  props: unknown
  chunk: string
  slots?: Record<string, string>
}

export interface NuxtIslandContext {
  id?: string
  name: string
  props?: Record<string, any>
  url: string
  slots: Record<string, Omit<NuxtIslandSlotResponse, 'fallback'>>
  components: Record<string, Omit<NuxtIslandClientResponse, 'html'>>
}

export interface NuxtIslandResponse {
  id?: string
  html: string
  head: SerializableHead
  props?: Record<string, Record<string, any>>
  components?: Record<string, NuxtIslandClientResponse>
  slots?: Record<string, NuxtIslandSlotResponse>
}

export interface NuxtRenderHTMLContext {
  htmlAttrs: string[]
  head: string[]
  bodyAttrs: string[]
  bodyPrepend: string[]
  body: string[]
  bodyAppend: string[]
}
</file>

<file path="packages/nuxt/src/app/utils.ts">
import { captureStackTrace } from 'errx'

/** @since 3.9.0 */
export function toArray<T> (value: T | T[]): T[] {
  return Array.isArray(value) ? value : [value]
}

const distURL = import.meta.url.replace(/\/app\/.*$/, '/')
type Trace = { source: string, line?: number, column?: number }

export function getUserTrace (): Trace[] {
  if (!import.meta.dev) {
    return []
  }

  const trace = captureStackTrace()
  const start = trace.findIndex(entry => !entry.source.startsWith(distURL))
  const end = [...trace].reverse().findIndex(entry => !entry.source.includes('node_modules') && !entry.source.startsWith(distURL))
  if (start === -1 || end === -1) {
    return []
  }
  return trace.slice(start, -end).map(i => ({
    ...i,
    source: i.source.replace(/^file:\/\//, ''),
  }))
}

export function getUserCaller (): Trace | null {
  if (!import.meta.dev) {
    return null
  }

  const { source, line, column } = captureStackTrace().find(entry => !entry.source.startsWith(distURL)) ?? {}

  if (!source) {
    return null
  }

  return {
    source: source.replace(/^file:\/\//, ''),
    line,
    column,
  }
}
</file>

<file path="packages/nuxt/src/components/plugins/component-names.ts">
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'
import { parseAndWalk } from 'oxc-walker'

import { SX_RE, isVue } from '../../core/utils/index.ts'
import type { Component } from 'nuxt/schema'

interface NameDevPluginOptions {
  sourcemap: boolean
  getComponents: () => Component[]
}
const FILENAME_RE = /([^/\\]+)\.\w+$/
/**
 * Set the default name of components to their PascalCase name
 */
export const ComponentNamePlugin = (options: NameDevPluginOptions) => createUnplugin(() => {
  return {
    name: 'nuxt:component-name-plugin',
    enforce: 'post',
    transformInclude (id) {
      /* v8 ignore next 2 */
      return isVue(id) || !!id.match(SX_RE)
    },
    transform: {
      filter: {
        id: { include: FILENAME_RE },
      },
      handler (code, id) {
        const filename = id.match(FILENAME_RE)?.[1]
        if (!filename) {
          return
        }
        const component = options.getComponents().find(c => c.filePath === id)

        if (!component) {
          return
        }

        const NAME_RE = new RegExp(`__name:\\s*['"]${filename}['"]`)
        const s = new MagicString(code)
        s.replace(NAME_RE, `__name: ${JSON.stringify(component.pascalName)}`)

        // Without setup function, vue compiler does not generate __name
        if (!s.hasChanged()) {
          parseAndWalk(code, id, function (node) {
            if (node.type !== 'ExportDefaultDeclaration') {
              return
            }

            const { start, end } = node.declaration
            s.overwrite(start, end, `Object.assign(${code.slice(start, end)}, { __name: ${JSON.stringify(component.pascalName)} })`)
            this.skip()
          })
        }

        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: options.sourcemap
              /* v8 ignore next */
              ? s.generateMap({ hires: true })
              : undefined,
          }
        }
      },
    },
  }
})
</file>

<file path="packages/nuxt/src/components/plugins/islands-transform.ts">
import { pathToFileURL } from 'node:url'
import type { Component } from '@nuxt/schema'
import { parseURL } from 'ufo'
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'
import { ELEMENT_NODE, parse, walk } from 'ultrahtml'
import { genObjectFromRawEntries, genString } from 'knitwork'
import type { Plugin } from 'vite'
import { isVue } from '../../core/utils/index.ts'

interface ServerOnlyComponentTransformPluginOptions {
  getComponents: () => Component[]
  /**
   * allow using `nuxt-client` attribute on components
   */
  selectiveClient?: boolean | 'deep'
}

const SCRIPT_RE = /<script[^>]*>/i
const SCRIPT_RE_GLOBAL = /<script[^>]*>/gi
const HAS_SLOT_OR_CLIENT_RE = /<slot[^>]*>|nuxt-client/
const TEMPLATE_RE = /<template>[\s\S]*<\/template>/
const NUXTCLIENT_ATTR_RE = /\s:?nuxt-client(?:="[^"]*")?/g
const IMPORT_CODE = '\nimport { mergeProps as __mergeProps } from \'vue\'' + '\nimport { vforToArray as __vforToArray } from \'#app/components/utils\'' + '\nimport NuxtTeleportIslandComponent from \'#app/components/nuxt-teleport-island-component\'' + '\nimport NuxtTeleportSsrSlot from \'#app/components/nuxt-teleport-island-slot\''
const EXTRACTED_ATTRS_RE = /v-(?:if|else-if|else)(?:="[^"]*")?/g
const KEY_RE = /:?key="[^"]"/g

function wrapWithVForDiv (code: string, vfor: string): string {
  return `<div v-for="${vfor}" style="display: contents;">${code}</div>`
}

export const IslandsTransformPlugin = (options: ServerOnlyComponentTransformPluginOptions) => createUnplugin((_options, meta) => {
  const isVite = meta.framework === 'vite'
  return {
    name: 'nuxt:server-only-component-transform',
    enforce: 'pre',
    transformInclude (id) {
      if (!isVue(id)) { return false }
      if (isVite && options.selectiveClient === 'deep') { return true }
      const components = options.getComponents()

      const islands = components.filter(component =>
        component.island || (component.mode === 'server' && !components.some(c => c.pascalName === component.pascalName && c.mode === 'client')),
      )
      const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href))
      return islands.some(c => c.filePath === pathname)
    },
    transform: {
      filter: {
        code: {
          include: [HAS_SLOT_OR_CLIENT_RE],
        },
      },
      async handler (code, id) {
        const template = code.match(TEMPLATE_RE)
        if (!template) { return }
        const startingIndex = template.index || 0
        const s = new MagicString(code)

        if (!SCRIPT_RE.test(code)) {
          s.prepend('<script setup>' + IMPORT_CODE + '</script>')
        } else {
          s.replace(SCRIPT_RE_GLOBAL, (full) => {
            return full + IMPORT_CODE
          })
        }

        let hasNuxtClient = false

        const ast = parse(template[0])
        await walk(ast, (node) => {
          if (node.type !== ELEMENT_NODE) {
            return
          }
          if (node.name === 'slot') {
            const { attributes, children, loc } = node

            const slotName = attributes.name ?? 'default'

            if (attributes.name) { delete attributes.name }
            if (attributes['v-bind']) {
              attributes._bind = extractAttributes(attributes, ['v-bind'])['v-bind']!
            }
            const teleportAttributes = extractAttributes(attributes, ['v-if', 'v-else-if', 'v-else'])
            const bindings = getPropsToString(attributes)
            // add the wrapper
            s.appendLeft(startingIndex + loc[0].start, `<NuxtTeleportSsrSlot${attributeToString(teleportAttributes)} name="${slotName}" :props="${bindings}">`)

            if (children.length) {
              // pass slot fallback to NuxtTeleportSsrSlot fallback
              const attrString = attributeToString(attributes)
              const slice = code.slice(startingIndex + loc[0].end, startingIndex + loc[1].start).replaceAll(KEY_RE, '')
              s.overwrite(startingIndex + loc[0].start, startingIndex + loc[1].end, `<slot${attrString.replaceAll(EXTRACTED_ATTRS_RE, '')}/><template #fallback>${attributes['v-for'] ? wrapWithVForDiv(slice, attributes['v-for']) : slice}</template>`)
            } else {
              s.overwrite(startingIndex + loc[0].start, startingIndex + loc[0].end, code.slice(startingIndex + loc[0].start, startingIndex + loc[0].end).replaceAll(EXTRACTED_ATTRS_RE, ''))
            }

            s.appendRight(startingIndex + loc[1].end, '</NuxtTeleportSsrSlot>')
            return
          }

          if (!('nuxt-client' in node.attributes) && !(':nuxt-client' in node.attributes)) {
            return
          }

          hasNuxtClient = true

          if (!isVite || !options.selectiveClient) {
            return
          }

          const { loc, attributes } = node
          const attributeValue = attributes[':nuxt-client'] || attributes['nuxt-client'] || 'true'
          const wrapperAttributes = extractAttributes(attributes, ['v-if', 'v-else-if', 'v-else'])

          let startTag = code.slice(startingIndex + loc[0].start, startingIndex + loc[0].end).replace(NUXTCLIENT_ATTR_RE, '')
          if (wrapperAttributes) {
            startTag = startTag.replaceAll(EXTRACTED_ATTRS_RE, '')
          }

          s.appendLeft(startingIndex + loc[0].start, `<NuxtTeleportIslandComponent${attributeToString(wrapperAttributes)} :nuxt-client="${attributeValue}">`)
          s.overwrite(startingIndex + loc[0].start, startingIndex + loc[0].end, startTag)
          s.appendRight(startingIndex + loc[1].end, '</NuxtTeleportIslandComponent>')
        })

        if (hasNuxtClient) {
          if (!options.selectiveClient) {
            console.warn(`The \`nuxt-client\` attribute and client components within islands are only supported when \`experimental.componentIslands.selectiveClient\` is enabled. file: ${id}`)
          } else if (!isVite) {
            console.warn(`The \`nuxt-client\` attribute and client components within islands are only supported with Vite. file: ${id}`)
          }
        }

        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: s.generateMap({ source: id, includeContent: true }),
          }
        }
      },
    },
  }
})

/**
 * extract attributes from a node
 */
function extractAttributes (attributes: Record<string, string>, names: string[]) {
  const extracted: Record<string, string> = {}
  for (const name of names) {
    if (name in attributes) {
      extracted[name] = attributes[name]!
      delete attributes[name]
    }
  }
  return extracted
}

function attributeToString (attributes: Record<string, string>) {
  return Object.entries(attributes).map(([name, value]) => value ? ` ${name}="${value}"` : ` ${name}`).join('')
}

function isBinding (attr: string): boolean {
  return attr.startsWith(':')
}

function getPropsToString (bindings: Record<string, string>): string {
  const vfor = bindings['v-for']?.split(' in ').map((v: string) => v.trim()) as [string, string] | undefined
  if (Object.keys(bindings).length === 0) { return 'undefined' }
  const contentParts: string[] = []
  for (const [name, value] of Object.entries(bindings)) {
    if (name && (name !== '_bind' && name !== 'v-for')) {
      contentParts.push(isBinding(name) ? `[\`${name.slice(1)}\`]: ${value}` : `[\`${name}\`]: \`${value}\``)
    }
  }
  const content = contentParts.join(',')
  const data = bindings._bind ? `__mergeProps(${bindings._bind}, { ${content} })` : `{ ${content} }`
  if (!vfor) {
    return `[${data}]`
  } else {
    return `__vforToArray(${vfor[1]}).map(${vfor[0]} => (${data}))`
  }
}

type ChunkPluginOptions = {
  dev: boolean
  getComponents: () => Component[]
}

const COMPONENT_CHUNK_ID = `#build/component-chunk`
const COMPONENT_CHUNK_RESOLVED_ID = '\0nuxt-component-chunk'

export const ComponentsChunkPlugin = (options: ChunkPluginOptions): Plugin[] => {
  const chunkIds = new Map<string, string>()
  const paths = new Map<string, string>()
  return [
    {
      name: 'nuxt:components-chunk:client',
      apply: () => !options.dev,
      applyToEnvironment: environment => environment.name === 'client',
      buildStart () {
        for (const c of options.getComponents()) {
          if (!c.filePath || c.mode === 'server') {
            continue
          }
          chunkIds.set(c.pascalName, this.emitFile({
            type: 'chunk',
            name: `${c.pascalName}-chunk.mjs`,
            id: c.filePath,
            preserveSignature: 'strict',
          }))
        }
      },
      generateBundle (_, bundle) {
        const ids = new Set<string>()
        for (const [name, id] of chunkIds.entries()) {
          const filename = this.getFileName(id)
          ids.add(filename)
          paths.set(name, filename)
        }
        for (const chunk of Object.values(bundle)) {
          if (chunk.type === 'chunk') {
            if (ids.has(chunk.fileName)) {
              chunk.isEntry = false
            }
          }
        }
      },
    },
    {
      name: 'nuxt:components-chunk:server',
      resolveId: {
        order: 'pre',
        handler (id) {
          if (id === COMPONENT_CHUNK_ID) {
            return COMPONENT_CHUNK_RESOLVED_ID
          }
        },
      },
      load (id) {
        if (id === COMPONENT_CHUNK_RESOLVED_ID) {
          if (options.dev) {
            const filePaths: Record<string, string> = {}
            for (const c of options.getComponents()) {
              if (!c.filePath || c.mode === 'server') {
                continue
              }
              filePaths[c.pascalName] = `@fs/${c.filePath}`
            }
            return `export default ${genObjectFromRawEntries(Object.entries(filePaths).map(([name, path]) => [name, genString(path)]))}`
          }

          return `export default ${
            genObjectFromRawEntries(Array.from(paths.entries())
              .map(([name, id]) => [name, genString('/' + id)]))
          }`
        }
      },
    },
  ]
}
</file>

<file path="packages/nuxt/src/components/plugins/lazy-hydration-macro-transform.ts">
import { createUnplugin } from 'unplugin'
import { relative } from 'pathe'
import { resolveAlias } from 'pathe/utils'
import MagicString from 'magic-string'
import { genImport } from 'knitwork'
import { isJS, isVue } from '../../core/utils/index.ts'
import type { ComponentsOptions } from 'nuxt/schema'
import { parseAndWalk } from 'oxc-walker'
import type { Argument, Expression, FunctionBody, ImportExpression } from 'oxc-parser'

interface LoaderOptions {
  srcDir: string
  sourcemap?: boolean
  transform?: ComponentsOptions['transform']
  clientDelayedComponentRuntime: string
  alias: Record<string, string>
}

const LAZY_HYDRATION_MACRO_RE = /\bdefineLazyHydrationComponent\s*\(/

const HYDRATION_TO_FACTORY = new Map<string, string>([
  ['visible', 'createLazyVisibleComponent'],
  ['idle', 'createLazyIdleComponent'],
  ['interaction', 'createLazyInteractionComponent'],
  ['mediaQuery', 'createLazyMediaQueryComponent'],
  ['if', 'createLazyIfComponent'],
  ['time', 'createLazyTimeComponent'],
  ['never', 'createLazyNeverComponent'],
])

export const LazyHydrationMacroTransformPlugin = (options: LoaderOptions) => createUnplugin(() => {
  const exclude = options.transform?.exclude || []
  const include = options.transform?.include || []

  return {
    name: 'nuxt:lazy-hydration-macro',
    enforce: 'post',
    transformInclude (id) {
      if (exclude.some(pattern => pattern.test(id))) {
        return false
      }
      if (include.some(pattern => pattern.test(id))) {
        return true
      }
      return isVue(id, { type: ['template', 'script'] }) || isJS(id)
    },

    transform: {
      filter: {
        code: {
          include: LAZY_HYDRATION_MACRO_RE,
        },
      },
      handler (code, id) {
        const s = new MagicString(code)
        const names = new Set<string>()
        type Edit = { start: number, end: number, replacement: string }
        const edits: Edit[] = []

        parseAndWalk(code, id, (node, parent) => {
          if (node.type !== 'CallExpression') { return }
          if (node.callee?.type !== 'Identifier') { return }
          if (node.callee.name !== 'defineLazyHydrationComponent') { return }

          if (parent?.type !== 'VariableDeclarator') { return }
          if (parent.id.type !== 'Identifier') { return }

          if (node.arguments.length < 2) { return }
          const [strategyArgument, loaderArgument] = node.arguments

          if (!isStringLiteral(strategyArgument)) { return }
          const strategy: string = strategyArgument.value

          const functionName = HYDRATION_TO_FACTORY.get(strategy)
          if (!functionName) { return }

          if (loaderArgument?.type !== 'ArrowFunctionExpression') { return }

          const { importExpression, importLiteral } = findImportExpression(loaderArgument.body)
          if (!importExpression || !isStringLiteral(importLiteral)) { return }

          const rawPath = importLiteral.value
          const filePath = resolveAlias(rawPath, options.alias || {})
          const relativePath = relative(options.srcDir, filePath)

          const originalLoader = code.slice(loaderArgument.start, loaderArgument.end)
          const replacement = `__${functionName}(${JSON.stringify(relativePath)}, ${originalLoader})`

          edits.push({ start: node.start, end: node.end, replacement })
          names.add(functionName)
        })

        for (const edit of edits) {
          s.overwrite(edit.start, edit.end, edit.replacement)
        }

        if (names.size) {
          const imports = genImport(options.clientDelayedComponentRuntime, [...names].map(name => ({ name, as: `__${name}` })))
          s.prepend(imports)
        }

        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: options.sourcemap
              ? s.generateMap({ hires: true })
              : undefined,
          }
        }
      },
    },
  }
})

function isStringLiteral (node: Argument | undefined) {
  return !!node && node.type === 'Literal' && typeof node.value === 'string'
}

function findImportExpression (node: Expression | FunctionBody): { importExpression?: ImportExpression, importLiteral?: Expression } {
  if (node.type === 'ImportExpression') {
    return { importExpression: node, importLiteral: node.source }
  }
  if (node.type === 'BlockStatement') {
    const returnStmt = node.body.find(stmt => stmt.type === 'ReturnStatement')
    if (returnStmt && returnStmt.argument) {
      return findImportExpression(returnStmt.argument)
    }
    return {}
  }
  if (node.type === 'ParenthesizedExpression') {
    return findImportExpression(node.expression)
  }
  if (node.type === 'AwaitExpression') {
    return findImportExpression(node.argument)
  }
  if (node.type === 'ConditionalExpression') {
    return findImportExpression(node.consequent) || findImportExpression(node.alternate)
  }
  if (node.type === 'MemberExpression') {
    return findImportExpression(node.object)
  }
  if (node.type === 'CallExpression') {
    return findImportExpression(node.callee)
  }
  return {}
}
</file>

<file path="packages/nuxt/src/components/plugins/lazy-hydration-transform.ts">
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'
import { camelCase, pascalCase } from 'scule'

import { tryUseNuxt } from '@nuxt/kit'
import { parse, walk } from 'ultrahtml'
import { ScopeTracker, parseAndWalk } from 'oxc-walker'
import { isVue } from '../../core/utils/index.ts'
import { logger, resolveToAlias } from '../../utils.ts'
import type { Component, ComponentsOptions } from 'nuxt/schema'

interface LoaderOptions {
  getComponents (): Component[]
  sourcemap?: boolean
  transform?: ComponentsOptions['transform']
}

const SCRIPT_RE = /(?<=<script[^>]*>)[\s\S]*?(?=<\/script>)/gi
const TEMPLATE_RE = /<template>([\s\S]*)<\/template>/
const hydrationStrategyMap = {
  hydrateOnIdle: 'Idle',
  hydrateOnVisible: 'Visible',
  hydrateOnInteraction: 'Interaction',
  hydrateOnMediaQuery: 'MediaQuery',
  hydrateAfter: 'Time',
  hydrateWhen: 'If',
  hydrateNever: 'Never',
}

const TEMPLATE_WITH_LAZY_HYDRATION_RE = /<template>[\s\S]*\b(?:hydrate-on-idle|hydrateOnIdle|hydrate-on-visible|hydrateOnVisible|hydrate-on-interaction|hydrateOnInteraction|hydrate-on-media-query|hydrateOnMediaQuery|hydrate-after|hydrateAfter|hydrate-when|hydrateWhen|hydrate-never|hydrateNever)\b[\s\S]*<\/template>/

export const LazyHydrationTransformPlugin = (options: LoaderOptions) => createUnplugin(() => {
  const exclude = options.transform?.exclude || []
  const include = options.transform?.include || []
  const nuxt = tryUseNuxt()

  return {
    name: 'nuxt:components-loader-pre',
    enforce: 'pre',
    transformInclude (id) {
      if (exclude.some(pattern => pattern.test(id))) {
        return false
      }
      if (include.some(pattern => pattern.test(id))) {
        return true
      }
      return isVue(id)
    },
    transform: {
      filter: {
        code: { include: TEMPLATE_WITH_LAZY_HYDRATION_RE },
      },

      async handler (code, id) {
        // change <LazyMyComponent hydrate-on-idle /> to <LazyIdleMyComponent hydrate-on-idle />
        const { 0: template, index: offset = 0 } = code.match(TEMPLATE_RE) || {}
        if (!template) {
          return
        }
        try {
          const ast = parse(template)

          const scopeTracker = new ScopeTracker({ preserveExitedScopes: true })
          for (const { 0: script } of code.matchAll(SCRIPT_RE)) {
            if (!script) { continue }
            try {
              parseAndWalk(script, id, { scopeTracker })
            } catch { /* ignore */ }
          }

          const s = new MagicString(code)

          const components = new Set(options.getComponents().map(c => c.pascalName))
          await walk(ast, (node) => {
            if (node.type !== 1 /* ELEMENT_NODE */) {
              return
            }

            if (scopeTracker.getDeclaration(node.name)) {
              return
            }

            const pascalName = pascalCase(node.name.replace(/^(?:Lazy|lazy-)/, ''))
            if (!components.has(pascalName)) {
              // not auto-imported
              return
            }

            let strategy: string | undefined

            for (const attr in node.attributes) {
              const isDynamic = attr.startsWith(':')
              const prop = camelCase(isDynamic ? attr.slice(1) : attr)
              if (prop in hydrationStrategyMap) {
                if (strategy) {
                  logger.warn(`Multiple hydration strategies are not supported in the same component`)
                } else {
                  strategy = hydrationStrategyMap[prop as keyof typeof hydrationStrategyMap]
                }
              }
            }

            if (strategy && !/^(?:Lazy|lazy-)/.test(node.name)) {
              if (node.name !== 'template' && (nuxt?.options.dev || nuxt?.options.test)) {
                const relativePath = resolveToAlias(id, nuxt)
                logger.warn(`Component \`<${node.name}>\` (used in \`${relativePath}\`) has lazy-hydration props but is not declared as a lazy component.\n` +
                  `Rename it to \`<Lazy${pascalCase(node.name)} />\` or remove the lazy-hydration props to avoid unexpected behavior.`)
              }
              return
            }

            if (strategy) {
              const newName = 'Lazy' + strategy + pascalName
              const chunk = template.slice(node.loc[0].start, node.loc.at(-1)!.end)
              const chunkOffset = node.loc[0].start + offset
              const { 0: startingChunk, index: startingPoint = 0 } = chunk.match(new RegExp(`<${node.name}[^>]*>`)) || {}
              s.overwrite(startingPoint + chunkOffset, startingPoint + chunkOffset + startingChunk!.length, startingChunk!.replace(node.name, newName))

              const { 0: endingChunk, index: endingPoint } = chunk.match(new RegExp(`<\\/${node.name}[^>]*>$`)) || {}
              if (endingChunk && endingPoint) {
                s.overwrite(endingPoint + chunkOffset, endingPoint + chunkOffset + endingChunk.length, endingChunk.replace(node.name, newName))
              }
            }
          })
          if (s.hasChanged()) {
            return {
              code: s.toString(),
              map: options.sourcemap
                ? s.generateMap({ hires: true })
                : undefined,
            }
          }
        } catch {
          // ignore errors if it's not html-like
        }
      },
    },
  }
})
</file>

<file path="packages/nuxt/src/components/plugins/loader.ts">
import { createUnplugin } from 'unplugin'
import { genDynamicImport, genImport } from 'knitwork'
import MagicString from 'magic-string'
import { pascalCase } from 'scule'
import { relative } from 'pathe'

import { tryUseNuxt } from '@nuxt/kit'
import { QUOTE_RE, SX_RE, isVue } from '../../core/utils/index.ts'
import { installNuxtModule } from '../../core/features.ts'
import { logger, resolveToAlias } from '../../utils.ts'
import type { Component, ComponentsOptions } from 'nuxt/schema'

interface LoaderOptions {
  getComponents (): Component[]
  mode: 'server' | 'client'
  srcDir: string
  serverComponentRuntime: string
  clientDelayedComponentRuntime: string
  sourcemap?: boolean
  transform?: ComponentsOptions['transform']
  experimentalComponentIslands?: boolean
}

// Match both:
// 1. _resolveComponent("ComponentName") - Vue's component resolution
// 2. h(ComponentName, ...) - JSX h() calls with PascalCase component identifiers
const REPLACE_COMPONENT_TO_DIRECT_IMPORT_RE = /(?<=[\s(=;])_?resolveComponent\s*\(\s*(?<quote>["'`])(?<lazy>lazy-|Lazy(?=[A-Z]))?(?<modifier>Idle|Visible|idle-|visible-|Interaction|interaction-|MediaQuery|media-query-|If|if-|Never|never-|Time|time-)?(?<name>[^'"`]*)\k<quote>[^)]*\)|(?<=\bh\s*\(\s*)(?<hLazy>lazy-|Lazy(?=[A-Z]))?(?<hModifier>Idle|Visible|idle-|visible-|Interaction|interaction-|MediaQuery|media-query-|If|if-|Never|never-|Time|time-)?(?<hName>[A-Z][\w$]*)\b/g

export const LoaderPlugin = (options: LoaderOptions) => createUnplugin(() => {
  const exclude = options.transform?.exclude || []
  const include = options.transform?.include || []
  const nuxt = tryUseNuxt()

  return {
    name: 'nuxt:components-loader',
    enforce: 'post',
    transformInclude (id) {
      if (exclude.some(pattern => pattern.test(id))) {
        return false
      }
      if (include.some(pattern => pattern.test(id))) {
        return true
      }
      return isVue(id, { type: ['template', 'script'] }) || !!id.match(SX_RE)
    },
    transform (code, id) {
      const components = options.getComponents()

      let num = 0
      const imports = new Set<string>()
      const map = new Map<Component, string>()
      const s = new MagicString(code)
      // replace `_resolveComponent("...")` to direct import
      s.replace(REPLACE_COMPONENT_TO_DIRECT_IMPORT_RE, (full: string, ...args) => {
        const groups = args.pop()
        const lazy = groups.hLazy || groups.lazy
        const modifier = groups.hModifier || groups.modifier
        const name = groups.hName || groups.name
        const normalComponent = findComponent(components, name, options.mode)
        const modifierComponent = !normalComponent && modifier ? findComponent(components, modifier + name, options.mode) : null
        const component = normalComponent || modifierComponent

        if (component) {
          // TODO: refactor to @nuxt/cli
          const internalInstall = ((component as any)._internal_install) as string
          if (internalInstall && nuxt?.options.test === false) {
            if (!nuxt.options.dev) {
              throw new Error(`[nuxt] \`${resolveToAlias(id, nuxt)}\` is using \`${component.pascalName}\` which requires \`${internalInstall}\``)
            }
            installNuxtModule(internalInstall)
          }
          let identifier = map.get(component) || `__nuxt_component_${num++}`
          map.set(component, identifier)

          const isServerOnly = !component._raw && component.mode === 'server' &&
            !components.some(c => c.pascalName === component.pascalName && c.mode === 'client')
          if (isServerOnly) {
            imports.add(genImport(options.serverComponentRuntime, [{ name: 'createServerComponent' }]))
            imports.add(`const ${identifier} = createServerComponent(${JSON.stringify(component.pascalName)})`)
            if (!options.experimentalComponentIslands) {
              logger.warn(`Standalone server components (\`${name}\`) are not yet supported without enabling \`experimental.componentIslands\`.`)
            }
            return identifier
          }

          const isClientOnly = !component._raw && component.mode === 'client'
          if (isClientOnly) {
            imports.add(genImport('#app/components/client-only', [{ name: 'createClientOnly' }]))
            identifier += '_client'
          }

          if (lazy) {
            const dynamicImport = `${genDynamicImport(component.filePath, { interopDefault: false })}.then(c => c.${component.export ?? 'default'} || c)`
            if (modifier && normalComponent) {
              const relativePath = relative(options.srcDir, component.filePath)
              switch (modifier) {
                case 'Visible':
                case 'visible-':
                  imports.add(genImport(options.clientDelayedComponentRuntime, [{ name: 'createLazyVisibleComponent' }]))
                  identifier += '_lazy_visible'
                  imports.add(`const ${identifier} = createLazyVisibleComponent(${JSON.stringify(relativePath)}, ${dynamicImport})`)
                  break
                case 'Interaction':
                case 'interaction-':
                  imports.add(genImport(options.clientDelayedComponentRuntime, [{ name: 'createLazyInteractionComponent' }]))
                  identifier += '_lazy_event'
                  imports.add(`const ${identifier} = createLazyInteractionComponent(${JSON.stringify(relativePath)}, ${dynamicImport})`)
                  break
                case 'Idle':
                case 'idle-':
                  imports.add(genImport(options.clientDelayedComponentRuntime, [{ name: 'createLazyIdleComponent' }]))
                  identifier += '_lazy_idle'
                  imports.add(`const ${identifier} = createLazyIdleComponent(${JSON.stringify(relativePath)}, ${dynamicImport})`)
                  break
                case 'MediaQuery':
                case 'media-query-':
                  imports.add(genImport(options.clientDelayedComponentRuntime, [{ name: 'createLazyMediaQueryComponent' }]))
                  identifier += '_lazy_media'
                  imports.add(`const ${identifier} = createLazyMediaQueryComponent(${JSON.stringify(relativePath)}, ${dynamicImport})`)
                  break
                case 'If':
                case 'if-':
                  imports.add(genImport(options.clientDelayedComponentRuntime, [{ name: 'createLazyIfComponent' }]))
                  identifier += '_lazy_if'
                  imports.add(`const ${identifier} = createLazyIfComponent(${JSON.stringify(relativePath)}, ${dynamicImport})`)
                  break
                case 'Never':
                case 'never-':
                  imports.add(genImport(options.clientDelayedComponentRuntime, [{ name: 'createLazyNeverComponent' }]))
                  identifier += '_lazy_never'
                  imports.add(`const ${identifier} = createLazyNeverComponent(${JSON.stringify(relativePath)}, ${dynamicImport})`)
                  break
                case 'Time':
                case 'time-':
                  imports.add(genImport(options.clientDelayedComponentRuntime, [{ name: 'createLazyTimeComponent' }]))
                  identifier += '_lazy_time'
                  imports.add(`const ${identifier} = createLazyTimeComponent(${JSON.stringify(relativePath)}, ${dynamicImport})`)
                  break
              }
            } else {
              imports.add(genImport('vue', [{ name: 'defineAsyncComponent', as: '__defineAsyncComponent' }]))
              identifier += '_lazy'
              imports.add(`const ${identifier} = __defineAsyncComponent(${dynamicImport}${isClientOnly ? '.then(c => createClientOnly(c))' : ''})`)
            }
          } else {
            imports.add(genImport(component.filePath, [{ name: component._raw ? 'default' : component.export, as: identifier }]))

            if (isClientOnly) {
              imports.add(`const ${identifier}_wrapped = createClientOnly(${identifier})`)
              identifier += '_wrapped'
            }
          }

          return identifier
        }
        // no matched
        return full
      })

      if (imports.size) {
        s.prepend([...imports, ''].join('\n'))
      }

      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: options.sourcemap
            ? s.generateMap({ hires: true })
            : undefined,
        }
      }
    },
  }
})

function findComponent (components: Component[], name: string, mode: LoaderOptions['mode']) {
  const id = pascalCase(name).replace(QUOTE_RE, '')
  // Prefer exact match
  const validModes = new Set(['all', mode, undefined])
  const component = components.find(component => id === component.pascalName && validModes.has(component.mode))
  if (component) { return component }

  const otherModeComponent = components.find(component => id === component.pascalName)

  // Render client-only components on the server with <ServerPlaceholder> (a simple div)
  if (mode === 'server' && otherModeComponent) {
    return components.find(c => c.pascalName === 'ServerPlaceholder')
  }

  // Return the other-mode component in all other cases - we'll handle createClientOnly
  // and createServerComponent above
  return otherModeComponent
}
</file>

<file path="packages/nuxt/src/components/plugins/transform.ts">
import { isObject } from '@vue/shared'
import { isIgnored } from '@nuxt/kit'
import type { Import } from 'unimport'
import { createUnimport } from 'unimport'
import { createUnplugin } from 'unplugin'
import { parseURL } from 'ufo'
import { parseQuery } from 'vue-router'
import { isAbsolute, normalize } from 'pathe'
import { readPackage } from 'pkg-types'
import { genImport } from 'knitwork'
import type { getComponentsT } from '../module.ts'
import type { Nuxt } from 'nuxt/schema'

const COMPONENT_QUERY_RE = /[?&]nuxt_component=/

interface TransformPluginOptions {
  getComponents: getComponentsT
  mode: 'client' | 'server' | 'all'
  serverComponentRuntime: string
}

export function TransformPlugin (nuxt: Nuxt, options: TransformPluginOptions) {
  const componentUnimport = createUnimport({
    imports: [
      {
        name: 'componentNames',
        from: '#build/component-names',
      },
    ],
    virtualImports: ['#components'],
    injectAtEnd: true,
  })

  function getComponentsImports (): Import[] {
    const components = options.getComponents(options.mode)
    const clientOrServerModes = new Set(['client', 'server'])
    return components.flatMap((c): Import[] => {
      const withMode = (mode: string | undefined) => mode
        ? `${c.filePath}${c.filePath.includes('?') ? '&' : '?'}nuxt_component=${mode}&nuxt_component_name=${c.pascalName}&nuxt_component_export=${c.export || 'default'}`
        : c.filePath

      const mode = !c._raw && c.mode && clientOrServerModes.has(c.mode) ? c.mode : undefined

      return [
        {
          as: c.pascalName,
          from: withMode(mode),
          name: c.export || 'default',
        },
        {
          as: 'Lazy' + c.pascalName,
          from: withMode([mode, 'async'].filter(Boolean).join(',')),
          name: c.export || 'default',
        },
      ]
    })
  }

  return createUnplugin(() => [
    {
      name: 'nuxt:components:imports-wrapper',
      enforce: 'post',
      transformInclude (id) {
        id = normalize(id)
        return id.startsWith('virtual:') || id.startsWith('\0virtual:') || id.startsWith(nuxt.options.buildDir) || !isIgnored(id, undefined, nuxt)
      },
      transform: {
        filter: {
          id: COMPONENT_QUERY_RE,
        },
        handler (_code, id) {
          // Virtual component wrapper
          const { search } = parseURL(id)
          const query = parseQuery(search)
          const mode = query.nuxt_component
          const bare = id.replace(/\?.*/, '')
          const componentExport = query.nuxt_component_export as string || 'default'
          const exportWording = componentExport === 'default' ? 'export default' : `export const ${componentExport} =`
          if (mode === 'async') {
            return {
              code: [
                'import { defineAsyncComponent } from "vue"',
                `${exportWording} defineAsyncComponent(() => import(${JSON.stringify(bare)}).then(r => r[${JSON.stringify(componentExport)}] || r.default || r))`,
              ].join('\n'),
              map: null,
            }
          } else if (mode === 'client') {
            return {
              code: [
                genImport(bare, [{ name: componentExport, as: '__component' }]),
                'import { createClientOnly } from "#app/components/client-only"',
                `${exportWording} createClientOnly(__component)`,
              ].join('\n'),
              map: null,
            }
          } else if (mode === 'client,async') {
            return {
              code: [
                'import { defineAsyncComponent } from "vue"',
                'import { createClientOnly } from "#app/components/client-only"',
                `${exportWording} defineAsyncComponent(() => import(${JSON.stringify(bare)}).then(r => createClientOnly(r[${JSON.stringify(componentExport)}] || r.default || r)))`,
              ].join('\n'),
              map: null,
            }
          } else if (mode === 'server' || mode === 'server,async') {
            const name = query.nuxt_component_name
            return {
              code: [
                `import { createServerComponent } from ${JSON.stringify(options.serverComponentRuntime)}`,
                `${exportWording} createServerComponent(${JSON.stringify(name)})`,
              ].join('\n'),
              map: null,
            }
          } else {
            throw new Error(`Unknown component mode: ${mode}, this might be an internal bug of Nuxt.`)
          }
        },
      },
    },
    {
      name: 'nuxt:components:imports-alias',
      enforce: 'post',
      transformInclude (id) {
        id = normalize(id)
        return id.startsWith('virtual:') || id.startsWith('\0virtual:') || id.startsWith(nuxt.options.buildDir) || !isIgnored(id, undefined, nuxt)
      },
      transform: {
        filter: {
          code: /#components/,
        },
        async handler (code, id) {
          // If package defines a "#components" import mapping, assume is used internally by the package.
          const pkg = isAbsolute(id) && /node_modules[\\/](?!\.virtual)/.test(id)
            ? await readPackage(id, { try: true })
            : undefined
          if (isObject(pkg) && isObject(pkg.imports) && Object.hasOwn(pkg.imports, '#components')) {
            return
          }

          componentUnimport.modifyDynamicImports((imports) => {
            imports.length = 0
            imports.push(...getComponentsImports())
            return imports
          })

          const result = await componentUnimport.injectImports(code, id, { autoImport: false, transformVirtualImports: true })
          if (!result) { return }

          return {
            code: result.code,
            map: nuxt.options.sourcemap.server || nuxt.options.sourcemap.client
              ? result.s.generateMap({ hires: true })
              : undefined,
          }
        },
      },
    },
  ])
}
</file>

<file path="packages/nuxt/src/components/plugins/tree-shake.ts">
import { pathToFileURL } from 'node:url'
import { parseURL } from 'ufo'
import MagicString from 'magic-string'
import { createUnplugin } from 'unplugin'
import type { Component } from '@nuxt/schema'
import { resolve } from 'pathe'

import { parseAndWalk, walk } from 'oxc-walker'
import type { BindingPattern, BindingProperty, CallExpression, Node, ObjectExpression, Program, ReturnStatement, VariableDeclaration } from 'oxc-parser'
import { distDir } from '../../dirs.ts'

interface TreeShakeTemplatePluginOptions {
  sourcemap?: boolean
  getComponents (): Component[]
}

const SSR_RENDER_RE = /ssrRenderComponent/
const PLACEHOLDER_EXACT_RE = /^(?:fallback|placeholder)$/
const CLIENT_ONLY_NAME_RE = /^(?:_unref\()?(?:_component_)?(?:Lazy|lazy_)?(?:client_only|ClientOnly\)?)$/

export const TreeShakeTemplatePlugin = (options: TreeShakeTemplatePluginOptions) => createUnplugin(() => {
  const regexpMap = new WeakMap<Component[], [RegExp, RegExp, string[]]>()
  return {
    name: 'nuxt:tree-shake-template',
    enforce: 'post',
    transformInclude (id) {
      const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href))
      return pathname.endsWith('.vue')
    },
    transform (code, id) {
      const components = options.getComponents()

      if (!regexpMap.has(components)) {
        const serverPlaceholderPath = resolve(distDir, 'app/components/server-placeholder')
        const clientOnlyComponents = components
          .filter(c => c.mode === 'client' && !components.some(other => other.mode !== 'client' && other.pascalName === c.pascalName && !other.filePath.startsWith(serverPlaceholderPath)))
          .flatMap(c => [c.pascalName, c.kebabName.replaceAll('-', '_')])
          .concat(['ClientOnly', 'client_only'])

        regexpMap.set(components, [new RegExp(`(${clientOnlyComponents.join('|')})`), new RegExp(`^(${clientOnlyComponents.map(c => `(?:(?:_unref\\()?(?:_component_)?(?:Lazy|lazy_)?${c}\\)?)`).join('|')})$`), clientOnlyComponents])
      }

      const s = new MagicString(code)

      const [COMPONENTS_RE, COMPONENTS_IDENTIFIERS_RE] = regexpMap.get(components)!
      if (!COMPONENTS_RE.test(code)) { return }

      const componentsToRemoveSet = new Set<string>()

      // remove client only components or components called in ClientOnly default slot
      const { program: ast } = parseAndWalk(code, id, (node) => {
        if (!isSsrRender(node)) {
          return
        }

        const [componentCall, _, children] = node.arguments
        if (!componentCall) { return }

        if (componentCall.type === 'Identifier' || componentCall.type === 'MemberExpression' || componentCall.type === 'CallExpression') {
          const componentName = getComponentName(node)
          if (!componentName || !COMPONENTS_IDENTIFIERS_RE.test(componentName) || children?.type !== 'ObjectExpression') { return }

          const isClientOnlyComponent = CLIENT_ONLY_NAME_RE.test(componentName)
          const slotsToRemove = isClientOnlyComponent ? children.properties.filter(prop => prop.type === 'Property' && prop.key.type === 'Identifier' && !PLACEHOLDER_EXACT_RE.test(prop.key.name)) : children.properties

          for (const slot of slotsToRemove) {
            s.remove(slot.start, slot.end + 1)
            const removedCode = `({${code.slice(slot.start, slot.end + 1)}})`
            const currentState = s.toString()

            parseAndWalk(removedCode, id, (node) => {
              if (!isSsrRender(node)) { return }
              const name = getComponentName(node)
              if (!name) { return }

              // detect if the component is called else where
              const nameToRemove = isComponentNotCalledInSetup(currentState, id, name)
              if (nameToRemove) {
                componentsToRemoveSet.add(nameToRemove)
              }
            })
          }
        }
      })

      const componentsToRemove = [...componentsToRemoveSet]
      const removedNodes = new WeakSet<Node>()

      for (const componentName of componentsToRemove) {
        // remove import declaration if it exists
        removeImportDeclaration(ast, componentName, s)
        // remove variable declaration
        removeVariableDeclarator(ast, componentName, s, removedNodes)
        // remove from setup return statement
        removeFromSetupReturn(ast, componentName, s)
      }

      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: options.sourcemap
            ? s.generateMap({ hires: true })
            : undefined,
        }
      }
    },
  }
})

/**
 * find and remove all property with the name parameter from the setup return statement and the __returned__ object
 */
function removeFromSetupReturn (codeAst: Program, name: string, magicString: MagicString) {
  let walkedInSetup = false
  walk(codeAst, {
    enter (node) {
      if (walkedInSetup) {
        this.skip()
      } else if (node.type === 'Property' && node.key.type === 'Identifier' && node.key.name === 'setup' && (node.value.type === 'FunctionExpression' || node.value.type === 'ArrowFunctionExpression')) {
        // walk into the setup function
        walkedInSetup = true
        if (node.value.body?.type === 'BlockStatement') {
          const returnStatement = node.value.body.body.find(statement => statement.type === 'ReturnStatement') as ReturnStatement
          if (returnStatement && returnStatement.argument?.type === 'ObjectExpression') {
            // remove from return statement
            removePropertyFromObject(returnStatement.argument, name, magicString)
          }

          // remove from __returned__
          const variableList = node.value.body.body.filter((statement): statement is VariableDeclaration => statement.type === 'VariableDeclaration')
          const returnedVariableDeclaration = variableList.find(declaration => declaration.declarations[0]?.id.type === 'Identifier' && declaration.declarations[0]?.id.name === '__returned__' && declaration.declarations[0]?.init?.type === 'ObjectExpression')
          if (returnedVariableDeclaration) {
            const init = returnedVariableDeclaration.declarations[0]?.init as ObjectExpression | undefined
            if (init) {
              removePropertyFromObject(init, name, magicString)
            }
          }
        }
      }
    },
  })
}

/**
 * remove a property from an object expression
 */
function removePropertyFromObject (node: ObjectExpression, name: string, magicString: MagicString) {
  for (const property of node.properties) {
    if (property.type === 'Property' && property.key.type === 'Identifier' && property.key.name === name) {
      magicString.remove(property.start, property.end + 1)
      return true
    }
  }
  return false
}

/**
 * is the node a call expression ssrRenderComponent()
 */
function isSsrRender (node: Node): node is CallExpression {
  return node.type === 'CallExpression' && node.callee.type === 'Identifier' && SSR_RENDER_RE.test(node.callee.name)
}

function removeImportDeclaration (ast: Program, importName: string, magicString: MagicString): boolean {
  for (const node of ast.body) {
    if (node.type !== 'ImportDeclaration' || !node.specifiers) {
      continue
    }
    const specifierIndex = node.specifiers.findIndex(s => s.local.name === importName)
    if (specifierIndex > -1) {
      if (node.specifiers!.length > 1) {
        const specifier = node.specifiers![specifierIndex]!
        magicString.remove(specifier.start, specifier.end + 1)
        node.specifiers!.splice(specifierIndex, 1)
      } else {
        magicString.remove(node.start, node.end)
      }
      return true
    }
  }
  return false
}

/**
 * detect if the component is called else where
 * ImportDeclarations and VariableDeclarations are ignored
 * return the name of the component if is not called
 */
function isComponentNotCalledInSetup (code: string, id: string, name: string): string | void {
  if (!name) { return }
  let found = false
  parseAndWalk(code, id, function (node) {
    if ((node.type === 'Property' && node.key.type === 'Identifier' && node.value.type === 'FunctionExpression' && node.key.name === 'setup') || (node.type === 'FunctionDeclaration' && (node.id?.name === '_sfc_ssrRender' || node.id?.name === 'ssrRender'))) {
      // walk through the setup function node or the ssrRender function
      walk(node, {
        enter (node) {
          if (found || node.type === 'VariableDeclaration') {
            this.skip()
          } else if (node.type === 'Identifier' && node.name === name) {
            found = true
          } else if (node.type === 'MemberExpression') {
            // dev only with $setup or _ctx
            found = (node.property.type === 'Literal' && node.property.value === name) || (node.property.type === 'Identifier' && node.property.name === name)
          }
        },
      })
    }
  })
  if (!found) { return name }
}

/**
 * retrieve the component identifier being used on ssrRender callExpression
 * @param ssrRenderNode - ssrRender callExpression
 */
function getComponentName (ssrRenderNode: CallExpression): string | undefined {
  const componentCall = ssrRenderNode.arguments[0]
  if (!componentCall) { return }

  if (componentCall.type === 'Identifier') {
    return componentCall.name
  } else if (componentCall.type === 'MemberExpression') {
    if (componentCall.property.type === 'Literal') {
      return componentCall.property.value as string
    }
  } else if (componentCall.type === 'CallExpression') {
    return getComponentName(componentCall)
  }
}

/**
 * remove a variable declaration within the code
 */
function removeVariableDeclarator (codeAst: Program, name: string, magicString: MagicString, removedNodes: WeakSet<Node>): Node | void {
  // remove variables
  walk(codeAst, {
    enter (node) {
      if (node.type !== 'VariableDeclaration') { return }
      for (const declarator of node.declarations) {
        const toRemove = findMatchingPatternToRemove(declarator.id, node, name, removedNodes)
        if (toRemove) {
          magicString.remove(toRemove.start, toRemove.end + 1)
          removedNodes.add(toRemove)
        }
      }
    },
  })
}

/**
 * find the Pattern to remove which the identifier is equal to the name parameter.
 */
function findMatchingPatternToRemove (node: BindingPattern, toRemoveIfMatched: Node, name: string, removedNodeSet: WeakSet<Node>): Node | undefined {
  if (node.type === 'Identifier') {
    if (node.name === name) {
      return toRemoveIfMatched
    }
  } else if (node.type === 'ArrayPattern') {
    const elements = node.elements.filter((e): e is BindingPattern => e !== null && !removedNodeSet.has(e))

    for (const element of elements) {
      const matched = findMatchingPatternToRemove(element, elements.length > 1 ? element : toRemoveIfMatched, name, removedNodeSet)
      if (matched) { return matched }
    }
  } else if (node.type === 'ObjectPattern') {
    const properties = node.properties.filter((e): e is BindingProperty => e.type === 'Property' && !removedNodeSet.has(e))

    for (const [index, property] of properties.entries()) {
      let nodeToRemove: Node = property
      if (properties.length < 2) {
        nodeToRemove = toRemoveIfMatched
      }

      const matched = findMatchingPatternToRemove(property.value, nodeToRemove, name, removedNodeSet)
      if (matched) {
        if (matched === property) {
          properties.splice(index, 1)
        }
        return matched
      }
    }
  } else if (node.type === 'AssignmentPattern') {
    const matched = findMatchingPatternToRemove(node.left, toRemoveIfMatched, name, removedNodeSet)
    if (matched) { return matched }
  }
}
</file>

<file path="packages/nuxt/src/components/runtime/client-component.ts">
import { getCurrentInstance, h, onMounted, provide, shallowRef } from 'vue'
import type { AsyncComponentLoader, ComponentOptions } from 'vue'
import { isPromise } from '@vue/shared'
import { useNuxtApp } from '#app/nuxt'
import ServerPlaceholder from '#app/components/server-placeholder'
import { clientOnlySymbol } from '#app/components/client-only'

/* @__NO_SIDE_EFFECTS__ */
export async function createClientPage (loader: AsyncComponentLoader) {
  // vue-router: Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".
  const m = await loader()
  const c = m.default || m
  if (import.meta.dev) {
    // mark component as client-only for `definePageMeta`
    c.__clientOnlyPage = true
  }
  return pageToClientOnly(c)
}

const cache = new WeakMap()

function pageToClientOnly<T extends ComponentOptions> (component: T) {
  if (import.meta.server) {
    return ServerPlaceholder
  }

  if (cache.has(component)) {
    return cache.get(component)
  }

  const clone = { ...component }

  if (clone.render) {
    // override the component render (non script setup component) or dev mode
    clone.render = (ctx: any, cache: any, $props: any, $setup: any, $data: any, $options: any) => ($setup.mounted$ ?? ctx.mounted$)
      ? h(component.render?.bind(ctx)(ctx, cache, $props, $setup, $data, $options))
      : h('div')
  } else {
    // handle runtime-compiler template
    clone.template &&= `
      <template v-if="mounted$">${component.template}</template>
      <template v-else><div></div></template>
    `
  }

  clone.setup = (props, ctx) => {
    const nuxtApp = useNuxtApp()
    const mounted$ = shallowRef(nuxtApp.isHydrating === false)
    provide(clientOnlySymbol, true)
    const vm = getCurrentInstance()
    if (vm) {
      vm._nuxtClientOnly = true
    }
    onMounted(() => {
      mounted$.value = true
    })
    const setupState = component.setup?.(props, ctx) || {}
    if (isPromise(setupState)) {
      return Promise.resolve(setupState).then((setupState: any) => {
        if (typeof setupState !== 'function') {
          setupState ||= {}
          setupState.mounted$ = mounted$
          return setupState
        }
        return (...args: any[]) => (mounted$.value || !nuxtApp.isHydrating) ? h(setupState(...args)) : h('div')
      })
    } else {
      return typeof setupState === 'function'
        ? (...args: any[]) => (mounted$.value || !nuxtApp.isHydrating)
            ? h(setupState(...args))
            : h('div')
        : Object.assign(setupState, { mounted$ })
    }
  }

  cache.set(component, clone)

  return clone
}
</file>

<file path="packages/nuxt/src/components/runtime/lazy-hydrated-component.ts">
import { defineAsyncComponent, defineComponent, h, hydrateOnIdle, hydrateOnInteraction, hydrateOnMediaQuery, hydrateOnVisible, mergeProps } from 'vue'
import type { AsyncComponentLoader, ComponentObjectPropsOptions, ExtractPropTypes, HydrationStrategy } from 'vue'
import { useNuxtApp } from '#app/nuxt'

function defineLazyComponent<P extends ComponentObjectPropsOptions> (props: P, defineStrategy: (props: ExtractPropTypes<P>) => HydrationStrategy | undefined) {
  return (id: string, loader: AsyncComponentLoader) => defineComponent({
    inheritAttrs: false,
    props,
    emits: ['hydrated'],
    setup (props, ctx) {
      if (import.meta.server) {
        const nuxtApp = useNuxtApp()
        nuxtApp.hook('app:rendered', ({ ssrContext }) => {
          // strip the lazy hydrated component from the ssrContext so prefetch/preload tags are not rendered for it
          ssrContext!.modules!.delete(id)
        })
      }
      // wrap the async component in a second component to avoid loading the chunk too soon
      const child = defineAsyncComponent({ loader })
      const comp = defineAsyncComponent({
        hydrate: defineStrategy(props as ExtractPropTypes<P>),
        loader: () => Promise.resolve(child),
      })
      const onVnodeMounted = () => { ctx.emit('hydrated') }
      return () => h(comp, mergeProps(ctx.attrs, { onVnodeMounted }), ctx.slots)
    },
  })
}

/* @__NO_SIDE_EFFECTS__ */
export const createLazyVisibleComponent = defineLazyComponent({
  hydrateOnVisible: {
    type: [Object, Boolean] as unknown as () => true | IntersectionObserverInit,
    required: false,
    default: true,
  },
},
props => hydrateOnVisible(props.hydrateOnVisible === true ? undefined : props.hydrateOnVisible),
)

/* @__NO_SIDE_EFFECTS__ */
export const createLazyIdleComponent = defineLazyComponent({
  hydrateOnIdle: {
    type: [Number, Boolean] as unknown as () => true | number,
    required: false,
    default: true,
  },
},
props => props.hydrateOnIdle === 0
  ? undefined /* hydrate immediately */
  : hydrateOnIdle(props.hydrateOnIdle === true ? undefined : props.hydrateOnIdle),
)

const defaultInteractionEvents = ['pointerenter', 'click', 'focus'] satisfies Array<keyof HTMLElementEventMap>

/* @__NO_SIDE_EFFECTS__ */
export const createLazyInteractionComponent = defineLazyComponent({
  hydrateOnInteraction: {
    type: [String, Array] as unknown as () => keyof HTMLElementEventMap | Array<keyof HTMLElementEventMap> | true,
    required: false,
    default: defaultInteractionEvents,
  },
},
props => hydrateOnInteraction(props.hydrateOnInteraction === true ? defaultInteractionEvents : (props.hydrateOnInteraction || defaultInteractionEvents)),
)

/* @__NO_SIDE_EFFECTS__ */
export const createLazyMediaQueryComponent = defineLazyComponent({
  hydrateOnMediaQuery: {
    type: String as unknown as () => string,
    required: true,
  },
},
props => hydrateOnMediaQuery(props.hydrateOnMediaQuery),
)

/* @__NO_SIDE_EFFECTS__ */
export const createLazyIfComponent = defineLazyComponent({
  hydrateWhen: {
    type: Boolean,
    default: true,
  },
},
props => props.hydrateWhen
  ? undefined /* hydrate immediately */
  : () => {}, /* Vue will trigger the hydration automatically when the prop changes */
)

/* @__NO_SIDE_EFFECTS__ */
export const createLazyTimeComponent = defineLazyComponent({
  hydrateAfter: {
    type: Number,
    required: true,
  },
},
props => props.hydrateAfter === 0
  ? undefined /* hydrate immediately */
  : (hydrate) => {
      const id = setTimeout(hydrate, props.hydrateAfter)
      return () => clearTimeout(id)
    },
)

/* @__NO_SIDE_EFFECTS__ */
const hydrateNever = () => {}
export const createLazyNeverComponent = defineLazyComponent({
  hydrateNever: {
    type: Boolean as () => true,
    required: false,
    default: true,
  },
},
() => hydrateNever,
)
</file>

<file path="packages/nuxt/src/components/runtime/server-component.ts">
import { defineComponent, getCurrentInstance, h, ref } from 'vue'
import NuxtIsland from '#app/components/nuxt-island'
import { useRoute } from '#app/composables/router'
import { isPrerendered } from '#app/composables/payload'
import { createError, showError } from '#app/composables/error'
import { useNuxtApp } from '#app/nuxt'

/* @__NO_SIDE_EFFECTS__ */
export const createServerComponent = (name: string) => {
  return defineComponent({
    name,
    inheritAttrs: false,
    props: { lazy: Boolean },
    emits: ['error'],
    setup (props, { attrs, slots, expose, emit }) {
      const vm = getCurrentInstance()
      const islandRef = ref<null | typeof NuxtIsland>(null)

      expose({
        refresh: () => islandRef.value?.refresh(),
      })

      return () => {
        return h(NuxtIsland, {
          name,
          lazy: props.lazy,
          props: attrs,
          scopeId: vm?.vnode.scopeId,
          ref: islandRef,
          onError: (err) => {
            emit('error', err)
          },
        }, slots)
      }
    },
  })
}

/* @__NO_SIDE_EFFECTS__ */
export const createIslandPage = (name: string) => {
  return defineComponent({
    name,
    inheritAttrs: false,
    props: { lazy: Boolean },
    async setup (props, { slots, expose }) {
      const islandRef = ref<null | typeof NuxtIsland>(null)

      expose({
        refresh: () => islandRef.value?.refresh(),
      })
      const nuxtApp = useNuxtApp()
      const route = useRoute()
      const path = import.meta.client && await isPrerendered(route.path) ? route.path : route.fullPath.replace(/#.*$/, '')
      return () => {
        return h('div', [
          h(NuxtIsland, {
            name: `page_${name}`,
            lazy: props.lazy,
            ref: islandRef,
            context: { url: path },
            onError: (e) => {
              if (e.cause && e.cause instanceof Response) {
                throw createError({
                  statusText: e.cause.statusText,
                  status: e.cause.status,
                })
              }
              nuxtApp.runWithContext(() => showError(e))
            },
          }, slots),
        ])
      }
    },
  })
}
</file>

<file path="packages/nuxt/src/components/module.ts">
import { existsSync } from 'node:fs'
import { isAbsolute, join, normalize, relative, resolve } from 'pathe'
import { addBuildPlugin, addImportsSources, addPluginTemplate, addTemplate, addTypeTemplate, addVitePlugin, defineNuxtModule, findPath, resolveAlias } from '@nuxt/kit'

import { resolveModulePath } from 'exsolve'
import { distDir } from '../dirs.ts'
import { DECLARATION_EXTENSIONS, isDirectorySync, logger } from '../utils.ts'
import { lazyHydrationMacroPreset } from '../imports/presets.ts'
import { componentNamesTemplate, componentsDeclarationTemplate, componentsIslandsTemplate, componentsMetadataTemplate, componentsPluginTemplate, componentsTypeTemplate } from './templates.ts'
import { scanComponents } from './scan.ts'

import { LoaderPlugin } from './plugins/loader.ts'
import { ComponentsChunkPlugin, IslandsTransformPlugin } from './plugins/islands-transform.ts'
import { TransformPlugin } from './plugins/transform.ts'
import { TreeShakeTemplatePlugin } from './plugins/tree-shake.ts'
import { ComponentNamePlugin } from './plugins/component-names.ts'
import { LazyHydrationTransformPlugin } from './plugins/lazy-hydration-transform.ts'
import { LazyHydrationMacroTransformPlugin } from './plugins/lazy-hydration-macro-transform.ts'
import type { Component, ComponentsDir, ComponentsOptions } from 'nuxt/schema'

const isPureObjectOrString = (val: unknown): val is object | string => (!Array.isArray(val) && typeof val === 'object') || typeof val === 'string'
const SLASH_SEPARATOR_RE = /[\\/]/
/**
 * Compare two directory entries by the number of path segments.
 *
 * Returns a sort comparator value based on the count of path segments (split on slashes). Deeper (more segments) paths are ordered before shallower ones.
 *
 * @param dirA - First directory
 * @param dirA.path - Path string
 * @param dirB - Second directory
 * @param dirB.path - Path string
 * @returns A negative number if the first directory should come before the second, positive if after, or 0 if equal
 */
function compareDirByPathLength ({ path: pathA }: { path: string }, { path: pathB }: { path: string }) {
  return pathB.split(SLASH_SEPARATOR_RE).filter(Boolean).length - pathA.split(SLASH_SEPARATOR_RE).filter(Boolean).length
}

const DEFAULT_COMPONENTS_DIRS_RE = /\/components(?:\/(?:global|islands))?$/
const STARTER_DOT_RE = /^\./g

export type getComponentsT = (mode?: 'client' | 'server' | 'all') => Component[]

export default defineNuxtModule<ComponentsOptions>({
  meta: {
    name: 'nuxt:components',
    configKey: 'components',
  },
  defaults: {
    dirs: [],
  },
  async setup (moduleOptions, nuxt) {
    let componentDirs: ComponentsDir[] = []
    const context = {
      components: [] as Component[],
    }

    const getComponents: getComponentsT = (mode) => {
      return (mode && mode !== 'all')
        ? context.components.filter(c => c.mode === mode || c.mode === 'all' || (c.mode === 'server' && !context.components.some(otherComponent => otherComponent.mode !== 'server' && otherComponent.pascalName === c.pascalName)))
        : context.components
    }

    // TODO: remove in Nuxt v5
    if (nuxt.options.experimental.normalizeComponentNames) {
      addBuildPlugin(ComponentNamePlugin({ sourcemap: !!nuxt.options.sourcemap.client, getComponents }), { server: false })
      addBuildPlugin(ComponentNamePlugin({ sourcemap: !!nuxt.options.sourcemap.server, getComponents }), { client: false })
    }

    // Resolve dirs
    nuxt.hook('app:resolve', async () => {
      // components/ dirs from all layers
      const allDirs: ComponentsDir[] = []
      const layerCount = nuxt.options._layers.length
      for (const [i, layer] of nuxt.options._layers.entries()) {
        // Assign priority based on layer position: lower index = higher priority
        // This ensures correct override order: root > auto-scanned > extends layers
        const priority = layerCount - i
        const layerDirs = normalizeDirs(layer.config.components, layer.config.srcDir, { priority })
        allDirs.push(...layerDirs)
      }

      await nuxt.callHook('components:dirs', allDirs)

      const userComponentDirs: ComponentsDir[] = []
      const libraryComponentDirs: ComponentsDir[] = []

      for (const dir of allDirs) {
        if (!isPureObjectOrString(dir)) {
          continue
        }

        const dirOptions = typeof dir === 'object' ? dir : { path: dir }
        const dirPath = resolveAlias(dirOptions.path)
        const extensions = (dirOptions.extensions || nuxt.options.extensions).map(e => e.replace(STARTER_DOT_RE, ''))
        const _transpile = typeof dirOptions.transpile === 'boolean' ? dirOptions.transpile : 'auto'
        const transpile = _transpile === 'auto' ? dirPath.includes('node_modules') : _transpile
        if (transpile) {
          nuxt.options.build.transpile.push(dirPath)
        }

        const present = isDirectorySync(dirPath)
        if (!present && !DEFAULT_COMPONENTS_DIRS_RE.test(dirOptions.path)) {
          logger.warn('Components directory not found: `' + dirPath + '`')
        }

        const dirs = dirPath.includes('node_modules') ? libraryComponentDirs : userComponentDirs

        dirs.push({
          global: moduleOptions.global,
          ...dirOptions,
          path: dirPath,
          extensions,
          pattern: dirOptions.pattern || (extensions.length > 1 ? `**/*.{${extensions.join(',')}}` : `**/*.${extensions[0] || '*'}`),
          ignore: [
            '**/*{M,.m,-m}ixin.{js,ts,jsx,tsx}', // ignore mixins
            `**/*.{${DECLARATION_EXTENSIONS.join(',')},}`, // .d.ts files
            ...(dirOptions.ignore || []),
          ],
          transpile,
        })
      }

      componentDirs = [
        ...userComponentDirs,
        ...libraryComponentDirs,
      ]
    })

    // components.d.ts
    addTemplate(componentsDeclarationTemplate)
    // types/components.d.ts
    addTypeTemplate(componentsTypeTemplate)
    // components.plugin.mjs
    addPluginTemplate(componentsPluginTemplate)
    // component-names.mjs
    addTemplate(componentNamesTemplate)
    // components.islands.mjs
    addTemplate(componentsIslandsTemplate)

    if (moduleOptions.generateMetadata) {
      addTemplate(componentsMetadataTemplate)
    }

    const serverComponentRuntime = await findPath(join(distDir, 'components/runtime/server-component')) ?? join(distDir, 'components/runtime/server-component')
    addBuildPlugin(TransformPlugin(nuxt, { getComponents, serverComponentRuntime, mode: 'server' }), { server: true, client: false })
    addBuildPlugin(TransformPlugin(nuxt, { getComponents, serverComponentRuntime, mode: 'client' }), { server: false, client: true })

    // Do not prefetch global components chunks
    nuxt.hook('build:manifest', (manifest) => {
      const sourceFiles = new Set<string>()
      for (const c of getComponents()) {
        if (c.global) {
          sourceFiles.add(relative(nuxt.options.srcDir, c.filePath))
        }
      }

      for (const chunk of Object.values(manifest)) {
        if (chunk.isEntry) {
          chunk.dynamicImports = chunk.dynamicImports?.filter(i => !sourceFiles.has(i))
        }
      }
    })

    // Restart dev server when component directories are added/removed
    const restartEvents = new Set(['addDir', 'unlinkDir'])
    // const restartPaths
    nuxt.hook('builder:watch', (event, relativePath) => {
      if (!restartEvents.has(event)) {
        return
      }

      const path = resolve(nuxt.options.srcDir, relativePath)
      if (componentDirs.some(dir => dir.path === path)) {
        logger.info(`Directory \`${relativePath}/\` ${event === 'addDir' ? 'created' : 'removed'}`)
        return nuxt.callHook('restart')
      }
    })

    const serverPlaceholderPath = await findPath(join(distDir, 'app/components/server-placeholder')) ?? join(distDir, 'app/components/server-placeholder')

    // Scan components and add to plugin
    nuxt.hook('app:templates', async (app) => {
      const newComponents = await scanComponents(componentDirs, nuxt.options.srcDir!)
      await nuxt.callHook('components:extend', newComponents)
      // add server placeholder for .client components server side. issue: #7085
      for (const component of newComponents) {
        if (!(component as any /* untyped internal property */)._scanned && !(component.filePath in nuxt.vfs) && isAbsolute(component.filePath) && !existsSync(component.filePath)) {
          // attempt to resolve component path
          component.filePath = resolveModulePath(resolveAlias(component.filePath), { try: true, extensions: nuxt.options.extensions }) ?? component.filePath
        }
        if (component.mode === 'client' && !newComponents.some(c => c.pascalName === component.pascalName && c.mode === 'server')) {
          newComponents.push({
            ...component,
            _raw: true,
            mode: 'server',
            filePath: serverPlaceholderPath,
            chunkName: 'components/' + component.kebabName,
          })
        }
        if (component.mode === 'server' && !nuxt.options.ssr && !newComponents.some(other => other.pascalName === component.pascalName && other.mode === 'client')) {
          logger.warn(`Using server components with \`ssr: false\` is not supported with auto-detected component islands. If you need to use server component \`${component.pascalName}\`, set \`experimental.componentIslands\` to \`true\`.`)
        }
      }
      context.components = newComponents
      app.components = newComponents
    })

    nuxt.hook('prepare:types', ({ tsConfig }) => {
      tsConfig.compilerOptions!.paths['#components'] = [resolve(nuxt.options.buildDir, 'components')]
    })

    addBuildPlugin(TreeShakeTemplatePlugin({ sourcemap: !!nuxt.options.sourcemap.server, getComponents }), { client: false })

    const clientDelayedComponentRuntime = await findPath(join(distDir, 'components/runtime/lazy-hydrated-component')) ?? join(distDir, 'components/runtime/lazy-hydrated-component')

    const sharedLoaderOptions = {
      getComponents,
      clientDelayedComponentRuntime,
      serverComponentRuntime,
      srcDir: nuxt.options.srcDir,
      transform: typeof nuxt.options.components === 'object' && !Array.isArray(nuxt.options.components) ? nuxt.options.components.transform : undefined,
      experimentalComponentIslands: !!nuxt.options.experimental.componentIslands,
    }

    addBuildPlugin(LoaderPlugin({ ...sharedLoaderOptions, sourcemap: !!nuxt.options.sourcemap.client, mode: 'client' }), { server: false })
    addBuildPlugin(LoaderPlugin({ ...sharedLoaderOptions, sourcemap: !!nuxt.options.sourcemap.server, mode: 'server' }), { client: false })

    if (nuxt.options.experimental.lazyHydration) {
      addBuildPlugin(LazyHydrationTransformPlugin({
        ...sharedLoaderOptions,
        sourcemap: !!(nuxt.options.sourcemap.server || nuxt.options.sourcemap.client),
      }), { prepend: true })

      addBuildPlugin(LazyHydrationMacroTransformPlugin({
        ...sharedLoaderOptions,
        sourcemap: !!(nuxt.options.sourcemap.server || nuxt.options.sourcemap.client),
        alias: nuxt.options.alias,
      }))

      addImportsSources(lazyHydrationMacroPreset)
    }

    if (nuxt.options.experimental.componentIslands) {
      const selectiveClient = typeof nuxt.options.experimental.componentIslands === 'object' && nuxt.options.experimental.componentIslands.selectiveClient

      addVitePlugin({
        name: 'nuxt-server-component-hmr',
        handleHotUpdate (ctx) {
          const components = getComponents()
          const filePath = normalize(ctx.file)
          const comp = components.find(c => c.filePath === filePath)
          if (comp?.mode === 'server') {
            ctx.server.ws.send({
              event: `nuxt-server-component:${comp.pascalName}`,
              type: 'custom',
            })
          }
        },
      }, { server: false })

      addBuildPlugin(IslandsTransformPlugin({ getComponents, selectiveClient }), { client: false, prepend: true })

      if (selectiveClient && nuxt.options.builder === '@nuxt/vite-builder') {
        addVitePlugin(() => ComponentsChunkPlugin({ dev: nuxt.options.dev, getComponents }))
      } else {
        addTemplate({
          filename: 'component-chunk.mjs',
          getContents: () => `export default {}`,
        })
      }
    }
  },
})

/**
 * Normalize the various user-provided `components.dirs` shapes into a flat array of ComponentsDir entries.
 *
 * Handles:
 * - Arrays (recursively flattened and sorted by path depth),
 * - `true`/`undefined` (returns default islands, global, and components dirs under `cwd`),
 * - Strings (resolved against `cwd` and alias resolution),
 * - Objects (either a single dir shape or an object with a `dirs` array).
 *
 * Each resulting entry has its `path` resolved via `resolveAlias` and `cwd`, receives a `priority` from `options.priority` (default 0), and entries without a `path` are skipped. The final list is sorted by path depth (shallowest first).
 *
 * @param dir - The raw `dirs` configuration value (single entry, array, true/undefined for defaults, or an options object).
 * @param cwd - Base directory used to resolve relative `path` values.
 * @param options - Optional settings; currently supports `priority` to assign a priority to all returned entries.
 * @param options.priority - Priority number to assign to all returned entries (default 0).
 * @returns A normalized, flat, and sorted array of ComponentsDir objects ready for component scanning.
 */
function normalizeDirs (dir: undefined | boolean | ComponentsOptions | ComponentsOptions['dirs'] | ComponentsOptions['dirs'][number], cwd: string, options?: { priority?: number }): ComponentsDir[] {
  if (Array.isArray(dir)) {
    return dir.map(dir => normalizeDirs(dir, cwd, options)).flat().sort(compareDirByPathLength)
  }
  if (dir === true || dir === undefined) {
    return [
      { priority: options?.priority || 0, path: resolve(cwd, 'components/islands'), island: true },
      { priority: options?.priority || 0, path: resolve(cwd, 'components/global'), global: true },
      { priority: options?.priority || 0, path: resolve(cwd, 'components') },
    ]
  }
  if (typeof dir === 'string') {
    return [
      { priority: options?.priority || 0, path: resolve(cwd, resolveAlias(dir)) },
    ]
  }
  if (!dir) {
    return []
  }

  const normalizedDirs: ComponentsDir[] = []
  for (const d of ('dirs' in dir ? dir.dirs || [] : [dir])) {
    const normalizedDir = typeof d === 'string' ? { path: d } : d
    if (!normalizedDir.path) {
      continue
    }
    normalizedDirs.push({
      priority: options?.priority || 0,
      ...normalizedDir,
      path: resolve(cwd, resolveAlias(normalizedDir.path)),
    })
  }

  return normalizedDirs.sort(compareDirByPathLength)
}
</file>

<file path="packages/nuxt/src/components/scan.ts">
import { readdir } from 'node:fs/promises'
import { basename, dirname, extname, join, relative } from 'pathe'
import { glob } from 'tinyglobby'
import { kebabCase, pascalCase, splitByCase } from 'scule'
import { isIgnored, useNuxt } from '@nuxt/kit'
import { withTrailingSlash } from 'ufo'

import { QUOTE_RE, resolveComponentNameSegments } from '../core/utils/index.ts'
import { logger, resolveToAlias } from '../utils.ts'
import type { Component, ComponentsDir } from 'nuxt/schema'

const ISLAND_RE = /\.island(?:\.global)?$/
const GLOBAL_RE = /\.global(?:\.island)?$/
const COMPONENT_MODE_RE = /(?<=\.)(client|server)(?:\.global|\.island)*$/
const MODE_REPLACEMENT_RE = /(?:\.(?:client|server))?(?:\.global|\.island)*$/
/**
 * Scan the components inside different components folders
 * and return a unique list of components
 * @param dirs all folders where components are defined
 * @param srcDir src path of your app
 * @returns {Promise} Component found promise
 */
export async function scanComponents (dirs: ComponentsDir[], srcDir: string): Promise<Component[]> {
  // All scanned components
  const components: Component[] = []

  // Keep resolved path to avoid duplicates
  const filePaths = new Set<string>()

  // All scanned paths
  const scannedPaths: string[] = []

  for (const dir of dirs) {
    // A map from resolved path to component name (used for making duplicate warning message)
    const resolvedNames = new Map<string, string>()

    const files = (await glob(dir.pattern!, { cwd: dir.path, ignore: dir.ignore })).sort()

    // Check if the directory exists (globby will otherwise read it case insensitively on MacOS)
    if (files.length) {
      const siblings = new Set(await readdir(dirname(dir.path)).catch(() => [] as string[]))
      const directory = basename(dir.path)
      if (!siblings.has(directory)) {
        const directoryLowerCase = directory.toLowerCase()
        for (const sibling of siblings) {
          if (sibling.toLowerCase() === directoryLowerCase) {
            const nuxt = useNuxt()
            const original = resolveToAlias(dir.path, nuxt)
            const corrected = resolveToAlias(join(dirname(dir.path), sibling), nuxt)
            logger.warn(`Components not scanned from \`${corrected}\`. Did you mean to name the directory \`${original}\` instead?`)
            break
          }
        }
      }
    }

    for (const _file of files) {
      const filePath = join(dir.path, _file)

      if (scannedPaths.find(d => filePath.startsWith(withTrailingSlash(d))) || isIgnored(filePath)) {
        continue
      }

      // Avoid duplicate paths
      if (filePaths.has(filePath)) { continue }

      filePaths.add(filePath)

      /**
       * Create an array of prefixes base on the prefix config
       * Empty prefix will be an empty array
       * @example prefix: 'nuxt' -> ['nuxt']
       * @example prefix: 'nuxt-test' -> ['nuxt', 'test']
       */
      const prefixParts = ([] as string[]).concat(
        dir.prefix ? splitByCase(dir.prefix) : [],
        (dir.pathPrefix !== false) ? splitByCase(relative(dir.path, dirname(filePath))) : [],
      )

      /**
       * In case we have index as filename the component become the parent path
       * @example third-components/index.vue -> third-component
       * if not take the filename
       * @example third-components/Awesome.vue -> Awesome
       */
      let fileName = basename(filePath, extname(filePath))

      const island = ISLAND_RE.test(fileName) || dir.island
      const global = GLOBAL_RE.test(fileName) || dir.global
      const mode = island ? 'server' : (fileName.match(COMPONENT_MODE_RE)?.[1] || 'all') as 'client' | 'server' | 'all'
      fileName = fileName.replace(MODE_REPLACEMENT_RE, '')

      if (fileName.toLowerCase() === 'index') {
        fileName = dir.pathPrefix === false ? basename(dirname(filePath)) : '' /* inherits from path */
      }

      const suffix = (mode !== 'all' ? `-${mode}` : '')
      const componentNameSegments = resolveComponentNameSegments(fileName.replace(QUOTE_RE, ''), prefixParts)
      const pascalName = pascalCase(componentNameSegments)

      if (LAZY_COMPONENT_NAME_REGEX.test(pascalName)) {
        logger.warn(`The component \`${pascalName}\` (in \`${filePath}\`) is using the reserved "Lazy" prefix used for dynamic imports, which may cause it to break at runtime.`)
      }

      if (resolvedNames.has(pascalName + suffix) || resolvedNames.has(pascalName)) {
        warnAboutDuplicateComponent(pascalName, filePath, resolvedNames.get(pascalName) || resolvedNames.get(pascalName + suffix)!)
        continue
      }
      resolvedNames.set(pascalName + suffix, filePath)

      const kebabName = kebabCase(componentNameSegments)
      const shortPath = relative(srcDir, filePath)
      const chunkName = 'components/' + kebabName + suffix

      let component: Component = {
        // inheritable from directory configuration
        mode,
        global,
        island,
        prefetch: Boolean(dir.prefetch),
        preload: Boolean(dir.preload),
        // specific to the file
        filePath,
        declarationPath: filePath,
        pascalName,
        kebabName,
        chunkName,
        shortPath,
        export: 'default',
        // by default, give priority to scanned components
        priority: dir.priority ?? 1,
        // @ts-expect-error untyped property
        _scanned: true,
      }

      if (typeof dir.extendComponent === 'function') {
        component = (await dir.extendComponent(component)) || component
      }

      // Ignore files like `~/components/index.vue` which end up not having a name at all
      if (!pascalName) {
        logger.warn(`Component did not resolve to a file name in \`${resolveToAlias(filePath)}\`.`)
        continue
      }

      const validModes = new Set(['all', component.mode])
      const existingComponent = components.find(c => c.pascalName === component.pascalName && validModes.has(c.mode))
      // Ignore component if component is already defined (with same mode)
      if (existingComponent) {
        const existingPriority = existingComponent.priority ?? 0
        const newPriority = component.priority ?? 0

        // Replace component if priority is higher
        if (newPriority > existingPriority) {
          components.splice(components.indexOf(existingComponent), 1, component)
        }
        // Warn if a user-defined (or prioritized) component conflicts with a previously scanned component
        if (newPriority > 0 && newPriority === existingPriority) {
          warnAboutDuplicateComponent(pascalName, filePath, existingComponent.filePath)
        }

        continue
      }

      components.push(component)
    }
    scannedPaths.push(dir.path)
  }

  return components
}

function warnAboutDuplicateComponent (componentName: string, filePath: string, duplicatePath: string) {
  logger.warn(`Two component files resolving to the same name \`${componentName}\`:\n` +
    `\n - ${filePath}` +
    `\n - ${duplicatePath}`,
  )
}

const LAZY_COMPONENT_NAME_REGEX = /^Lazy(?=[A-Z])/
</file>

<file path="packages/nuxt/src/components/templates.ts">
import { isAbsolute, join, relative, resolve } from 'pathe'
import { genDynamicImport, genDynamicTypeImport } from 'knitwork'
import { distDir } from '../dirs.ts'
import type { NuxtApp, NuxtPluginTemplate, NuxtTemplate } from 'nuxt/schema'

type ImportMagicCommentsOptions = {
  chunkName: string
  prefetch?: boolean | number
  preload?: boolean | number
}

const createImportMagicComments = (options: ImportMagicCommentsOptions) => {
  const { chunkName, prefetch, preload } = options
  return [
    `webpackChunkName: "${chunkName}"`,
    prefetch === true || typeof prefetch === 'number' ? `webpackPrefetch: ${prefetch}` : false,
    preload === true || typeof preload === 'number' ? `webpackPreload: ${preload}` : false,
  ].filter(Boolean).join(', ')
}

const emptyComponentsPlugin = `
import { defineNuxtPlugin } from '#app/nuxt'
export default defineNuxtPlugin({
  name: 'nuxt:global-components',
})
`

export const componentsPluginTemplate: NuxtPluginTemplate = {
  filename: 'components.plugin.mjs',
  getContents ({ app }) {
    const lazyGlobalComponents = new Set<string>()
    const syncGlobalComponents = new Set<string>()
    for (const component of app.components) {
      if (component.global === 'sync') {
        syncGlobalComponents.add(component.pascalName)
      } else if (component.global) {
        lazyGlobalComponents.add(component.pascalName)
      }
    }
    if (!lazyGlobalComponents.size && !syncGlobalComponents.size) { return emptyComponentsPlugin }

    const lazyComponents = [...lazyGlobalComponents]
    const syncComponents = [...syncGlobalComponents]

    return `import { defineNuxtPlugin } from '#app/nuxt'
import { ${[...lazyComponents.map(c => 'Lazy' + c), ...syncComponents].join(', ')} } from '#components'
const lazyGlobalComponents = [
  ${lazyComponents.map(c => `["${c}", Lazy${c}]`).join(',\n')},
  ${syncComponents.map(c => `["${c}", ${c}]`).join(',\n')}
]

export default defineNuxtPlugin({
  name: 'nuxt:global-components',
  setup (nuxtApp) {
    for (const [name, component] of lazyGlobalComponents) {
      nuxtApp.vueApp.component(name, component)
      nuxtApp.vueApp.component('Lazy' + name, component)
    }
  }
})
`
  },
}

export const componentNamesTemplate: NuxtTemplate = {
  filename: 'component-names.mjs',
  getContents ({ app }) {
    const componentNames = new Set<string>()
    for (const c of app.components) {
      if (!c.island) {
        componentNames.add(c.pascalName)
      }
    }
    return `export const componentNames = ${JSON.stringify([...componentNames])}`
  },
}

export const componentsIslandsTemplate: NuxtTemplate = {
  filename: 'components.islands.mjs',
  getContents ({ app, nuxt }) {
    if (!nuxt.options.experimental.componentIslands) {
      return 'export const islandComponents = {}'
    }

    const components = app.components
    const pages = app.pages
    const islands = components.filter(component =>
      component.island ||
      // .server components without a corresponding .client component will need to be rendered as an island
      (component.mode === 'server' && !components.some(c => c.pascalName === component.pascalName && c.mode === 'client')),
    )

    const pageExports = pages?.filter(p => (p.mode === 'server' && p.file && p.name)).map((p) => {
      return `"page_${p.name}": defineAsyncComponent(${genDynamicImport(p.file!)}.then(c => c.default || c))`
    }) || []

    return [
      'import { defineAsyncComponent } from \'vue\'',
      'export const islandComponents = import.meta.client ? {} : {',
      islands.map(
        (c) => {
          const exp = c.export === 'default' ? 'c.default || c' : `c['${c.export}']`
          const comment = createImportMagicComments(c)
          return `  "${c.pascalName}": defineAsyncComponent(${genDynamicImport(c.filePath, { comment })}.then(c => ${exp}))`
        },
      ).concat(pageExports).join(',\n'),
      '}',
    ].join('\n')
  },
}

const NON_VUE_RE = /\b\.(?!vue)\w+$/g
function resolveComponentTypes (app: NuxtApp, baseDir: string) {
  const serverPlaceholderPath = resolve(distDir, 'app/components/server-placeholder')
  const componentTypes: Array<[string, string]> = []
  for (const c of app.components) {
    if (c.island) {
      continue
    }
    // Use declarationPath if provided, otherwise fall back to filePath
    const filePath = c.declarationPath || c.filePath
    let type = genDynamicTypeImport(isAbsolute(filePath)
      ? relative(baseDir, filePath).replace(NON_VUE_RE, '')
      : filePath.replace(NON_VUE_RE, ''), c.export)

    if (c.mode === 'server') {
      if (app.components.some(other => other.pascalName === c.pascalName && other.mode === 'client')) {
        if (c.filePath.startsWith(serverPlaceholderPath)) {
          continue
        }
      } else {
        type = `IslandComponent<${type}>`
      }
    }
    componentTypes.push([c.pascalName, type])
  }

  return componentTypes
}

const islandType = 'type IslandComponent<T> = DefineComponent<{}, {refresh: () => Promise<void>}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, SlotsType<{ fallback: { error: unknown } }>> & T'
const hydrationTypes = `
type HydrationStrategies = {
  hydrateOnVisible?: IntersectionObserverInit | true
  hydrateOnIdle?: number | true
  hydrateOnInteraction?: keyof HTMLElementEventMap | Array<keyof HTMLElementEventMap> | true
  hydrateOnMediaQuery?: string
  hydrateAfter?: number
  hydrateWhen?: boolean
  hydrateNever?: true
}
type LazyComponent<T> = DefineComponent<HydrationStrategies, {}, {}, {}, {}, {}, {}, { hydrated: () => void }> & T
`
export const componentsDeclarationTemplate = {
  filename: 'components.d.ts' as const,
  write: true,
  getContents: ({ app, nuxt }) => {
    const componentTypes = resolveComponentTypes(app, nuxt.options.buildDir)
    return `
import type { DefineComponent, SlotsType } from 'vue'
${nuxt.options.experimental.componentIslands ? islandType : ''}
${hydrationTypes}

${componentTypes.map(([pascalName, type]) => `export const ${pascalName}: ${type}`).join('\n')}
${componentTypes.map(([pascalName, type]) => `export const Lazy${pascalName}: LazyComponent<${type}>`).join('\n')}

export const componentNames: string[]
`
  },
} satisfies NuxtTemplate

export const componentsTypeTemplate = {
  filename: 'types/components.d.ts' as const,
  getContents: ({ app, nuxt }) => {
    const componentTypes = resolveComponentTypes(app, join(nuxt.options.buildDir, 'types'))
    return `
import type { DefineComponent, SlotsType } from 'vue'
${nuxt.options.experimental.componentIslands ? islandType : ''}
${hydrationTypes}
interface _GlobalComponents {
${componentTypes.map(([pascalName, type]) => `  '${pascalName}': ${type}`).join('\n')}
${componentTypes.map(([pascalName, type]) => `  'Lazy${pascalName}': LazyComponent<${type}>`).join('\n')}
}

declare module 'vue' {
  export interface GlobalComponents extends _GlobalComponents { }
}

export {}
`
  },
} satisfies NuxtTemplate

export const componentsMetadataTemplate: NuxtTemplate = {
  filename: 'components.json',
  write: true,
  getContents: ({ app }) => JSON.stringify(app.components, null, 2),
}
</file>

<file path="packages/nuxt/src/core/plugins/async-context.ts">
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'
import type { Nuxt } from '@nuxt/schema'
import { isVue } from '../utils/index.ts'

export const AsyncContextInjectionPlugin = (nuxt: Nuxt) => createUnplugin(() => {
  return {
    name: 'nuxt:vue-async-context',
    transformInclude (id) {
      return isVue(id, { type: ['template', 'script'] })
    },
    transform: {
      filter: {
        code: { include: /_withAsyncContext/ },
      },
      handler (code) {
        const s = new MagicString(code)
        s.prepend('import { withAsyncContext as _withAsyncContext } from "#app/composables/asyncContext";\n')
        s.replace(/withAsyncContext as _withAsyncContext,?/, '')
        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: nuxt.options.sourcemap.client || nuxt.options.sourcemap.server
              ? s.generateMap({ hires: true })
              : undefined,
          }
        }
      },
    },
  }
})
</file>

<file path="packages/nuxt/src/core/plugins/dev-only.ts">
import MagicString from 'magic-string'
import { createUnplugin } from 'unplugin'
import { parse } from 'ultrahtml'
import type { Node } from 'ultrahtml'
import { isVue } from '../utils/index.ts'

interface DevOnlyPluginOptions {
  sourcemap?: boolean
}

const DEVONLY_COMP_SINGLE_RE = /<(?:dev-only|DevOnly|lazy-dev-only|LazyDevOnly)>[\s\S]*?<\/(?:dev-only|DevOnly|lazy-dev-only|LazyDevOnly)>/
const DEVONLY_COMP_RE = /<(?:dev-only|DevOnly|lazy-dev-only|LazyDevOnly)>[\s\S]*?<\/(?:dev-only|DevOnly|lazy-dev-only|LazyDevOnly)>/g

export const DevOnlyPlugin = (options: DevOnlyPluginOptions) => createUnplugin(() => {
  return {
    name: 'nuxt:server-devonly:transform',
    enforce: 'pre',
    transformInclude (id) {
      return isVue(id, { type: ['template'] })
    },
    transform: {
      filter: {
        code: { include: DEVONLY_COMP_SINGLE_RE },
      },
      handler (code) {
        const s = new MagicString(code)
        for (const match of code.matchAll(DEVONLY_COMP_RE)) {
          const ast: Node = parse(match[0]).children[0]
          const fallback: Node | undefined = ast.children?.find((n: Node) => {
            if (n.name !== 'template') { return false }
            return 'fallback' in n.attributes || '#fallback' in n.attributes || 'v-slot:fallback' in n.attributes
          })
          const replacement = fallback ? match[0].slice(fallback.loc[0].end, fallback.loc.at(-1).start) : ''
          s.overwrite(match.index!, match.index! + match[0].length, replacement)
        }

        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: options.sourcemap
              ? s.generateMap({ hires: true })
              : undefined,
          }
        }
      },
    },
  }
})
</file>

<file path="packages/nuxt/src/core/plugins/extract-async-data-handlers.ts">
import { pathToFileURL } from 'node:url'
import type { SourceMapInput } from 'rollup'
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'
import { dirname } from 'pathe'
import { parseQuery, parseURL } from 'ufo'
import { ScopeTracker, parseAndWalk, walk } from 'oxc-walker'
import type { ArrowFunctionExpression, Function } from 'oxc-parser'

const functionsToExtract = new Set(['useAsyncData', 'useLazyAsyncData'])
const FUNCTIONS_RE = /\buse(?:Lazy)?AsyncData\b/
const SUPPORTED_EXT_RE = /\.(?:m?[jt]sx?|vue)$/
const SCRIPT_RE = /(?<=<script[^>]*>)[\s\S]*?(?=<\/script>)/i

export interface ExtractAsyncDataHandlersOptions {
  sourcemap: boolean
  rootDir: string
}

export const ExtractAsyncDataHandlersPlugin = (options: ExtractAsyncDataHandlersOptions) => createUnplugin(() => {
  const asyncDatas: Record<string, { code: string, map?: SourceMapInput }> = {}

  let count = 0

  return {
    name: 'nuxt:extract-async-data-handlers',
    enforce: 'post',
    resolveId (source) {
      if (source in asyncDatas) {
        return source
      }
    },
    load (id) {
      if (id in asyncDatas) {
        return asyncDatas[id]
      }
    },
    transformInclude (id) {
      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href))
      return SUPPORTED_EXT_RE.test(pathname) && parseQuery(search).type !== 'style' && !parseQuery(search).macro
    },
    transform: {
      filter: {
        id: {
          exclude: [/nuxt\/(src|dist)\/app/],
        },
        code: { include: FUNCTIONS_RE },
      },
      handler (code, id) {
        const { 0: script = code, index: codeIndex = 0 } = code.match(SCRIPT_RE) || { index: 0, 0: code }

        let s: MagicString | undefined

        const scopeTracker = new ScopeTracker({ preserveExitedScopes: true })
        const parseResult = parseAndWalk(script, id, { scopeTracker })
        scopeTracker.freeze()

        walk(parseResult.program, {
          scopeTracker,
          enter (node) {
            if (node.type !== 'CallExpression' || node.callee.type !== 'Identifier' || !functionsToExtract.has(node.callee.name)) {
              return
            }

            const callExpression = node

            const fetcherFunction = callExpression.arguments.find((fn): fn is Function | ArrowFunctionExpression => fn.type === 'ArrowFunctionExpression' || fn.type === 'FunctionExpression')

            if (!fetcherFunction || (fetcherFunction.type !== 'ArrowFunctionExpression' && fetcherFunction.type !== 'FunctionExpression') || !fetcherFunction.body) {
              return
            }

            s ||= new MagicString(code)

            const referencedVariables = new Set<string>()
            const imports = new Set<string>()

            // Walk the function body to find all identifiers
            walk(fetcherFunction.body, {
              scopeTracker,
              enter (innerNode, parent) {
                if (innerNode.type !== 'Identifier') {
                  return
                }

                // Skip identifiers that are property keys (not variable references)
                if (parent) {
                  // Skip non-computed member expression properties (e.g., the "data" in response.data)
                  if (parent.type === 'MemberExpression' && parent.property === innerNode && parent.computed === false) {
                    return
                  }
                  // Skip non-computed object property keys (e.g., { data: value })
                  if (parent.type === 'Property' && parent.key === innerNode && parent.computed === false) {
                    return
                  }
                  // Skip non-computed class method keys
                  if (parent.type === 'MethodDefinition' && parent.key === innerNode && parent.computed === false) {
                    return
                  }
                  // Skip non-computed property definition keys
                  if (parent.type === 'PropertyDefinition' && parent.key === innerNode && parent.computed === false) {
                    return
                  }
                }

                const declaration = scopeTracker.getDeclaration(innerNode.name)
                if (!declaration) {
                  return
                }

                if (declaration.type === 'Import') {
                  // This is an imported variable, we need to include the import
                  imports.add(innerNode.name)
                } else if (declaration.type !== 'FunctionParam') {
                  const functionBodyStart = fetcherFunction.body!.start
                  const functionBodyEnd = fetcherFunction.body!.end

                  // If the declaration is not within the function body, it's external
                  if (declaration.start < functionBodyStart || declaration.end > functionBodyEnd) {
                    referencedVariables.add(innerNode.name)
                  }
                }
              },
            })

            // Collect import statements for the referenced imports
            const importStatements = new Set<string>()
            walk(parseResult.program, {
              enter (importDecl) {
                if (importDecl.type !== 'ImportDeclaration') {
                  return
                }

                // Check if this import declaration contains any of our referenced imports
                if (importDecl.specifiers?.some(spec => spec.local && imports.has(spec.local.name))) {
                  importStatements.add(script.slice(importDecl.start, importDecl.end))
                }
              },
            })

            const imps = Array.from(importStatements).join('\n')

            // Generate a unique key for the extracted chunk
            const key = `${dirname(id)}/async-data-chunk-${count++}.js`

            // Get the function body content
            const isBlockStatement = fetcherFunction.body.type === 'BlockStatement'

            const startOffset = codeIndex + fetcherFunction.body.start
            const endOffset = codeIndex + fetcherFunction.body.end

            // Create the extracted chunk
            const chunk = s.clone()
            const parameters = [...referencedVariables].join(', ')
            const returnPrefix = isBlockStatement ? '' : 'return '
            const preface = `${imps}\nexport default async function (${parameters}) { ${returnPrefix}`
            const suffix = ` }`

            if (isBlockStatement) {
              // For block statements, we need to extract the content inside the braces
              chunk.overwrite(0, startOffset + 1, preface)
              chunk.overwrite(endOffset - 1, code.length, suffix)
            } else {
              // For expression bodies, wrap in return statement
              chunk.overwrite(0, startOffset, preface)
              chunk.overwrite(endOffset, code.length, suffix)
            }

            asyncDatas[key] = {
              code: chunk.toString(),
              map: options.sourcemap ? chunk.generateMap({ hires: true }) : undefined,
            }

            // Replace the original function with a dynamic import
            const importCall = `() => import('${key}').then(r => (r.default || r)(${parameters}))`
            s.overwrite(codeIndex + fetcherFunction.start, codeIndex + fetcherFunction.end, importCall)
          },
        })

        if (s?.hasChanged()) {
          return {
            code: s.toString(),
            map: options.sourcemap
              ? s.generateMap({ hires: true })
              : undefined,
          }
        }
      },
    },
  }
})
</file>

<file path="packages/nuxt/src/core/plugins/import-protection.ts">
import { relative, resolve } from 'pathe'
import escapeRE from 'escape-string-regexp'
import type { NuxtOptions } from 'nuxt/schema'

interface ImportProtectionOptions {
  rootDir: string
  modulesDir: string[]
  patterns: [importPattern: string | RegExp, warning?: string][]
  exclude?: Array<RegExp | string>
}

interface NuxtImportProtectionOptions {
  context: 'nuxt-app' | 'nitro-app' | 'shared'
}

export function createImportProtectionPatterns (nuxt: { options: NuxtOptions }, options: NuxtImportProtectionOptions) {
  const patterns: ImportProtectionOptions['patterns'] = []
  const context = contextFlags[options.context]

  patterns.push([
    /^(nuxt|nuxt3|nuxt-nightly)$/,
    `\`nuxt\`, or \`nuxt-nightly\` cannot be imported directly in ${context}.` + (options.context === 'nuxt-app' ? ' Instead, import runtime Nuxt composables from `#app` or `#imports`.' : ''),
  ])

  patterns.push([
    /^((~|~~|@|@@)?\/)?nuxt\.config(\.|$)/,
    'Importing directly from a `nuxt.config` file is not allowed. Instead, use runtime config or a module.',
  ])

  patterns.push([/(^|node_modules\/)@vue\/composition-api/])

  for (const mod of nuxt.options._installedModules) {
    if (mod.entryPath) {
      patterns.push([
        new RegExp(`^${escapeRE(mod.entryPath)}$`),
        'Importing directly from module entry-points is not allowed.',
      ])
    }
  }

  for (const i of [/(^|node_modules\/)@nuxt\/(cli|kit|test-utils)/, /(^|node_modules\/)nuxi/, /(^|node_modules\/)nitro(?:pack)?(?:-nightly)?(?:$|\/)(?!(?:dist\/)?(?:node_modules|presets|runtime|types))/, /(^|node_modules\/)nuxt\/(config|kit|schema)/]) {
    patterns.push([i, `This module cannot be imported in ${context}.`])
  }

  if (options.context === 'nitro-app' || options.context === 'shared') {
    for (const i of ['#app', /^#build(\/|$)/]) {
      patterns.push([i, `Vue app aliases are not allowed in ${context}.`])
    }
  }

  if (options.context === 'nuxt-app' || options.context === 'shared') {
    patterns.push([
      new RegExp(escapeRE(relative(nuxt.options.srcDir, resolve(nuxt.options.srcDir, nuxt.options.serverDir || 'server'))) + '\\/(api|routes|middleware|plugins)\\/'),
      `Importing from server is not allowed in ${context}.`,
    ])
    patterns.push([
      /^#server(\/|$)/,
      `Server aliases are not allowed in ${context}.`,
    ])
  }

  return patterns
}

const contextFlags = {
  'nitro-app': 'server runtime',
  'nuxt-app': 'the Vue part of your app',
  'shared': 'the #shared directory',
} as const
</file>

<file path="packages/nuxt/src/core/plugins/keyed-functions.ts">
import { pathToFileURL } from 'node:url'
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'
import { hash } from 'ohash'
import { parseQuery, parseURL } from 'ufo'
import { isAbsolute, join, parse } from 'pathe'
import { camelCase } from 'scule'
import escapeRE from 'escape-string-regexp'
import { findStaticImports, parseStaticImport } from 'mlly'
import { ScopeTracker, type ScopeTrackerNode, parseAndWalk, walk } from 'oxc-walker'
import { resolveAlias } from '@nuxt/kit'
import type { KeyedFunction } from '@nuxt/schema'
import type { Node } from 'oxc-parser'
import type { Import } from 'unimport'

import { isWhitespace, logger, stripExtension } from '../../utils.ts'
import type { FunctionCallMetadata } from '../utils/parse-utils.ts'
import { parseStaticExportIdentifiers, parseStaticFunctionCall, processImports } from '../utils/parse-utils.ts'

interface KeyedFunctionsOptions {
  sourcemap: boolean
  keyedFunctions: KeyedFunction[]
  alias: Record<string, string>
  // TODO: remove in Nuxt 5
  getAutoImports: () => Promise<Import[]>
}

const stringTypes: Array<string | undefined> = ['Literal', 'TemplateLiteral']
const NUXT_LIB_RE = /node_modules\/(?:nuxt|nuxt3|nuxt-nightly|@nuxt)\//
const SUPPORTED_EXT_RE = /\.(?:m?[jt]sx?|vue)/
const SCRIPT_RE = /(?<=<script[^>]*>)[\s\S]*?(?=<\/script>)/i
const NUXT_INJECTED_MARKER = '/* nuxt-injected */'

export function shouldTransformFile (id: string, extensions: RegExp | readonly string[]) {
  const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href))
  return !NUXT_LIB_RE.test(pathname)
    && (
      extensions instanceof RegExp
        ? extensions.test(pathname)
        : new RegExp(`\\.(${extensions.map(e => escapeRE(e)).join('|')})$`).test(pathname)
    )
    && parseQuery(search).type !== 'style' && !parseQuery(search).macro
}

// TODO: remove in Nuxt 5
type BackwardsCompatibleKeyedFunction = Omit<KeyedFunction, 'source'> & { source?: KeyedFunction['source'] | RegExp }

export const KeyedFunctionsPlugin = (options: KeyedFunctionsOptions) => createUnplugin(() => {
  // DO NOT USE IN TRANSFORM - this is a global copy that doesn't include local import names
  // - the `source`s have resolved aliases and are without extensions
  const namesToSourcesToFunctionMeta = new Map<string, Map<string, BackwardsCompatibleKeyedFunction>>()
  // filenames (without extension) of files that have a `default` keyed function export
  const defaultExportSources = new Set<string>()

  for (const f of options.keyedFunctions) {
    let functionName = f.name
    const fnSource = typeof f.source === 'string' ? stripExtension(f.source) : ''

    if (f.name === 'default') {
      const parsedSource = parse(f.source)
      defaultExportSources.add(parsedSource.name)
      functionName = camelCase(parsedSource.name)
    }

    if (import.meta.dev) {
      const sourcesToFunctionMeta = namesToSourcesToFunctionMeta.get(functionName)
      const existingEntry = sourcesToFunctionMeta?.get(fnSource)
      if (existingEntry?.source && existingEntry.source === fnSource) {
        logger.warn(`[nuxt:compiler] [keyed-functions] Duplicate function name \`${functionName}\`${functionName !== f.name ? ` defined as \`${f.name}\`` : ''} with ${f.source ? `the same source \`${f.source}\`` : 'no source'} found. Overwriting the existing entry.`)
      }
    }

    let sourcesToFunctionMeta = namesToSourcesToFunctionMeta.get(functionName)
    if (!sourcesToFunctionMeta) {
      sourcesToFunctionMeta = new Map<string, KeyedFunction>()
      namesToSourcesToFunctionMeta.set(functionName, sourcesToFunctionMeta)
    }

    sourcesToFunctionMeta.set(fnSource, {
      ...f,
      // TODO: use only `fnSource` in Nuxt 5
      source: typeof f.source === 'string' ? fnSource : f.source,
    })
  }

  // resolved paths of all the sources WITHOUT EXTENSIONS
  const sources = new Set<string>()
  for (const sourcesToFunctionMeta of namesToSourcesToFunctionMeta.values()) {
    for (const f of sourcesToFunctionMeta.values()) {
      // TODO: remove check in Nuxt 5 (keeping it at the moment for the case when there is a RegExp in `source`)
      if (f.source && typeof f.source === 'string') {
        sources.add(f.source)
      }
    }
  }

  // TODO: come up with a better way to include files importing a `default` export (imported name can be arbitrary)
  const CODE_INCLUDE_RE = new RegExp(`\\b(${[...namesToSourcesToFunctionMeta.keys(), ...defaultExportSources].map(f => escapeRE(f)).join('|')})\\b`)

  return {
    name: 'nuxt:compiler:keyed-functions',
    enforce: 'post',
    transformInclude: id => shouldTransformFile(id, SUPPORTED_EXT_RE),
    transform: {
      filter: {
        code: { include: CODE_INCLUDE_RE },
      },
      async handler (code, _id) {
        const { 0: script = code, index: codeIndex = 0 } = code.match(SCRIPT_RE) || { 0: code, index: 0 }
        const id = stripExtension(_id)

        const { directImports, namespaces } = processImports(findStaticImports(script).map(i => parseStaticImport(i)))

        // consider exports when processing a file that exports a keyed function
        const shouldConsiderExports = sources.has(id)

        // all local names that refer to a keyed function
        // mapped to their exported names
        const localNamesToExportedName = new Map<string, string>()

        const possibleLocalFunctionNames = new Set<string>(namesToSourcesToFunctionMeta.keys())
        for (const [localName, directImport] of directImports) {
          // add import names that refer to keyed functions
          const functionName = directImport.originalName === 'default'
            ? camelCase(parse(directImport.source).name)
            : directImport.originalName
          if (namesToSourcesToFunctionMeta.has(functionName)) {
            possibleLocalFunctionNames.add(localName)
          }
        }

        const autoImports = await options.getAutoImports()
        // auto-imported name -> source (without alias resolution and with extension)
        const autoImportsToSources = new Map<string, string>(autoImports.map(i => [i.as || i.name, i.from]))

        /**
         * @param localName the local name of the function to get the meta for
         * @param source the resolved source of the function to get the meta for (needs to be WITHOUT EXTENSION)
         */
        function getFunctionMetaByLocalName (localName: string, source: string): BackwardsCompatibleKeyedFunction | undefined {
          if (!localName) { return }
          // check exports (higher priority)
          const exportedName = localNamesToExportedName.get(localName)
          if (exportedName) {
            return namesToSourcesToFunctionMeta.get(exportedName)?.get(source)
          }
          // check static direct imports
          const directImport = directImports.get(localName)
          if (directImport) {
            const functionName = directImport.originalName === 'default'
              ? camelCase(parse(directImport.source).name)
              : directImport.originalName

            // TODO: remove auto-import checks in Nuxt 5
            const sourcesToMetas = namesToSourcesToFunctionMeta.get(functionName)
            if (!sourcesToMetas) { return }

            const fnMeta = sourcesToMetas.get(source)
            if (fnMeta) { return fnMeta }

            const backwardsCompatibleFnMeta = sourcesToMetas.get('') // functions without a source or with a regex fall under ''
            if (backwardsCompatibleFnMeta?.source === undefined) {
              const autoImportResolvedSource = stripExtension(resolveAlias(autoImportsToSources.get(localName) ?? ''))
              if (autoImportResolvedSource === source) {
                return backwardsCompatibleFnMeta
              }
            } else if (backwardsCompatibleFnMeta.source instanceof RegExp && backwardsCompatibleFnMeta.source.test(source)) {
              return backwardsCompatibleFnMeta
            }

            return
          }

          // check local names
          return namesToSourcesToFunctionMeta.get(localName)?.get(source)
        }

        // TODO: use async walker or create sync version of `resolvePath` from kit
        function _resolvePath (path: string) {
          let p = path
          if (isAbsolute(p)) { return p }
          p = resolveAlias(p, options.alias)
          if (isAbsolute(p)) { return p }
          return join(parse(id).dir, p)
        }

        const s = new MagicString(code)
        let count = 0

        const scopeTracker = new ScopeTracker({
          preserveExitedScopes: true,
        })

        // pre-pass to collect hoisted identifiers & exports
        const { program } = parseAndWalk(code, _id, {
          scopeTracker,
          enter (node) {
            if (!shouldConsiderExports) { return }
            if (node.type !== 'ExportNamedDeclaration' && node.type !== 'ExportDefaultDeclaration') { return }

            const result = parseStaticExportIdentifiers(node)
            for (const exportMeta of result) {
              const { localName, exportedName } = exportMeta
              const functionName = exportedName === 'default'
                ? camelCase(parse(id).name)
                // the function cannot look up function meta by local names yet,
                // so we need to use the `exportedName` instead because that is the one
                // that's used in the keyed functions definition
                : getFunctionMetaByLocalName(exportedName, id)?.name
              if (!functionName) { continue }
              localNamesToExportedName.set(localName, functionName)
            }
          },
        })

        scopeTracker.freeze()

        // add exported local identifiers that refer to keyed functions
        for (const localName of localNamesToExportedName.keys()) {
          possibleLocalFunctionNames.add(localName)
        }

        const LOCAL_FUNCTION_NAMES_RE = new RegExp(`\\b(${[...possibleLocalFunctionNames].map(f => escapeRE(f)).join('|')})\\b`)

        function processKeyedFunction (
          walkContext: ThisParameterType<NonNullable<Parameters<typeof walk>[1]['enter']>>, // TODO: export type from `oxc-walker`
          node: Node,
          handler: (ctx: { parsedCall: FunctionCallMetadata, fnMeta: BackwardsCompatibleKeyedFunction }) => void,
        ) {
          if (node.type !== 'CallExpression' && node.type !== 'ChainExpression') { return }
          const parsedCall = parseStaticFunctionCall(node, LOCAL_FUNCTION_NAMES_RE)
          if (!parsedCall) { return }

          const functionScopeTrackerNode = scopeTracker.getDeclaration(!parsedCall.namespace ? parsedCall.name : parsedCall.namespace)

          function isKeyedFunctionImport (node: ScopeTrackerNode | null): node is ScopeTrackerNode & { type: 'Import' } {
            return node?.type === 'Import' && node.importNode.importKind !== 'type'
          }

          // import source WITHOUT EXTENSION and with resolved aliases
          let importSourceResolved: string | undefined

          // check for exports with a higher priority
          if (localNamesToExportedName.has(parsedCall.name) && functionScopeTrackerNode?.scope === '') { // TODO: add support for checking root scope in `oxc-walker`
            importSourceResolved = id
          } else if (isKeyedFunctionImport(functionScopeTrackerNode)) {
            importSourceResolved = stripExtension(_resolvePath(functionScopeTrackerNode.importNode.source.value))
          }

          if (!importSourceResolved) {
            walkContext.skip()
            return
          }

          const fnMeta = getFunctionMetaByLocalName(parsedCall.name, importSourceResolved)

          if (!fnMeta) {
            walkContext.skip()
            return
          }

          // the function is called directly
          // `useKeyed()`
          if (!parsedCall.namespace) {
            // skip if there are more arguments than allowed
            if (
              parsedCall.callExpression.arguments.length >= fnMeta.argumentLength
              // do not skip when there is a spread element (we don't know how many arguments there are)
              && !parsedCall.callExpression.arguments.some(a => a.type === 'SpreadElement')
            ) {
              walkContext.skip()
              return
            }

            if (
              // the function is imported
              (
                isKeyedFunctionImport(functionScopeTrackerNode) && (
                  // import { useKeyed } from '...'
                  (
                    functionScopeTrackerNode.node.type === 'ImportSpecifier'
                    && functionScopeTrackerNode.node.importKind !== 'type'
                  )
                  // import useKeyed from '...'
                  || (
                    functionScopeTrackerNode.node.type === 'ImportDefaultSpecifier'
                    && fnMeta.name === 'default'
                  )
                )
                && (
                  // the function is imported from the correct source when `source` is specified
                  (typeof fnMeta.source === 'string' && (stripExtension(fnMeta.source) === importSourceResolved))
                  // TODO: remove the checks below in Nuxt 5
                  // or the function is auto-imported when there is no source specified
                  || (!fnMeta.source && stripExtension(_resolvePath(autoImportsToSources.get(parsedCall.name) ?? '')) === importSourceResolved)
                  // or the specified function's source RegExp matches the import source
                  || (fnMeta.source instanceof RegExp && fnMeta.source.test(importSourceResolved))
                )
              )
              // or the function is defined in the current file, and we're considering the root level scope declaration
              || (localNamesToExportedName.has(parsedCall.name) && functionScopeTrackerNode?.scope === '') // TODO: add support for checking root scope in `oxc-walker`
            ) {
              handler({ parsedCall, fnMeta })
            }

            walkContext.skip()
            return
          }

          // the function is called as a member of a namespace import
          // `namespace.useKeyed()`
          if (parsedCall.namespace) {
            const namespacedImportMeta = namespaces.get(importSourceResolved)
            const namespaceScopeTrackerNode = scopeTracker.getDeclaration(parsedCall.namespace)

            if (
              namespacedImportMeta && namespacedImportMeta.namespaces.has(parsedCall.namespace)
              // the namespace is not shadowed
              && namespaceScopeTrackerNode?.type === 'Import' && namespaceScopeTrackerNode.node.type === 'ImportNamespaceSpecifier'
            ) {
              handler({ parsedCall, fnMeta })
            }

            // prevent descending into CallExpression of a ChainExpression
            walkContext.skip()
            return
          }
        }

        walk(program, {
          scopeTracker,
          enter (node) {
            processKeyedFunction(this, node, ({ parsedCall, fnMeta }) => {
              // (workaround for webpack calling the build plugin multiple times on the same file in some cases)
              // skip key injection if we already injected one
              const lastArgument = parsedCall.callExpression.arguments[parsedCall.callExpression.arguments.length - 1]
              if (
                lastArgument?.type === 'Literal' && typeof lastArgument.value === 'string'
                // there is a magic comment with a space before it after the last string argument
                && lastArgument.end + NUXT_INJECTED_MARKER.length + 1 < parsedCall.callExpression.end
              ) {
                let wasKeyInjected = true
                for (let i = 0; i < NUXT_INJECTED_MARKER.length; i++) {
                  // the magic comment does not match, we have not injected a key yet
                  if (code[codeIndex + lastArgument.end + 1 + i] !== NUXT_INJECTED_MARKER[i]) {
                    wasKeyInjected = false
                    break
                  }
                }
                if (wasKeyInjected) { return }
              }

              // skip key injection for Nuxt internal composables when they already have a key
              switch (parsedCall.name) {
                case 'useState':
                  if (
                    stringTypes.includes(parsedCall.callExpression.arguments[0]?.type)
                    && typeof fnMeta.source === 'string' && stripExtension(fnMeta.source) === stripExtension(resolveAlias('#app/composables/state', options.alias))
                  ) { return }
                  break
                case 'useFetch':
                case 'useLazyFetch':
                  if (
                    stringTypes.includes(parsedCall.callExpression.arguments[1]?.type)
                    && typeof fnMeta.source === 'string' && stripExtension(fnMeta.source) === stripExtension(resolveAlias('#app/composables/fetch', options.alias))
                  ) { return }
                  break

                case 'useAsyncData':
                case 'useLazyAsyncData':
                  if (
                    stringTypes.includes(parsedCall.callExpression.arguments[0]?.type)
                    && typeof fnMeta.source === 'string' && stripExtension(fnMeta.source) === stripExtension(resolveAlias('#app/composables/asyncData', options.alias))
                  ) { return }
                  break
              }

              // inject a key to the function call
              let i = codeIndex + parsedCall.callExpression.end - 2 // char before the closing `)`
              while (i >= codeIndex + parsedCall.callExpression.start && isWhitespace(code[i])) {
                i--
              }
              const endsWithComma = code[i] === ','

              s.appendLeft(
                codeIndex + parsedCall.callExpression.end - 1,
                (parsedCall.callExpression.arguments.length && !endsWithComma ? ', ' : '') + '\'$' + hash(`${_id}-${++count}`).slice(0, 10) + `' ${NUXT_INJECTED_MARKER}`,
              )
            })
          },
        })

        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: options.sourcemap
              ? s.generateMap({ hires: true })
              : undefined,
          }
        }
      },
    },
  }
})
</file>

<file path="packages/nuxt/src/core/plugins/layer-aliasing.ts">
import { type UnpluginOptions, createUnplugin } from 'unplugin'
import { resolveAlias } from '@nuxt/kit'
import { normalize } from 'pathe'
import MagicString from 'magic-string'
import type { NuxtConfigLayer } from 'nuxt/schema'

interface LayerAliasingOptions {
  sourcemap?: boolean
  root: string
  dev: boolean
  layers: NuxtConfigLayer[]
}

const ALIAS_RE = /(?<=['"])[~@]{1,2}(?=\/)/g
const ALIAS_RE_SINGLE = /(?<=['"])[~@]{1,2}(?=\/)/
const ALIAS_ID_RE = /^[~@]{1,2}\//

export const LayerAliasingPlugin = (options: LayerAliasingOptions) => createUnplugin((_options, meta) => {
  const aliases: Record<string, Record<string, string>> = {}
  for (const layer of options.layers) {
    const srcDir = layer.config.srcDir || layer.cwd
    const rootDir = layer.config.rootDir || layer.cwd

    aliases[srcDir] = {
      '~': layer.config?.alias?.['~'] || srcDir,
      '@': layer.config?.alias?.['@'] || srcDir,
      '~~': layer.config?.alias?.['~~'] || rootDir,
      '@@': layer.config?.alias?.['@@'] || rootDir,
    }
  }
  const layers = Object.keys(aliases).sort((a, b) => b.length - a.length)

  const nonViteTransformIncludes: UnpluginOptions['transformInclude'] = (id) => {
    const _id = normalize(id)
    return layers.some(dir => _id.startsWith(dir))
  }
  const nonViteTransform: UnpluginOptions['transform'] = {
    filter: {
      code: { include: ALIAS_RE_SINGLE },
    },
    handler (code, id) {
      const _id = normalize(id)
      const layer = layers.find(l => _id.startsWith(l))
      if (!layer) { return }

      const s = new MagicString(code)
      s.replace(ALIAS_RE, r => aliases[layer]?.[r as '~'] || r)

      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: options.sourcemap ? s.generateMap({ hires: true }) : undefined,
        }
      }
    },
  }

  return {
    name: 'nuxt:layer-aliasing',
    enforce: 'pre',
    vite: {
      resolveId: {
        order: 'pre',
        filter: {
          id: ALIAS_ID_RE,
        },
        async handler (id, importer) {
          if (!importer) { return }

          const layer = layers.find(l => importer.startsWith(l))
          if (!layer) { return }

          const resolvedId = resolveAlias(id, aliases[layer])
          if (resolvedId !== id) {
            return await this.resolve(resolvedId, importer, { skipSelf: true })
          }
        },
      },
    },

    // webpack-only transform
    transformInclude: meta.framework !== 'vite' ? nonViteTransformIncludes : undefined,
    transform: meta.framework !== 'vite' ? nonViteTransform : undefined,
  }
})
</file>

<file path="packages/nuxt/src/core/plugins/plugin-metadata.ts">
import type { Literal } from 'estree'
import { defu } from 'defu'
import { findExports } from 'mlly'
import type { Nuxt } from '@nuxt/schema'
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'
import { normalize } from 'pathe'
import type { NuxtAppLiterals, ObjectPlugin, PluginMeta } from 'nuxt/app'

import { parseAndWalk } from 'oxc-walker'
import type { IdentifierName, ObjectPropertyKind } from 'oxc-parser'
import { logger } from '../../utils.ts'

const internalOrderMap = {
  // -50: pre-all (nuxt)
  'nuxt-pre-all': -50,
  // -40: custom payload revivers (user)
  'user-revivers': -40,
  // -30: payload reviving (nuxt)
  'nuxt-revivers': -30,
  // -20: pre (user) <-- pre mapped to this
  'user-pre': -20,
  // -10: default (nuxt)
  'nuxt-default': -10,
  // 0: default (user) <-- default behavior
  'user-default': 0,
  // +10: post (nuxt)
  'nuxt-post': 10,
  // +20: post (user) <-- post mapped to this
  'user-post': 20,
  // +30: post-all (nuxt)
  'nuxt-post-all': 30,
}

export const orderMap: Record<NonNullable<ObjectPlugin['enforce']>, number> = {
  pre: internalOrderMap['user-pre'],
  default: internalOrderMap['user-default'],
  post: internalOrderMap['user-post'],
}

const metaCache: Record<string, Omit<PluginMeta, 'enforce'>> = {}
export function extractMetadata (code: string, loader = 'ts' as 'ts' | 'tsx') {
  let meta: PluginMeta = {}
  if (metaCache[code]) {
    return metaCache[code]
  }
  // non-object syntax plugin
  if (/defineNuxtPlugin\s*\([\w(]/.test(code)) {
    return {}
  }
  parseAndWalk(code, `file.${loader}`, (node) => {
    if (node.type !== 'CallExpression' || node.callee.type !== 'Identifier') { return }

    const name = 'name' in node.callee && node.callee.name
    if (name !== 'defineNuxtPlugin' && name !== 'definePayloadPlugin') { return }

    if (name === 'definePayloadPlugin') {
      meta.order = internalOrderMap['user-revivers']
    }

    const metaArg = node.arguments[1]
    if (metaArg) {
      if (metaArg.type !== 'ObjectExpression') {
        throw new Error('Invalid plugin metadata')
      }
      meta = extractMetaFromObject(metaArg.properties)
    }

    const plugin = node.arguments[0]
    if (plugin?.type === 'ObjectExpression') {
      meta = defu(extractMetaFromObject(plugin.properties), meta)
    }

    meta.order ||= orderMap[meta.enforce || 'default'] || orderMap.default
    delete meta.enforce
  })
  metaCache[code] = meta
  return meta as Omit<PluginMeta, 'enforce'>
}

type PluginMetaKey = keyof PluginMeta
const keys: Record<PluginMetaKey, string> = {
  name: 'name',
  order: 'order',
  enforce: 'enforce',
  dependsOn: 'dependsOn',
}
function isMetadataKey (key: string | IdentifierName): key is PluginMetaKey {
  return typeof key !== 'string' ? key.name in keys : key in keys
}

function extractMetaFromObject (properties: Array<ObjectPropertyKind>) {
  const meta: PluginMeta = {}
  for (const property of properties) {
    if (property.type === 'SpreadElement' || !('name' in property.key)) {
      throw new Error('Invalid plugin metadata')
    }
    const propertyKey = property.key.name
    if (!isMetadataKey(propertyKey)) { continue }
    if (property.value.type === 'Literal') {
      meta[propertyKey] = property.value.value as any
    }
    if (property.value.type === 'UnaryExpression' && property.value.argument.type === 'Literal') {
      meta[propertyKey] = JSON.parse(property.value.operator + property.value.argument.raw!)
    }
    if (propertyKey === 'dependsOn' && property.value.type === 'ArrayExpression') {
      if (property.value.elements.some(e => !e || e.type !== 'Literal' || typeof e.value !== 'string')) {
        throw new Error('dependsOn must take an array of string literals')
      }
      meta[propertyKey] = property.value.elements.map(e => (e as Literal)!.value as NuxtAppLiterals['pluginName'])
    }
  }
  return meta
}

export const RemovePluginMetadataPlugin = (nuxt: Nuxt) => createUnplugin(() => {
  return {
    name: 'nuxt:remove-plugin-metadata',
    transform (code, id) {
      id = normalize(id)
      const plugin = nuxt.apps.default?.plugins.find(p => p.src === id)
      if (!plugin) { return }

      if (!code.trim()) {
        logger.warn(`Plugin \`${plugin.src}\` has no content.`)

        return {
          code: 'export default () => {}',
          map: null,
        }
      }

      const exports = findExports(code)
      const defaultExport = exports.find(e => e.type === 'default' || e.name === 'default')
      if (!defaultExport) {
        logger.warn(`Plugin \`${plugin.src}\` has no default export and will be ignored at build time. Add \`export default defineNuxtPlugin(() => {})\` to your plugin.`)
        return {
          code: 'export default () => {}',
          map: null,
        }
      }

      const s = new MagicString(code)
      let wrapped = false
      const wrapperNames = new Set(['defineNuxtPlugin', 'definePayloadPlugin'])

      try {
        parseAndWalk(code, id, (node) => {
          if (node.type === 'ImportSpecifier' && node.imported.type === 'Identifier' && (node.imported.name === 'defineNuxtPlugin' || node.imported.name === 'definePayloadPlugin')) {
            wrapperNames.add(node.local.name)
          }
          if (node.type !== 'CallExpression' || node.callee.type !== 'Identifier') { return }

          const name = 'name' in node.callee && node.callee.name
          if (!name || !wrapperNames.has(name)) { return }
          wrapped = true

          // Remove metadata that already has been extracted
          if (!('order' in plugin) && !('name' in plugin)) { return }
          for (const [argIndex, arg] of node.arguments.entries()) {
            if (arg.type !== 'ObjectExpression') { continue }

            for (const [propertyIndex, property] of arg.properties.entries()) {
              if (property.type === 'SpreadElement' || !('name' in property.key)) { continue }

              const propertyKey = property.key.name
              if (propertyKey === 'order' || propertyKey === 'enforce' || propertyKey === 'name') {
                const nextNode = arg.properties[propertyIndex + 1] || node.arguments[argIndex + 1]
                const nextIndex = nextNode?.start || (arg.end - 1)

                s.remove(property.start, nextIndex)
              }
            }
          }
        })
      } catch (e) {
        logger.error(e)
        return
      }

      if (!wrapped) {
        logger.warn(`Plugin \`${plugin.src}\` is not wrapped in \`defineNuxtPlugin\`. It is advised to wrap your plugins as in the future this may enable enhancements.`)
      }

      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: nuxt.options.sourcemap.client || nuxt.options.sourcemap.server ? s.generateMap({ hires: true }) : null,
        }
      }
    },
  }
})
</file>

<file path="packages/nuxt/src/core/plugins/prehydrate.ts">
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'
import { hash } from 'ohash'

import { parseAndWalk } from 'oxc-walker'
import { transformAndMinify } from '../../core/utils/parse.ts'
import { isJS, isVue } from '../utils/index.ts'

export function PrehydrateTransformPlugin (options: { sourcemap?: boolean } = {}) {
  return createUnplugin(() => ({
    name: 'nuxt:prehydrate-transform',
    transformInclude (id) {
      return isJS(id) || isVue(id, { type: ['script'] })
    },
    transform: {
      filter: {
        code: { include: /onPrehydrate\(/ },
      },
      handler (code, id) {
        const s = new MagicString(code)

        parseAndWalk(code, id, (node) => {
          if (node.type !== 'CallExpression' || node.callee.type !== 'Identifier') {
            return
          }
          if (node.callee.name === 'onPrehydrate') {
            const callback = node.arguments[0]
            if (!callback) { return }
            if (callback.type !== 'ArrowFunctionExpression' && callback.type !== 'FunctionExpression') { return }

            const needsAttr = callback.params.length > 0
            const { code: result } = transformAndMinify(`forEach(${code.slice(callback.start, callback.end)})`, { lang: 'ts' })
            const cleaned = result.slice('forEach'.length).replace(/;$/, '')
            const args = [JSON.stringify(cleaned)]
            if (needsAttr) {
              args.push(JSON.stringify(hash(result).slice(0, 10)))
            }
            s.overwrite(callback.start, callback.end, args.join(', '))
          }
        })

        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: options.sourcemap
              ? s.generateMap({ hires: true })
              : undefined,
          }
        }
      },
    },
  }))
}
</file>

<file path="packages/nuxt/src/core/plugins/tree-shake.ts">
import MagicString from 'magic-string'
import { createUnplugin } from 'unplugin'
import { ScopeTracker, parseAndWalk, walk } from 'oxc-walker'
import escapeStringRegexp from 'escape-string-regexp'

import { isJS, isVue } from '../utils/index.ts'

type ImportPath = string

interface TreeShakeComposablesPluginOptions {
  sourcemap?: boolean
  composables: Record<ImportPath, string[]>
}

export const TreeShakeComposablesPlugin = (options: TreeShakeComposablesPluginOptions) => createUnplugin(() => {
  // Create a fast lookup for all composable names
  const allComposableNames = new Set(Object.values(options.composables).flat())

  if (!allComposableNames.size) {
    return []
  }

  return {
    name: 'nuxt:tree-shake-composables:transform',
    enforce: 'post',
    transformInclude (id) {
      return isVue(id, { type: ['script'] }) || isJS(id)
    },
    transform: {
      filter: {
        code: { include: new RegExp(`\\b(?:${[...allComposableNames].map(r => escapeStringRegexp(r)).join('|')})\\b`) },
      },
      handler (code, id) {
        const s = new MagicString(code)

        // Parse and collect scope information
        const scopeTracker = new ScopeTracker({ preserveExitedScopes: true })
        const parseResult = parseAndWalk(code, id, {
          scopeTracker,
        })
        scopeTracker.freeze()

        // Process nodes and check for tree-shaking opportunities
        walk(parseResult.program, {
          scopeTracker,
          enter (node) {
            if (node.type !== 'CallExpression' || node.callee.type !== 'Identifier') {
              return
            }

            const functionName = node.callee.name
            const scopeTrackerNode = scopeTracker.getDeclaration(functionName)

            if (scopeTrackerNode) {
            // don't tree-shake if there's a local declaration
              if (scopeTrackerNode.type !== 'Import') {
                return
              }

              if (scopeTrackerNode.importNode.type !== 'ImportDeclaration') {
                return
              }

              // check if import is from an allowed source and composable
              const importPath = scopeTrackerNode.importNode.source.value

              const importSpecifier = scopeTrackerNode.node
              const importedName = importSpecifier.type === 'ImportSpecifier' && importSpecifier.imported.type === 'Identifier'
                ? importSpecifier.imported.name
                : importSpecifier.local.name

              const isFromAllowedPath = importPath === '#imports'
                ? allComposableNames.has(importedName)
                : options.composables[importPath]?.includes(importedName)

              if (!isFromAllowedPath) {
                return
              }
            }

            if (!scopeTrackerNode && !allComposableNames.has(functionName)) {
              return
            }

            // TODO: validate function name against actual auto-imports registry
            s.overwrite(node.start, node.end, ` false && /*@__PURE__*/ ${functionName}${code.slice(node.callee.end, node.end)}`)
            this.skip()
          },
        })

        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: options.sourcemap ? s.generateMap({ hires: true }) : undefined,
          }
        }
      },
    },
  }
})
</file>

<file path="packages/nuxt/src/core/plugins/unctx.ts">
import type { TransformerOptions } from 'unctx/transform'
import { createTransformer } from 'unctx/transform'
import { createUnplugin } from 'unplugin'

import { isJS, isVue } from '../utils/index.ts'

const TRANSFORM_MARKER = '/* _processed_nuxt_unctx_transform */\n'
const TRANSFORM_MARKER_RE = /^\/\* _processed_nuxt_unctx_transform \*\/\n/

interface UnctxTransformPluginOptions {
  sourcemap?: boolean
  transformerOptions: TransformerOptions
}

export const UnctxTransformPlugin = (options: UnctxTransformPluginOptions) => createUnplugin(() => {
  const transformer = createTransformer(options.transformerOptions)

  return {
    name: 'unctx:transform',
    enforce: 'post',
    transformInclude (id) {
      return isVue(id, { type: ['template', 'script'] }) || isJS(id)
    },
    transform: {
      filter: {
        ...transformer.filter,
        code: {
          ...transformer.filter.code,
          exclude: TRANSFORM_MARKER_RE,
        },
      },
      handler (code) {
        // TODO: needed for webpack - update transform in unctx/unplugin?
        if (!transformer.shouldTransform(code)) { return }
        const result = transformer.transform(code)
        if (result) {
          return {
            code: TRANSFORM_MARKER + result.code,
            map: options.sourcemap
              ? result.magicString.generateMap({ hires: true })
              : undefined,
          }
        }
      },
    },
  }
})
</file>

<file path="packages/nuxt/src/core/plugins/virtual.ts">
import process from 'node:process'
import { resolveAlias } from '@nuxt/kit'
import type { Nuxt } from '@nuxt/schema'
import { dirname, isAbsolute, resolve } from 'pathe'
import { createUnplugin } from 'unplugin'
import escapeStringRegexp from 'escape-string-regexp'

const PREFIX = 'virtual:nuxt:'
const PREFIX_RE = /^\/?virtual:nuxt:/

interface VirtualFSPluginOptions {
  mode: 'client' | 'server'
  alias?: Record<string, string>
}

const RELATIVE_ID_RE = /^\.{1,2}[\\/]/
export const VirtualFSPlugin = (nuxt: Nuxt, options: VirtualFSPluginOptions) => createUnplugin((_, meta) => {
  const extensions = ['', ...nuxt.options.extensions]
  const alias = { ...nuxt.options.alias, ...options.alias }

  const resolveWithExt = (id: string) => {
    for (const suffix of ['', '.' + options.mode]) {
      for (const ext of extensions) {
        const rId = id + suffix + ext
        if (rId in nuxt.vfs) {
          return rId
        }
      }
    }
  }

  function resolveId (id: string, importer?: string) {
    id = resolveAlias(id, alias)

    if (PREFIX_RE.test(id)) {
      id = withoutPrefix(decodeURIComponent(id))
    }

    const search = id.match(QUERY_RE)?.[0] || ''
    id = withoutQuery(id)

    if (process.platform === 'win32' && isAbsolute(id)) {
      // Add back C: prefix on Windows
      id = resolve(id)
    }

    const resolvedId = resolveWithExt(id)
    if (resolvedId) {
      return PREFIX + encodeURIComponent(resolvedId) + search
    }

    if (importer && RELATIVE_ID_RE.test(id)) {
      const path = resolve(dirname(withoutPrefix(decodeURIComponent(importer))), id)
      // resolve relative paths to virtual files
      const resolved = resolveWithExt(path)
      if (resolved) {
        return PREFIX + encodeURIComponent(resolved) + search
      }
    }
  }

  const relevantAliases = new Set<string>()
  for (const key in alias) {
    const value = alias[key]
    if (value && Object.keys(nuxt.vfs).some(vfsPath => vfsPath.startsWith(value))) {
      relevantAliases.add(escapeDirectory(key))
    }
  }

  const vfsEntries = new Set<string>()
  for (const key in nuxt.vfs) {
    if (!key.startsWith('#build/') && !key.startsWith(nuxt.options.buildDir)) {
      vfsEntries.add(escapeDirectory(dirname(key)))
    }
  }

  const filter = {
    id: [
      PREFIX_RE,
      RELATIVE_ID_RE,
      /^#build\//,
      new RegExp('^(\\w:)?' + escapeDirectory(nuxt.options.buildDir)),
      ...Array.from(vfsEntries).map(id => new RegExp('^' + id)),
      ...relevantAliases.size ? [new RegExp('^' + Array.from(relevantAliases).join('|') + '([\\\\/]|$)')] : [],
    ],
  }

  return {
    name: 'nuxt:virtual',

    resolveId: meta.framework === 'vite' ? undefined : { order: 'pre', filter, handler: resolveId },

    vite: {
      resolveId: {
        order: 'pre',
        filter,
        handler (id, importer) {
          const res = resolveId(id, importer)
          if (res) {
            return res
          }
          if (importer && PREFIX_RE.test(importer) && RELATIVE_ID_RE.test(id)) {
            return this.resolve?.(id, withoutPrefix(decodeURIComponent(importer)), { skipSelf: true })
          }
        },
      },
    },

    load: {
      filter: {
        id: PREFIX_RE,
      },
      handler (id) {
        const key = withoutQuery(withoutPrefix(decodeURIComponent(id)))
        return {
          code: nuxt.vfs[key] || '',
          map: null,
        }
      },
    },
  }
})

function withoutPrefix (id: string) {
  return id.replace(PREFIX_RE, '')
}

const QUERY_RE = /\?.*$/

function withoutQuery (id: string) {
  return id.replace(QUERY_RE, '')
}

function escapeDirectory (path: string) {
  return escapeStringRegexp(path).replace(/\//g, '[\\\\/]')
}
</file>

<file path="packages/nuxt/src/core/utils/index.ts">
export { getNameFromPath, hasSuffix, resolveComponentNameSegments } from './names.ts'
export { getLoader, isJS, isVue } from './plugins.ts'

export function uniqueBy<T, K extends keyof T> (arr: T[], key: K) {
  if (arr.length < 2) {
    return arr
  }
  const res: T[] = []
  const seen = new Set<T[K]>()
  for (const item of arr) {
    if (seen.has(item[key])) { continue }
    seen.add(item[key])
    res.push(item)
  }
  return res
}

export const QUOTE_RE = /["']/g
export const EXTENSION_RE = /\b\.\w+$/g
export const SX_RE = /\.[tj]sx$/
</file>

<file path="packages/nuxt/src/core/utils/names.ts">
import { basename, dirname, extname, normalize } from 'pathe'
import { kebabCase, splitByCase } from 'scule'
import { withTrailingSlash } from 'ufo'
import { QUOTE_RE } from './index.ts'

export function getNameFromPath (path: string, relativeTo?: string) {
  const relativePath = relativeTo
    ? normalize(path).replace(withTrailingSlash(normalize(relativeTo)), '')
    : basename(path)
  const prefixParts = splitByCase(dirname(relativePath))
  const fileName = basename(relativePath, extname(relativePath))
  const segments = resolveComponentNameSegments(fileName.toLowerCase() === 'index' ? '' : fileName, prefixParts).filter(Boolean)
  return kebabCase(segments).replace(QUOTE_RE, '')
}

export function hasSuffix (path: string, suffix: string) {
  return basename(path, extname(path)).endsWith(suffix)
}

export function resolveComponentNameSegments (fileName: string, prefixParts: string[]) {
  /**
   * Array of fileName parts split by case, / or -
   * @example third-component -> ['third', 'component']
   * @example AwesomeComponent -> ['Awesome', 'Component']
   */
  const fileNameParts = splitByCase(fileName)
  const fileNamePartsContent = fileNameParts.join('/').toLowerCase()
  const componentNameParts: string[] = prefixParts.flatMap(p => splitByCase(p))
  let index = prefixParts.length - 1
  const matchedSuffix: string[] = []
  while (index >= 0) {
    const prefixPart = prefixParts[index]!
    matchedSuffix.unshift(...splitByCase(prefixPart).map(p => p.toLowerCase()))
    const matchedSuffixContent = matchedSuffix.join('/')
    if ((fileNamePartsContent === matchedSuffixContent || fileNamePartsContent.startsWith(matchedSuffixContent + '/')) ||
      // e.g. Item/Item/Item.vue -> Item
      (prefixPart.toLowerCase() === fileNamePartsContent &&
        prefixParts[index + 1] &&
        prefixParts[index] === prefixParts[index + 1])) {
      componentNameParts.length = index
    }
    index--
  }
  return [...componentNameParts, ...fileNameParts]
}
</file>

<file path="packages/nuxt/src/core/utils/parse-utils.ts">
import type { CallExpression, ChainExpression, ExportDefaultDeclaration, ExportNamedDeclaration, IdentifierReference, MemberExpression, ParenthesizedExpression, TSExportAssignment } from 'oxc-parser'
import type { ParsedStaticImport } from 'mlly'
import { resolveAlias } from '@nuxt/kit'

import { stripExtension } from '../../utils.ts'

export function processImports (imports: ParsedStaticImport[]) {
  /**
   * import alias -> original name; source with aliases resolved and without extension
   */
  const directImports = new Map<string, {
    originalName: string
    /**
     * import source with aliases resolved and without extension
     */
    source: string
  }>()

  /**
   * import source with aliases resolved and without extension -> set of namespaces from that source
   */
  const namespaces = new Map<string, {
    namespaces: Set<string>
  }>()

  for (const i of imports) {
    const resolvedSpecifier = stripExtension(resolveAlias(i.specifier))

    // handle named imports
    const namedImports = i.namedImports ?? {}

    for (const originalIdentifier in namedImports) {
      const localIdentifier = namedImports[originalIdentifier] || originalIdentifier
      directImports.set(localIdentifier, {
        originalName: originalIdentifier,
        source: resolvedSpecifier,
      })
    }

    if (i.namespacedImport || i.defaultImport) {
      if (!namespaces.has(resolvedSpecifier)) {
        namespaces.set(resolvedSpecifier, {
          namespaces: new Set(),
        })
      }
    }

    if (i.defaultImport) {
      // handle default import
      const namespace = i.defaultImport
      const entry = namespaces.get(resolvedSpecifier)!
      entry.namespaces.add(namespace)
      directImports.set(i.defaultImport, {
        originalName: 'default',
        source: resolvedSpecifier,
      })
    } else if (i.namespacedImport) {
      // handle namespace import
      const namespace = i.namespacedImport
      const entry = namespaces.get(resolvedSpecifier)!
      entry.namespaces.add(namespace)
    }
  }

  return {
    directImports,
    namespaces,
  }
}

export interface FunctionCallMetadata {
  name: string
  /**
   * The name of the single-level namespace (object) the function belongs to,
   * or null if it's a top-level function.
   *
   * @example
   * foo()        //-> null
   * foo.bar()    //-> 'foo'
   * (foo.bar)()  //-> 'foo'
   * foo['bar']() //-> 'foo'
   */
  namespace: string | null
  /**
   * The callee node representing the function being called
   * or the property being accessed in case of a member expression.
   *
   * @example
   * foo()        //-> Identifier node for `foo`
   * foo.bar()    //-> Identifier node for `bar`
   * (foo.bar)()  //-> Parenthesized Expression node for `foo.bar`
   * foo['bar']() //-> Member Expression node for `foo['bar']`
   */
  node: IdentifierReference | MemberExpression | ParenthesizedExpression
  callExpression: CallExpression
}

/**
 * Checks if a node is a statically analyzable function call matching the given filter and returns parsed metadata about it.
 *
 * This is meant to statically identify functions and their origin in combination with scope tracking & imports analysis.
 * @param node The AST node to check.
 * @param filter A regular expression to match the function name.
 * @returns An object containing the metadata about the function call, or null if it doesn't match.
 */
export function parseStaticFunctionCall (node: CallExpression | ChainExpression, filter: RegExp): FunctionCallMetadata | null {
  // unwrap call expression
  const callExpression = node.type === 'CallExpression'
    ? node
    : node.type === 'ChainExpression' && node.expression.type === 'CallExpression'
      ? node.expression
      : null
  if (!callExpression) { return null }

  // Simple function calls

  let functionName: string | undefined
  let identifierNode: FunctionCallMetadata['node'] | undefined
  // foo()
  if (callExpression.callee.type === 'Identifier') {
    functionName = callExpression.callee.name
    identifierNode = callExpression.callee
  // (<identifier>)()
  } else if (callExpression.callee.type === 'ParenthesizedExpression') {
    // (foo)()
    if (callExpression.callee.expression.type === 'Identifier') {
      functionName = callExpression.callee.expression.name
      identifierNode = callExpression.callee
    // (foo as any)()
    // (<any>foo)()
    // (foo!)()
    } else if (
      (
        callExpression.callee.expression.type === 'TSAsExpression'
        || callExpression.callee.expression.type === 'TSTypeAssertion'
        || callExpression.callee.expression.type === 'TSNonNullExpression'
      )
      && callExpression.callee.expression.expression.type === 'Identifier'
    ) {
      functionName = callExpression.callee.expression.expression.name
      identifierNode = callExpression.callee
    }
  }

  if (functionName && identifierNode && filter.test(functionName)) {
    return {
      name: functionName,
      namespace: null,
      node: identifierNode,
      callExpression,
    }
  }

  function getParsedMemberExpression (memberExpression: MemberExpression): Omit<FunctionCallMetadata, 'callExpression'> | null {
    // <object name>
    let memberObjectName: string | undefined
    // foo.bar()
    if (memberExpression.object.type === 'Identifier') {
      memberObjectName = memberExpression.object.name
      // (foo).bar()
    } else if (memberExpression.object.type === 'ParenthesizedExpression') {
      if (memberExpression.object.expression.type === 'Identifier') {
        memberObjectName = memberExpression.object.expression.name
      // (foo as any).bar()
      // (<any>foo).bar()
      // (foo!).bar()
      } else if (
        (
          memberExpression.object.expression.type === 'TSAsExpression'
          || memberExpression.object.expression.type === 'TSTypeAssertion'
          || memberExpression.object.expression.type === 'TSNonNullExpression'
        )
        && memberExpression.object.expression.expression.type === 'Identifier'
      ) {
        memberObjectName = memberExpression.object.expression.expression.name
      }
    }

    // <property name>
    if (memberObjectName) {
      // foo.bar()
      if (memberExpression.property.type === 'Identifier' && filter.test(memberExpression.property.name)) {
        return {
          name: memberExpression.property.name,
          namespace: memberObjectName,
          node: memberExpression.property,
        }
      }

      // foo['bar']()
      if (memberExpression.property.type === 'Literal' && typeof memberExpression.property.value === 'string' && filter.test(memberExpression.property.value)) {
        return {
          name: memberExpression.property.value,
          namespace: memberObjectName,
          node: memberExpression,
        }
      }
    }

    return null
  }

  // TODO: handle optional chaining, type assertions, non-null assertions, etc.
  // Member Expressions
  // foo.bar()
  if (callExpression.callee.type === 'MemberExpression') {
    const val = getParsedMemberExpression(callExpression.callee)
    if (val) {
      return {
        ...val,
        callExpression,
      }
    }
  // (foo.bar)()
  } else if (callExpression.callee.type === 'ParenthesizedExpression' && callExpression.callee.expression.type === 'MemberExpression') {
    const val = getParsedMemberExpression(callExpression.callee.expression)
    if (val) {
      return {
        ...val,
        node: callExpression.callee,
        callExpression,
      }
    }
  }

  return null
}

export interface ExportMetadata {
  localName: string
  exportedName: string
}

/**
 * Parses static export declarations to extract local and exported identifiers.
 * Considers only runtime value exports (not types).
 *
 * Doesn't handle barrel exports, destructured exports, literals in export names, etc.
 *
 * @example
 * ```ts
 * export const foo = 1 // { localName: 'foo', exportedName: 'foo' }
 * export function bar() {} // { localName: 'bar', exportedName: 'bar' }
 * export class Baz {} // { localName: 'Baz', exportedName: 'Baz' }
 * export { foo } // { localName: 'foo', exportedName: 'foo' }
 * export { foo as bar } // { localName: 'foo', exportedName: 'bar' }
 * export default function foo() {} // { localName: 'foo', exportedName: 'default' }
 * export default class Bar {} // { localName: 'Bar', exportedName: 'default' }
 * ```
 * @param node the export declaration node to parse
 * @param filter optional regex to filter based on exported names
 */
export function parseStaticExportIdentifiers (node: ExportNamedDeclaration | ExportDefaultDeclaration | TSExportAssignment, filter?: RegExp): ExportMetadata[] {
  // NAMED EXPORT -------------------------
  if (node.type === 'ExportNamedDeclaration' && node.exportKind !== 'type') {
    // export const, let, var
    if (node.declaration?.type === 'VariableDeclaration') {
      return node.declaration.declarations.map((d) => {
        if (d.id.type === 'Identifier' && (!filter || filter.test(d.id.name))) {
          return {
            localName: d.id.name,
            exportedName: d.id.name,
          }
        }
        return null
      }).filter((v): v is ExportMetadata => !!v)
    }

    // export function
    if (node.declaration?.type === 'FunctionDeclaration') {
      if (node.declaration.id?.type === 'Identifier' && (!filter || filter.test(node.declaration.id.name))) {
        return [{
          localName: node.declaration.id.name,
          exportedName: node.declaration.id.name,
        }]
      }
      return []
    }

    // export class
    if (node.declaration?.type === 'ClassDeclaration') {
      if (node.declaration.id?.type === 'Identifier' && (!filter || filter.test(node.declaration.id.name))) {
        return [{
          localName: node.declaration.id.name,
          exportedName: node.declaration.id.name,
        }]
      }
      return []
    }

    // export { foo, bar as baz }
    if (node.specifiers && node.specifiers.length) {
      return node.specifiers.map((s) => {
        if (s.exported.type === 'Identifier' && s.exportKind !== 'type' && s.local.type === 'Identifier' && (!filter || filter.test(s.exported.name))) {
          return {
            localName: s.local.name,
            exportedName: s.exported.name,
          }
        }
        return null
      }).filter((v): v is ExportMetadata => !!v)
    }

    return []
  }

  // DEFAULT EXPORT -------------------------
  if (node.type === 'ExportDefaultDeclaration' && (!node.exportKind || node.exportKind === 'value')) {
    // export default <identifier>
    if (node.declaration.type === 'Identifier') {
      return [{
        localName: node.declaration.name,
        exportedName: 'default',
      }]
    }

    // export default function
    if (node.declaration.type === 'FunctionDeclaration') {
      if (node.declaration.id?.type === 'Identifier') {
        return [{
          localName: node.declaration.id.name,
          exportedName: 'default',
        }]
      }
      return []
    }

    // export default class
    if (node.declaration.type === 'ClassDeclaration') {
      if (node.declaration.id?.type === 'Identifier') {
        return [{
          localName: node.declaration.id.name,
          exportedName: 'default',
        }]
      }
      return []
    }
  }

  if (node.type === 'TSExportAssignment') {
    // export = <identifier>
    if (node.expression.type === 'Identifier') {
      if (!filter || filter.test(node.expression.name)) {
        return [{
          localName: node.expression.name,
          exportedName: 'default',
        }]
      }
    }
  }

  return []
}
</file>

<file path="packages/nuxt/src/core/utils/parse.ts">
import { tryUseNuxt } from '@nuxt/kit'
import type { TransformOptions, TransformResult } from 'oxc-transform'
import { transformSync } from 'oxc-transform'
import { minifySync } from 'oxc-minify'
import type { MinifyResult } from 'oxc-minify'

export function transformAndMinify (input: string, options?: TransformOptions): TransformResult | MinifyResult {
  const oxcOptions = tryUseNuxt()?.options.oxc
  const transformResult = transformSync('', input, { ...oxcOptions?.transform.options, ...options })
  const minifyResult = minifySync('', transformResult.code, { compress: { target: oxcOptions?.transform.options.target as 'esnext' || 'esnext' } })

  return {
    ...transformResult,
    ...minifyResult,
  }
}
</file>

<file path="packages/nuxt/src/core/utils/plugins.ts">
import { pathToFileURL } from 'node:url'
import { extname } from 'pathe'
import { parseQuery, parseURL } from 'ufo'

export function isVue (id: string, opts: { type?: Array<'template' | 'script' | 'style'> } = {}) {
  // Bare `.vue` file (in Vite)
  const { search } = parseURL(decodeURIComponent(pathToFileURL(id).href))
  if (id.endsWith('.vue') && !search) {
    return true
  }

  if (!search) {
    return false
  }

  const query = parseQuery(search)

  // Component async/lazy wrapper
  if (query.nuxt_component) {
    return false
  }

  // Macro
  if (query.macro && (search === '?macro=true' || !opts.type || opts.type.includes('script'))) {
    return true
  }

  // Non-Vue or Styles
  const type = 'setup' in query ? 'script' : query.type as 'script' | 'template' | 'style'
  if (!('vue' in query) || (opts.type && !opts.type.includes(type))) {
    return false
  }

  // Query `?vue&type=template` (in Webpack or external template)
  return true
}

const JS_RE = /\.(?:[cm]?j|t)sx?$/

export function isJS (id: string) {
  // JavaScript files
  const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href))
  return JS_RE.test(pathname)
}

export function getLoader (id: string): 'vue' | 'ts' | 'tsx' | null {
  const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href))
  const ext = extname(pathname)
  if (ext === '.vue') {
    return 'vue'
  }
  if (!JS_RE.test(ext)) {
    return null
  }
  return ext.endsWith('x') ? 'tsx' : 'ts'
}
</file>

<file path="packages/nuxt/src/core/utils/types.ts">
import { resolvePackageJSON } from 'pkg-types'
import { resolveModulePath } from 'exsolve'
import { dirname } from 'pathe'
import { directoryToURL, tryUseNuxt } from '@nuxt/kit'

export async function resolveTypePath (path: string, subpath: string, searchPaths = tryUseNuxt()?.options.modulesDir) {
  try {
    const r = resolveModulePath(path, {
      from: searchPaths?.map(d => directoryToURL(d)),
      conditions: ['types', 'import', 'require'],
      extensions: ['.js', '.mjs', '.cjs', '.ts', '.mts', '.cts'],
    })
    if (subpath) {
      return r.replace(/(?:\.d)?\.[mc]?[jt]s$/, '')
    }
    const rootPath = await resolvePackageJSON(r)
    return dirname(rootPath)
  } catch {
    return null
  }
}
</file>

<file path="packages/nuxt/src/core/app.ts">
import { promises as fsp, mkdirSync, writeFileSync } from 'node:fs'
import process from 'node:process'
import { performance } from 'node:perf_hooks'
import { dirname, join, relative, resolve } from 'pathe'
import { defu } from 'defu'
import { findPath, getLayerDirectories, normalizePlugin, normalizeTemplate, resolveFiles, resolvePath } from '@nuxt/kit'

import type { PluginMeta } from 'nuxt/app'

import { logger, resolveToAlias } from '../utils.ts'
import * as defaultTemplates from './templates.ts'
import { getNameFromPath, hasSuffix, uniqueBy } from './utils/index.ts'
import { extractMetadata, orderMap } from './plugins/plugin-metadata.ts'
import type { Nuxt, NuxtApp, NuxtPlugin, NuxtTemplate, ResolvedNuxtTemplate } from 'nuxt/schema'

export function createApp (nuxt: Nuxt, options: Partial<NuxtApp> = {}): NuxtApp {
  return defu(options, {
    dir: nuxt.options.srcDir,
    extensions: nuxt.options.extensions,
    plugins: [],
    components: [],
    templates: [],
  } as unknown as NuxtApp) as NuxtApp
}

const postTemplates = new Set([
  defaultTemplates.clientPluginTemplate.filename,
  defaultTemplates.serverPluginTemplate.filename,
  defaultTemplates.pluginsDeclaration.filename,
])

export async function generateApp (nuxt: Nuxt, app: NuxtApp, options: { filter?: (template: ResolvedNuxtTemplate<any>) => boolean } = {}) {
  // Resolve app
  await resolveApp(nuxt, app)

  // User templates from options.build.templates
  app.templates = Object.values(defaultTemplates).concat(nuxt.options.build.templates) as NuxtTemplate[]

  // Extend templates with hook
  await nuxt.callHook('app:templates', app)

  // Normalize templates
  app.templates = app.templates.map(tmpl => normalizeTemplate(tmpl, nuxt.options.buildDir))

  // compile plugins first as they are needed within the nuxt.vfs
  // in order to annotate templated plugins
  const filteredTemplates: Record<'pre' | 'post', Array<ResolvedNuxtTemplate<any>>> = {
    pre: [],
    post: [],
  }

  for (const template of app.templates as Array<ResolvedNuxtTemplate<any>>) {
    if (options.filter && !options.filter(template)) { continue }
    const key = template.filename && postTemplates.has(template.filename) ? 'post' : 'pre'
    filteredTemplates[key].push(template)
  }

  // Compile templates into vfs
  const templateContext = { nuxt, app }

  const writes: Array<() => void> = []
  const dirs = new Set<string>()
  const changedTemplates: Array<ResolvedNuxtTemplate<any>> = []
  const FORWARD_SLASH_RE = /\//g
  async function processTemplate (template: ResolvedNuxtTemplate) {
    const fullPath = template.dst || resolve(nuxt.options.buildDir, template.filename!)
    const start = performance.now()
    const oldContents = nuxt.vfs[fullPath]
    const contents = await compileTemplate(template, templateContext).catch((e) => {
      logger.error(`Could not compile template \`${template.filename}\`.`)
      logger.error(e)
      throw e
    })

    template.modified = oldContents !== contents
    if (template.modified) {
      nuxt.vfs[fullPath] = contents

      const aliasPath = '#build/' + template.filename
      nuxt.vfs[aliasPath] = contents

      // In case a non-normalized absolute path is called for on Windows
      if (process.platform === 'win32') {
        nuxt.vfs[fullPath.replace(FORWARD_SLASH_RE, '\\')] = contents
      }

      changedTemplates.push(template)
    }

    const perf = performance.now() - start
    const setupTime = Math.round((perf * 100)) / 100

    if ((nuxt.options.debug && nuxt.options.debug.templates) || setupTime > 500) {
      logger.info(`Compiled \`${template.filename}\` in ${setupTime}ms`)
    }

    if (template.modified && template.write) {
      dirs.add(dirname(fullPath))
      writes.push(() => writeFileSync(fullPath, contents, 'utf8'))
    }
  }

  await Promise.allSettled(filteredTemplates.pre.map(processTemplate))
  await Promise.allSettled(filteredTemplates.post.map(processTemplate))

  // Write template files in single synchronous step to avoid (possible) additional
  // runtime overhead of cascading HMRs from vite/webpack
  for (const dir of dirs) {
    mkdirSync(dir, { recursive: true })
  }
  for (const write of writes) {
    write()
  }

  if (changedTemplates.length) {
    await nuxt.callHook('app:templatesGenerated', app, changedTemplates, options)
  }
}

/** @internal */
async function compileTemplate<T> (template: NuxtTemplate<T>, ctx: { nuxt: Nuxt, app: NuxtApp, utils?: unknown }) {
  delete ctx.utils

  if (template.src) {
    try {
      return await fsp.readFile(template.src, 'utf-8')
    } catch (err) {
      logger.error(`[nuxt] Error reading template from \`${template.src}\``)
      throw err
    }
  }
  if (template.getContents) {
    return template.getContents({ ...ctx, options: template.options! })
  }

  throw new Error('[nuxt] Invalid template. Templates must have either `src` or `getContents`: ' + JSON.stringify(template))
}

export async function resolveApp (nuxt: Nuxt, app: NuxtApp) {
  // resolve layer
  const layerDirs = getLayerDirectories(nuxt)
  const reversedLayerDirs = [...layerDirs].reverse()

  // Resolve main (app.vue)
  app.mainComponent ||= await findPath(layerDirs.flatMap(d => [join(d.app, 'App'), join(d.app, 'app')]))
  app.mainComponent ||= resolve(nuxt.options.appDir, 'components/welcome.vue')

  // Resolve root component
  app.rootComponent ||= await findPath(['~/app.root', resolve(nuxt.options.appDir, 'components/nuxt-root.vue')])

  // Resolve error component
  app.errorComponent ||= await findPath(layerDirs.map(d => join(d.app, 'error'))) ?? resolve(nuxt.options.appDir, 'components/nuxt-error-page.vue')

  const extensionGlob = nuxt.options.extensions.join(',')

  // Resolve layouts/ from all config layers
  const layouts: NuxtApp['layouts'] = {}
  for (const dirs of layerDirs) {
    const layoutFiles = await resolveFiles(dirs.appLayouts, `**/*{${extensionGlob}}`)
    for (const file of layoutFiles) {
      const name = getNameFromPath(file, dirs.appLayouts)
      if (!name) {
        // Ignore files like `~/layouts/index.vue` which end up not having a name at all
        logger.warn(`No layout name could be resolved for \`${resolveToAlias(file, nuxt)}\`. Bear in mind that \`index\` is ignored for the purpose of creating a layout name.`)
        continue
      }
      layouts[name] ||= { name, file }
    }
  }

  // Resolve middleware/ from all config layers, layers first
  let middleware: NuxtApp['middleware'] = []
  for (const dirs of reversedLayerDirs) {
    const middlewareFiles = await resolveFiles(dirs.appMiddleware, [
      `*{${extensionGlob}}`,
      `*/index{${extensionGlob}}`,
    ])
    for (const file of middlewareFiles) {
      const name = getNameFromPath(file)
      if (!name) {
        // Ignore files like `~/middleware/index.vue` which end up not having a name at all
        logger.warn(`No middleware name could be resolved for \`${resolveToAlias(file, nuxt)}\`. Bear in mind that \`index\` is ignored for the purpose of creating a middleware name.`)
        continue
      }
      middleware.push({ name, path: file, global: hasSuffix(file, '.global') })
    }
  }

  const reversedLayers = nuxt.options._layers.slice().reverse()
  // Resolve plugins, first extended layers and then base
  let plugins: NuxtApp['plugins'] = []
  for (let i = 0; i < reversedLayerDirs.length; i++) {
    const config = reversedLayers[i]!.config
    const dirs = reversedLayerDirs[i]!
    plugins.push(...[
      ...(config.plugins || []),
      ...await resolveFiles(dirs.appPlugins, [
        `*{${extensionGlob}}`,
        `*/index{${extensionGlob}}`,
      ]),
    ].map(plugin => normalizePlugin(plugin as NuxtPlugin)))
  }

  // Add back plugins not specified in layers or user config
  for (const p of [...nuxt.options.plugins].reverse()) {
    const plugin = normalizePlugin(p)
    if (!plugins.some(p => p.src === plugin.src)) {
      plugins.unshift(plugin)
    }
  }

  // Normalize and de-duplicate plugins and middleware
  middleware = uniqueBy(await resolvePaths(nuxt, [...middleware].reverse(), 'path'), 'name').reverse()
  plugins = uniqueBy(await resolvePaths(nuxt, plugins, 'src'), 'src')

  // Resolve app.config
  const configs: NuxtApp['configs'] = []
  for (const dirs of layerDirs) {
    const appConfigPath = await findPath(join(dirs.app, 'app.config'))
    if (appConfigPath) {
      configs.push(appConfigPath)
    }
  }

  Object.assign(app, { middleware, plugins, configs, layouts })

  // Extend app
  await nuxt.callHook('app:resolve', app)

  // Normalize and de-duplicate plugins, middleware and app configs
  app.middleware = uniqueBy(await resolvePaths(nuxt, app.middleware, 'path'), 'name')
  app.plugins = uniqueBy(await resolvePaths(nuxt, app.plugins, 'src'), 'src')
  app.configs = [...new Set(app.configs)]
}

function resolvePaths<Item extends Record<string, any>> (nuxt: Nuxt, items: Item[], key: { [K in keyof Item]: Item[K] extends string ? K : never }[keyof Item]) {
  return Promise.all(items.map(async (item) => {
    if (!item[key]) { return item }
    return {
      ...item,
      [key]: await resolvePath(item[key], {
        alias: nuxt.options.alias,
        extensions: nuxt.options.extensions,
        fallbackToOriginal: true,
        virtual: true,
      }),
    }
  }))
}

const IS_TSX = /\.[jt]sx$/

export async function annotatePlugins (nuxt: Nuxt, plugins: NuxtPlugin[]) {
  const _plugins: Array<NuxtPlugin & Omit<PluginMeta, 'enforce'>> = []
  for (const plugin of plugins) {
    try {
      const code = plugin.src in nuxt.vfs ? nuxt.vfs[plugin.src]! : await fsp.readFile(plugin.src!, 'utf-8')
      _plugins.push({
        ...await extractMetadata(code, IS_TSX.test(plugin.src) ? 'tsx' : 'ts'),
        ...plugin,
      })
    } catch (e) {
      const relativePluginSrc = relative(nuxt.options.rootDir, plugin.src)
      if ((e as Error).message === 'Invalid plugin metadata') {
        logger.warn(`Failed to parse static properties from plugin \`${relativePluginSrc}\`, falling back to non-optimized runtime meta. Learn more: https://nuxt.com/docs/4.x/directory-structure/app/plugins#object-syntax-plugins`)
      } else {
        logger.warn(`Failed to parse static properties from plugin \`${relativePluginSrc}\`.`, e)
      }
      _plugins.push(plugin)
    }
  }

  return _plugins.sort((a, b) => (a.order ?? orderMap.default) - (b.order ?? orderMap.default))
}

export function checkForCircularDependencies (_plugins: Array<NuxtPlugin & Omit<PluginMeta, 'enforce'>>) {
  const deps: Record<string, string[]> = Object.create(null)
  const pluginNames = new Set(_plugins.map(plugin => plugin.name))
  for (const plugin of _plugins) {
    // Make sure dependency plugins are registered
    if (plugin.dependsOn && plugin.dependsOn.some(name => !pluginNames.has(name))) {
      console.error(`Plugin \`${plugin.name}\` depends on \`${plugin.dependsOn.filter(name => !pluginNames.has(name)).join(', ')}\` but they are not registered.`)
    }
    // Make graph to detect circular dependencies
    if (plugin.name) {
      deps[plugin.name] = plugin.dependsOn || []
    }
  }
  const checkDeps = (name: string, visited: string[] = []): string[] => {
    if (visited.includes(name)) {
      console.error(`Circular dependency detected in plugins: ${visited.join(' -> ')} -> ${name}`)
      return []
    }
    visited.push(name)
    return deps[name]?.length ? deps[name].flatMap(dep => checkDeps(dep, [...visited])) : []
  }
  for (const name in deps) {
    checkDeps(name)
  }
}
</file>

<file path="packages/nuxt/src/core/builder.ts">
import type { EventType } from '@parcel/watcher'
import type { FSWatcher } from 'chokidar'
import { watch as chokidarWatch } from 'chokidar'
import { createIsIgnored, directoryToURL, getLayerDirectories, importModule, isIgnored, useNuxt } from '@nuxt/kit'
import { debounce } from 'perfect-debounce'
import { dirname, join, normalize, relative, resolve } from 'pathe'

import { isDirectory, logger } from '../utils.ts'
import { generateApp as _generateApp, createApp } from './app.ts'
import { checkForExternalConfigurationFiles } from './external-config-files.ts'
import { cleanupCaches, getVueHash } from './cache.ts'
import type { Nuxt, NuxtBuilder } from 'nuxt/schema'

export async function build (nuxt: Nuxt): Promise<void> {
  const app = createApp(nuxt)
  nuxt.apps.default = app

  const generateApp = debounce(() => _generateApp(nuxt, app), undefined, { leading: true })
  await generateApp()

  if (nuxt.options.dev) {
    watch(nuxt)
    nuxt.hook('builder:watch', async (event, relativePath) => {
      // Unset mainComponent and errorComponent if app or error component is changed
      if (event === 'add' || event === 'unlink') {
        const path = resolve(nuxt.options.srcDir, relativePath)
        for (const dirs of getLayerDirectories(nuxt)) {
          const relativePath = relative(dirs.app, path)
          if (/^app\./i.test(relativePath)) {
            app.mainComponent = undefined
            break
          }
          if (/^error\./i.test(relativePath)) {
            app.errorComponent = undefined
            break
          }
        }
      }

      // Recompile app templates
      await generateApp()
    })
    nuxt.hook('builder:generateApp', (options) => {
      // Bypass debounce if we are selectively invalidating templates
      if (options) { return _generateApp(nuxt, app, options) }
      return generateApp()
    })
  }

  if (!nuxt.options._prepare && !nuxt.options.dev && nuxt.options.experimental.buildCache) {
    const { restoreCache, collectCache } = await getVueHash(nuxt)
    if (await restoreCache()) {
      await nuxt.callHook('build:done')
      return await nuxt.callHook('close', nuxt)
    }
    nuxt.hooks.hookOnce('nitro:build:before', () => collectCache())
    nuxt.hooks.hookOnce('close', () => cleanupCaches(nuxt))
  }

  await nuxt.callHook('build:before')
  if (nuxt.options._prepare) {
    nuxt.hook('prepare:types', () => nuxt.close())
    return
  }

  if (nuxt.options.dev && !nuxt.options.test) {
    nuxt.hooks.hookOnce('build:done', () => {
      checkForExternalConfigurationFiles()
        .catch(e => logger.warn('Problem checking for external configuration files.', e))
    })
  }

  await bundle(nuxt)

  await nuxt.callHook('build:done')

  if (!nuxt.options.dev) {
    await nuxt.callHook('close', nuxt)
  }
}

const watchEvents: Record<EventType, 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir'> = {
  create: 'add',
  delete: 'unlink',
  update: 'change',
}

async function watch (nuxt: Nuxt) {
  if (nuxt.options.experimental.watcher === 'parcel') {
    const success = await createParcelWatcher()
    if (success) { return }
  }

  if (nuxt.options.experimental.watcher === 'chokidar') {
    return createWatcher()
  }

  return createGranularWatcher()
}

function createWatcher () {
  const nuxt = useNuxt()
  const isIgnored = createIsIgnored(nuxt)

  const watcher = chokidarWatch(getLayerDirectories(nuxt).map(dirs => dirs.app), {
    ...nuxt.options.watchers.chokidar,
    ignoreInitial: true,
    ignored: [isIgnored, /[\\/]node_modules[\\/]/],
  })

  const restartPaths = new Set<string>()
  const srcDir = nuxt.options.srcDir.replace(/\/?$/, '/')
  for (const pattern of nuxt.options.watch) {
    if (typeof pattern !== 'string') { continue }
    const path = resolve(nuxt.options.srcDir, pattern)
    if (!path.startsWith(srcDir)) {
      restartPaths.add(path)
    }
  }

  watcher.add([...restartPaths])

  watcher.on('all', (event, path) => {
    if (event === 'all' || event === 'ready' || event === 'error' || event === 'raw') {
      return
    }
    nuxt.callHook('builder:watch', event, normalize(path))
  })
  nuxt.hook('close', () => watcher?.close())
}

function createGranularWatcher () {
  const nuxt = useNuxt()
  const isIgnored = createIsIgnored(nuxt)

  if (nuxt.options.debug && nuxt.options.debug.watchers) {
    // eslint-disable-next-line no-console
    console.time('[nuxt] builder:chokidar:watch')
  }

  let pending = 0

  const ignoredDirs = new Set([...nuxt.options.modulesDir, nuxt.options.buildDir])
  const pathsToWatch = resolvePathsToWatch(nuxt)
  for (const dir of pathsToWatch) {
    pending++
    const watcher = chokidarWatch(dir, { ...nuxt.options.watchers.chokidar, ignoreInitial: false, depth: 0, ignored: [isIgnored, /[\\/]node_modules[\\/]/] })
    const watchers: Record<string, FSWatcher> = {}

    watcher.on('all', (event, path) => {
      if (event === 'all' || event === 'ready' || event === 'error' || event === 'raw') {
        return
      }
      path = normalize(path)
      if (!pending) {
        nuxt.callHook('builder:watch', event, path)
      }
      if (event === 'unlinkDir' && path in watchers) {
        watchers[path]?.close()
        delete watchers[path]
      }
      if (event === 'addDir' && path !== dir && !ignoredDirs.has(path) && !pathsToWatch.has(path) && !(path in watchers) && !isIgnored(path)) {
        const pathWatcher = watchers[path] = chokidarWatch(path, { ...nuxt.options.watchers.chokidar, ignored: [isIgnored] })
        pathWatcher.on('all', (event, p) => {
          if (event === 'all' || event === 'ready' || event === 'error' || event === 'raw') {
            return
          }
          nuxt.callHook('builder:watch', event, normalize(p))
        })
        nuxt.hook('close', () => pathWatcher?.close())
      }
    })
    watcher.on('ready', () => {
      pending--
      if (nuxt.options.debug && nuxt.options.debug.watchers && !pending) {
        // eslint-disable-next-line no-console
        console.timeEnd('[nuxt] builder:chokidar:watch')
      }
    })
    nuxt.hook('close', () => watcher?.close())
  }
}

async function createParcelWatcher () {
  const nuxt = useNuxt()
  if (nuxt.options.debug && nuxt.options.debug.watchers) {
    // eslint-disable-next-line no-console
    console.time('[nuxt] builder:parcel:watch')
  }
  try {
    const { subscribe } = await importModule<typeof import('@parcel/watcher')>('@parcel/watcher', { url: [nuxt.options.rootDir, ...nuxt.options.modulesDir].map(d => directoryToURL(d)) })
    const pathsToWatch = resolvePathsToWatch(nuxt, { parentDirectories: true })
    for (const dir of pathsToWatch) {
      if (!await isDirectory(dir)) { continue }
      const watcher = subscribe(dir, (err, events) => {
        if (err) { return }
        for (const event of events) {
          if (isIgnored(event.path)) { continue }
          nuxt.callHook('builder:watch', watchEvents[event.type], normalize(event.path))
        }
      }, {
        ignore: [
          ...nuxt.options.ignore,
          'node_modules',
        ],
      })
      watcher.then((subscription) => {
        if (nuxt.options.debug && nuxt.options.debug.watchers) {
        // eslint-disable-next-line no-console
          console.timeEnd('[nuxt] builder:parcel:watch')
        }
        nuxt.hook('close', () => subscription.unsubscribe())
      })
    }
    return true
  } catch {
    logger.warn('Falling back to `chokidar-granular` as `@parcel/watcher` cannot be resolved in your project.')
    return false
  }
}

async function bundle (nuxt: Nuxt) {
  try {
    const { bundle } = typeof nuxt.options.builder === 'string'
      ? await loadBuilder(nuxt, nuxt.options.builder)
      : nuxt.options.builder

    await bundle(nuxt)
  } catch (error: any) {
    await nuxt.callHook('build:error', error)

    if (error.toString().includes('Cannot find module \'@nuxt/webpack-builder\'')) {
      throw new Error('Could not load `@nuxt/webpack-builder`. You may need to add it to your project dependencies, following the steps in `https://github.com/nuxt/framework/pull/2812`.')
    }

    throw error
  }
}

async function loadBuilder (nuxt: Nuxt, builder: string): Promise<NuxtBuilder> {
  try {
    return await importModule(builder, { url: [directoryToURL(nuxt.options.rootDir), new URL(import.meta.url)] })
  } catch (err) {
    throw new Error(`Loading \`${builder}\` builder failed. You can read more about the nuxt \`builder\` option at: \`https://nuxt.com/docs/4.x/api/nuxt-config#builder\``, { cause: err })
  }
}

function resolvePathsToWatch (nuxt: Nuxt, opts: { parentDirectories?: boolean } = {}): Set<string> {
  const pathsToWatch = new Set<string>()
  for (const dirs of getLayerDirectories(nuxt)) {
    if (!dirs.app || isIgnored(dirs.app)) { continue }

    pathsToWatch.add(dirs.app)
  }
  for (const pattern of nuxt.options.watch) {
    if (typeof pattern !== 'string') { continue }
    const path = opts?.parentDirectories
      ? join(dirname(resolve(nuxt.options.srcDir, pattern)), '')
      : resolve(nuxt.options.srcDir, pattern)
    let shouldAdd = true
    for (const w of [...pathsToWatch]) {
      if (w.startsWith(path)) {
        pathsToWatch.delete(w)
      }
      if (path.startsWith(w)) {
        shouldAdd = false
      }
    }
    if (shouldAdd) {
      pathsToWatch.add(path)
    }
  }
  return pathsToWatch
}
</file>

<file path="packages/nuxt/src/core/cache.ts">
import { mkdir, open, readFile, stat, unlink, writeFile } from 'node:fs/promises'
import type { FileHandle } from 'node:fs/promises'
import { resolve } from 'node:path'
import { existsSync } from 'node:fs'
import { createIsIgnored } from '@nuxt/kit'
import type { Nuxt, NuxtConfig, NuxtConfigLayer } from '@nuxt/schema'
import { hash, serialize } from 'ohash'
import { glob } from 'tinyglobby'
import { consola } from 'consola'
import { dirname, join, relative } from 'pathe'
import { createTar, parseTar } from 'nanotar'
import type { TarFileInput } from 'nanotar'

export async function getVueHash (nuxt: Nuxt) {
  const id = 'vue'

  const { hash } = await getHashes(nuxt, {
    id,
    cwd: layer => layer.config.srcDir || layer.cwd,
    patterns: (layer) => {
      const srcDir = layer.config.srcDir || layer.cwd
      return [
        '**',
        `!${relative(srcDir, layer.config.serverDir || join(layer.cwd, 'server'))}/**`,
        `!${relative(srcDir, resolve(layer.cwd, layer.config.dir?.public || 'public'))}/**`,
        '!node_modules/**',
        '!nuxt.config.*',
      ]
    },
    configOverrides: {
      buildId: undefined,
      serverDir: undefined,
      nitro: undefined,
      devServer: undefined,
      runtimeConfig: undefined,
      logLevel: undefined,
      devServerHandlers: undefined,
      devtools: undefined,
    },
  })

  const cacheFile = join(getCacheDir(nuxt), id, hash + '.tar')

  return {
    hash,
    async collectCache () {
      const start = Date.now()
      await writeCache(nuxt.options.buildDir, nuxt.options.buildDir, cacheFile)
      const elapsed = Date.now() - start
      consola.success(`Cached Vue client and server builds in \`${elapsed}ms\`.`)
    },
    async restoreCache () {
      const start = Date.now()
      const res = await restoreCache(nuxt.options.buildDir, cacheFile)
      const elapsed = Date.now() - start
      if (res) {
        consola.success(`Restored Vue client and server builds from cache in \`${elapsed}ms\`.`)
      }
      return res
    },
  }
}

export async function cleanupCaches (nuxt: Nuxt) {
  const start = Date.now()
  const caches = await glob(['*/*.tar'], {
    cwd: getCacheDir(nuxt),
    absolute: true,
  })
  if (caches.length >= 10) {
    const cachesWithMeta = await Promise.all(caches.map(async (cache) => {
      return [cache, await stat(cache).then(r => r.mtime.getTime()).catch(() => 0)] as const
    }))
    cachesWithMeta.sort((a, b) => a[1] - b[1])
    for (const [cache] of cachesWithMeta.slice(0, cachesWithMeta.length - 10)) {
      await unlink(cache)
    }
    const elapsed = Date.now() - start
    consola.success(`Cleaned up old build caches in \`${elapsed}ms\`.`)
  }
}

// internal

type HashSource = { name: string, data: any }
type Hashes = { hash: string, sources: HashSource[] }

interface GetHashOptions {
  id: string
  cwd: (layer: NuxtConfigLayer) => string
  patterns: (layer: NuxtConfigLayer) => string[]
  configOverrides: Partial<Record<keyof NuxtConfig, unknown>>
}

async function getHashes (nuxt: Nuxt, options: GetHashOptions): Promise<Hashes> {
  if ((nuxt as any)[`_${options.id}BuildHash`]) {
    return (nuxt as any)[`_${options.id}BuildHash`]
  }

  const start = Date.now()
  const hashSources: HashSource[] = []

  // Layers
  let layerCtr = 0
  for (const layer of nuxt.options._layers) {
    if (layer.cwd.includes('node_modules')) { continue }

    const layerName = `layer#${layerCtr++}`
    hashSources.push({
      name: `${layerName}:config`,
      data: serialize({
        ...layer.config,
        ...options.configOverrides || {},
      }),
    })

    const normalizeFiles = (files: Awaited<ReturnType<typeof readFilesRecursive>>) => files.map(f => ({
      name: f.name,
      size: f.attrs?.size,
      data: hash(f.data),
    })).sort((a, b) => a.name.localeCompare(b.name))

    const isIgnored = createIsIgnored(nuxt)
    const sourceFiles = await readFilesRecursive(options.cwd(layer), {
      shouldIgnore: isIgnored, // TODO: Validate if works with absolute paths
      cwd: nuxt.options.rootDir,
      patterns: options.patterns(layer),
    })

    hashSources.push({
      name: `${layerName}:src`,
      data: normalizeFiles(sourceFiles),
    })

    const rootFiles = await readFilesRecursive(layer.config?.rootDir || layer.cwd, {
      shouldIgnore: isIgnored, // TODO: Validate if works with absolute paths
      cwd: nuxt.options.rootDir,
      patterns: [
        '.nuxtrc',
        '.npmrc',
        'package.json',
        'package-lock.json',
        'yarn.lock',
        'pnpm-lock.yaml',
        'tsconfig.json',
        'bun.lock',
        'bun.lockb',
      ],
    })

    hashSources.push({
      name: `${layerName}:root`,
      data: normalizeFiles(rootFiles),
    })
  }

  hashSources.sort((a, b) => a.name.localeCompare(b.name))

  const res = ((nuxt as any)[`_${options.id}BuildHash`] = {
    hash: hash(hashSources),
    sources: hashSources,
  })

  const elapsed = Date.now() - start
  consola.debug(`Computed \`${options.id}\` build hash in \`${elapsed}ms\`.`)

  return res
}

type FileWithMeta = TarFileInput & {
  attrs: {
    mtime: number
    size: number
  }
}

interface ReadFilesRecursiveOptions {
  shouldIgnore?: (name: string) => boolean
  patterns: string[]
  cwd: string
}

async function readFilesRecursive (dir: string | string[], opts: ReadFilesRecursiveOptions): Promise<FileWithMeta[]> {
  if (Array.isArray(dir)) {
    return (await Promise.all(dir.map(d => readFilesRecursive(d, opts)))).flat()
  }

  const files = await glob(opts.patterns, { cwd: dir })

  const fileEntries = await Promise.all(files.map(async (fileName) => {
    if (!opts.shouldIgnore?.(fileName)) {
      const file = await readFileWithMeta(dir, fileName)
      if (!file) { return }
      return {
        ...file,
        name: relative(opts.cwd, join(dir, file.name)),
      }
    }
  }))

  return fileEntries.filter(Boolean) as FileWithMeta[]
}

async function readFileWithMeta (dir: string, fileName: string, count = 0): Promise<FileWithMeta | undefined> {
  let fd: FileHandle | undefined = undefined

  try {
    fd = await open(resolve(dir, fileName))
    const stats = await fd.stat()

    if (!stats?.isFile()) { return }

    const mtime = stats.mtime.getTime()
    const data = await fd.readFile()

    // retry if file has changed during read
    if ((await fd.stat()).mtime.getTime() !== mtime) {
      if (count < 5) {
        return readFileWithMeta(dir, fileName, count + 1)
      }
      console.warn(`Failed to read file \`${fileName}\` as it changed during read.`)
      return
    }

    return {
      name: fileName,
      data,
      attrs: {
        mtime,
        size: stats.size,
      },
    }
  } catch (err) {
    console.warn(`Failed to read file \`${fileName}\`:`, err)
  } finally {
    await fd?.close()
  }
}

async function restoreCache (cwd: string, cacheFile: string) {
  if (!existsSync(cacheFile)) {
    return false
  }

  const files = parseTar(await readFile(cacheFile))
  for (const file of files) {
    let fd: FileHandle | undefined = undefined
    try {
      const filePath = resolve(cwd, file.name)
      await mkdir(dirname(filePath), { recursive: true })

      fd = await open(filePath, 'w')

      const stats = await fd.stat().catch(() => null)
      if (stats?.isFile() && stats.size) {
        const lastModified = Number.parseInt(file.attrs?.mtime?.toString().padEnd(13, '0') || '0')
        if (stats.mtime.getTime() >= lastModified) {
          consola.debug(`Skipping \`${file.name}\` (up to date or newer than cache)`)
          continue
        }
      }
      await fd.writeFile(file.data!)
    } catch (err) {
      console.error(err)
    } finally {
      await fd?.close()
    }
  }
  return true
}

async function writeCache (cwd: string, sources: string | string[], cacheFile: string) {
  const fileEntries = await readFilesRecursive(sources, {
    patterns: ['**/*', '!analyze/**'],
    cwd,
  })
  const tarData = createTar(fileEntries)
  await mkdir(dirname(cacheFile), { recursive: true })
  await writeFile(cacheFile, tarData)
}

function getCacheDir (nuxt: Nuxt) {
  let cacheDir = join(nuxt.options.workspaceDir, 'node_modules')
  if (!existsSync(cacheDir)) {
    for (const dir of [...nuxt.options.modulesDir].sort((a, b) => a.length - b.length)) {
      if (existsSync(dir)) {
        cacheDir = dir
        break
      }
    }
  }
  return join(cacheDir, '.cache/nuxt/builds')
}
</file>

<file path="packages/nuxt/src/core/external-config-files.ts">
import { findPath } from '@nuxt/kit'
import { basename } from 'pathe'
import { logger } from '../utils.ts'

/**
 * Check for those external configuration files that are not compatible with Nuxt,
 * and warns the user about them.
 * @see {@link https://nuxt.com/docs/4.x/getting-started/configuration#external-configuration-files}
 */
export async function checkForExternalConfigurationFiles () {
  const checkResults = await Promise.all([checkViteConfig(), checkWebpackConfig(), checkNitroConfig(), checkPostCSSConfig()])
  const warningMessages = checkResults.filter(Boolean) as string[]

  if (!warningMessages.length) {
    return
  }

  const foundOneExternalConfig = warningMessages.length === 1
  if (foundOneExternalConfig) {
    logger.warn(warningMessages[0])
  } else {
    const warningsAsList = warningMessages.map(message => `- ${message}`).join('\n')
    const warning = `Found multiple external configuration files: \n\n${warningsAsList}`
    logger.warn(warning)
  }
}

async function checkViteConfig () {
  // https://github.com/vitejs/vite/blob/8fe69524d25d45290179175ba9b9956cbce87a91/packages/vite/src/node/constants.ts#L38
  return await checkAndWarnAboutConfigFileExistence({
    fileName: 'vite.config',
    extensions: ['.js', '.mjs', '.ts', '.cjs', '.mts', '.cts'],
    createWarningMessage: foundFile => `Using \`${foundFile}\` is not supported together with Nuxt. Use \`options.vite\` instead. You can read more in \`https://nuxt.com/docs/4.x/api/nuxt-config#vite\`.`,
  })
}

async function checkWebpackConfig () {
  // https://webpack.js.org/configuration/configuration-languages/
  return await checkAndWarnAboutConfigFileExistence({
    fileName: 'webpack.config',
    extensions: ['.js', '.mjs', '.ts', '.cjs', '.mts', '.cts', 'coffee'],
    createWarningMessage: foundFile => `Using \`${foundFile}\` is not supported together with Nuxt. Use \`options.webpack\` instead. You can read more in \`https://nuxt.com/docs/4.x/api/nuxt-config#webpack-1\`.`,
  })
}

async function checkNitroConfig () {
  // https://nitro.build/config
  return await checkAndWarnAboutConfigFileExistence({
    fileName: 'nitro.config',
    extensions: ['.ts', '.mts'],
    createWarningMessage: foundFile => `Using \`${foundFile}\` is not supported together with Nuxt. Use \`options.nitro\` instead. You can read more in \`https://nuxt.com/docs/4.x/api/nuxt-config#nitro\`.`,
  })
}

async function checkPostCSSConfig () {
  return await checkAndWarnAboutConfigFileExistence({
    fileName: 'postcss.config',
    extensions: ['.js', '.cjs'],
    createWarningMessage: foundFile => `Using \`${foundFile}\` is not supported together with Nuxt. Use \`options.postcss\` instead. You can read more in \`https://nuxt.com/docs/4.x/api/nuxt-config#postcss\`.`,
  })
}

interface CheckAndWarnAboutConfigFileExistenceOptions {
  fileName: string
  extensions: string[]
  createWarningMessage: (foundFile: string) => string
}

async function checkAndWarnAboutConfigFileExistence (options: CheckAndWarnAboutConfigFileExistenceOptions) {
  const { fileName, extensions, createWarningMessage } = options

  const configFile = await findPath(fileName, { extensions }).catch(() => null)
  if (configFile) {
    return createWarningMessage(basename(configFile))
  }
}
</file>

<file path="packages/nuxt/src/core/features.ts">
import { addDependency } from 'nypm'
import { resolvePackageJSON } from 'pkg-types'
import { useNuxt } from '@nuxt/kit'
import { isCI, provider } from 'std-env'
import { logger } from '../utils.ts'

const isStackblitz = provider === 'stackblitz'

interface EnsurePackageInstalledOptions {
  rootDir: string
  searchPaths?: string[]
  prompt?: boolean
}

async function promptToInstall (name: string, installCommand: () => Promise<unknown>, options: EnsurePackageInstalledOptions) {
  for (const parent of options.searchPaths || []) {
    if (await resolvePackageJSON(name, { parent }).catch(() => null)) {
      return true
    }
  }

  logger.info(`Package ${name} is missing`)
  if (isCI) {
    return false
  }

  // In StackBlitz we install packages automatically by default
  if (options.prompt === true || (options.prompt !== false && !isStackblitz)) {
    const confirm = await logger.prompt(`Do you want to install ${name} package?`, {
      type: 'confirm',
      name: 'confirm',
      initial: true,
    })

    if (!confirm) {
      return false
    }
  }

  logger.info(`Installing ${name}...`)
  try {
    await installCommand()
    logger.success(`Installed ${name}`)
    return true
  } catch (err) {
    logger.error(err)
    return false
  }
}

// TODO: refactor to @nuxt/cli
const installPrompts = new Set<string>()
export function installNuxtModule (name: string, options?: EnsurePackageInstalledOptions) {
  if (installPrompts.has(name)) { return }
  installPrompts.add(name)
  const nuxt = useNuxt()
  return promptToInstall(name, async () => {
    const { runCommand } = await import('@nuxt/cli')
    await runCommand('module', ['add', name, '--cwd', nuxt.options.rootDir])
  }, { rootDir: nuxt.options.rootDir, searchPaths: nuxt.options.modulesDir, ...options })
}

export function ensurePackageInstalled (name: string, options: EnsurePackageInstalledOptions) {
  return promptToInstall(name, () => addDependency(name, {
    cwd: options.rootDir,
    dev: true,
  }), options)
}
</file>

<file path="packages/nuxt/src/core/modules.ts">
import { normalizeModuleTranspilePath } from '@nuxt/kit'
import type { Nuxt } from '@nuxt/schema'
import escapeStringRegexp from 'escape-string-regexp'

export const addModuleTranspiles = (nuxt: Nuxt) => {
  // Try to sanitize modules to better match imports
  const transpile: RegExp[] = []
  for (const t of nuxt.options.build.transpile) {
    if (t instanceof Function) {
      continue
    }
    if (typeof t === 'string') {
      transpile.push(new RegExp(escapeStringRegexp(t)))
    } else {
      transpile.push(t)
    }
  }

  for (const m of [...nuxt.options.modules, ...nuxt.options._modules]) {
    const mod = typeof m === 'string' ? m : Array.isArray(m) ? m[0] : m.src
    if (typeof mod !== 'string') {
      continue
    }
    const path = normalizeModuleTranspilePath(mod)
    // Automatically add used modules to the transpile
    if (!transpile.some(t => t.test(path))) {
      nuxt.options.build.transpile.push(path)
    }
  }
}
</file>

<file path="packages/nuxt/src/core/nuxt.ts">
import process from 'node:process'
import { existsSync } from 'node:fs'
import { rm } from 'node:fs/promises'
import { randomUUID } from 'node:crypto'
import { AsyncLocalStorage } from 'node:async_hooks'
import { join, normalize, relative, resolve } from 'pathe'
import { createDebugger, createHooks } from 'hookable'
import ignore from 'ignore'
import type { LoadNuxtOptions } from '@nuxt/kit'
import { addBuildPlugin, addComponent, addPlugin, addPluginTemplate, addRouteMiddleware, addTypeTemplate, addVitePlugin, getLayerDirectories, installModules, loadNuxtConfig, nuxtCtx, resolveFiles, resolveIgnorePatterns, resolveModuleWithOptions, resolvePath, runWithNuxtContext, useNitro } from '@nuxt/kit'
import type { PackageJson } from 'pkg-types'
import { readPackageJSON } from 'pkg-types'
import { hash } from 'ohash'
import { consola } from 'consola'
import onChange from 'on-change'
import { colors } from 'consola/utils'
import { formatDate, resolveCompatibilityDatesFromEnv } from 'compatx'
import type { DateString } from 'compatx'
import escapeRE from 'escape-string-regexp'
import { withoutLeadingSlash } from 'ufo'
import { ImpoundPlugin } from 'impound'
import { defu } from 'defu'
import { coerce, satisfies } from 'semver'
import { hasTTY, isCI } from 'std-env'
import { genImport, genString } from 'knitwork'
import { resolveModulePath } from 'exsolve'
import type { Nuxt, NuxtHooks, NuxtModule, NuxtOptions } from 'nuxt/schema'
import type { Unimport } from 'unimport'

import { installNuxtModule } from '../core/features.ts'
import pagesModule from '../pages/module.ts'
import metaModule from '../head/module.ts'
import componentsModule from '../components/module.ts'
import importsModule from '../imports/module.ts'

import { distDir, pkgDir } from '../dirs.ts'
import pkg from '../../package.json' with { type: 'json' }
import { scriptsStubsPreset } from '../imports/presets.ts'
import { logger } from '../utils.ts'
import { resolveTypePath } from './utils/types.ts'
import { createImportProtectionPatterns } from './plugins/import-protection.ts'
import { UnctxTransformPlugin } from './plugins/unctx.ts'
import { TreeShakeComposablesPlugin } from './plugins/tree-shake.ts'
import { DevOnlyPlugin } from './plugins/dev-only.ts'
import { LayerAliasingPlugin } from './plugins/layer-aliasing.ts'
import { addModuleTranspiles } from './modules.ts'
import { bundleServer } from './server.ts'
import schemaModule from './schema.ts'
import { RemovePluginMetadataPlugin } from './plugins/plugin-metadata.ts'
import { AsyncContextInjectionPlugin } from './plugins/async-context.ts'
import { KeyedFunctionsPlugin } from './plugins/keyed-functions.ts'
import { PrehydrateTransformPlugin } from './plugins/prehydrate.ts'
import { ExtractAsyncDataHandlersPlugin } from './plugins/extract-async-data-handlers.ts'
import { VirtualFSPlugin } from './plugins/virtual.ts'

export function createNuxt (options: NuxtOptions): Nuxt {
  const hooks = createHooks<NuxtHooks>()

  const { callHook, callHookParallel, callHookWith } = hooks
  hooks.callHook = (...args) => runWithNuxtContext(nuxt, () => callHook(...args))
  hooks.callHookParallel = (...args) => runWithNuxtContext(nuxt, () => callHookParallel(...args))
  hooks.callHookWith = (...args) => runWithNuxtContext(nuxt, () => callHookWith(...args))

  const nuxt: Nuxt = {
    __name: randomUUID(),
    _version: pkg.version,
    _asyncLocalStorageModule: options.experimental.debugModuleMutation ? new AsyncLocalStorage() : undefined,
    hooks,
    callHook: hooks.callHook,
    addHooks: hooks.addHooks,
    hook: hooks.hook,
    ready: () => runWithNuxtContext(nuxt, () => initNuxt(nuxt)),
    close: () => hooks.callHook('close', nuxt),
    vfs: {},
    apps: {},
    runWithContext: fn => runWithNuxtContext(nuxt, fn),
    options,
  }

  if (options.experimental.debugModuleMutation) {
    const proxiedOptions = new WeakMap<NuxtModule, NuxtOptions>()

    Object.defineProperty(nuxt, 'options', {
      get () {
        const currentModule = nuxt._asyncLocalStorageModule!.getStore()
        if (!currentModule) {
          return options
        }

        if (proxiedOptions.has(currentModule)) {
          return proxiedOptions.get(currentModule)!
        }

        nuxt._debug ||= {}
        nuxt._debug.moduleMutationRecords ||= []

        const proxied = onChange(options, (keys, newValue, previousValue, applyData) => {
          if (newValue === previousValue && !applyData) {
            return
          }
          let value = applyData?.args ?? newValue
          // Make a shallow copy of the value
          if (Array.isArray(value)) {
            value = [...value]
          } else if (typeof value === 'object') {
            value = { ...(value as any) }
          }
          nuxt._debug!.moduleMutationRecords!.push({
            module: currentModule,
            keys,
            target: 'nuxt.options',
            value,
            timestamp: Date.now(),
            method: applyData?.name,
          })
        }, {
          ignoreUnderscores: true,
          ignoreSymbols: true,
          pathAsArray: true,
        })

        proxiedOptions.set(currentModule, proxied)
        return proxied
      },
    })
  }

  // TODO: remove in nuxt v5
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  if (!nuxtCtx.tryUse()) {
    // backward compatibility with 3.x
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    nuxtCtx.set(nuxt)
    nuxt.hook('close', () => {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      nuxtCtx.unset()
    })
  }

  hooks.hookOnce('close', () => { hooks.removeAllHooks() })

  return nuxt
}

const fallbackCompatibilityDate = '2025-07-15' as DateString

const nightlies = {
  'nitropack': 'nitropack-nightly',
  'nitro': 'nitro-nightly',
  'h3': 'h3-nightly',
  'nuxt': 'nuxt-nightly',
  '@nuxt/schema': '@nuxt/schema-nightly',
  '@nuxt/kit': '@nuxt/kit-nightly',
}

export const keyDependencies: string[] = [
  '@nuxt/kit',
]

let warnedAboutCompatDate = false

async function initNuxt (nuxt: Nuxt) {
  const layerDirs = getLayerDirectories(nuxt)

  // Register user hooks
  for (const config of nuxt.options._layers.map(layer => layer.config).reverse()) {
    if (config.hooks) {
      nuxt.hooks.addHooks(config.hooks)
    }
  }

  // Prompt to set compatibility date
  nuxt.options.compatibilityDate = resolveCompatibilityDatesFromEnv(nuxt.options.compatibilityDate)

  if (!nuxt.options.compatibilityDate.default) {
    nuxt.options.compatibilityDate.default = fallbackCompatibilityDate

    if (nuxt.options.dev && hasTTY && !isCI && !nuxt.options.test && !warnedAboutCompatDate) {
      warnedAboutCompatDate = true
      consola.warn(`We recommend adding \`compatibilityDate: '${formatDate('latest')}'\` to your \`nuxt.config\` file.\nUsing \`${fallbackCompatibilityDate}\` as fallback. More info at: ${colors.underline('https://nitro.build/deploy#compatibility-date')}`)
    }
  }

  // Restart Nuxt when layer directories are added or removed
  const layersDir = withTrailingSlash(resolve(nuxt.options.rootDir, 'layers'))
  nuxt.hook('builder:watch', (event, relativePath) => {
    const path = resolve(nuxt.options.srcDir, relativePath)
    if (event === 'addDir' || event === 'unlinkDir') {
      if (path.startsWith(layersDir)) {
        return nuxt.callHook('restart', { hard: true })
      }
    }
  })

  addTypeTemplate({
    filename: 'types/nitro-layouts.d.ts',
    getContents: ({ app }) => {
      return [
        `export type LayoutKey = ${Object.keys(app.layouts).map(name => genString(name)).join(' | ') || 'string'}`,
        'declare module \'nitropack\' {',
        '  interface NitroRouteConfig {',
        '    appLayout?: LayoutKey | false',
        '  }',
        '  interface NitroRouteRules {',
        '    appLayout?: LayoutKey | false',
        '  }',
        '}',
        'declare module \'nitropack/types\' {',
        '  interface NitroRouteConfig {',
        '    appLayout?: LayoutKey | false',
        '  }',
        '  interface NitroRouteRules {',
        '    appLayout?: LayoutKey | false',
        '  }',
        '}',
      ].join('\n')
    },
  }, { nuxt: true, nitro: true, node: true })

  // Disable environment types entirely if `typescript.builder` is false
  if (nuxt.options.typescript.builder !== false) {
    const envMap = {
      // defaults from `builder` based on package name
      '@nuxt/rspack-builder': '@rspack/core/module',
      '@nuxt/vite-builder': 'vite/client',
      '@nuxt/webpack-builder': 'webpack/module',
      // simpler overrides from `typescript.builder` for better DX
      'rspack': '@rspack/core/module',
      'vite': 'vite/client',
      'webpack': 'webpack/module',
      // default 'merged' builder environment for module authors
      'shared': '@nuxt/schema/builder-env',
    }

    const overrideEnv = nuxt.options.typescript.builder && envMap[nuxt.options.typescript.builder]
    // If there's no override, infer based on builder. If a custom builder is provided, we disable shared types
    const defaultEnv = typeof nuxt.options.builder === 'string' ? envMap[nuxt.options.builder] : false
    const environmentTypes = overrideEnv || defaultEnv

    if (environmentTypes) {
      nuxt.options.typescript.hoist.push(environmentTypes)
      addTypeTemplate({
        filename: 'types/builder-env.d.ts',
        getContents: () => genImport(environmentTypes),
      })
    }
  }

  const packageJSON = await readPackageJSON(nuxt.options.rootDir).catch(() => ({}) as PackageJson)
  nuxt._dependencies = new Set([...Object.keys(packageJSON.dependencies || {}), ...Object.keys(packageJSON.devDependencies || {})])

  // Set nitro resolutions for types that might be obscured with shamefully-hoist=false
  let paths: Record<string, [string]> | undefined
  nuxt.hook('nitro:config', async (nitroConfig) => {
    paths ||= await resolveTypescriptPaths(nuxt)
    nitroConfig.typescript = defu(nitroConfig.typescript, {
      tsConfig: { compilerOptions: { paths: { ...paths } } },
    })
  })

  const serverBuilderTypePath = typeof nuxt.options.server.builder === 'string'
    ? nuxt.options.server.builder === '@nuxt/nitro-server'
      ? resolveModulePath(nuxt.options.server.builder, { from: import.meta.url })
      : nuxt.options.server.builder
    : undefined

  // Add nuxt types
  nuxt.hook('prepare:types', async (opts) => {
    opts.references.push({ path: resolve(nuxt.options.buildDir, 'types/plugins.d.ts') })
    // Add vue shim
    if (nuxt.options.typescript.shim) {
      opts.references.push({ path: resolve(nuxt.options.buildDir, 'types/vue-shim.d.ts') })
    }

    // Add shims for `#build/*` imports that do not already have matching types
    opts.references.push({ path: resolve(nuxt.options.buildDir, 'types/build.d.ts') })
    opts.references.push({ path: resolve(nuxt.options.buildDir, 'types/app.config.d.ts') })
    opts.references.push({ path: resolve(nuxt.options.buildDir, 'types/runtime-config.d.ts') })
    opts.references.push({ types: 'nuxt/app' })

    // Add module augmentations directly to NuxtConfig
    opts.nodeReferences.push({ path: resolve(nuxt.options.buildDir, 'types/modules.d.ts') })
    opts.nodeReferences.push({ path: resolve(nuxt.options.buildDir, 'types/runtime-config.d.ts') })
    opts.nodeReferences.push({ path: resolve(nuxt.options.buildDir, 'types/app.config.d.ts') })
    opts.nodeReferences.push({ types: 'nuxt' })
    opts.nodeReferences.push({ types: relative(nuxt.options.buildDir, resolveModulePath('@nuxt/vite-builder', { from: import.meta.url })) })
    if (typeof nuxt.options.builder === 'string' && nuxt.options.builder !== '@nuxt/vite-builder') {
      opts.nodeReferences.push({ types: nuxt.options.builder })
    }

    if (serverBuilderTypePath) {
      opts.references.push({ types: serverBuilderTypePath })
      opts.nodeReferences.push({ types: serverBuilderTypePath })
    }

    opts.sharedReferences.push({ path: resolve(nuxt.options.buildDir, 'types/runtime-config.d.ts') })
    opts.sharedReferences.push({ path: resolve(nuxt.options.buildDir, 'types/app.config.d.ts') })
    opts.sharedReferences.push({ path: resolve(nuxt.options.buildDir, 'types/shared-imports.d.ts') })

    // Set Nuxt resolutions for types that might be obscured with shamefully-hoist=false
    paths ||= await resolveTypescriptPaths(nuxt)
    opts.tsConfig.compilerOptions = defu(opts.tsConfig.compilerOptions, { paths: { ...paths } })
    opts.nodeTsConfig.compilerOptions = defu(opts.nodeTsConfig.compilerOptions, { paths: { ...paths } })
    opts.sharedTsConfig.compilerOptions = defu(opts.sharedTsConfig.compilerOptions, { paths: { ...paths } })

    for (const dirs of layerDirs) {
      const declaration = join(dirs.root, 'index.d.ts')
      if (existsSync(declaration)) {
        opts.references.push({ path: declaration })
        opts.nodeReferences.push({ path: declaration })
        opts.sharedReferences.push({ path: declaration })
      }
    }
  })

  // Add nitro types
  nuxt.hook('nitro:prepare:types', (opts) => {
    opts.references.push({ path: resolve(nuxt.options.buildDir, 'types/app.config.d.ts') })
    opts.references.push({ path: resolve(nuxt.options.buildDir, 'types/runtime-config.d.ts') })

    if (serverBuilderTypePath) {
      opts.references.push({ types: serverBuilderTypePath })
    }
  })

  // Prompt to install `@nuxt/scripts` if user has configured it
  // @ts-expect-error scripts types are not present as the module is not installed
  if (nuxt.options.scripts) {
    if (!nuxt.options._modules.some(m => m === '@nuxt/scripts' || m === '@nuxt/scripts-nightly')) {
      installNuxtModule('@nuxt/scripts')
    }
  }

  // Support Nuxt VFS
  addBuildPlugin(VirtualFSPlugin(nuxt, { mode: 'server' }), { client: false })
  addBuildPlugin(VirtualFSPlugin(nuxt, {
    mode: 'client',
    alias: {
      '#internal/nitro': join(nuxt.options.buildDir, 'nitro.client.mjs'),
      'nitro/runtime': join(nuxt.options.buildDir, 'nitro.client.mjs'),
      'nitropack/runtime': join(nuxt.options.buildDir, 'nitro.client.mjs'),
    },
  }), { server: false })

  // Add plugin normalization plugin
  addBuildPlugin(RemovePluginMetadataPlugin(nuxt))

  // Add transform for `onPrehydrate` lifecycle hook
  addBuildPlugin(PrehydrateTransformPlugin({ sourcemap: !!nuxt.options.sourcemap.server || !!nuxt.options.sourcemap.client }))

  if (nuxt.options.experimental.localLayerAliases) {
    // Add layer aliasing support for ~, ~~, @ and @@ aliases
    addBuildPlugin(LayerAliasingPlugin({
      sourcemap: !!nuxt.options.sourcemap.server || !!nuxt.options.sourcemap.client,
      dev: nuxt.options.dev,
      root: nuxt.options.srcDir,
      // skip top-level layer (user's project) as the aliases will already be correctly resolved
      layers: nuxt.options._layers.slice(1),
    }))
  }

  nuxt.hook('modules:done', () => {
    // Add unctx transform
    addBuildPlugin(UnctxTransformPlugin({
      sourcemap: !!nuxt.options.sourcemap.server || !!nuxt.options.sourcemap.client,
      transformerOptions: {
        ...nuxt.options.optimization.asyncTransforms,
        helperModule: 'unctx',
      },
    }))

    // Add composable tree-shaking optimisations
    if (Object.keys(nuxt.options.optimization.treeShake.composables.server).length) {
      addBuildPlugin(TreeShakeComposablesPlugin({
        sourcemap: !!nuxt.options.sourcemap.server,
        composables: nuxt.options.optimization.treeShake.composables.server,
      }), { client: false })
    }
    if (Object.keys(nuxt.options.optimization.treeShake.composables.client).length) {
      addBuildPlugin(TreeShakeComposablesPlugin({
        sourcemap: !!nuxt.options.sourcemap.client,
        composables: nuxt.options.optimization.treeShake.composables.client,
      }), { server: false })
    }

    // shared folder import protection
    const sharedDir = withTrailingSlash(resolve(nuxt.options.rootDir, nuxt.options.dir.shared))
    const relativeSharedDir = withTrailingSlash(relative(nuxt.options.rootDir, resolve(nuxt.options.rootDir, nuxt.options.dir.shared)))
    const sharedPatterns = [/^#shared\//, new RegExp('^' + escapeRE(sharedDir)), new RegExp('^' + escapeRE(relativeSharedDir))]
    const sharedProtectionConfig = {
      cwd: nuxt.options.rootDir,
      include: sharedPatterns,
      patterns: createImportProtectionPatterns(nuxt, { context: 'shared' }),
    }
    addBuildPlugin({
      vite: () => ImpoundPlugin.vite(sharedProtectionConfig),
      webpack: () => ImpoundPlugin.webpack(sharedProtectionConfig),
      rspack: () => ImpoundPlugin.rspack(sharedProtectionConfig),
    }, { server: false })

    // Add import protection
    const nuxtProtectionConfig = {
      cwd: nuxt.options.rootDir,
      // Exclude top-level resolutions by plugins
      exclude: [relative(nuxt.options.rootDir, join(nuxt.options.srcDir, 'index.html')), ...sharedPatterns],
      patterns: createImportProtectionPatterns(nuxt, { context: 'nuxt-app' }),
    }
    addBuildPlugin({
      webpack: () => ImpoundPlugin.webpack(nuxtProtectionConfig),
      rspack: () => ImpoundPlugin.rspack(nuxtProtectionConfig),
    })
    // TODO: remove in nuxt v5 when we can use vite env api
    addVitePlugin(() => Object.assign(ImpoundPlugin.vite({ ...nuxtProtectionConfig, error: false }), { name: 'nuxt:import-protection' }), { client: false })
    addVitePlugin(() => Object.assign(ImpoundPlugin.vite({ ...nuxtProtectionConfig, error: true }), { name: 'nuxt:import-protection' }), { server: false })
  })

  if (!nuxt.options.dev) {
    // DevOnly component tree-shaking - build time only
    addBuildPlugin(DevOnlyPlugin({
      sourcemap: !!nuxt.options.sourcemap.server || !!nuxt.options.sourcemap.client,
    }))

    // Extract async data handlers into separate chunks for better performance
    if (nuxt.options.experimental.extractAsyncDataHandlers) {
      addBuildPlugin(ExtractAsyncDataHandlersPlugin({
        sourcemap: !!nuxt.options.sourcemap.client,
        rootDir: nuxt.options.rootDir,
      }), { server: false })
    }
  }

  if (nuxt.options.dev) {
    // Add plugin to check if layouts are defined without NuxtLayout being instantiated
    addPlugin(resolve(nuxt.options.appDir, 'plugins/check-if-layout-used'))

    // add plugin to make warnings less verbose in dev mode
    addPlugin(resolve(nuxt.options.appDir, 'plugins/warn.dev.server'))
  }

  // Transform initial composable call within `<script setup>` to preserve context
  if (nuxt.options.experimental.asyncContext) {
    addBuildPlugin(AsyncContextInjectionPlugin(nuxt), { client: false })
  }

  // TODO: [Experimental] Avoid emitting assets when flag is enabled
  if (nuxt.options.features.noScripts && !nuxt.options.dev) {
    nuxt.hook('build:manifest', async (manifest) => {
      for (const chunk of Object.values(manifest)) {
        if (chunk.resourceType === 'script') {
          await rm(resolve(nuxt.options.buildDir, 'dist/client', withoutLeadingSlash(nuxt.options.app.buildAssetsDir), chunk.file), { force: true })
          chunk.file = ''
        }
      }
    })
  }

  // Transpile #app if it is imported directly from subpath export
  nuxt.options.build.transpile.push('nuxt/app')

  // Transpile layers within node_modules
  for (const layer of layerDirs) {
    if (layer.root.includes('node_modules')) {
      nuxt.options.build.transpile.push(layer.root.replace(/\/$/, ''))
    }
  }

  // Ensure we can resolve dependencies within layers - filtering out local `~~/layers` directories
  const locallyScannedLayersDirs = layerDirs.map(l => join(l.root, 'layers/'))
  const rootWithTrailingSlash = withTrailingSlash(nuxt.options.rootDir)
  for (const dirs of layerDirs) {
    if (dirs.root === rootWithTrailingSlash) {
      continue
    }
    if (locallyScannedLayersDirs.every(dir => !dirs.root.startsWith(dir))) {
      nuxt.options.modulesDir.push(join(dirs.root, 'node_modules'))
    }
  }

  // Init user modules
  await nuxt.callHook('modules:before')

  const { paths: watchedModulePaths, resolvedModulePaths, modules } = await resolveModules(nuxt)

  nuxt.options.watch.push(...watchedModulePaths)

  // Add <NuxtWelcome>
  // TODO: revert when deep server component config is properly bundle-split: https://github.com/nuxt/nuxt/pull/29956
  const islandsConfig = nuxt.options.experimental.componentIslands
  if (nuxt.options.dev || !(typeof islandsConfig === 'object' && islandsConfig.selectiveClient === 'deep')) {
    addComponent({
      name: 'NuxtWelcome',
      priority: 10, // built-in that we do not expect the user to override
      filePath: resolve(nuxt.options.appDir, 'components/welcome'),
    })
  }

  addComponent({
    name: 'NuxtLayout',
    priority: 10, // built-in that we do not expect the user to override
    filePath: resolve(nuxt.options.appDir, 'components/nuxt-layout'),
  })

  // Add <NuxtErrorBoundary>
  addComponent({
    name: 'NuxtErrorBoundary',
    priority: 10, // built-in that we do not expect the user to override
    filePath: resolve(nuxt.options.appDir, 'components/nuxt-error-boundary'),
  })

  // Add <ClientOnly>
  addComponent({
    name: 'ClientOnly',
    priority: 10, // built-in that we do not expect the user to override
    filePath: resolve(nuxt.options.appDir, 'components/client-only'),
  })

  // Add <DevOnly>
  addComponent({
    name: 'DevOnly',
    priority: 10, // built-in that we do not expect the user to override
    filePath: resolve(nuxt.options.appDir, 'components/dev-only'),
  })

  // Add <ServerPlaceholder>
  addComponent({
    name: 'ServerPlaceholder',
    priority: 10, // built-in that we do not expect the user to override
    filePath: resolve(nuxt.options.appDir, 'components/server-placeholder'),
  })

  // Add <NuxtLink>
  addComponent({
    name: 'NuxtLink',
    priority: 10, // built-in that we do not expect the user to override
    filePath: resolve(nuxt.options.appDir, 'components/nuxt-link'),
  })

  // Add <NuxtLoadingIndicator>
  addComponent({
    name: 'NuxtLoadingIndicator',
    priority: 10, // built-in that we do not expect the user to override
    filePath: resolve(nuxt.options.appDir, 'components/nuxt-loading-indicator'),
  })

  // Add <NuxtTime>
  addComponent({
    name: 'NuxtTime',
    priority: 10, // built-in that we do not expect the user to override
    filePath: resolve(nuxt.options.appDir, 'components/nuxt-time.vue'),
  })

  // Add <NuxtRouteAnnouncer>
  addComponent({
    name: 'NuxtRouteAnnouncer',
    priority: 10, // built-in that we do not expect the user to override
    filePath: resolve(nuxt.options.appDir, 'components/nuxt-route-announcer'),
    mode: 'client',
  })

  // Add <NuxtClientFallback>
  if (nuxt.options.experimental.clientFallback) {
    addComponent({
      name: 'NuxtClientFallback',
      _raw: true,
      priority: 10, // built-in that we do not expect the user to override
      filePath: resolve(nuxt.options.appDir, 'components/client-fallback.client'),
      mode: 'client',
    })

    addComponent({
      name: 'NuxtClientFallback',
      _raw: true,
      priority: 10, // built-in that we do not expect the user to override
      filePath: resolve(nuxt.options.appDir, 'components/client-fallback.server'),
      mode: 'server',
    })
  }

  // Add stubs for <NuxtImg> and <NuxtPicture>
  for (const name of ['NuxtImg', 'NuxtPicture']) {
    addComponent({
      name,
      export: name,
      priority: -1,
      filePath: resolve(nuxt.options.appDir, 'components/nuxt-stubs'),
      // @ts-expect-error TODO: refactor to @nuxt/cli
      _internal_install: '@nuxt/image',
    })
  }

  // Track components used to render for webpack
  if (nuxt.options.builder === '@nuxt/webpack-builder' || nuxt.options.builder === '@nuxt/rspack-builder') {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/preload.server'))
  }

  // Add nuxt app hooks debugger
  if (
    nuxt.options.debug
    && nuxt.options.debug.hooks
    && (nuxt.options.debug.hooks === true || nuxt.options.debug.hooks.client)
  ) {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/debug-hooks'))
  }

  // Add experimental Chrome devtools timings support
  // https://developer.chrome.com/docs/devtools/performance/extension
  if (nuxt.options.experimental.browserDevtoolsTiming) {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/browser-devtools-timing.client'))
  }

  await installModules(modules, resolvedModulePaths, nuxt)

  // (Re)initialise ignore handler with resolved ignores from modules
  nuxt._ignore = ignore(nuxt.options.ignoreOptions)
  nuxt._ignore.add(resolveIgnorePatterns())

  // will be assigned after `modules:done`
  let unimport: Unimport | undefined
  nuxt.hook('imports:context', (ctx) => {
    unimport = ctx
  })

  await nuxt.callHook('modules:done')

  // Add keys for useFetch, useAsyncData, etc.
  const normalizedKeyedFunctions = await Promise.all(nuxt.options.optimization.keyedComposables.map(async ({ source, ...rest }) => ({
    ...rest,
    source: typeof source === 'string'
      ? await resolvePath(source, { fallbackToOriginal: true }) ?? source
      : source,
  })))

  addBuildPlugin(KeyedFunctionsPlugin({
    sourcemap: !!nuxt.options.sourcemap.server || !!nuxt.options.sourcemap.client,
    keyedFunctions: normalizedKeyedFunctions,
    alias: nuxt.options.alias,
    getAutoImports: unimport!.getImports,
  }))

  // remove duplicate css after modules are done
  nuxt.options.css = nuxt.options.css
    .filter((value, index, array) => !array.includes(value, index + 1))

  // Add <NuxtIsland>
  if (nuxt.options.experimental.componentIslands) {
    addComponent({
      name: 'NuxtIsland',
      priority: 10, // built-in that we do not expect the user to override
      filePath: resolve(nuxt.options.appDir, 'components/nuxt-island'),
    })
  }

  // Add experimental cross-origin prefetch support using Speculation Rules API
  if (nuxt.options.experimental.crossOriginPrefetch) {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/cross-origin-prefetch.client'))
  }

  // Add experimental page reload support
  if (nuxt.options.experimental.emitRouteChunkError === 'automatic') {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/chunk-reload.client'))
  }
  // Add experimental immediate page reload support
  if (nuxt.options.experimental.emitRouteChunkError === 'automatic-immediate') {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/chunk-reload-immediate.client'))
  }

  // Add experimental session restoration support
  if (nuxt.options.experimental.restoreState) {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/restore-state.client'))
  }

  // Add experimental automatic view transition api support
  if (nuxt.options.experimental.viewTransition) {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/view-transitions.client'))
  }

  // Add experimental support for custom types in JSON payload
  if (nuxt.options.experimental.renderJsonPayloads) {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/revive-payload.client'))
    addPlugin(resolve(nuxt.options.appDir, 'plugins/revive-payload.server'))
  }

  addRouteMiddleware({
    name: 'manifest-route-rule',
    path: resolve(nuxt.options.appDir, 'middleware/route-rules'),
    global: true,
  })

  if (nuxt.options.experimental.appManifest) {
    if (nuxt.options.experimental.checkOutdatedBuildInterval !== false) {
      addPlugin(resolve(nuxt.options.appDir, 'plugins/check-outdated-build.client'))
    }
  }

  if (nuxt.options.experimental.navigationRepaint) {
    addPlugin({
      src: resolve(nuxt.options.appDir, 'plugins/navigation-repaint.client'),
    })
  }

  if (nuxt.options.vue.config && Object.values(nuxt.options.vue.config).some(v => v !== null && v !== undefined)) {
    addPluginTemplate({
      filename: 'vue-app-config.mjs',
      getContents: () => `
import { defineNuxtPlugin } from '#app/nuxt'
export default defineNuxtPlugin({
  name: 'nuxt:vue-app-config',
  enforce: 'pre',
  setup (nuxtApp) {
    ${Object.keys(nuxt.options.vue.config!).map(k => `    nuxtApp.vueApp.config[${JSON.stringify(k)}] = ${JSON.stringify(nuxt.options.vue.config![k as 'idPrefix'])}`).join('\n')}
  }
})`,
    })
  }

  nuxt.hooks.hook('builder:watch', (event, relativePath) => {
    const path = resolve(nuxt.options.srcDir, relativePath)
    // Local module patterns
    if (watchedModulePaths.has(path)) {
      return nuxt.callHook('restart', { hard: true })
    }

    // User provided patterns
    const layerRelativePaths = new Set(getLayerDirectories(nuxt).map(l => relative(l.app, path)))
    for (const pattern of nuxt.options.watch) {
      if (typeof pattern === 'string') {
        // Test (normalized) strings against absolute path and relative path to any layer `srcDir`
        if (pattern === path || layerRelativePaths.has(pattern)) { return nuxt.callHook('restart') }
        continue
      }
      // Test regular expressions against path to _any_ layer `srcDir`
      for (const p of layerRelativePaths) {
        if (pattern.test(p)) {
          return nuxt.callHook('restart')
        }
      }
    }

    // Restart Nuxt when new `app/` dir is added
    if (event === 'addDir' && path === resolve(nuxt.options.srcDir, 'app')) {
      logger.info(`\`${path}/\` ${event === 'addDir' ? 'created' : 'removed'}`)
      return nuxt.callHook('restart', { hard: true })
    }

    // Core Nuxt files: app.vue, error.vue and app.config.ts
    const isFileChange = ['add', 'unlink'].includes(event)
    if (isFileChange && RESTART_RE.test(path)) {
      logger.info(`\`${path}\` ${event === 'add' ? 'created' : 'removed'}`)
      return nuxt.callHook('restart')
    }
  })

  nuxt.options.build.transpile = nuxt.options.build.transpile.map((t) => {
    if (typeof t !== 'string') {
      return t
    }
    // Normalize windows transpile paths added by modules
    return normalize(t).split('node_modules/').pop()!
  })

  addModuleTranspiles(nuxt)

  // Init nitro
  await bundleServer(nuxt)

  // TODO: remove when app manifest support is landed in https://github.com/nuxt/nuxt/pull/21641
  // Add prerender payload support
  const nitro = useNitro()
  if (nitro.options.static && nuxt.options.experimental.payloadExtraction === undefined) {
    logger.warn('Using experimental payload extraction for full-static output. You can opt-out by setting `experimental.payloadExtraction` to `false`.')
    nuxt.options.experimental.payloadExtraction = true
  }

  // Add prerender payload support
  if (nuxt.options.experimental.payloadExtraction) {
    addPlugin(resolve(nuxt.options.appDir, 'plugins/payload.client'))
  }

  // Show compatibility version banner when Nuxt is running with a compatibility version
  // that is different from the current major version
  if (!(satisfies(coerce(nuxt._version) ?? nuxt._version, nuxt.options.future.compatibilityVersion + '.x'))) {
    logger.info(`Running with compatibility version \`${nuxt.options.future.compatibilityVersion}\``)
  }

  await nuxt.callHook('ready', nuxt)
}

export async function loadNuxt (opts: LoadNuxtOptions): Promise<Nuxt> {
  const options = await loadNuxtConfig(opts)

  // Temporary until finding better placement for each
  options.appDir = options.alias['#app'] = withTrailingSlash(resolve(distDir, 'app'))
  options._majorVersion = 4

  // De-duplicate key arrays
  for (const key in options.app.head || {}) {
    options.app.head[key as 'link'] = deduplicateArray(options.app.head[key as 'link'])
  }

  // Nuxt DevTools only works for Vite
  if (options.builder === '@nuxt/vite-builder') {
    const isDevToolsEnabled = typeof options.devtools === 'boolean'
      ? options.devtools
      : options.devtools?.enabled !== false // enabled by default unless explicitly disabled

    if (isDevToolsEnabled) {
      if (!options._modules.some(m => m === '@nuxt/devtools' || m === '@nuxt/devtools-nightly' || m === '@nuxt/devtools-edge')) {
        options._modules.push('@nuxt/devtools')
      }
    }
  }

  if (!options._modules.some(m => m === '@nuxt/scripts' || m === '@nuxt/scripts-nightly')) {
    options.imports = defu(options.imports, {
      presets: [scriptsStubsPreset],
    })
  }

  // Nuxt Webpack Builder is currently opt-in
  if (options.builder === '@nuxt/webpack-builder') {
    if (!await import('./features.ts').then(r => r.ensurePackageInstalled('@nuxt/webpack-builder', {
      rootDir: options.rootDir,
      searchPaths: options.modulesDir,
    }))) {
      logger.warn('Failed to install `@nuxt/webpack-builder`, please install it manually, or change the `builder` option to vite in `nuxt.config`')
    }
  }

  // Add core modules
  options._modules.push(pagesModule, metaModule, componentsModule)
  const importIncludes: RegExp[] = []
  for (const layer of options._layers) {
    if (layer.cwd && layer.cwd.includes('node_modules')) {
      importIncludes.push(new RegExp(`(^|\\/)${escapeRE(layer.cwd.split('node_modules/').pop()!)}(\\/|$)(?!node_modules\\/)`))
    }
  }
  options._modules.push([importsModule, {
    transform: {
      include: importIncludes,
    },
  }])
  options._modules.push(schemaModule)
  options.modulesDir.push(resolve(options.workspaceDir, 'node_modules'))
  options.modulesDir.push(resolve(pkgDir, 'node_modules'))
  options.build.transpile.push(
    'mocked-exports',
    'std-env', // we need to statically replace process.env when used in runtime code
  )
  options.alias['vue-demi'] = resolve(options.appDir, 'compat/vue-demi')
  options.alias['@vue/composition-api'] = resolve(options.appDir, 'compat/capi')
  if (options.telemetry !== false && !process.env.NUXT_TELEMETRY_DISABLED) {
    options._modules.push('@nuxt/telemetry')
  }
  if (options.experimental.typescriptPlugin) {
    options._modules.push('@dxup/nuxt')
  }

  // warn if user is using reserved namespaces
  const allowedKeys = new Set(['baseURL', 'buildAssetsDir', 'cdnURL', 'buildId'])
  for (const key in options.runtimeConfig.app) {
    if (!allowedKeys.has(key)) {
      logger.warn(`The \`app\` namespace is reserved for Nuxt and is exposed to the browser. Please move \`runtimeConfig.app.${key}\` to a different namespace.`)
      delete options.runtimeConfig.app[key]
    }
  }

  // Ensure we share key config between Nuxt and Nitro
  createPortalProperties(options.nitro.runtimeConfig, options, ['nitro.runtimeConfig', 'runtimeConfig'])
  createPortalProperties(options.nitro.routeRules, options, ['nitro.routeRules', 'routeRules'])

  // prevent replacement of options.nitro
  const nitroOptions = options.nitro
  Object.defineProperties(options, {
    nitro: {
      configurable: false,
      enumerable: true,
      get: () => nitroOptions,
      set (value) {
        Object.assign(nitroOptions, value)
      },
    },
  })

  const nuxt = createNuxt(options)

  nuxt.runWithContext(() => {
    // We register hooks layer-by-layer so any overrides need to be registered separately
    if (opts.overrides?.hooks) {
      nuxt.hooks.addHooks(opts.overrides.hooks)
    }

    if (
      nuxt.options.debug
      && nuxt.options.debug.hooks
      && (nuxt.options.debug.hooks === true || nuxt.options.debug.hooks.server)
    ) {
      createDebugger(nuxt.hooks, { tag: 'nuxt' })
    }
  })

  if (opts.ready !== false) {
    await nuxt.ready()
  }

  return nuxt
}

const RESTART_RE = /^(?:app|error|app\.config)\.(?:js|ts|mjs|jsx|tsx|vue)$/i

function deduplicateArray<T = unknown> (maybeArray: T): T {
  if (!Array.isArray(maybeArray)) { return maybeArray }

  const fresh: any[] = []
  const hashes = new Set<string>()
  for (const item of maybeArray) {
    const _hash = hash(item)
    if (!hashes.has(_hash)) {
      hashes.add(_hash)
      fresh.push(item)
    }
  }
  return fresh as T
}

function createPortalProperties (sourceValue: any, options: NuxtOptions, paths: string[]) {
  let sharedValue = sourceValue

  for (const path of paths) {
    const segments = path.split('.')
    const key = segments.pop()!
    let parent: Record<string, any> = options

    while (segments.length) {
      const key = segments.shift()!
      parent = parent[key] ||= {}
    }

    delete parent[key]

    Object.defineProperties(parent, {
      [key]: {
        configurable: false,
        enumerable: true,
        get: () => sharedValue,
        set (value) {
          sharedValue = value
        },
      },
    })
  }
}

async function resolveModules (nuxt: Nuxt) {
  const modules = new Map<string | NuxtModule, Record<string, any>>()
  const paths = new Set<string>()
  const resolvedModulePaths = new Set<string>()

  // Loop layers in reverse order, so that the extends are loaded first and project is the last
  const configs = nuxt.options._layers.map(layer => layer.config).reverse()
  for (const config of configs) {
    // First register modules defined in layer's config
    const definedModules = config.modules ?? []
    for (const module of definedModules) {
      const resolvedModule = resolveModuleWithOptions(module, nuxt)
      if (resolvedModule && (!resolvedModule.resolvedPath || !resolvedModulePaths.has(resolvedModule.resolvedPath))) {
        modules.set(resolvedModule.module, resolvedModule.options)
        const path = resolvedModule.resolvedPath || resolvedModule.module
        if (typeof path === 'string') {
          resolvedModulePaths.add(path)
        }
      }
    }

    // Secondly automatically register modules from layer's module directory
    const modulesDir = resolve(config.srcDir, (config.rootDir === nuxt.options.rootDir ? nuxt.options.dir : config.dir)?.modules || 'modules')
    const layerModules = await resolveFiles(modulesDir, [
      `*{${nuxt.options.extensions.join(',')}}`,
      `*/index{${nuxt.options.extensions.join(',')}}`,
    ])

    for (const module of layerModules) {
      // add path to watch
      paths.add(module)

      if (!modules.has(module)) {
        modules.set(module, {})
      }
    }
  }

  // Lastly register private modules and modules added after loading config
  for (const key of ['modules', '_modules'] as const) {
    for (const module of nuxt.options[key as 'modules']) {
      const resolvedModule = resolveModuleWithOptions(module, nuxt)

      if (resolvedModule && !modules.has(resolvedModule.module) && (!resolvedModule.resolvedPath || !resolvedModulePaths.has(resolvedModule.resolvedPath))) {
        modules.set(resolvedModule.module, resolvedModule.options)
        const path = resolvedModule.resolvedPath || resolvedModule.module
        if (typeof path === 'string') {
          resolvedModulePaths.add(path)
        }
      }
    }
  }

  return {
    paths,
    resolvedModulePaths,
    modules,
  }
}

const NESTED_PKG_RE = /^[^@]+\//
async function resolveTypescriptPaths (nuxt: Nuxt): Promise<Record<string, [string]>> {
  nuxt.options.typescript.hoist ||= []
  const paths = Object.fromEntries(await Promise.all(nuxt.options.typescript.hoist.map(async (pkg) => {
    const [_pkg = pkg, _subpath] = NESTED_PKG_RE.test(pkg) ? pkg.split('/') : [pkg]
    const subpath = _subpath ? '/' + _subpath : ''

    // ignore packages that exist in `package.json` as these can be resolved by TypeScript
    if (nuxt._dependencies?.has(_pkg) && !(_pkg in nightlies)) { return [] }

    // deduplicate types for nightly releases
    if (_pkg in nightlies) {
      const nightly = nightlies[_pkg as keyof typeof nightlies]
      const path = await resolveTypePath(nightly + subpath, subpath, nuxt.options.modulesDir)
      if (path) {
        return [[pkg, [path]], [nightly + subpath, [path]]]
      }
    }

    const path = await resolveTypePath(_pkg + subpath, subpath, nuxt.options.modulesDir)
    if (path) {
      return [[pkg, [path]]]
    }

    return []
  })).then(r => r.flat()))

  return paths
}

function withTrailingSlash (dir: string) {
  return dir.replace(/[^/]$/, '$&/')
}
</file>

<file path="packages/nuxt/src/core/schema.ts">
import { existsSync } from 'node:fs'
import { mkdir, writeFile } from 'node:fs/promises'
import { fileURLToPath } from 'node:url'
import { join, relative, resolve } from 'pathe'
import { watch } from 'chokidar'
import { defu } from 'defu'
import { debounce } from 'perfect-debounce'
import { createIsIgnored, createResolver, defineNuxtModule, directoryToURL, getLayerDirectories, importModule } from '@nuxt/kit'
import { generateTypes, resolveSchema as resolveUntypedSchema } from 'untyped'
import type { Schema, SchemaDefinition } from 'untyped'
import untypedPlugin from 'untyped/babel-plugin'
import { createJiti } from 'jiti'
import { logger } from '../utils.ts'

export default defineNuxtModule({
  meta: {
    name: 'nuxt:nuxt-config-schema',
  },
  async setup (_, nuxt) {
    const resolver = createResolver(import.meta.url)

    // Initialize untyped/jiti loader
    const _resolveSchema = createJiti(fileURLToPath(import.meta.url), {
      cache: false,
      transformOptions: {
        babel: {
          plugins: [untypedPlugin],
        },
      },
    })

    // Register module types
    nuxt.hook('prepare:types', async (ctx) => {
      ctx.references.push({ path: 'schema/nuxt.schema.d.ts' })
      ctx.sharedReferences.push({ path: 'schema/nuxt.schema.d.ts' })
      ctx.nodeReferences.push({ path: 'schema/nuxt.schema.d.ts' })

      ctx.nodeTsConfig.include ||= []
      ctx.nodeTsConfig.include.push(
        relative(nuxt.options.buildDir, join(nuxt.options.rootDir, 'nuxt.schema.*')),
        relative(nuxt.options.buildDir, join(nuxt.options.rootDir, 'layers/*/nuxt.schema.*')),
      )

      if (nuxt.options._prepare) {
        await writeSchema(schema)
      }
    })

    // Resolve schema after all modules initialized
    let schema: Schema
    nuxt.hook('modules:done', async () => {
      schema = await resolveSchema()
    })

    // Write schema after build to allow further modifications
    nuxt.hooks.hook('build:done', () => writeSchema(schema))

    const layerDirs = getLayerDirectories(nuxt)

    // Watch for schema changes in development mode
    if (nuxt.options.dev) {
      const onChange = debounce(async () => {
        schema = await resolveSchema()
        await writeSchema(schema)
      })

      if (nuxt.options.experimental.watcher === 'parcel') {
        try {
          const { subscribe } = await importModule<typeof import('@parcel/watcher')>('@parcel/watcher', {
            url: [nuxt.options.rootDir, ...nuxt.options.modulesDir].map(dir => directoryToURL(dir)),
          })
          for (const dirs of layerDirs) {
            const subscription = await subscribe(dirs.root, onChange, {
              ignore: ['!nuxt.schema.*'],
            })
            nuxt.hook('close', () => subscription.unsubscribe())
          }
          return
        } catch {
          logger.warn('Falling back to `chokidar` as `@parcel/watcher` cannot be resolved in your project.')
        }
      }

      const isIgnored = createIsIgnored(nuxt)
      const rootDirs = layerDirs.map(layer => layer.root)
      const SCHEMA_RE = /(?:^|\/)nuxt.schema.\w+$/
      const watcher = watch(rootDirs, {
        ...nuxt.options.watchers.chokidar,
        depth: 1,
        ignored: [
          (path, stats) => (stats && !stats.isFile()) || !SCHEMA_RE.test(path),
          isIgnored,
          /[\\/]node_modules[\\/]/,
        ],
        ignoreInitial: true,
      })
      watcher.on('all', onChange)
      nuxt.hook('close', () => watcher.close())
    }

    // --- utils ---

    async function resolveSchema () {
      // Global import
      // @ts-expect-error adding to globalThis for 'auto-import' support within nuxt.config file
      globalThis.defineNuxtSchema = (val: any) => val

      // Load schema from layers
      const schemaDefs: SchemaDefinition[] = [nuxt.options.$schema]
      for (const dirs of layerDirs) {
        const filePath = await resolver.resolvePath(join(dirs.root, 'nuxt.schema'))
        if (filePath && existsSync(filePath)) {
          let loadedConfig: SchemaDefinition
          try {
            // TODO: fix type for second argument of `import`
            loadedConfig = await _resolveSchema.import(filePath, { default: true }) as SchemaDefinition
          } catch (err) {
            logger.warn(
              'Unable to load schema from',
              filePath,
              err,
            )
            continue
          }
          schemaDefs.push(loadedConfig)
        }
      }

      // Allow hooking to extend custom schemas
      await nuxt.hooks.callHook('schema:extend', schemaDefs)

      // Resolve and merge schemas
      const schemas = await Promise.all(
        schemaDefs.map(schemaDef => resolveUntypedSchema(schemaDef)),
      )

      // Merge after normalization
      const schema = defu(...schemas as [Schema, Schema])

      // Allow hooking to extend resolved schema
      await nuxt.hooks.callHook('schema:resolved', schema)

      return schema
    }

    async function writeSchema (schema: Schema) {
      await nuxt.hooks.callHook('schema:beforeWrite', schema)
      // Write it to build dir
      await mkdir(resolve(nuxt.options.buildDir, 'schema'), { recursive: true })
      await writeFile(
        resolve(nuxt.options.buildDir, 'schema/nuxt.schema.json'),
        JSON.stringify(schema, null, 2),
        'utf8',
      )
      const _types = generateTypes(schema, {
        addExport: true,
        interfaceName: 'NuxtCustomSchema',
        partial: true,
        allowExtraKeys: false,
      })
      const types =
        _types +
        `
export type CustomAppConfig = Exclude<NuxtCustomSchema['appConfig'], undefined>
type _CustomAppConfig = CustomAppConfig

declare module '@nuxt/schema' {
  interface NuxtConfig extends Omit<NuxtCustomSchema, 'appConfig'> {}
  interface NuxtOptions extends Omit<NuxtCustomSchema, 'appConfig'> {}
  interface CustomAppConfig extends _CustomAppConfig {}
}

declare module 'nuxt/schema' {
  interface NuxtConfig extends Omit<NuxtCustomSchema, 'appConfig'> {}
  interface NuxtOptions extends Omit<NuxtCustomSchema, 'appConfig'> {}
  interface CustomAppConfig extends _CustomAppConfig {}
}
`
      const typesPath = resolve(nuxt.options.buildDir, 'schema/nuxt.schema.d.ts')
      await writeFile(typesPath, types, 'utf8')
      await nuxt.hooks.callHook('schema:written')
    }
  },
})
</file>

<file path="packages/nuxt/src/core/server.ts">
import { directoryToURL, importModule } from '@nuxt/kit'

import type { Nuxt, NuxtBuilder } from 'nuxt/schema'

export async function bundleServer (nuxt: Nuxt) {
  try {
    const { bundle } = !nuxt.options.server.builder || typeof nuxt.options.server.builder === 'string'
      ? await loadServerBuilder(nuxt, nuxt.options.server.builder)
      : nuxt.options.server.builder

    await bundle(nuxt)
  } catch (error: any) {
    await nuxt.callHook('build:error', error)

    throw error
  }
}

async function loadServerBuilder (nuxt: Nuxt, builder = '@nuxt/nitro-server'): Promise<NuxtBuilder> {
  try {
    return await importModule(builder, { url: [directoryToURL(nuxt.options.rootDir), new URL(import.meta.url)] })
  } catch (err) {
    // TODO: docs
    throw new Error(`Loading \`${builder}\` server builder failed.`, { cause: err })
  }
}
</file>

<file path="packages/nuxt/src/core/templates.ts">
import { existsSync } from 'node:fs'
import { genArrayFromRaw, genDynamicImport, genExport, genImport, genObjectFromRawEntries, genSafeVariableName, genString } from 'knitwork'
import { join, relative, resolve } from 'pathe'
import type { JSValue } from 'untyped'
import { generateTypes, resolveSchema } from 'untyped'
import escapeRE from 'escape-string-regexp'
import { hash } from 'ohash'
import { camelCase } from 'scule'
import { filename, reverseResolveAlias } from 'pathe/utils'
import type { Nitro } from 'nitropack/types'
import { useNitro } from '@nuxt/kit'

import { annotatePlugins, checkForCircularDependencies } from './app.ts'
import { EXTENSION_RE } from './utils/index.ts'
import type { NuxtOptions, NuxtTemplate } from 'nuxt/schema'

export const vueShim: NuxtTemplate = {
  filename: 'types/vue-shim.d.ts',
  getContents: ({ nuxt }) => {
    if (!nuxt.options.typescript.shim) {
      return ''
    }

    return [
      'declare module \'*.vue\' {',
      '  import { DefineComponent } from \'vue\'',
      '  const component: DefineComponent<{}, {}, any>',
      '  export default component',
      '}',
    ].join('\n')
  },
}

// TODO: Use an alias
export const appComponentTemplate: NuxtTemplate = {
  filename: 'app-component.mjs',
  getContents: ctx => genExport(ctx.app.mainComponent!, ['default']),
}
// TODO: Use an alias
export const rootComponentTemplate: NuxtTemplate = {
  filename: 'root-component.mjs',
  // TODO: fix upstream in vite - this ensures that vite generates a module graph for islands
  // but should not be necessary (and has a warmup performance cost). See https://github.com/nuxt/nuxt/pull/24584.
  getContents: ctx => (ctx.nuxt.options.dev ? 'import \'#build/components.islands.mjs\';\n' : '') + genExport(ctx.app.rootComponent!, ['default']),
}
// TODO: Use an alias
export const errorComponentTemplate: NuxtTemplate = {
  filename: 'error-component.mjs',
  getContents: ctx => genExport(ctx.app.errorComponent!, ['default']),
}
// TODO: Use an alias
export const testComponentWrapperTemplate: NuxtTemplate = {
  filename: 'test-component-wrapper.mjs',
  getContents: ctx => genExport(resolve(ctx.nuxt.options.appDir, 'components/test-component-wrapper'), ['default']),
}

export const cssTemplate: NuxtTemplate = {
  filename: 'css.mjs',
  getContents: ctx => ctx.nuxt.options.css.map(i => genImport(i)).join('\n'),
}

const PLUGIN_TEMPLATE_RE = /_(?:45|46|47)/g
export const clientPluginTemplate: NuxtTemplate = {
  filename: 'plugins.client.mjs',
  async getContents (ctx) {
    const clientPlugins = await annotatePlugins(ctx.nuxt, ctx.app.plugins.filter(p => !p.mode || p.mode !== 'server'))
    checkForCircularDependencies(clientPlugins)
    const exports: string[] = []
    const imports: string[] = []
    for (const plugin of clientPlugins) {
      const path = relative(ctx.nuxt.options.rootDir, plugin.src)
      const variable = genSafeVariableName(filename(plugin.src) || path).replace(PLUGIN_TEMPLATE_RE, '_') + '_' + hash(path).replace(/-/g, '_')
      exports.push(variable)
      imports.push(genImport(plugin.src, variable))
    }
    return [
      ...imports,
      `export default ${genArrayFromRaw(exports)}`,
    ].join('\n')
  },
}

export const serverPluginTemplate: NuxtTemplate = {
  filename: 'plugins.server.mjs',
  async getContents (ctx) {
    const serverPlugins = await annotatePlugins(ctx.nuxt, ctx.app.plugins.filter(p => !p.mode || p.mode !== 'client'))
    checkForCircularDependencies(serverPlugins)
    const exports: string[] = []
    const imports: string[] = []
    for (const plugin of serverPlugins) {
      const path = relative(ctx.nuxt.options.rootDir, plugin.src)
      const variable = genSafeVariableName(filename(plugin.src) || path).replace(PLUGIN_TEMPLATE_RE, '_') + '_' + hash(path).replace(/-/g, '_')
      exports.push(variable)
      imports.push(genImport(plugin.src, variable))
    }
    return [
      ...imports,
      `export default ${genArrayFromRaw(exports)}`,
    ].join('\n')
  },
}

const TS_RE = /\.[cm]?tsx?$/
const JS_LETTER_RE = /\.(?<letter>[cm])?jsx?$/
const JS_RE = /\.[cm]jsx?$/
const JS_CAPTURE_RE = /\.[cm](jsx?)$/
export const pluginsDeclaration: NuxtTemplate = {
  filename: 'types/plugins.d.ts',
  getContents: async ({ nuxt, app }) => {
    const EXTENSION_RE = new RegExp(`(?<=\\w)(${nuxt.options.extensions.map(e => escapeRE(e)).join('|')})$`, 'g')

    const typesDir = join(nuxt.options.buildDir, 'types')
    const tsImports: string[] = []
    const pluginNames: string[] = []

    function exists (path: string) {
      return app.templates.some(t => t.write && path === t.dst) || existsSync(path)
    }

    for (const plugin of await annotatePlugins(nuxt, app.plugins)) {
      if (plugin.name) {
        pluginNames.push(`'${plugin.name}'`)
      }

      const pluginPath = resolve(typesDir, plugin.src)
      const relativePath = relative(typesDir, pluginPath)

      const correspondingDeclaration = pluginPath.replace(JS_LETTER_RE, '.d.$<letter>ts')
      // if `.d.ts` file exists alongside a `.js` plugin, or if `.d.mts` file exists alongside a `.mjs` plugin, we can use the entire path
      if (correspondingDeclaration !== pluginPath && exists(correspondingDeclaration)) {
        tsImports.push(relativePath)
        continue
      }

      const incorrectDeclaration = pluginPath.replace(JS_RE, '.d.ts')
      // if `.d.ts` file exists, but plugin is `.mjs`, add `.js` extension to the import
      // to hotfix issue until ecosystem updates to `@nuxt/module-builder@>=0.8.0`
      if (incorrectDeclaration !== pluginPath && exists(incorrectDeclaration)) {
        tsImports.push(relativePath.replace(JS_CAPTURE_RE, '.$1'))
        continue
      }

      // if there is no declaration we only want to remove the extension if it's a TypeScript file
      if (exists(pluginPath)) {
        if (TS_RE.test(pluginPath)) {
          tsImports.push(relativePath.replace(EXTENSION_RE, ''))
          continue
        }
        tsImports.push(relativePath)
      }

      // No declaration found that TypeScript can use
    }

    return `// Generated by Nuxt'
import type { Plugin } from '#app'

type Decorate<T extends Record<string, any>> = { [K in keyof T as K extends string ? \`$\${K}\` : never]: T[K] }

type InjectionType<A extends Plugin> = A extends {default: Plugin<infer T>} ? Decorate<T> : unknown

type NuxtAppInjections = \n  ${tsImports.map(p => `InjectionType<typeof ${genDynamicImport(p, { wrapper: false })}>`).join(' &\n  ')}

declare module '#app' {
  interface NuxtApp extends NuxtAppInjections { }

  interface NuxtAppLiterals {
    pluginName: ${pluginNames.join(' | ')}
  }
}

declare module 'vue' {
  interface ComponentCustomProperties extends NuxtAppInjections { }
}

export { }
`
  },
}

const IMPORT_NAME_RE = /\.\w+$/
const GIT_RE = /^git\+/
export const schemaTemplate: NuxtTemplate = {
  filename: 'types/runtime-config.d.ts',
  getContents: async ({ nuxt }) => {
    const privateRuntimeConfig = Object.create(null)
    for (const key in nuxt.options.runtimeConfig) {
      if (key !== 'public') {
        privateRuntimeConfig[key] = nuxt.options.runtimeConfig[key]
      }
    }

    return [
      `import { RuntimeConfig as UserRuntimeConfig, PublicRuntimeConfig as UserPublicRuntimeConfig } from 'nuxt/schema'`,
      generateTypes(await resolveSchema(privateRuntimeConfig as Record<string, JSValue>),
        {
          interfaceName: 'SharedRuntimeConfig',
          addExport: false,
          addDefaults: false,
          allowExtraKeys: false,
          indentation: 2,
        }),
      generateTypes(await resolveSchema(nuxt.options.runtimeConfig.public as Record<string, JSValue>),
        {
          interfaceName: 'SharedPublicRuntimeConfig',
          addExport: false,
          addDefaults: false,
          allowExtraKeys: false,
          indentation: 2,
        }),
      `declare module '@nuxt/schema' {`,
      `  interface RuntimeConfig extends UserRuntimeConfig {}`,
      `  interface PublicRuntimeConfig extends UserPublicRuntimeConfig {}`,
      `}`,
      `declare module 'nuxt/schema' {`,
      `  interface RuntimeConfig extends SharedRuntimeConfig {}`,
      `  interface PublicRuntimeConfig extends SharedPublicRuntimeConfig {}`,
      '}',
      `declare module 'vue' {
        interface ComponentCustomProperties {
          $config: UserRuntimeConfig
        }
      }`,
    ].join('\n')
  },
}
export const schemaNodeTemplate: NuxtTemplate = {
  filename: 'types/modules.d.ts',
  getContents: ({ nuxt }) => {
    const relativeRoot = relative(resolve(nuxt.options.buildDir, 'types'), nuxt.options.rootDir)
    const getImportName = (name: string) => (name[0] === '.' ? './' + join(relativeRoot, name) : name).replace(IMPORT_NAME_RE, '')

    const modules: [string, string, NuxtOptions['_installedModules'][number]][] = []
    for (const m of nuxt.options._installedModules) {
      // modules without sufficient metadata
      if (!m.meta || !m.meta.configKey || !m.meta.name) {
        continue
      }
      // core nuxt modules
      if (m.meta.name.startsWith('nuxt:') || m.meta.name === 'nuxt-config-schema') {
        continue
      }
      modules.push([genString(m.meta.configKey), getImportName(m.entryPath || m.meta.name), m])
    }

    const moduleOptionsInterface = (options: { addJSDocTags: boolean, unresolved: boolean }) => [
      ...modules.flatMap(([configKey, importName, mod]) => {
        let link: string | undefined

        // If it's not a local module, provide a link based on its name
        if (!mod.meta?.rawPath) {
          link = `https://www.npmjs.com/package/${importName}`
        }

        if (typeof mod.meta?.docs === 'string') {
          link = mod.meta.docs
        } else if (mod.meta?.repository) {
          if (typeof mod.meta.repository === 'string') {
            link = mod.meta.repository
          } else if (typeof mod.meta.repository === 'object' && 'url' in mod.meta.repository && typeof mod.meta.repository.url === 'string') {
            link = mod.meta.repository.url
          }
          if (link) {
            if (link.startsWith('git+')) {
              link = link.replace(GIT_RE, '')
            }
            if (!link.startsWith('http')) {
              link = 'https://github.com/' + link
            }
          }
        }

        return [
          `    /**`,
          `     * Configuration for \`${importName}\``,
          ...options.addJSDocTags && link ? [`     * @see ${link}`] : [],
          `     */`,
          `    [${configKey}]${options.unresolved ? '?' : ''}: typeof ${genDynamicImport(importName, { wrapper: false })}.default extends NuxtModule<infer O, unknown, boolean> ? ${options.unresolved ? 'Partial<O>' : 'O'} | false : Record<string, any> | false`,
        ]
      }),
      modules.length > 0 && options.unresolved ? `    modules?: (undefined | null | false | NuxtModule<any> | string | [NuxtModule | string, Record<string, any>] | ${modules.map(([configKey, importName, mod]) => `[${genString(mod.meta?.rawPath || importName)}, Exclude<NuxtConfig[${configKey}], boolean>]`).join(' | ')})[],` : '',
    ].filter(Boolean)

    const moduleDependencies = modules.flatMap(([_configKey, importName, mod]) => [
      `    [${genString(mod.meta.name || importName)}]?: ModuleDependencyMeta<typeof ${genDynamicImport(importName, { wrapper: false })}.default extends NuxtModule<infer O> ? O | false : Record<string, unknown>> | false`,
    ]).join('\n')

    return [
      'import { NuxtModule, ModuleDependencyMeta } from \'@nuxt/schema\'',
      'declare module \'@nuxt/schema\' {',
      '  interface ModuleDependencies {',
      moduleDependencies,
      '  }',
      '  interface NuxtOptions {',
      ...moduleOptionsInterface({ addJSDocTags: false, unresolved: false }),
      '  }',
      '  interface NuxtConfig {',
      // TypeScript will duplicate the jsdoc tags if we augment it twice
      // So here we only generate tags for `nuxt/schema`
      ...moduleOptionsInterface({ addJSDocTags: false, unresolved: true }),
      '  }',
      '}',
      'declare module \'nuxt/schema\' {',
      '  interface ModuleDependencies {',
      moduleDependencies,
      '  }',
      '  interface NuxtOptions {',
      ...moduleOptionsInterface({ addJSDocTags: true, unresolved: false }),
      '  }',
      '  interface NuxtConfig {',
      ...moduleOptionsInterface({ addJSDocTags: true, unresolved: true }),
      '  }',
      '}',
    ].join('\n')
  },
}

// Add layouts template
export const layoutTemplate: NuxtTemplate = {
  filename: 'layouts.mjs',
  getContents ({ app }) {
    const layoutsObject = genObjectFromRawEntries(Object.values(app.layouts).map(({ name, file }) => {
      return [name, `defineAsyncComponent(${genDynamicImport(file, { interopDefault: true })})`]
    }))
    return [
      `import { defineAsyncComponent } from 'vue'`,
      `export default ${layoutsObject}`,
    ].join('\n')
  },
}

// Add middleware template
export const middlewareTemplate: NuxtTemplate = {
  filename: 'middleware.mjs',
  getContents ({ app, nuxt }) {
    const globalMiddleware = app.middleware.filter(mw => mw.global)
    const namedMiddleware = app.middleware.filter(mw => !mw.global)
    const alias = nuxt.options.dev ? { ...nuxt?.options.alias || {}, ...strippedAtAliases } : {}
    return [
      ...globalMiddleware.map(mw => genImport(mw.path, genSafeVariableName(mw.name))),
      ...!nuxt.options.dev
        ? [
            `export const globalMiddleware = ${genArrayFromRaw(globalMiddleware.map(mw => genSafeVariableName(mw.name)))}`,
            `export const namedMiddleware = ${genObjectFromRawEntries(namedMiddleware.map(mw => [mw.name, genDynamicImport(mw.path)]))}`,
          ]
        : [
            `const _globalMiddleware = ${genObjectFromRawEntries(globalMiddleware.map(mw => [reverseResolveAlias(mw.path, alias).pop() || mw.path, genSafeVariableName(mw.name)]))}`,
            `for (const path in _globalMiddleware) {`,
            `  Object.defineProperty(_globalMiddleware[path], '_path', { value: path, configurable: true })`,
            `}`,
            `export const globalMiddleware = Object.values(_globalMiddleware)`,
            `const _namedMiddleware = ${genArrayFromRaw(namedMiddleware.map(mw => ({
              name: genString(mw.name),
              path: genString(reverseResolveAlias(mw.path, alias).pop() || mw.path),
              import: genDynamicImport(mw.path),
            })))}`,
            `for (const mw of _namedMiddleware) {`,
            `  const i = mw.import`,
            `  mw.import = () => i().then(r => {`,
            `    Object.defineProperty(r.default || r, '_path', { value: mw.path, configurable: true })`,
            `    return r`,
            `  })`,
            `}`,
            `export const namedMiddleware = Object.fromEntries(_namedMiddleware.map(mw => [mw.name, mw.import]))`,
          ],

    ].join('\n')
  },
}

export const clientConfigTemplate: NuxtTemplate = {
  filename: 'nitro.client.mjs',
  getContents: ({ nuxt }) => {
    const appId = JSON.stringify(nuxt.options.appId)
    return [
      'export const useRuntimeConfig = () => ',
      (!nuxt.options.future.multiApp
        ? 'window?.__NUXT__?.config || window?.useNuxtApp?.().payload?.config'
        : `window?.__NUXT__?.[${appId}]?.config || window?.useNuxtApp?.(${appId}).payload?.config`)
        || {},
    ].join('\n')
  },
}

export const appConfigDeclarationTemplate: NuxtTemplate = {
  filename: 'types/app.config.d.ts',
  getContents ({ app, nuxt }) {
    const typesDir = join(nuxt.options.buildDir, 'types')
    const configPaths = app.configs.map(path => relative(typesDir, path).replace(EXTENSION_RE, ''))

    return `
import type { AppConfigInput, CustomAppConfig } from 'nuxt/schema'
import type { Defu } from 'defu'
${configPaths.map((id: string, index: number) => `import ${`cfg${index}`} from ${JSON.stringify(id)}`).join('\n')}

declare global {
  const defineAppConfig: <C extends AppConfigInput> (config: C) => C
}

declare const inlineConfig = ${JSON.stringify(nuxt.options.appConfig, null, 2)}
type ResolvedAppConfig = Defu<typeof inlineConfig, [${app.configs.map((_id: string, index: number) => `typeof cfg${index}`).join(', ')}]>
type IsAny<T> = 0 extends 1 & T ? true : false

type MergedAppConfig<Resolved extends Record<string, unknown>, Custom extends Record<string, unknown>> = {
  [K in keyof (Resolved & Custom)]: K extends keyof Custom
    ? unknown extends Custom[K]
      ? Resolved[K]
      : IsAny<Custom[K]> extends true
        ? Resolved[K]
        : Custom[K] extends Record<string, any>
            ? Resolved[K] extends Record<string, any>
              ? MergedAppConfig<Resolved[K], Custom[K]>
              : Exclude<Custom[K], undefined>
            : Exclude<Custom[K], undefined>
    : Resolved[K]
}

declare module 'nuxt/schema' {
  interface AppConfig extends MergedAppConfig<ResolvedAppConfig, CustomAppConfig> { }
}
declare module '@nuxt/schema' {
  interface AppConfig extends MergedAppConfig<ResolvedAppConfig, CustomAppConfig> { }
}
`
  },
}

export const appConfigTemplate: NuxtTemplate = {
  filename: 'app.config.mjs',
  write: true,
  getContents ({ app, nuxt }) {
    return `
import { defuFn } from 'defu'

const inlineConfig = ${JSON.stringify(nuxt.options.appConfig, null, 2)}

/** client **/
import { _replaceAppConfig } from '#app/config'

// Vite - webpack is handled directly in #app/config
if (import.meta.dev && !import.meta.nitro && import.meta.hot) {
  import.meta.hot.accept((newModule) => {
    _replaceAppConfig(newModule.default)
  })
}
/** client-end **/

${app.configs.map((id: string, index: number) => `import ${`cfg${index}`} from ${JSON.stringify(id)}`).join('\n')}

export default /*@__PURE__*/ defuFn(${app.configs.map((_id: string, index: number) => `cfg${index}`).concat(['inlineConfig']).join(', ')})
`
  },
}

export const publicPathTemplate: NuxtTemplate = {
  filename: 'paths.mjs',
  getContents ({ nuxt }) {
    return [
      'import { joinRelativeURL } from \'ufo\'',
      !nuxt.options.dev && 'import { useRuntimeConfig } from \'nitropack/runtime\'',

      nuxt.options.dev
        ? `const getAppConfig = () => (${JSON.stringify(nuxt.options.app)})`
        : 'const getAppConfig = () => useRuntimeConfig().app',

      'export const baseURL = () => getAppConfig().baseURL',
      'export const buildAssetsDir = () => getAppConfig().buildAssetsDir',

      'export const buildAssetsURL = (...path) => joinRelativeURL(publicAssetsURL(), buildAssetsDir(), ...path)',

      'export const publicAssetsURL = (...path) => {',
      '  const appConfig = getAppConfig()',
      '  const publicBase = appConfig.cdnURL || appConfig.baseURL',
      '  return path.length ? joinRelativeURL(publicBase, ...path) : publicBase',
      '}',

      // On server these are registered directly in packages/nuxt/src/core/runtime/nitro/handlers/renderer.ts
      'if (import.meta.client) {',
      '  globalThis.__buildAssetsURL = buildAssetsURL',
      '  globalThis.__publicAssetsURL = publicAssetsURL',
      '}',
    ].filter(Boolean).join('\n')
  },
}

export const globalPolyfillsTemplate: NuxtTemplate = {
  filename: 'global-polyfills.mjs',
  getContents () {
    // Node.js compatibility
    return `
if (!("global" in globalThis)) {
  globalThis.global = globalThis;
}`
  },
}

export const dollarFetchTemplate: NuxtTemplate = {
  filename: 'fetch.mjs',
  getContents () {
    return [
      'import { $fetch } from \'ofetch\'',
      'import { baseURL } from \'#internal/nuxt/paths\'',
      'if (!globalThis.$fetch) {',
      '  globalThis.$fetch = $fetch.create({',
      '    baseURL: baseURL()',
      '  })',
      '}',
    ].join('\n')
  },
}

// Allow direct access to specific exposed nuxt.config
export const nuxtConfigTemplate: NuxtTemplate = {
  filename: 'nuxt.config.mjs',
  getContents: (ctx) => {
    const fetchDefaults = {
      ...ctx.nuxt.options.experimental.defaults.useFetch,
      baseURL: undefined,
      headers: undefined,
    }
    const shouldEnableComponentIslands = ctx.nuxt.options.experimental.componentIslands && (
      ctx.nuxt.options.dev || ctx.nuxt.options.experimental.componentIslands !== 'auto' || ctx.app.pages?.some(p => p.mode === 'server') || ctx.app.components?.some(c => c.mode === 'server' && !ctx.app.components.some(other => other.pascalName === c.pascalName && other.mode === 'client'))
    )
    const nitro = useNitro()
    const hasCachedRoutes = Object.values(nitro.options.routeRules).some(r => r.isr || r.cache)
    const payloadExtraction = !!ctx.nuxt.options.experimental.payloadExtraction && (nitro.options.static || hasCachedRoutes || nitro.options.prerender.routes.length > 0 || Object.values(nitro.options.routeRules).some(r => r.prerender))
    return [
      ...Object.entries(ctx.nuxt.options.app).map(([k, v]) => `export const ${camelCase('app-' + k)} = ${JSON.stringify(v)}`),
      `export const renderJsonPayloads = ${!!ctx.nuxt.options.experimental.renderJsonPayloads}`,
      `export const componentIslands = ${shouldEnableComponentIslands}`,
      `export const payloadExtraction = ${payloadExtraction}`,
      `export const cookieStore = ${!!ctx.nuxt.options.experimental.cookieStore}`,
      `export const appManifest = ${!!ctx.nuxt.options.experimental.appManifest}`,
      `export const remoteComponentIslands = ${typeof ctx.nuxt.options.experimental.componentIslands === 'object' && ctx.nuxt.options.experimental.componentIslands.remoteIsland}`,
      `export const selectiveClient = ${typeof ctx.nuxt.options.experimental.componentIslands === 'object' && Boolean(ctx.nuxt.options.experimental.componentIslands.selectiveClient)}`,
      `export const devPagesDir = ${ctx.nuxt.options.dev ? JSON.stringify(ctx.nuxt.options.dir.pages) : 'null'}`,
      `export const devRootDir = ${ctx.nuxt.options.dev ? JSON.stringify(ctx.nuxt.options.rootDir) : 'null'}`,
      `export const devLogs = ${JSON.stringify(ctx.nuxt.options.features.devLogs)}`,
      `export const nuxtLinkDefaults = ${JSON.stringify(ctx.nuxt.options.experimental.defaults.nuxtLink)}`,
      `export const asyncDataDefaults = ${JSON.stringify(ctx.nuxt.options.experimental.defaults.useAsyncData)}`,
      `export const fetchDefaults = ${JSON.stringify(fetchDefaults)}`,
      `export const vueAppRootContainer = ${ctx.nuxt.options.app.rootAttrs.id ? `'#${ctx.nuxt.options.app.rootAttrs.id}'` : `'body > ${ctx.nuxt.options.app.rootTag}'`}`,
      `export const viewTransition = ${ctx.nuxt.options.experimental.viewTransition}`,
      `export const appId = ${JSON.stringify(ctx.nuxt.options.appId)}`,
      `export const outdatedBuildInterval = ${ctx.nuxt.options.experimental.checkOutdatedBuildInterval}`,
      `export const multiApp = ${!!ctx.nuxt.options.future.multiApp}`,
      `export const chunkErrorEvent = ${ctx.nuxt.options.experimental.emitRouteChunkError ? ctx.nuxt.options.builder === '@nuxt/vite-builder' ? '"vite:preloadError"' : '"nuxt:preloadError"' : 'false'}`,
      `export const crawlLinks = ${!!((ctx.nuxt as any)._nitro as Nitro).options.prerender.crawlLinks}`,
      `export const spaLoadingTemplateOutside = ${ctx.nuxt.options.experimental.spaLoadingTemplateLocation === 'body'}`,
      `export const purgeCachedData = ${!!ctx.nuxt.options.experimental.purgeCachedData}`,
      `export const granularCachedData = ${!!ctx.nuxt.options.experimental.granularCachedData}`,
      `export const pendingWhenIdle = ${!!ctx.nuxt.options.experimental.pendingWhenIdle}`,
      `export const alwaysRunFetchOnKeyChange = ${!!ctx.nuxt.options.experimental.alwaysRunFetchOnKeyChange}`,
    ].join('\n\n')
  },
}

const TYPE_FILENAME_RE = /\.([cm])?[jt]s$/
const DECLARATION_RE = /\.d\.[cm]?ts$/
export const buildTypeTemplate: NuxtTemplate = {
  filename: 'types/build.d.ts',
  getContents ({ app }) {
    let declarations = ''

    for (const file of app.templates) {
      if (file.write || !file.filename || DECLARATION_RE.test(file.filename)) {
        continue
      }

      if (TYPE_FILENAME_RE.test(file.filename)) {
        const typeFilenames = new Set([file.filename.replace(TYPE_FILENAME_RE, '.d.$1ts'), file.filename.replace(TYPE_FILENAME_RE, '.d.ts')])
        if (app.templates.some(f => f.filename && typeFilenames.has(f.filename))) {
          continue
        }
      }

      declarations += 'declare module ' + JSON.stringify(join('#build', file.filename)) + ';\n'
    }

    return declarations
  },
}

const strippedAtAliases = {
  '@': '',
  '@@': '',
}
</file>

<file path="packages/nuxt/src/head/plugins/unhead-imports.ts">
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'
import type { Identifier, ImportSpecifier } from 'estree'
import { normalize, relative } from 'pathe'
import { unheadVueComposablesImports } from '@unhead/vue'
import { genImport } from 'knitwork'
import { parseAndWalk } from 'oxc-walker'
import { isJS, isVue } from '../../core/utils/index.ts'
import { distDir } from '../../dirs.ts'
import { logger } from '../../utils.ts'

interface UnheadImportsPluginOptions {
  sourcemap: boolean
  rootDir: string
}

const UNHEAD_LIB_RE = /node_modules[/\\](?:@unhead[/\\][^/\\]+|unhead)[/\\]/

function toImports (specifiers: ImportSpecifier[]) {
  return specifiers.map((specifier) => {
    const imported = specifier.imported as Identifier | null
    const isNamedImport = imported && imported.name !== specifier.local.name
    return isNamedImport ? `${imported.name} as ${specifier.local.name}` : specifier.local.name
  })
}

const UnheadVue = '@unhead/vue'
const UnheadVueRE = /@unhead\/vue/

/**
 * To use composable in an async context we need to pass Nuxt context to the Unhead composables.
 *
 * We swap imports from @unhead/vue to #app/composables/head and warn users for type safety.
 */
export const UnheadImportsPlugin = (options: UnheadImportsPluginOptions) => createUnplugin(() => {
  return {
    name: 'nuxt:head:unhead-imports',
    enforce: 'post',
    transformInclude (id) {
      id = normalize(id)
      return (
        (isJS(id) || isVue(id, { type: ['script'] })) &&
        !id.startsWith('virtual:') &&
        !id.startsWith(normalize(distDir)) &&
        !UNHEAD_LIB_RE.test(id)
      )
    },
    transform: {
      filter: {
        code: { include: UnheadVueRE },
      },
      handler (code, id) {
        const s = new MagicString(code)
        const importsToAdd: ImportSpecifier[] = []
        parseAndWalk(code, id, function (node) {
          if (node.type === 'ImportDeclaration' && [UnheadVue, '#app/composables/head'].includes(String(node.source.value))) {
            importsToAdd.push(...node.specifiers as ImportSpecifier[])
            const { start, end } = node
            s.remove(start, end)
          }
        })

        const importsFromUnhead = importsToAdd.filter(specifier => unheadVueComposablesImports[UnheadVue].includes((specifier.imported as Identifier)?.name))
        const importsFromHead = importsToAdd.filter(specifier => !unheadVueComposablesImports[UnheadVue].includes((specifier.imported as Identifier)?.name))
        if (importsFromUnhead.length) {
          // warn if user has imported from @unhead/vue themselves
          if (!normalize(id).includes('node_modules')) {
            logger.warn(`You are importing from \`${UnheadVue}\` in \`./${relative(normalize(options.rootDir), normalize(id))}\`. Please import from \`#imports\` instead for full type safety.`)
          }
          s.prepend(`${genImport('#app/composables/head', toImports(importsFromUnhead))}\n`)
        }
        if (importsFromHead.length) {
          s.prepend(`${genImport(UnheadVue, toImports(importsFromHead))}\n`)
        }

        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: options.sourcemap
              ? s.generateMap({ hires: true })
              : undefined,
          }
        }
      },
    },
  }
})
</file>

<file path="packages/nuxt/src/head/runtime/plugins/unhead.ts">
import { createHead as createClientHead, renderDOMHead } from '@unhead/vue/client'
import { defineNuxtPlugin } from '#app/nuxt'

// @ts-expect-error virtual file
import unheadOptions from '#build/unhead-options.mjs'

export default defineNuxtPlugin({
  name: 'nuxt:head',
  enforce: 'pre',
  setup (nuxtApp) {
    const head = import.meta.server
      ? nuxtApp.ssrContext!.head
      : createClientHead(unheadOptions)
    // nuxt.config appHead is set server-side within the renderer
    nuxtApp.vueApp.use(head)

    if (import.meta.client) {
      // pause dom updates until page is ready and between page transitions
      let pauseDOMUpdates = true
      const syncHead = async () => {
        pauseDOMUpdates = false
        await renderDOMHead(head)
      }
      head.hooks.hook('dom:beforeRender', (context) => { context.shouldRender = !pauseDOMUpdates })
      nuxtApp.hooks.hook('page:start', () => { pauseDOMUpdates = true })
      // wait for new page before unpausing dom updates (triggered after suspense resolved)
      nuxtApp.hooks.hook('page:finish', () => {
        // app:suspense:resolve hook will unpause the DOM
        if (!nuxtApp.isHydrating) { syncHead() }
      })
      // unpause on error
      nuxtApp.hooks.hook('app:error', syncHead)
      // unpause the DOM once the mount suspense is resolved
      nuxtApp.hooks.hook('app:suspense:resolve', syncHead)
    }
  },
})
</file>

<file path="packages/nuxt/src/head/runtime/components.ts">
import { defineComponent, getCurrentInstance, inject, onUnmounted, provide, reactive } from 'vue'
import type { PropType, VNodeNormalizedChildren } from 'vue'
import type {
  BodyAttributes,
  HtmlAttributes,
  Noscript,
  Base as UnheadBase,
  Link as UnheadLink,
  Meta as UnheadMeta,
  Style as UnheadStyle,
} from '@unhead/vue/types'
import type {
  CrossOrigin,
  FetchPriority,
  HTTPEquiv,
  LinkRelationship,
  ReferrerPolicy,
  Target,
} from './types'
import { useHead } from '#app/composables/head'

interface HeadComponents {
  base?: UnheadBase | null
  bodyAttrs?: BodyAttributes | null
  htmlAttrs?: HtmlAttributes | null
  link?: (UnheadLink | null)[]
  meta?: (UnheadMeta | null)[]
  noscript?: (Noscript | null)[]
  style?: (UnheadStyle | null)[]
  title?: string | null
}
type HeadComponentCtx = { input: HeadComponents, entry: ReturnType<typeof useHead>, update: () => void }
const HeadComponentCtxSymbol = Symbol('head-component')

const TagPositionProps = {
  /**
   * @deprecated Use tagPosition
   */
  body: { type: Boolean, default: undefined },
  tagPosition: { type: String as PropType<UnheadStyle['tagPosition']> },
}

function normalizeProps<T extends Record<string, any>> (_props: T, key?: string): Partial<T> {
  const props = Object.fromEntries(
    Object.entries(_props).filter(([_, value]) => value !== undefined),
  ) as Partial<T> & { tagPosition?: UnheadStyle['tagPosition'], tagPriority: UnheadStyle['tagPriority'] }
  if (typeof props.body !== 'undefined') {
    props.tagPosition = props.body ? 'bodyClose' : 'head'
  }
  if (typeof props.renderPriority !== 'undefined') {
    props.tagPriority = props.renderPriority
  }
  return {
    ...props,
    key,
  }
}

function useVNodeStringKey () {
  const vnodeKey = getCurrentInstance()?.vnode.key
  return vnodeKey != null && typeof vnodeKey !== 'symbol' ? String(vnodeKey) : undefined
}

function useHeadComponentCtx (): HeadComponentCtx {
  return inject<HeadComponentCtx>(HeadComponentCtxSymbol, createHeadComponentCtx, true)
}

function createHeadComponentCtx (): HeadComponentCtx {
  // avoid creating multiple contexts
  const prev = inject<HeadComponentCtx | null>(HeadComponentCtxSymbol, null)
  if (prev) {
    return prev
  }
  const input = reactive({})
  const entry = useHead(input)
  const ctx: HeadComponentCtx = { input, entry, update: () => entry.patch(input) }
  provide(HeadComponentCtxSymbol, ctx)
  return ctx
}

const globalProps = {
  accesskey: String,
  autocapitalize: String,
  autofocus: {
    type: Boolean,
    default: undefined,
  },
  class: { type: [String, Object, Array], default: undefined },
  contenteditable: {
    type: Boolean,
    default: undefined,
  },
  contextmenu: String,
  dir: String,
  draggable: {
    type: Boolean,
    default: undefined,
  },
  enterkeyhint: String,
  exportparts: String,
  hidden: {
    type: Boolean,
    default: undefined,
  },
  id: String,
  inputmode: String,
  is: String,
  itemid: String,
  itemprop: String,
  itemref: String,
  itemscope: String,
  itemtype: String,
  lang: String,
  nonce: String,
  part: String,
  slot: String,
  spellcheck: {
    type: Boolean,
    default: undefined,
  },
  style: { type: [String, Object, Array], default: undefined },
  tabindex: String,
  title: String,
  translate: String,
  /**
   * @deprecated Use tagPriority
   */
  renderPriority: [String, Number],
  /**
   * Unhead prop to modify the priority of the tag.
   */
  tagPriority: { type: [String, Number] as PropType<UnheadStyle['tagPriority']> },
}

// <noscript>
export const NoScript = defineComponent({
  name: 'NoScript',
  inheritAttrs: false,
  props: {
    ...globalProps,
    ...TagPositionProps,
    title: String,
  },
  setup (props, { slots }) {
    const { input, update } = useHeadComponentCtx()
    input.noscript ||= []
    const idx: keyof typeof input.noscript = input.noscript.push({}) - 1
    onUnmounted(() => {
      input.noscript![idx] = null
      update()
    })
    const key = useVNodeStringKey()
    return () => {
      const noscript = normalizeProps(props, key) as Noscript
      const slotVnodes = slots.default?.()
      const textContent: VNodeNormalizedChildren[] = []
      if (slotVnodes) {
        for (const vnode of slotVnodes) {
          if (vnode.children) {
            textContent.push(vnode.children)
          }
        }
      }
      if (textContent.length > 0) {
        noscript.innerHTML = textContent.join('')
      }
      input.noscript![idx] = noscript
      update()
      return null
    }
  },
})

// <link>
export const Link = defineComponent({
  name: 'Link',
  inheritAttrs: false,
  props: {
    ...globalProps,
    ...TagPositionProps,
    as: String,
    crossorigin: String as PropType<CrossOrigin>,
    disabled: Boolean,
    fetchpriority: String as PropType<FetchPriority>,
    href: String,
    hreflang: String,
    imagesizes: String,
    imagesrcset: String,
    integrity: String,
    media: String,
    prefetch: {
      type: Boolean,
      default: undefined,
    },
    referrerpolicy: String as PropType<ReferrerPolicy>,
    rel: String as PropType<LinkRelationship>,
    sizes: String,
    title: String,
    type: String,
    /** @deprecated **/
    methods: String,
    /** @deprecated **/
    target: String as PropType<Target>,
  },
  setup (props) {
    const { input, update } = useHeadComponentCtx()
    input.link ||= []
    const idx: keyof typeof input.link = input.link.push({}) - 1
    const key = useVNodeStringKey()

    onUnmounted(() => {
      input.link![idx] = null
      update()
    })

    return () => {
      input.link![idx] = normalizeProps(props, key) as UnheadLink
      update()
      return null
    }
  },
})

// <base>
export const Base = defineComponent({
  name: 'Base',
  inheritAttrs: false,
  props: {
    ...globalProps,
    href: String,
    target: String as PropType<Target>,
  },
  setup (props) {
    const { input, update } = useHeadComponentCtx()
    const key = useVNodeStringKey()
    onUnmounted(() => {
      input.base = null
      update()
    })
    return () => {
      input.base = normalizeProps(props, key) as UnheadBase
      update()
      return null
    }
  },
})

// <title>
export const Title = defineComponent({
  name: 'Title',
  inheritAttrs: false,
  setup (_, { slots }) {
    const { input, update } = useHeadComponentCtx()
    onUnmounted(() => {
      input.title = null
      update()
    })
    return () => {
      const defaultSlot = slots.default?.()
      input.title = defaultSlot?.[0]?.children ? String(defaultSlot?.[0]?.children) : undefined
      if (import.meta.dev) {
        if (defaultSlot && (defaultSlot.length > 1 || (defaultSlot[0] && typeof defaultSlot[0].children !== 'string'))) {
          console.error('<Title> can take only one string in its default slot.')
        }
      }
      update()
      return null
    }
  },
})

// <meta>
export const Meta = defineComponent({
  name: 'Meta',
  inheritAttrs: false,
  props: {
    ...globalProps,
    charset: String,
    content: String,
    httpEquiv: String as PropType<HTTPEquiv>,
    name: String,
    property: String,
  },
  setup (props) {
    const { input, update } = useHeadComponentCtx()
    const key = useVNodeStringKey()
    input.meta ||= []
    const idx: keyof typeof input.meta = input.meta.push({}) - 1
    onUnmounted(() => {
      input.meta![idx] = null
      update()
    })
    return () => {
      const meta = { 'http-equiv': props.httpEquiv, ...normalizeProps(props, key) } as UnheadMeta
      // fix casing for http-equiv
      if ('httpEquiv' in meta) {
        delete meta.httpEquiv
      }
      input.meta![idx] = meta
      update()
      return null
    }
  },
})

// <style>
export const Style = defineComponent({
  name: 'Style',
  inheritAttrs: false,
  props: {
    ...globalProps,
    ...TagPositionProps,
    type: String,
    media: String,
    nonce: String,
    title: String,
    /** @deprecated **/
    scoped: {
      type: Boolean,
      default: undefined,
    },
  },
  setup (props, { slots }) {
    const { input, update } = useHeadComponentCtx()
    const key = useVNodeStringKey()
    input.style ||= []
    const idx: keyof typeof input.style = input.style.push({}) - 1
    onUnmounted(() => {
      input.style![idx] = null
      update()
    })
    return () => {
      const style = normalizeProps(props, key) as UnheadStyle
      const textContent = slots.default?.()?.[0]?.children
      if (textContent) {
        if (import.meta.dev && typeof textContent !== 'string') {
          console.error('<Style> can only take a string in its default slot.')
        }
        input.style![idx] = style
        style.textContent = textContent
      }
      update()
      return null
    }
  },
})

// <head>
export const Head = defineComponent({
  name: 'Head',
  inheritAttrs: false,
  setup: (_props, ctx) => {
    createHeadComponentCtx()
    return () => ctx.slots.default?.()
  },
})

// <html>
export const Html = defineComponent({
  name: 'Html',
  inheritAttrs: false,
  props: {
    ...globalProps,
    manifest: String,
    version: String,
    xmlns: String,
  },
  setup (_props, ctx) {
    const { input, update } = useHeadComponentCtx()
    onUnmounted(() => {
      input.htmlAttrs = null
      update()
    })
    return () => {
      input.htmlAttrs = { ..._props, ...ctx.attrs } as HtmlAttributes
      update()
      return ctx.slots.default?.()
    }
  },
})

// <body>
export const Body = defineComponent({
  name: 'Body',
  inheritAttrs: false,
  props: globalProps,
  setup (_props, ctx) {
    const { input, update } = useHeadComponentCtx()
    onUnmounted(() => {
      input.bodyAttrs = null
      update()
    })
    return () => {
      input.bodyAttrs = { ..._props, ...ctx.attrs } as BodyAttributes
      update()
      return ctx.slots.default?.()
    }
  },
})
</file>

<file path="packages/nuxt/src/head/runtime/composables.ts">
import type { ActiveHeadEntry, UseHeadInput, UseHeadOptions, UseHeadSafeInput, UseSeoMetaInput, VueHeadClient } from '@unhead/vue/types'
import { hasInjectionContext, inject } from 'vue'
import {
  useHead as headCore,
  useHeadSafe as headSafe,
  headSymbol,
  useSeoMeta as seoMeta, useServerHead as serverHead, useServerHeadSafe as serverHeadSafe,
  useServerSeoMeta as serverSeoMeta,
} from '@unhead/vue'
import { useNuxtApp } from '#app/nuxt'
import type { NuxtApp } from '#app/nuxt'

/**
 * Injects the head client from the Nuxt context or Vue inject.
 */
export function injectHead (nuxtApp?: NuxtApp): VueHeadClient {
  // Nuxt 4 will throw an error if the context is missing
  const nuxt = nuxtApp || useNuxtApp()
  return nuxt.ssrContext?.head || nuxt.runWithContext(() => {
    if (hasInjectionContext()) {
      const head = inject<VueHeadClient>(headSymbol)
      // should not be possible
      if (!head) {
        throw new Error('[nuxt] [unhead] Missing Unhead instance.')
      }
      return head
    }
  }) as VueHeadClient
}

interface NuxtUseHeadOptions extends UseHeadOptions {
  nuxt?: NuxtApp
}

export function useHead (input: UseHeadInput, options: NuxtUseHeadOptions = {}): ActiveHeadEntry<UseHeadInput> {
  const head = options.head || injectHead(options.nuxt)
  return headCore(input, { head, ...options }) as ActiveHeadEntry<UseHeadInput>
}

export function useHeadSafe (input: UseHeadSafeInput, options: NuxtUseHeadOptions = {}): ActiveHeadEntry<UseHeadSafeInput> {
  const head = options.head || injectHead(options.nuxt)
  return headSafe(input, { head, ...options }) as ActiveHeadEntry<UseHeadSafeInput>
}

export function useSeoMeta (input: UseSeoMetaInput, options: NuxtUseHeadOptions = {}): ActiveHeadEntry<UseSeoMetaInput> {
  const head = options.head || injectHead(options.nuxt)
  return seoMeta(input, { head, ...options }) as ActiveHeadEntry<UseSeoMetaInput>
}

/**
 * @deprecated Use `useHead` instead and wrap with `if (import.meta.server)`
 */
export function useServerHead (input: UseHeadInput, options: NuxtUseHeadOptions = {}): ActiveHeadEntry<UseHeadInput> {
  const head = options.head || injectHead(options.nuxt)
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  return serverHead(input, { head, ...options }) as ActiveHeadEntry<UseHeadInput>
}

/**
 * @deprecated Use `useHeadSafe` instead and wrap with `if (import.meta.server)`
 */
export function useServerHeadSafe (input: UseHeadSafeInput, options: NuxtUseHeadOptions = {}): ActiveHeadEntry<UseHeadSafeInput> {
  const head = options.head || injectHead(options.nuxt)
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  return serverHeadSafe(input, { head, ...options }) as ActiveHeadEntry<UseHeadSafeInput>
}

/**
 * @deprecated Use `useSeoMeta` instead and wrap with `if (import.meta.server)`
 */
export function useServerSeoMeta (input: UseSeoMetaInput, options: NuxtUseHeadOptions = {}): ActiveHeadEntry<UseSeoMetaInput> {
  const head = options.head || injectHead(options.nuxt)
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  return serverSeoMeta(input, { head, ...options }) as ActiveHeadEntry<UseSeoMetaInput>
}
</file>

<file path="packages/nuxt/src/head/runtime/types.ts">
export type Props = Readonly<Record<string, any>>

export type FetchPriority = 'high' | 'low' | 'auto'

export type CrossOrigin = '' | 'anonymous' | 'use-credentials'

export type HTTPEquiv =
  | 'content-security-policy'
  | 'content-type'
  | 'default-style'
  | 'refresh'
  | 'x-ua-compatible'

export type ReferrerPolicy =
  | ''
  | 'no-referrer'
  | 'no-referrer-when-downgrade'
  | 'same-origin'
  | 'origin'
  | 'strict-origin'
  | 'origin-when-cross-origin'
  | 'strict-origin-when-cross-origin'
  | 'unsafe-url'

export type LinkRelationship =
  | 'alternate'
  | 'author'
  | 'canonical'
  | 'dns-prefetch'
  | 'help'
  | 'icon'
  | 'license'
  | 'manifest'
  | 'me'
  | 'modulepreload'
  | 'next'
  | 'pingback'
  | 'preconnect'
  | 'prefetch'
  | 'preload'
  | 'prerender'
  | 'prev'
  | 'search'
  | 'stylesheet'
  | (string & {})

export type Target = '_blank' | '_self' | '_parent' | '_top' | (string & {})
</file>

<file path="packages/nuxt/src/head/module.ts">
import { resolve } from 'pathe'
import { addBuildPlugin, addComponent, addPlugin, addTemplate, defineNuxtModule, directoryToURL } from '@nuxt/kit'
import type { NuxtOptions } from '@nuxt/schema'
import { resolveModulePath } from 'exsolve'
import { distDir } from '../dirs.ts'
import { UnheadImportsPlugin } from './plugins/unhead-imports.ts'

const components = ['NoScript', 'Link', 'Base', 'Title', 'Meta', 'Style', 'Head', 'Html', 'Body']

export default defineNuxtModule<NuxtOptions['unhead']>({
  meta: {
    name: 'nuxt:meta',
    configKey: 'unhead',
  },
  setup (options, nuxt) {
    const runtimeDir = resolve(distDir, 'head/runtime')

    // Transpile @unhead/vue
    nuxt.options.build.transpile.push('@unhead/vue')

    // Register components
    const componentsPath = resolve(runtimeDir, 'components')
    for (const componentName of components) {
      addComponent({
        name: componentName,
        filePath: componentsPath,
        export: componentName,
        // built-in that we do not expect the user to override
        priority: 10,
        // kebab case version of these tags is not valid
        kebabName: componentName,
      })
    }

    // allow @unhead/vue server composables to be tree-shaken from the client bundle
    if (!nuxt.options.dev) {
      nuxt.options.optimization.treeShake.composables.client['@unhead/vue'] = [
        'useServerHead', 'useServerSeoMeta', 'useServerHeadSafe',
      ]
    }

    nuxt.options.alias['#unhead/composables'] = resolve(runtimeDir, 'composables')
    addBuildPlugin(UnheadImportsPlugin({
      sourcemap: !!nuxt.options.sourcemap.server,
      rootDir: nuxt.options.rootDir,
    }))

    // Opt-out feature allowing dependencies using @vueuse/head to work
    const importPaths = nuxt.options.modulesDir.map(d => directoryToURL(d))
    const unheadPlugins = resolveModulePath('@unhead/vue/plugins', { try: true, from: importPaths }) || '@unhead/vue/plugins'

    addTemplate({
      filename: 'unhead-options.mjs',
      getContents () {
        // disableDefaults is enabled to avoid server component issues
        if (!options.legacy) {
          return `
export default {
  disableDefaults: true,
}`
        }
        // v1 unhead legacy options
        const disableCapoSorting = !nuxt.options.experimental.headNext
        return `import { DeprecationsPlugin, PromisesPlugin, TemplateParamsPlugin, AliasSortingPlugin } from ${JSON.stringify(unheadPlugins)};
export default {
  disableDefaults: true,
  disableCapoSorting: ${Boolean(disableCapoSorting)},
  plugins: [DeprecationsPlugin, PromisesPlugin, TemplateParamsPlugin, AliasSortingPlugin],
}`
      },
    })

    addTemplate({
      filename: 'unhead.config.mjs',
      getContents () {
        return [
          `export const renderSSRHeadOptions = ${JSON.stringify(options.renderSSRHeadOptions || {})}`,
        ].join('\n')
      },
    })

    // template is only exposed in nuxt context, expose in nitro context as well
    nuxt.hooks.hook('nitro:config', (config) => {
      config.virtual!['#internal/unhead-options.mjs'] = () => nuxt.vfs['#build/unhead-options.mjs'] || ''
      config.virtual!['#internal/unhead.config.mjs'] = () => nuxt.vfs['#build/unhead.config.mjs'] || ''
    })

    // Add library-specific plugin
    addPlugin({ src: resolve(runtimeDir, 'plugins/unhead') })
  },
})
</file>

<file path="packages/nuxt/src/imports/module.ts">
import { existsSync } from 'node:fs'
import { addBuildPlugin, addTemplate, addTypeTemplate, createIsIgnored, defineNuxtModule, directoryToURL, getLayerDirectories, resolveAlias, tryResolveModule, updateTemplates, useNitro, useNuxt } from '@nuxt/kit'
import { isAbsolute, join, normalize, relative, resolve } from 'pathe'
import type { Import, InlinePreset, Unimport } from 'unimport'
import { createUnimport, scanDirExports, toExports, toTypeDeclarationFile } from 'unimport'
import escapeRE from 'escape-string-regexp'

import { lookupNodeModuleSubpath, parseNodeModulePath } from 'mlly'
import { isDirectory, logger, resolveToAlias } from '../utils.ts'
import { TransformPlugin } from './transform.ts'
import { appCompatPresets, defaultPresets } from './presets.ts'
import type { ImportsOptions, ResolvedNuxtTemplate } from 'nuxt/schema'

import { pagesImportPresets, routeRulesPresets } from '../pages/module.ts'

const allNuxtPresets = [
  ...pagesImportPresets,
  ...routeRulesPresets,
  ...defaultPresets,
]

export default defineNuxtModule<Partial<ImportsOptions>>({
  meta: {
    name: 'nuxt:imports',
    configKey: 'imports',
  },
  defaults: nuxt => ({
    autoImport: true,
    scan: true,
    presets: defaultPresets,
    global: false,
    imports: [],
    dirs: [],
    transform: {
      include: [
        new RegExp('^' + escapeRE(nuxt.options.buildDir)),
      ],
      exclude: undefined,
    },
    virtualImports: ['#imports'],
    polyfills: true,
  }),
  setup (options, nuxt) {
    // TODO: fix sharing of defaults between invocations of modules
    const presets: InlinePreset[] = JSON.parse(JSON.stringify(options.presets))

    if (options.polyfills) {
      presets.push(...appCompatPresets)
    }

    // composables/ dirs from all layers
    let composablesDirs: string[] = []
    if (options.scan) {
      for (const layer of nuxt.options._layers) {
        // Layer disabled scanning for itself
        if (layer.config?.imports?.scan === false) {
          continue
        }

        composablesDirs.push(
          resolve(layer.config.srcDir, 'composables'),
          resolve(layer.config.srcDir, 'utils'),
          resolve(layer.config.rootDir, layer.config.dir?.shared ?? 'shared', 'utils'),
          resolve(layer.config.rootDir, layer.config.dir?.shared ?? 'shared', 'types'),
        )

        for (const dir of (layer.config.imports?.dirs ?? [])) {
          if (dir) {
            composablesDirs.push(resolve(layer.config.srcDir, resolveAlias(dir, nuxt.options.alias)))
          }
        }
      }

      nuxt.hook('modules:done', async () => {
        await nuxt.callHook('imports:dirs', composablesDirs)
        composablesDirs = composablesDirs.map(dir => normalize(dir))
      })

      // Restart nuxt when composable directories are added/removed
      nuxt.hook('builder:watch', (event, relativePath) => {
        if (!['addDir', 'unlinkDir'].includes(event)) { return }

        const path = resolve(nuxt.options.srcDir, relativePath)
        if (composablesDirs.includes(path)) {
          logger.info(`Directory \`${relativePath}/\` ${event === 'addDir' ? 'created' : 'removed'}`)
          return nuxt.callHook('restart')
        }
      })
    }

    let ctx: Unimport

    // initialise unimport only after all modules
    // have had a chance to register their hooks
    nuxt.hook('modules:done', async () => {
      await nuxt.callHook('imports:sources', presets)

      const { addons: inlineAddons, ...rest } = options
      const [addons, addonsOptions] = Array.isArray(inlineAddons) ? [inlineAddons] : [[], inlineAddons]

      // Create a context to share state between module internals
      ctx = createUnimport({
        injectAtEnd: true,
        ...rest,
        addons: {
          addons,
          vueTemplate: options.autoImport,
          vueDirectives: options.autoImport === false ? undefined : true,
          ...addonsOptions,
        },
        presets,
      })

      await nuxt.callHook('imports:context', ctx)
    })

    // Support for importing from '#imports'
    addTemplate({
      filename: 'imports.mjs',
      getContents: async () => toExports(await ctx.getImports()) + '\nif (import.meta.dev) { console.warn("[nuxt] `#imports` should be transformed with real imports. There seems to be something wrong with the imports plugin.") }',
    })
    nuxt.options.alias['#imports'] = join(nuxt.options.buildDir, 'imports')

    // Transform to inject imports in production mode
    addBuildPlugin(TransformPlugin({
      ctx: {
        injectImports: (code, id, options) => ctx.injectImports(code, id, options),
      },
      options,
      sourcemap: !!nuxt.options.sourcemap.server || !!nuxt.options.sourcemap.client,
    }))

    const priorities = getLayerDirectories(nuxt).map((dirs, i) => [dirs.app, -i] as const).sort(([a], [b]) => b.length - a.length)

    const IMPORTS_TEMPLATE_RE = /\/imports\.(?:d\.ts|mjs)$/
    function isImportsTemplate (template: ResolvedNuxtTemplate) {
      return IMPORTS_TEMPLATE_RE.test(template.filename)
    }

    const isIgnored = createIsIgnored(nuxt)
    const nuxtImportSources = new Set(allNuxtPresets.flatMap(i => i.from))
    const nuxtImports = new Set(presets.flatMap(p => nuxtImportSources.has(p.from) ? p.imports : []))
    const regenerateImports = async () => {
      await ctx.modifyDynamicImports(async (imports) => {
        // Clear old imports
        imports.length = 0

        // Scan for `composables/` and `utils/` directories
        if (options.scan) {
          const scannedImports = await scanDirExports(composablesDirs, {
            fileFilter: file => !isIgnored(file),
          })
          for (const i of scannedImports) {
            i.priority ||= priorities.find(([dir]) => i.from.startsWith(dir))?.[1]
          }
          imports.push(...scannedImports)
        }

        // Modules extending
        await nuxt.callHook('imports:extend', imports)
        for (const i of imports) {
          if (!nuxtImportSources.has(i.from)) {
            const value = i.as || i.name
            if (nuxtImports.has(value) && (!i.priority || i.priority >= 0 /* default priority */)) {
              const relativePath = isAbsolute(i.from) ? `${resolveToAlias(i.from, nuxt)}` : i.from
              logger.error(`\`${value}\` is an auto-imported function that is in use by Nuxt. Overriding it will likely cause issues. Please consider renaming \`${value}\` in \`${relativePath}\`.`)
            }
          }
        }

        return imports
      })

      await updateTemplates({
        filter: isImportsTemplate,
      })
    }

    nuxt.hook('modules:done', () => regenerateImports())

    // Generate types
    addDeclarationTemplates({
      generateTypeDeclarations: options => ctx.generateTypeDeclarations(options),
      getImports: () => ctx.getImports(),
    }, options)

    // Watch composables/ directory
    nuxt.hook('builder:watch', async (_, relativePath) => {
      const path = resolve(nuxt.options.srcDir, relativePath)
      if (options.scan && composablesDirs.some(dir => dir === path || path.startsWith(dir + '/'))) {
        await regenerateImports()
      }
    })

    // Watch for template generation
    nuxt.hook('app:templatesGenerated', async (_app, templates) => {
      // Only regenerate when non-imports templates are updated
      if (templates.some(t => !isImportsTemplate(t))) {
        await regenerateImports()
      }
    })
  },
})

function addDeclarationTemplates (ctx: Pick<Unimport, 'getImports' | 'generateTypeDeclarations'>, options: Partial<ImportsOptions>) {
  const nuxt = useNuxt()

  const resolvedImportPathMap = new Map<string, string>()
  const r = (i: Import) => resolvedImportPathMap.get(i.typeFrom || i.from)

  const SUPPORTED_EXTENSION_RE = new RegExp(`\\.(?:${nuxt.options.extensions.map(i => i.replace('.', '')).join('|')})$`)

  const importPaths = nuxt.options.modulesDir.map(dir => directoryToURL(dir))

  async function cacheImportPaths (imports: Import[]) {
    const importSource = Array.from(new Set(imports.map(i => i.typeFrom || i.from)))
    // skip relative import paths for node_modules that are explicitly installed
    await Promise.all(importSource.map(async (from) => {
      if (resolvedImportPathMap.has(from) || nuxt._dependencies?.has(from)) {
        return
      }
      let path = resolveAlias(from)
      if (!isAbsolute(path)) {
        path = await tryResolveModule(from, importPaths).then(async (r) => {
          if (!r) { return r }

          const { dir, name } = parseNodeModulePath(r)
          if (name && nuxt._dependencies?.has(name)) { return from }

          if (!dir || !name) { return r }
          const subpath = await lookupNodeModuleSubpath(r)
          return join(dir, name, subpath || '')
        }) ?? path
      }

      if (existsSync(path) && !(await isDirectory(path))) {
        path = path.replace(SUPPORTED_EXTENSION_RE, '')
      }

      if (isAbsolute(path)) {
        path = relative(join(nuxt.options.buildDir, 'types'), path)
      }

      resolvedImportPathMap.set(from, path)
    }))
  }

  addTypeTemplate({
    filename: 'imports.d.ts',
    getContents: async ({ nuxt }) => toExports(await ctx.getImports(), nuxt.options.buildDir, true),
  })

  const GENERATED_BY_COMMENT = '// Generated by auto imports\n'
  const AUTO_IMPORTS_DISABLED_COMMENT = '// Implicit auto importing is disabled, you can explicitly import from `#imports` instead.\n'

  addTypeTemplate({
    filename: 'types/imports.d.ts',
    getContents: async () => {
      const imports = await ctx.getImports()
      await cacheImportPaths(imports)
      return GENERATED_BY_COMMENT + (
        options.autoImport
          ? await ctx.generateTypeDeclarations({ resolvePath: r })
          : AUTO_IMPORTS_DISABLED_COMMENT
      )
    },
  })

  addTemplate({
    filename: 'types/shared-imports.d.ts',
    getContents: async () => {
      if (!options.autoImport) {
        return GENERATED_BY_COMMENT + AUTO_IMPORTS_DISABLED_COMMENT
      }
      const nitro = useNitro()

      const nuxtImports = await ctx.getImports()

      const nitroImports = await nitro.unimport?.getImports() ?? []
      const nitroImportsByName = new Map<string, Import>(nitroImports.map(i => [i.as || i.name, i]))

      const sharedImports: Import[] = []

      for (const i of nuxtImports) {
        const importName = i.as || i.name
        const nitroImport = nitroImportsByName.get(importName)
        if (!nitroImport || i.dtsDisabled || nitroImport.dtsDisabled) { continue }

        sharedImports.push(i)

        // add the nitro import too to create a union, if it differs
        // TODO: uncomment when https://github.com/unjs/unimport/pull/489 is merged
        // if (i.from !== nitroImport.from) {
        //   sharedImports.push(nitroImport)
        // }
      }

      await cacheImportPaths(sharedImports)

      return GENERATED_BY_COMMENT + toTypeDeclarationFile(sharedImports, { resolvePath: r })
    },
  })
}
</file>

<file path="packages/nuxt/src/imports/presets.ts">
import type { InlinePreset } from 'unimport'
import { defineUnimportPreset } from 'unimport'

const commonPresets: InlinePreset[] = [
  // vue-demi (mocked)
  defineUnimportPreset({
    from: 'vue-demi',
    imports: [
      'isVue2',
      'isVue3',
    ],
  }),
]

const granularAppPresets: InlinePreset[] = [
  {
    from: '#app/components/nuxt-link',
    imports: ['defineNuxtLink'],
  },
  {
    imports: ['useNuxtApp', 'tryUseNuxtApp', 'defineNuxtPlugin', 'definePayloadPlugin', 'useRuntimeConfig', 'defineAppConfig'],
    from: '#app/nuxt',
  },
  {
    imports: ['useAppConfig', 'updateAppConfig'],
    from: '#app/config',
  },
  {
    imports: ['defineNuxtComponent'],
    from: '#app/composables/component',
  },
  {
    imports: ['useAsyncData', 'useLazyAsyncData', 'useNuxtData', 'refreshNuxtData', 'clearNuxtData'],
    from: '#app/composables/asyncData',
  },
  {
    imports: ['useHydration'],
    from: '#app/composables/hydrate',
  },
  {
    imports: ['callOnce'],
    from: '#app/composables/once',
  },
  {
    imports: ['useState', 'clearNuxtState'],
    from: '#app/composables/state',
  },
  {
    imports: ['clearError', 'createError', 'isNuxtError', 'showError', 'useError'],
    from: '#app/composables/error',
  },
  {
    imports: ['useFetch', 'useLazyFetch'],
    from: '#app/composables/fetch',
  },
  {
    imports: ['useCookie', 'refreshCookie'],
    from: '#app/composables/cookie',
  },
  {
    imports: ['onPrehydrate', 'prerenderRoutes', 'useRequestHeader', 'useRequestHeaders', 'useResponseHeader', 'useRequestEvent', 'useRequestFetch', 'setResponseStatus'],
    from: '#app/composables/ssr',
  },
  {
    imports: ['onNuxtReady'],
    from: '#app/composables/ready',
  },
  {
    imports: ['preloadComponents', 'prefetchComponents', 'preloadRouteComponents'],
    from: '#app/composables/preload',
  },
  {
    imports: ['abortNavigation', 'addRouteMiddleware', 'defineNuxtRouteMiddleware', 'setPageLayout', 'navigateTo', 'useRoute', 'useRouter'],
    from: '#app/composables/router',
  },
  {
    imports: ['isPrerendered', 'loadPayload', 'preloadPayload', 'definePayloadReducer', 'definePayloadReviver'],
    from: '#app/composables/payload',
  },
  {
    imports: ['useLoadingIndicator'],
    from: '#app/composables/loading-indicator',
  },
  {
    imports: ['getAppManifest', 'getRouteRules'],
    from: '#app/composables/manifest',
  },
  {
    imports: ['reloadNuxtApp'],
    from: '#app/composables/chunk',
  },
  {
    imports: ['useRequestURL'],
    from: '#app/composables/url',
  },
  {
    imports: ['usePreviewMode'],
    from: '#app/composables/preview',
  },
  {
    imports: ['useRouteAnnouncer'],
    from: '#app/composables/route-announcer',
  },
  {
    imports: ['useRuntimeHook'],
    from: '#app/composables/runtime-hook',
  },
  {
    imports: ['useHead', 'useHeadSafe', 'useServerHeadSafe', 'useServerHead', 'useSeoMeta', 'useServerSeoMeta', 'injectHead'],
    from: '#app/composables/head',
  },
]

export const scriptsStubsPreset = {
  imports: [
    'useScriptTriggerConsent',
    'useScriptEventPage',
    'useScriptTriggerElement',
    'useScript',
    'useScriptGoogleAnalytics',
    'useScriptPlausibleAnalytics',
    'useScriptCrisp',
    'useScriptClarity',
    'useScriptCloudflareWebAnalytics',
    'useScriptFathomAnalytics',
    'useScriptMatomoAnalytics',
    'useScriptGoogleTagManager',
    'useScriptGoogleAdsense',
    'useScriptSegment',
    'useScriptMetaPixel',
    'useScriptXPixel',
    'useScriptIntercom',
    'useScriptHotjar',
    'useScriptStripe',
    'useScriptLemonSqueezy',
    'useScriptVimeoPlayer',
    'useScriptYouTubePlayer',
    'useScriptGoogleMaps',
    'useScriptNpm',
    'useScriptUmamiAnalytics',
    'useScriptSnapchatPixel',
    'useScriptRybbitAnalytics',
    'useScriptDatabuddyAnalytics',
    'useScriptRedditPixel',
    'useScriptPayPal',
  ],
  priority: -1,
  from: '#app/composables/script-stubs',
} satisfies InlinePreset

// This is a separate preset as we'll swap these out for import from `vue-router` itself in `pages` module
const routerPreset = defineUnimportPreset({
  imports: ['onBeforeRouteLeave', 'onBeforeRouteUpdate'],
  from: '#app/composables/router',
})

// vue
const vuePreset = defineUnimportPreset({
  from: 'vue',
  imports: [
    // <script setup>
    'withCtx',
    'withDirectives',
    'withKeys',
    'withMemo',
    'withModifiers',
    'withScopeId',

    // Lifecycle
    'onActivated',
    'onBeforeMount',
    'onBeforeUnmount',
    'onBeforeUpdate',
    'onDeactivated',
    'onErrorCaptured',
    'onMounted',
    'onRenderTracked',
    'onRenderTriggered',
    'onServerPrefetch',
    'onUnmounted',
    'onUpdated',

    // Reactivity
    'computed',
    'customRef',
    'isProxy',
    'isReactive',
    'isReadonly',
    'isRef',
    'markRaw',
    'proxyRefs',
    'reactive',
    'readonly',
    'ref',
    'shallowReactive',
    'shallowReadonly',
    'shallowRef',
    'toRaw',
    'toRef',
    'toRefs',
    'triggerRef',
    'unref',
    'watch',
    'watchEffect',
    'watchPostEffect',
    'watchSyncEffect',
    'onWatcherCleanup',
    'isShallow',

    // effect
    'effect',
    'effectScope',
    'getCurrentScope',
    'onScopeDispose',

    // Component
    'defineComponent',
    'defineAsyncComponent',
    'resolveComponent',
    'getCurrentInstance',
    'h',
    'inject',
    'hasInjectionContext',
    'nextTick',
    'provide',
    'toValue',
    'useModel',
    'useAttrs',
    'useCssModule',
    'useCssVars',
    'useSlots',
    'useTransitionState',
    'useId',
    'useTemplateRef',
    'useShadowRoot',
    'useCssVars',
  ],
})

const vueTypesPreset = defineUnimportPreset({
  from: 'vue',
  type: true,
  imports: [
    'Component',
    'ComponentPublicInstance',
    'ComputedRef',
    'DirectiveBinding',
    'ExtractDefaultPropTypes',
    'ExtractPropTypes',
    'ExtractPublicPropTypes',
    'InjectionKey',
    'PropType',
    'Ref',
    'MaybeRef',
    'MaybeRefOrGetter',
    'VNode',
    'WritableComputedRef',
  ],
})

export const appCompatPresets: InlinePreset[] = [
  {
    imports: ['requestIdleCallback', 'cancelIdleCallback'],
    from: '#app/compat/idle-callback',
  },
  {
    imports: ['setInterval'],
    from: '#app/compat/interval',
  },
]

export const lazyHydrationMacroPreset = [
  {
    imports: ['defineLazyHydrationComponent'],
    from: '#app/composables/lazy-hydration',
  },
]

export const defaultPresets: InlinePreset[] = [
  ...commonPresets,
  ...granularAppPresets,
  routerPreset,
  vuePreset,
  vueTypesPreset,
]
</file>

<file path="packages/nuxt/src/imports/transform.ts">
import { createUnplugin } from 'unplugin'
import type { Unimport } from 'unimport'
import { normalize } from 'pathe'
import { tryUseNuxt } from '@nuxt/kit'

import { isJS, isVue } from '../core/utils/index.ts'
import { installNuxtModule } from '../core/features.ts'
import type { ImportsOptions } from 'nuxt/schema'

const NODE_MODULES_RE = /[\\/]node_modules[\\/]/
const IMPORTS_RE = /(['"])#imports\1/

interface TransformPluginOptions {
  ctx: Pick<Unimport, 'injectImports'>
  options: Partial<ImportsOptions>
  sourcemap?: boolean
}

export const TransformPlugin = ({ ctx, options, sourcemap }: TransformPluginOptions) => createUnplugin(() => {
  return {
    name: 'nuxt:imports-transform',
    enforce: 'post',
    transformInclude (id) {
      // Included
      if (options.transform?.include?.some(pattern => pattern.test(id))) {
        return true
      }
      // Excluded
      if (options.transform?.exclude?.some(pattern => pattern.test(id))) {
        return false
      }

      // Vue files
      if (isVue(id, { type: ['script', 'template'] })) {
        return true
      }

      // JavaScript files
      return isJS(id)
    },
    async transform (code, id) {
      id = normalize(id)
      const isNodeModule = NODE_MODULES_RE.test(id) && !options.transform?.include?.some(pattern => pattern.test(id))
      // For modules in node_modules, we only transform `#imports` but not doing imports
      if (isNodeModule && !IMPORTS_RE.test(code)) {
        return
      }

      const { s, imports } = await ctx.injectImports(code, id, { autoImport: options.autoImport && !isNodeModule })
      if (imports.some(i => i.from === '#app/composables/script-stubs') && tryUseNuxt()?.options.test === false) {
        installNuxtModule('@nuxt/scripts')
      }

      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: sourcemap
            ? s.generateMap({ hires: true })
            : undefined,
        }
      }
    },
  }
})
</file>

<file path="packages/nuxt/src/pages/plugins/page-meta.ts">
import { pathToFileURL } from 'node:url'
import { createUnplugin } from 'unplugin'
import { parseQuery, parseURL } from 'ufo'
import type { ParsedQuery } from 'ufo'
import type { StaticImport } from 'mlly'
import { findExports, findStaticImports, parseStaticImport } from 'mlly'
import MagicString from 'magic-string'
import { isAbsolute } from 'pathe'
import { ScopeTracker, getUndeclaredIdentifiersInFunction, isBindingIdentifier, parseAndWalk, walk } from 'oxc-walker'
import type { ScopeTrackerNode } from 'oxc-walker'

import { logger } from '../../utils.ts'
import { isSerializable } from '../utils.ts'
import type { ParserOptions } from 'oxc-parser'

interface PageMetaPluginOptions {
  dev?: boolean
  sourcemap?: boolean
  isPage?: (file: string) => boolean
  routesPath?: string
  extractedKeys?: string[]
}

const HAS_MACRO_RE = /\bdefinePageMeta\s*\(\s*/

const CODE_EMPTY = `
const __nuxt_page_meta = null
export default __nuxt_page_meta
`

const CODE_DEV_EMPTY = `
const __nuxt_page_meta = {}
export default __nuxt_page_meta
`

const CODE_HMR = `
// Vite
if (import.meta.hot) {
  import.meta.hot.accept(mod => {
    Object.assign(__nuxt_page_meta, mod)
  })
}
// webpack
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept((err) => {
    if (err) { window.location = window.location.href }
  })
}`

export const PageMetaPlugin = (options: PageMetaPluginOptions = {}) => createUnplugin(() => {
  return {
    name: 'nuxt:pages-macros-transform',
    enforce: 'post',
    transformInclude (id) {
      return !!parseMacroQuery(id).macro
    },
    transform: {
      filter: {
        id: {
          exclude: [/(?:\?|%3F).*type=(?:style|template)/],
        },
        code: {
          include: [
            HAS_MACRO_RE,
            /\bfrom\s+["'][^"'?]*\?[^"']*type=script[^"']*["']/,
            /export\s+\{\s*default\s*\}\s+from\s+["'][^"'?]*\?[^"']*type=script[^"']*["']/,
            /^(?!.*__nuxt_page_meta)(?!.*export\s+\{\s*default\s*\})(?!.*\bdefinePageMeta\s*\()[\s\S]*$/,
          ],
        },
      },
      handler (code, id) {
        const query = parseMacroQuery(id)
        if (query.type && query.type !== 'script') { return }

        const s = new MagicString(code)
        function result () {
          if (s.hasChanged()) {
            return {
              code: s.toString(),
              map: options.sourcemap
                ? s.generateMap({ hires: true })
                : undefined,
            }
          }
        }

        const hasMacro = HAS_MACRO_RE.test(code)

        const imports = findStaticImports(code)

        // [vite] Re-export any script imports
        const scriptImport = imports.find(i => parseMacroQuery(i.specifier).type === 'script')
        if (scriptImport) {
          const reorderedQuery = rewriteQuery(scriptImport.specifier)
          // Avoid using JSON.stringify which can add extra escapes to paths with non-ASCII characters
          const quotedSpecifier = getQuotedSpecifier(scriptImport.code)?.replace(scriptImport.specifier, reorderedQuery) ?? JSON.stringify(reorderedQuery)
          s.overwrite(0, code.length, `export { default } from ${quotedSpecifier}`)
          return result()
        }

        // [webpack] Re-export any exports from script blocks in the components
        const currentExports = findExports(code)
        for (const match of currentExports) {
          if (match.type !== 'default' || !match.specifier) {
            continue
          }

          const reorderedQuery = rewriteQuery(match.specifier)
          // Avoid using JSON.stringify which can add extra escapes to paths with non-ASCII characters
          const quotedSpecifier = getQuotedSpecifier(match.code)?.replace(match.specifier, reorderedQuery) ?? JSON.stringify(reorderedQuery)
          s.overwrite(0, code.length, `export { default } from ${quotedSpecifier}`)
          return result()
        }

        if (!hasMacro && !code.includes('export { default }') && !code.includes('__nuxt_page_meta')) {
          if (!code) {
            s.append(options.dev ? (CODE_DEV_EMPTY + CODE_HMR) : CODE_EMPTY)
            const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href))
            logger.error(`The file \`${pathname}\` is not a valid page as it has no content.`)
          } else {
            s.overwrite(0, code.length, options.dev ? (CODE_DEV_EMPTY + CODE_HMR) : CODE_EMPTY)
          }

          return result()
        }

        const importMap = new Map<string, StaticImport>()
        const addedImports = new Set()
        for (const i of imports) {
          const parsed = parseStaticImport(i)
          for (const name of [
            parsed.defaultImport,
            ...Object.values(parsed.namedImports || {}),
            parsed.namespacedImport,
          ].filter(Boolean) as string[]) {
            importMap.set(name, i)
          }
        }

        function isStaticIdentifier (name: string | false): name is string {
          return !!(name && importMap.has(name))
        }

        function addImport (name: string | false) {
          if (!isStaticIdentifier(name)) { return }
          const importValue = importMap.get(name)!.code.trim()
          if (!addedImports.has(importValue)) {
            addedImports.add(importValue)
          }
        }

        const declarationNodes: ScopeTrackerNode[] = []
        const addedDeclarations = new Set<string>()

        function addDeclaration (node: ScopeTrackerNode) {
          const codeSectionKey = `${resolveStart(node)}-${resolveEnd(node)}`
          if (addedDeclarations.has(codeSectionKey)) { return }
          addedDeclarations.add(codeSectionKey)
          declarationNodes.push(node)
        }

        /**
         * Adds an import or a declaration to the extracted code.
         * @param name The name of the import or declaration to add.
         * @param node The node that is currently being processed. (To detect self-references)
         */
        function addImportOrDeclaration (name: string, node?: ScopeTrackerNode) {
          if (isStaticIdentifier(name)) {
            addImport(name)
          } else {
            const declaration = scopeTracker.getDeclaration(name)
            /*
           Without checking for `declaration !== node`, we would end up in an infinite loop
           when, for example, a variable is declared and then used in its own initializer.
           (we shouldn't mask the underlying error by throwing a `Maximum call stack size exceeded` error)

           ```ts
           const a = { b: a }
           ```
           */
            if (declaration && declaration !== node) {
              processDeclaration(declaration)
            }
          }
        }

        const scopeTracker = new ScopeTracker({
          preserveExitedScopes: true,
        })

        function processDeclaration (scopeTrackerNode: ScopeTrackerNode | null) {
          if (scopeTrackerNode?.type === 'Variable') {
            addDeclaration(scopeTrackerNode)

            for (const decl of scopeTrackerNode.variableNode.declarations) {
              if (!decl.init) { continue }
              walk(decl.init, {
                enter: (node, parent) => {
                  if (node.type === 'AwaitExpression') {
                    logger.error(`Await expressions are not supported in definePageMeta. File: '${id}'`)
                    throw new Error('await in definePageMeta')
                  }
                  if (
                    isBindingIdentifier(node, parent)
                  || node.type !== 'Identifier' // checking for `node.type` to narrow down the type
                  ) { return }

                  addImportOrDeclaration(node.name, scopeTrackerNode)
                },
              })
            }
          } else if (scopeTrackerNode?.type === 'Function') {
          // arrow functions are going to be assigned to a variable
            if (scopeTrackerNode.node.type === 'ArrowFunctionExpression') { return }
            const name = scopeTrackerNode.node.id?.name
            if (!name) { return }
            addDeclaration(scopeTrackerNode)

            const undeclaredIdentifiers = getUndeclaredIdentifiersInFunction(scopeTrackerNode.node)
            for (const name of undeclaredIdentifiers) {
              addImportOrDeclaration(name)
            }
          }
        }

        const { program: ast } = parseAndWalk(code, id, {
          scopeTracker,
          parseOptions: {
            lang: query.lang ?? 'ts',
          },
        })

        scopeTracker.freeze()

        let instances = 0

        walk(ast, {
          scopeTracker,
          enter: (node) => {
            if (node.type !== 'CallExpression' || node.callee.type !== 'Identifier') { return }
            if (!('name' in node.callee) || node.callee.name !== 'definePageMeta') { return }

            instances++
            const meta = node.arguments[0]

            if (!meta) { return }
            const metaCode = code!.slice(meta.start, meta.end)
            const m = new MagicString(metaCode)

            if (meta.type === 'ObjectExpression') {
              for (let i = 0; i < meta.properties.length; i++) {
                const prop = meta.properties[i]!
                if (prop.type === 'Property' && prop.key.type === 'Identifier' && options.extractedKeys?.includes(prop.key.name)) {
                  const { serializable } = isSerializable(metaCode, prop.value)
                  if (!serializable) {
                    continue
                  }
                  const nextProperty = meta.properties[i + 1]
                  if (nextProperty) {
                    m.overwrite(prop.start - meta.start, nextProperty.start - meta.start, '')
                  } else if (code[prop.end] === ',') {
                    m.overwrite(prop.start - meta.start, prop.end - meta.start + 1, '')
                  } else {
                    m.overwrite(prop.start - meta.start, prop.end - meta.start, '')
                  }
                }
              }
            }

            const definePageMetaScope = scopeTracker.getCurrentScope()

            walk(meta, {
              scopeTracker,
              enter (node, parent) {
                if (
                  isBindingIdentifier(node, parent)
                || node.type !== 'Identifier' // checking for `node.type` to narrow down the type
                ) { return }

                const declaration = scopeTracker.getDeclaration(node.name)
                if (declaration) {
                // check if the declaration was made inside `definePageMeta` and if so, do not process it
                // (ensures that we don't hoist local variables in inline middleware, for example)
                  if (
                    declaration.isUnderScope(definePageMetaScope)
                  // ensures that we compare the correct declaration to the reference
                  // (when in the same scope, the declaration must come before the reference, otherwise it must be in a parent scope)
                  && (scopeTracker.isCurrentScopeUnder(declaration.scope) || resolveStart(declaration) < node.start)
                  ) {
                    return
                  }
                }

                if (isStaticIdentifier(node.name)) {
                  addImport(node.name)
                } else if (declaration) {
                  processDeclaration(declaration)
                }
              },
            })

            const importStatements = Array.from(addedImports).join('\n')

            const declarations = declarationNodes
              .sort((a, b) => resolveStart(a) - resolveStart(b))
              .map(node => code.slice(resolveStart(node), resolveEnd(node)))
              .join('\n')

            const extracted = [
              importStatements,
              declarations,
              `const __nuxt_page_meta = ${m.toString() || 'null'}\nexport default __nuxt_page_meta` + (options.dev ? CODE_HMR : ''),
            ].join('\n')

            s.overwrite(0, code.length, extracted.trim())
          },
        })

        if (instances > 1) {
          throw new Error('Multiple `definePageMeta` calls are not supported. File: ' + id.replace(/\?.+$/, ''))
        }

        if (!s.hasChanged() && !code.includes('__nuxt_page_meta')) {
          s.overwrite(0, code.length, options.dev ? (CODE_DEV_EMPTY + CODE_HMR) : CODE_EMPTY)
        }

        return result()
      },
    },
    vite: {
      handleHotUpdate: {
        order: 'post',
        handler: ({ file, modules, server }) => {
          if (options.routesPath && options.isPage?.(file)) {
            const macroModule = server.moduleGraph.getModuleById(file + '?macro=true')
            const routesModule = server.moduleGraph.getModuleById('virtual:nuxt:' + encodeURIComponent(options.routesPath))
            return [
              ...modules,
              ...macroModule ? [macroModule] : [],
              ...routesModule ? [routesModule] : [],
            ]
          }
        },
      },
    },
  }
})

// https://github.com/vuejs/vue-loader/pull/1911
// https://github.com/vitejs/vite-plugin-vue/issues/23
const QUERY_START_RE = /^\?/
const MACRO_RE = /&macro=true/
function rewriteQuery (id: string) {
  return id.replace(/\?.+$/, r => '?macro=true&' + r.replace(QUERY_START_RE, '').replace(MACRO_RE, ''))
}

function parseMacroQuery (id: string) {
  const { search } = parseURL(decodeURIComponent(isAbsolute(id) ? pathToFileURL(id).href : id).replace(/\?macro=true$/, ''))
  const query = parseQuery<{
    lang?: ParserOptions['lang']
  } & ParsedQuery>(search)
  if (id.includes('?macro=true')) {
    return { macro: 'true', ...query }
  }
  return query
}

const QUOTED_SPECIFIER_RE = /(["']).*\1/
function getQuotedSpecifier (id: string) {
  return id.match(QUOTED_SPECIFIER_RE)?.[0]
}

function resolveStart (node: ScopeTrackerNode) {
  return 'fnNode' in node ? node.fnNode.start : node.start
}
function resolveEnd (node: ScopeTrackerNode) {
  return 'fnNode' in node ? node.fnNode.end : node.end
}
</file>

<file path="packages/nuxt/src/pages/plugins/route-injection.ts">
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'
import type { Nuxt } from '@nuxt/schema'
import { parseAndWalk } from 'oxc-walker'
import { isVue } from '../../core/utils/index.ts'

const INJECTION_SINGLE_RE = /\bthis\.\$route\b|\b_ctx\.\$route\b/

export const RouteInjectionPlugin = (nuxt: Nuxt) => createUnplugin(() => {
  return {
    name: 'nuxt:route-injection-plugin',
    enforce: 'post',
    transformInclude (id) {
      return isVue(id, { type: ['template', 'script'] })
    },
    transform: {
      filter: {
        code: {
          include: INJECTION_SINGLE_RE,
          exclude: [
            `_ctx._.provides[__nuxt_route_symbol`,
            'this._.provides[__nuxt_route_symbol',
          ],
        },
      },
      handler (code, id) {
        const s = new MagicString(code)

        parseAndWalk(code, id, (node) => {
          if (node.type !== 'MemberExpression') { return }

          // Check for this.$route pattern
          if (node.object.type === 'ThisExpression' && node.property.type === 'Identifier' && node.property.name === '$route') {
            s.overwrite(node.start, node.end, '(this._.provides[__nuxt_route_symbol] || this.$route)')
            return
          }

          // Check for _ctx.$route pattern
          if (node.object.type === 'Identifier' && node.object.name === '_ctx' && node.property.type === 'Identifier' && node.property.name === '$route') {
            s.overwrite(node.start, node.end, '(_ctx._.provides[__nuxt_route_symbol] || _ctx.$route)')
          }
        })

        if (s.hasChanged()) {
          s.prepend('import { PageRouteSymbol as __nuxt_route_symbol } from \'#app/components/injections\';\n')

          return {
            code: s.toString(),
            map: nuxt.options.sourcemap.client || nuxt.options.sourcemap.server
              ? s.generateMap({ hires: true })
              : undefined,
          }
        }
      },
    },

  }
})
</file>

<file path="packages/nuxt/src/pages/runtime/plugins/check-if-page-unused.ts">
import { nextTick } from 'vue'
import { defineNuxtPlugin } from '#app/nuxt'
import { onNuxtReady } from '#app/composables/ready'
import { useError } from '#app/composables/error'

export default defineNuxtPlugin({
  name: 'nuxt:checkIfPageUnused',
  setup (nuxtApp) {
    const error = useError()

    function checkIfPageUnused () {
      if (!error.value && !nuxtApp._isNuxtPageUsed) {
        console.warn(
          '[nuxt] Your project has pages but the `<NuxtPage />` component has not been used.' +
          ' You might be using the `<RouterView />` component instead, which will not work correctly in Nuxt.' +
          ' You can set `pages: false` in `nuxt.config` if you do not wish to use the Nuxt `vue-router` integration.',
        )
      }
    }

    if (import.meta.server) {
      nuxtApp.hook('app:rendered', ({ renderResult }) => {
        if (renderResult?.html) {
          nextTick(checkIfPageUnused)
        }
      })
    } else {
      onNuxtReady(checkIfPageUnused)
    }
  },
  env: {
    islands: false,
  },
})
</file>

<file path="packages/nuxt/src/pages/runtime/plugins/prefetch.client.ts">
import { hasProtocol } from 'ufo'
import { toArray } from '../utils'
import { defineNuxtPlugin } from '#app/nuxt'
import { useRouter } from '#app/composables/router'
// @ts-expect-error virtual file
import layouts from '#build/layouts'
// @ts-expect-error virtual file
import { namedMiddleware } from '#build/middleware'
import { _loadAsyncComponent } from '#app/composables/preload'

export default defineNuxtPlugin({
  name: 'nuxt:prefetch',
  setup (nuxtApp) {
    const router = useRouter()

    // Force layout prefetch on route changes
    nuxtApp.hooks.hook('app:mounted', () => {
      router.beforeEach(async (to) => {
        const layout = to?.meta?.layout
        if (layout && typeof layouts[layout] === 'function') {
          await layouts[layout]()
        }
      })
    })
    // Prefetch layouts & middleware
    nuxtApp.hooks.hook('link:prefetch', (url) => {
      if (hasProtocol(url)) { return }
      const route = router.resolve(url)
      if (!route) { return }
      const layout = route.meta.layout
      let middleware = toArray(route.meta.middleware)
      middleware = middleware.filter(m => typeof m === 'string')

      for (const name of middleware) {
        if (typeof namedMiddleware[name] === 'function') {
          namedMiddleware[name]()
        }
      }

      if (typeof layout === 'string' && layout in layouts) {
        _loadAsyncComponent(layouts[layout])
      }
    })
  },
})
</file>

<file path="packages/nuxt/src/pages/runtime/plugins/prerender.server.ts">
import type { RouteRecordRaw } from 'vue-router'
import { joinURL } from 'ufo'
import type { NitroRouteRules } from 'nitropack/types'

import { defineNuxtPlugin } from '#app/nuxt'
import { prerenderRoutes } from '#app/composables/ssr'
import _routes from '#build/routes'
import routerOptions, { hashMode } from '#build/router.options.mjs'
// @ts-expect-error virtual file
import { crawlLinks } from '#build/nuxt.config.mjs'
// @ts-expect-error virtual file
import _routeRulesMatcher from '#build/route-rules.mjs'

const routeRulesMatcher = _routeRulesMatcher as (path: string) => NitroRouteRules

let routes: string[]

export default defineNuxtPlugin(async () => {
  if (!import.meta.server || !import.meta.prerender || hashMode) {
    return
  }
  if (routes && !routes.length) { return }

  routes ||= Array.from(processRoutes(await routerOptions.routes?.(_routes) ?? _routes))
  const batch = routes.splice(0, 10)
  prerenderRoutes(batch)
})

// Implementation

const OPTIONAL_PARAM_RE = /^\/?:.*(?:\?|\(\.\*\)\*)$/

function shouldPrerender (path: string) {
  return crawlLinks || !!routeRulesMatcher(path).prerender
}

function processRoutes (routes: readonly RouteRecordRaw[], currentPath = '/', routesToPrerender = new Set<string>()) {
  for (const route of routes) {
    // Add root of optional dynamic paths and catchalls
    if (OPTIONAL_PARAM_RE.test(route.path) && !route.children?.length && shouldPrerender(currentPath)) {
      routesToPrerender.add(currentPath)
    }
    // Skip dynamic paths
    if (route.path.includes(':')) {
      continue
    }
    const fullPath = joinURL(currentPath, route.path)
    if (shouldPrerender(fullPath)) {
      routesToPrerender.add(fullPath)
    }
    if (route.children) {
      processRoutes(route.children, fullPath, routesToPrerender)
    }
  }
  return routesToPrerender
}
</file>

<file path="packages/nuxt/src/pages/runtime/plugins/router.ts">
import { isReadonly, reactive, shallowReactive, shallowRef } from 'vue'
import type { Ref } from 'vue'
import type { RouteLocationNormalizedLoadedGeneric, Router, RouterScrollBehavior } from 'vue-router'
import { START_LOCATION, createMemoryHistory, createRouter, createWebHashHistory, createWebHistory } from 'vue-router'
import { isSamePath, withoutBase } from 'ufo'

import type { NuxtApp, Plugin, RouteMiddleware } from 'nuxt/app'
import type { PageMeta } from '../composables'

import { toArray } from '../utils'

import { getRouteRules } from '#app/composables/manifest'
import { defineNuxtPlugin, useRuntimeConfig } from '#app/nuxt'
import { clearError, createError, isNuxtError, showError, useError } from '#app/composables/error'
import { navigateTo } from '#app/composables/router'

import _routes, { handleHotUpdate } from '#build/routes'
import routerOptions, { hashMode } from '#build/router.options.mjs'
// @ts-expect-error virtual file
import { globalMiddleware, namedMiddleware } from '#build/middleware'

// https://github.com/vuejs/router/blob/4a0cc8b9c1e642cdf47cc007fa5bbebde70afc66/packages/router/src/history/html5.ts#L37
function createCurrentLocation (
  base: string,
  location: Location,
  renderedPath?: string,
): string {
  const { pathname, search, hash } = location
  // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end
  const hashPos = base.indexOf('#')
  if (hashPos > -1) {
    const slicePos = hash.includes(base.slice(hashPos))
      ? base.slice(hashPos).length
      : 1
    let pathFromHash = hash.slice(slicePos)
    // prepend the starting slash to hash so the url starts with /#
    if (pathFromHash[0] !== '/') { pathFromHash = '/' + pathFromHash }
    return withoutBase(pathFromHash, '')
  }
  const displayedPath = withoutBase(pathname, base)
  const path = !renderedPath || isSamePath(displayedPath, renderedPath) ? displayedPath : renderedPath
  return path + (path.includes('?') ? '' : search) + hash
}

const plugin: Plugin<{ router: Router }> = defineNuxtPlugin({
  name: 'nuxt:router',
  enforce: 'pre',
  async setup (nuxtApp) {
    let routerBase = useRuntimeConfig().app.baseURL
    if (hashMode && !routerBase.includes('#')) {
      // allow the user to provide a `#` in the middle: `/base/#/app`
      routerBase += '#'
    }

    const history = routerOptions.history?.(routerBase) ?? (import.meta.client
      ? (hashMode ? createWebHashHistory(routerBase) : createWebHistory(routerBase))
      : createMemoryHistory(routerBase)
    )

    const routes = routerOptions.routes ? await routerOptions.routes(_routes) ?? _routes : _routes

    let startPosition: Parameters<RouterScrollBehavior>[2] | null

    const router = createRouter({
      ...routerOptions,
      scrollBehavior: (to, from, savedPosition) => {
        if (from === START_LOCATION) {
          startPosition = savedPosition
          return
        }
        if (routerOptions.scrollBehavior) {
          // reset scroll behavior to initial value
          router.options.scrollBehavior = routerOptions.scrollBehavior
          if ('scrollRestoration' in window.history) {
            const unsub = router.beforeEach(() => {
              unsub()
              window.history.scrollRestoration = 'manual'
            })
          }
          return routerOptions.scrollBehavior(to, START_LOCATION, startPosition || savedPosition)
        }
      },
      history,
      routes,
    })

    if (import.meta.hot) {
      handleHotUpdate(router, routerOptions.routes ? routerOptions.routes : routes => routes)
    }

    if (import.meta.client && 'scrollRestoration' in window.history) {
      window.history.scrollRestoration = 'auto'
    }
    nuxtApp.vueApp.use(router)

    const previousRoute = shallowRef(router.currentRoute.value)
    router.afterEach((_to, from) => {
      previousRoute.value = from
    })

    Object.defineProperty(nuxtApp.vueApp.config.globalProperties, 'previousRoute', {
      get: () => previousRoute.value,
    })

    const initialURL = import.meta.server
      ? nuxtApp.ssrContext!.url
      : createCurrentLocation(routerBase, window.location, nuxtApp.payload.path)

    // Allows suspending the route object until page navigation completes
    const _route = shallowRef(router.currentRoute.value)
    const syncCurrentRoute = () => { _route.value = router.currentRoute.value }
    router.afterEach((to, from) => {
      // We won't trigger suspense if the component is reused between routes
      // so we need to update the route manually
      if (to.matched.at(-1)?.components?.default === from.matched.at(-1)?.components?.default) {
        syncCurrentRoute()
      }
    })

    // https://github.com/vuejs/router/blob/8487c3e18882a0883e464a0f25fb28fa50eeda38/packages/router/src/router.ts#L1283-L1289
    const route = { sync: syncCurrentRoute } as NuxtApp['_route']
    for (const key in _route.value) {
      Object.defineProperty(route, key, {
        get: () => _route.value[key as keyof RouteLocationNormalizedLoadedGeneric],
        enumerable: true,
      })
    }

    nuxtApp._route = shallowReactive(route)

    nuxtApp._middleware ||= {
      global: [],
      named: {},
    }

    const error = useError()
    if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {
      router.afterEach(async (to, _from, failure) => {
        delete nuxtApp._processingMiddleware

        if (import.meta.client && !nuxtApp.isHydrating && error.value) {
          // Clear any existing errors
          await nuxtApp.runWithContext(clearError)
        }
        if (failure) {
          await nuxtApp.callHook('page:loading:end')
        }
        if (import.meta.server && failure?.type === 4 /* ErrorTypes.NAVIGATION_ABORTED */) {
          return
        }

        if (import.meta.server && to.redirectedFrom && to.fullPath !== initialURL) {
          await nuxtApp.runWithContext(() => navigateTo(to.fullPath || '/'))
        }
      })
    }

    try {
      if (import.meta.server) {
        await router.push(initialURL)
      }
      await router.isReady()
    } catch (error: any) {
      // We'll catch 404s here
      await nuxtApp.runWithContext(() => showError(error))
    }

    const resolvedInitialRoute = import.meta.client && initialURL !== router.currentRoute.value.fullPath
      ? router.resolve(initialURL)
      : router.currentRoute.value
    syncCurrentRoute()

    if (import.meta.server && nuxtApp.ssrContext?.islandContext) {
      // We're in an island context, and don't need to handle middleware or redirections
      return { provide: { router } }
    }

    const initialLayout = nuxtApp.payload.state._layout
    router.beforeEach(async (to, from) => {
      await nuxtApp.callHook('page:loading:start')
      to.meta = reactive(to.meta)
      if (nuxtApp.isHydrating && initialLayout && !isReadonly(to.meta.layout)) {
        to.meta.layout = initialLayout as Exclude<PageMeta['layout'], Ref | false>
      }
      nuxtApp._processingMiddleware = true

      if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {
        type MiddlewareDef = string | RouteMiddleware
        const middlewareEntries = new Set<MiddlewareDef>([...globalMiddleware, ...nuxtApp._middleware.global])
        for (const component of to.matched) {
          const componentMiddleware = component.meta.middleware as MiddlewareDef | MiddlewareDef[]
          if (!componentMiddleware) { continue }
          for (const entry of toArray(componentMiddleware)) {
            middlewareEntries.add(entry)
          }
        }

        const routeRules = getRouteRules({ path: to.path })

        if (routeRules.appMiddleware) {
          for (const key in routeRules.appMiddleware) {
            if (routeRules.appMiddleware[key]) {
              middlewareEntries.add(key)
            } else {
              middlewareEntries.delete(key)
            }
          }
        }

        for (const entry of middlewareEntries) {
          const middleware: RouteMiddleware = typeof entry === 'string' ? nuxtApp._middleware.named[entry] || await namedMiddleware[entry]?.().then((r: any) => r.default || r) : entry

          if (!middleware) {
            if (import.meta.dev) {
              throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map(mw => `'${mw}'`).join(', ')}.`)
            }
            throw new Error(`Unknown route middleware: '${entry}'.`)
          }

          try {
            if (import.meta.dev) {
              nuxtApp._processingMiddleware = (middleware as any)._path || (typeof entry === 'string' ? entry : true)
            }
            const result = await nuxtApp.runWithContext(() => middleware(to, from))
            if (import.meta.server || (!nuxtApp.payload.serverRendered && nuxtApp.isHydrating)) {
              if (result === false || result instanceof Error) {
                const error = result || createError({
                  status: 404,
                  statusText: `Page Not Found: ${initialURL}`,
                })
                await nuxtApp.runWithContext(() => showError(error))
                return false
              }
            }

            if (result === true) { continue }
            if (result === false) {
              return result
            }
            if (result) {
              if (isNuxtError(result) && result.fatal) {
                await nuxtApp.runWithContext(() => showError(result))
              }
              return result
            }
          } catch (err: any) {
            const error = createError(err)
            if (error.fatal) {
              await nuxtApp.runWithContext(() => showError(error))
            }
            return error
          }
        }
      }
    })

    router.onError(async () => {
      delete nuxtApp._processingMiddleware
      await nuxtApp.callHook('page:loading:end')
    })

    router.afterEach((to) => {
      if (to.matched.length === 0) {
        return nuxtApp.runWithContext(() => showError(createError({
          status: 404,
          fatal: false,
          statusText: `Page not found: ${to.fullPath}`,
          data: {
            path: to.fullPath,
          },
        })))
      }
    })

    nuxtApp.hooks.hookOnce('app:created', async () => {
      try {
        // #4920, #4982
        if ('name' in resolvedInitialRoute) {
          resolvedInitialRoute.name = undefined
        }
        await router.replace({
          ...resolvedInitialRoute,
          force: true,
        })
        // reset scroll behavior to initial value
        router.options.scrollBehavior = routerOptions.scrollBehavior
      } catch (error: any) {
        // We'll catch middleware errors or deliberate exceptions here
        await nuxtApp.runWithContext(() => showError(error))
      }
    })

    return { provide: { router } }
  },
})

export default plugin
</file>

<file path="packages/nuxt/src/pages/runtime/app.vue">
<template>
  <NuxtLayout>
    <NuxtRouteAnnouncer />
    <NuxtPage />
  </NuxtLayout>
</template>
</file>

<file path="packages/nuxt/src/pages/runtime/component-stub.ts">
export default {}
</file>

<file path="packages/nuxt/src/pages/runtime/composables.ts">
import type { KeepAliveProps, TransitionProps, UnwrapRef } from 'vue'
import { getCurrentInstance } from 'vue'
import type { RouteLocationNormalized, RouteLocationNormalizedLoaded, RouteRecordRaw, RouteRecordRedirectOption } from 'vue-router'
import { useRoute } from 'vue-router'
import type { NitroRouteConfig } from 'nitropack/types'
import type { NuxtError } from 'nuxt/app'
import { useNuxtApp } from '#app/nuxt'
import type { SerializableValue } from './utils'

// Generated at runtime to be extended
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface NuxtLayouts {

}

export interface PageMeta {
  [key: string]: unknown
  /**
   * Validate whether a given route can validly be rendered with this page.
   *
   * Return true if it is valid, or false if not. If another match can't be found,
   * this will mean a 404. You can also directly return an object with
   * status/statusText to respond immediately with an error (other matches
   * will not be checked).
   */
  validate?: (route: RouteLocationNormalized) => boolean | Partial<NuxtError> | Promise<boolean | Partial<NuxtError>>
  /**
   * Where to redirect if the route is directly matched. The redirection happens
   * before any navigation guard and triggers a new navigation with the new
   * target location.
   */
  redirect?: RouteRecordRedirectOption
  /**
   * Aliases for the record. Allows defining extra paths that will behave like a
   * copy of the record. Allows having paths shorthands like `/users/:id` and
   * `/u/:id`. All `alias` and `path` values must share the same params.
   */
  alias?: string | string[]
  pageTransition?: boolean | TransitionProps
  layoutTransition?: boolean | TransitionProps
  key?: false | string | ((route: RouteLocationNormalizedLoaded) => string)
  keepalive?: boolean | KeepAliveProps
  /** You may define a name for this page's route. */
  name?: string
  /** You may define a path matcher, if you have a more complex pattern than can be expressed with the file name. */
  path?: string
  /** Route groups based on the file path, like `/(protected)/users/profile` -> ['protected'] */
  groups?: string[]
  /**
   * Allows accessing the route `params` as props passed to the page component.
   * @see https://router.vuejs.org/guide/essentials/passing-props
   */
  props?: RouteRecordRaw['props']
  /** Set to `false` to avoid scrolling to top on page navigations */
  scrollToTop?: boolean | ((to: RouteLocationNormalizedLoaded, from: RouteLocationNormalizedLoaded) => boolean)
}

declare module 'vue-router' {

  interface RouteMeta extends UnwrapRef<PageMeta> {
    /**
     * @internal
     */
    layoutProps?: Record<string, SerializableValue>
  }
}

const warnRuntimeUsage = (method: string) => {
  console.warn(
    `${method}() is a compiler-hint helper that is only usable inside ` +
    'the script block of a single file component which is also a page. Its arguments should be ' +
    'compiled away and passing it at runtime has no effect.',
  )
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export const definePageMeta = (meta: PageMeta): void => {
  if (import.meta.dev) {
    const component = getCurrentInstance()?.type
    try {
      const isRouteComponent = component && useRoute().matched.some(p => Object.values(p.components || {}).includes(component))
      const isRenderingServerPage = import.meta.server && useNuxtApp().ssrContext?.islandContext
      if (isRouteComponent || isRenderingServerPage || ((component as any)?.__clientOnlyPage)) {
        // don't warn if it's being used in a route component (or server page)
        return
      }
    } catch {
      // ignore any errors with accessing current instance or route
    }
    warnRuntimeUsage('definePageMeta')
  }
}

/**
 * You can define route rules for the current page. Matching route rules will be created, based on the page's _path_.
 *
 * For example, a rule defined in `~/pages/foo/bar.vue` will be applied to `/foo/bar` requests. A rule in
 * `~/pages/foo/[id].vue` will be applied to `/foo/**` requests.
 *
 * For more control, such as if you are using a custom `path` or `alias` set in the page's `definePageMeta`, you
 * should set `routeRules` directly within your `nuxt.config`.
 */
/* @__NO_SIDE_EFFECTS__ */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export const defineRouteRules = (rules: NitroRouteConfig): void => {}
</file>

<file path="packages/nuxt/src/pages/runtime/index.ts">
export { definePageMeta, defineRouteRules } from './composables'
export type { PageMeta, NuxtLayouts } from './composables'
export type { NuxtPageProps } from './page'
</file>

<file path="packages/nuxt/src/pages/runtime/page-placeholder.ts">
import { defineComponent } from 'vue'
// @ts-expect-error virtual file
import { devPagesDir } from '#build/nuxt.config.mjs'

export default defineComponent({
  name: 'NuxtPage',
  setup (_, props) {
    if (import.meta.dev) {
      console.warn(`Create a Vue component in the \`${devPagesDir}/\` directory to enable \`<NuxtPage>\``)
    }
    return () => props.slots.default?.()
  },
})
</file>

<file path="packages/nuxt/src/pages/runtime/page.ts">
import { Fragment, Suspense, defineComponent, h, inject, nextTick, onBeforeUnmount, ref, watch } from 'vue'
import type { AllowedComponentProps, Component, ComponentCustomProps, ComponentPublicInstance, KeepAliveProps, Slot, TransitionProps, VNode, VNodeProps } from 'vue'
import { RouterView } from 'vue-router'
import { defu } from 'defu'
import type { RouteLocationNormalized, RouteLocationNormalizedLoaded, RouterViewProps } from 'vue-router'

import { generateRouteKey, toArray, wrapInKeepAlive } from './utils'
import type { RouterViewSlotProps } from './utils'
import { RouteProvider, defineRouteProvider } from '#app/components/route-provider'
import { useNuxtApp } from '#app/nuxt'
import { useRouter } from '#app/composables/router'
import { _wrapInTransition } from '#app/components/utils'
import { LayoutMetaSymbol, PageRouteSymbol } from '#app/components/injections'
// @ts-expect-error virtual file
import { appKeepalive as defaultKeepaliveConfig, appPageTransition as defaultPageTransition } from '#build/nuxt.config.mjs'

export interface NuxtPageProps extends RouterViewProps {
  /**
   * Define global transitions for all pages rendered with the `NuxtPage` component.
   */
  transition?: boolean | TransitionProps

  /**
   * Control state preservation of pages rendered with the `NuxtPage` component.
   */
  keepalive?: boolean | KeepAliveProps

  /**
   * Control when the `NuxtPage` component is re-rendered.
   */
  pageKey?: string | ((route: RouteLocationNormalizedLoaded) => string)
}

const _routeProviders = import.meta.dev ? new Map<string, ReturnType<typeof defineRouteProvider> | undefined>() : new WeakMap<Component, ReturnType<typeof defineRouteProvider> | undefined>()

export default defineComponent({
  name: 'NuxtPage',
  inheritAttrs: false,
  props: {
    name: {
      type: String,
    },
    transition: {
      type: [Boolean, Object] as any as () => boolean | TransitionProps,
      default: undefined,
    },
    keepalive: {
      type: [Boolean, Object] as any as () => boolean | KeepAliveProps,
      default: undefined,
    },
    route: {
      type: Object as () => RouteLocationNormalized,
    },
    pageKey: {
      type: [Function, String] as unknown as () => string | ((route: RouteLocationNormalizedLoaded) => string),
      default: null,
    },
  },
  setup (props, { attrs, slots, expose }) {
    const nuxtApp = useNuxtApp()
    const pageRef = ref()
    const forkRoute = inject(PageRouteSymbol, null)
    let previousPageKey: string | undefined | false

    expose({ pageRef })

    const _layoutMeta = inject(LayoutMetaSymbol, null)
    let vnode: VNode

    const done = nuxtApp.deferHydration()
    if (import.meta.client && nuxtApp.isHydrating) {
      const removeErrorHook = nuxtApp.hooks.hookOnce('app:error', done)
      useRouter().beforeEach(removeErrorHook)
    }

    if (import.meta.client && props.pageKey) {
      watch(() => props.pageKey, (next, prev) => {
        if (next !== prev) {
          nuxtApp.callHook('page:loading:start')
        }
      })
    }

    if (import.meta.dev) {
      nuxtApp._isNuxtPageUsed = true
    }

    let pageLoadingEndHookAlreadyCalled = false
    if (import.meta.client) {
      const unsub = useRouter().beforeResolve(() => {
        pageLoadingEndHookAlreadyCalled = false
      })
      onBeforeUnmount(() => {
        unsub()
      })
    }

    return () => {
      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {
        default: import.meta.server
          ? (routeProps: RouterViewSlotProps) => {
              return h(Suspense, { suspensible: true }, {
                default () {
                  return h(RouteProvider, {
                    vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,
                    route: routeProps.route,
                    vnodeRef: pageRef,
                  })
                },
              })
            }
          : (routeProps: RouterViewSlotProps) => {
              const isRenderingNewRouteInOldFork = haveParentRoutesRendered(forkRoute, routeProps.route, routeProps.Component)
              const hasSameChildren = forkRoute && forkRoute.matched.length === routeProps.route.matched.length

              if (!routeProps.Component) {
              // If we're rendering a `<NuxtPage>` child route on navigation to a route which lacks a child page
              // we'll render the old vnode until the new route finishes resolving
                if (vnode && !hasSameChildren) {
                  return vnode
                }
                done()
                return
              }

              // Return old vnode if we are rendering _new_ page suspense fork in _old_ layout suspense fork
              if (vnode && _layoutMeta && !_layoutMeta.isCurrent(routeProps.route)) {
                return vnode
              }

              if (isRenderingNewRouteInOldFork && forkRoute && (!_layoutMeta || _layoutMeta?.isCurrent(forkRoute))) {
              // if leaving a route with an existing child route, render the old vnode
                if (hasSameChildren) {
                  return vnode
                }
                // If _leaving_ null child route, return null vnode
                return null
              }

              const key = generateRouteKey(routeProps, props.pageKey)

              const willRenderAnotherChild = hasChildrenRoutes(forkRoute, routeProps.route, routeProps.Component)
              if (!nuxtApp.isHydrating && previousPageKey === key && !willRenderAnotherChild) {
                nextTick(() => {
                  if (!pageLoadingEndHookAlreadyCalled) {
                    pageLoadingEndHookAlreadyCalled = true
                    nuxtApp.callHook('page:loading:end')
                  }
                })
              }

              previousPageKey = key

              const hasTransition = !!(props.transition ?? routeProps.route.meta.pageTransition ?? defaultPageTransition)
              const transitionProps = hasTransition && _mergeTransitionProps([
                props.transition,
                routeProps.route.meta.pageTransition,
                defaultPageTransition,
                {
                  onAfterLeave () {
                    delete nuxtApp._runningTransition
                    nuxtApp.callHook('page:transition:finish', routeProps.Component)
                  },
                },
              ])

              const keepaliveConfig = props.keepalive ?? routeProps.route.meta.keepalive ?? (defaultKeepaliveConfig as KeepAliveProps)
              vnode = _wrapInTransition(hasTransition && transitionProps,
                wrapInKeepAlive(keepaliveConfig, h(Suspense, {
                  suspensible: true,
                  onPending: () => {
                    if (hasTransition) { nuxtApp._runningTransition = true }
                    nuxtApp.callHook('page:start', routeProps.Component)
                  },
                  onResolve: async () => {
                    await nextTick()
                    try {
                      nuxtApp._route.sync?.()
                      await nuxtApp.callHook('page:finish', routeProps.Component)
                      delete nuxtApp._runningTransition
                      if (!pageLoadingEndHookAlreadyCalled && !willRenderAnotherChild) {
                        pageLoadingEndHookAlreadyCalled = true
                        await nuxtApp.callHook('page:loading:end')
                      }
                    } finally {
                      done()
                    }
                  },
                }, {
                  default: () => {
                    const routeProviderProps = {
                      key: key || undefined,
                      vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,
                      route: routeProps.route,
                      renderKey: key || undefined,
                      trackRootNodes: hasTransition,
                      vnodeRef: pageRef,
                    }

                    if (!keepaliveConfig) {
                      return h(RouteProvider, routeProviderProps)
                    }

                    const routerComponentType = routeProps.Component.type as any
                    const routeProviderKey = import.meta.dev ? routerComponentType.name || routerComponentType.__name : routerComponentType
                    let PageRouteProvider = _routeProviders.get(routeProviderKey)

                    if (!PageRouteProvider) {
                      PageRouteProvider = defineRouteProvider(routerComponentType.name || routerComponentType.__name)
                      _routeProviders.set(routeProviderKey, PageRouteProvider)
                    }

                    return h(PageRouteProvider, routeProviderProps)
                  },
                }),
                )).default()

              return vnode
            },
      })
    }
  },
}) as unknown as {
  new(): {
    $props: AllowedComponentProps &
      ComponentCustomProps &
      VNodeProps &
      NuxtPageProps

    $slots: {
      default?: (routeProps: RouterViewSlotProps) => VNode[]
    }

    // expose
    /**
     * Reference to the page component instance
     */
    pageRef: Element | ComponentPublicInstance | null
  }
}

function _mergeTransitionProps (routeProps: TransitionProps[]): TransitionProps {
  const _props: TransitionProps[] = []
  for (const prop of routeProps) {
    if (!prop) { continue }
    _props.push({
      ...prop,
      onAfterLeave: prop.onAfterLeave ? toArray(prop.onAfterLeave) : undefined,
    })
  }
  return defu(..._props as [TransitionProps, TransitionProps])
}

function haveParentRoutesRendered (fork: RouteLocationNormalizedLoaded | null, newRoute: RouteLocationNormalizedLoaded, Component?: VNode) {
  if (!fork) { return false }

  const index = newRoute.matched.findIndex(m => m.components?.default === Component?.type)
  if (!index || index === -1) { return false }

  // we only care whether the parent route components have had to rerender
  return newRoute.matched.slice(0, index)
    .some(
      (c, i) => c.components?.default !== fork.matched[i]?.components?.default) ||
    (Component && generateRouteKey({ route: newRoute, Component }) !== generateRouteKey({ route: fork, Component }))
}

function hasChildrenRoutes (fork: RouteLocationNormalizedLoaded | null, newRoute: RouteLocationNormalizedLoaded, Component?: VNode) {
  if (!fork) { return false }

  const index = newRoute.matched.findIndex(m => m.components?.default === Component?.type)
  return index < newRoute.matched.length - 1
}

function normalizeSlot (slot: Slot, data: RouterViewSlotProps) {
  const slotContent = slot(data)
  return slotContent.length === 1 ? h(slotContent[0]!) : h(Fragment, undefined, slotContent)
}
</file>

<file path="packages/nuxt/src/pages/runtime/router.options.ts">
import { START_LOCATION } from 'vue-router'
import type { RouteLocationNormalized, RouterScrollBehavior } from 'vue-router'
import type { RouterConfig } from 'nuxt/schema'
import { useNuxtApp } from '#app/nuxt'
import { isChangingPage } from '#app/components/utils'
import { useRouter } from '#app/composables/router'

type ScrollPosition = Awaited<ReturnType<RouterScrollBehavior>>

// Default router options
// https://router.vuejs.org/api/interfaces/routeroptions
export default <RouterConfig> {
  scrollBehavior (to, from, savedPosition) {
    const nuxtApp = useNuxtApp()
    // @ts-expect-error untyped, nuxt-injected option
    const hashScrollBehaviour = useRouter().options?.scrollBehaviorType ?? 'auto'

    // Hash routes on the same page, no page hook is fired so resolve here
    if (to.path.replace(/\/$/, '') === from.path.replace(/\/$/, '')) {
      if (from.hash && !to.hash) {
        return { left: 0, top: 0 }
      }
      if (to.hash) {
        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior: hashScrollBehaviour }
      }
      // The route isn't changing so keep current scroll position
      return false
    }

    const routeAllowsScrollToTop = typeof to.meta.scrollToTop === 'function' ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop

    if (routeAllowsScrollToTop === false) { return false }

    const hookToWait = nuxtApp._runningTransition ? 'page:transition:finish' : 'page:loading:end'

    return new Promise((resolve) => {
      if (from === START_LOCATION) {
        resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour))
        return
      }

      nuxtApp.hooks.hookOnce(hookToWait, () => {
        requestAnimationFrame(() => resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour)))
      })
    })
  },
}

function _getHashElementScrollMarginTop (selector: string): number {
  try {
    const elem = document.querySelector(selector)
    if (elem) {
      return (Number.parseFloat(getComputedStyle(elem).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle(document.documentElement).scrollPaddingTop) || 0)
    }
  } catch {
    // ignore any errors parsing scrollMarginTop
  }
  return 0
}

function _calculatePosition (
  to: RouteLocationNormalized,
  from: RouteLocationNormalized,
  savedPosition: ScrollPosition | null,
  defaultHashScrollBehaviour: ScrollBehavior,
): ScrollPosition {
  // By default when the returned position is falsy or an empty object, vue-router will retain the current scroll position
  // savedPosition is only available for popstate navigations (back button)
  if (savedPosition) {
    return savedPosition
  }

  const isPageNavigation = isChangingPage(to, from)

  // Scroll to the element specified in the URL hash, if present
  if (to.hash) {
    return {
      el: to.hash,
      top: _getHashElementScrollMarginTop(to.hash),
      behavior: isPageNavigation ? defaultHashScrollBehaviour : 'instant',
    }
  }

  return {
    left: 0,
    top: 0,
  }
}
</file>

<file path="packages/nuxt/src/pages/runtime/utils.ts">
import { KeepAlive, h } from 'vue'
import type { RouteLocationMatched, RouteLocationNormalizedLoaded, RouterView } from 'vue-router'

type InstanceOf<T> = T extends new (...args: any[]) => infer R ? R : never
type RouterViewSlot = Exclude<InstanceOf<typeof RouterView>['$slots']['default'], undefined>
export type RouterViewSlotProps = Parameters<RouterViewSlot>[0]

type SerializablePrimitive = string | number | boolean | null | undefined

/** JSON-serializable value (non-recursive definition to avoid excessive type depth) */
export type SerializableValue = SerializablePrimitive | SerializablePrimitive[] | Record<string, unknown>

/** Constrains T to only contain serializable properties. Non-serializable properties become `never`. */
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
export type MakeSerializableObject<T> = T extends Function | symbol ? never : {
  [K in keyof T]: T[K] extends SerializablePrimitive
    ? T[K]
    : T[K] extends (infer U)[]
      ? U extends SerializablePrimitive ? T[K] : never
      : T[K] extends Record<string, unknown>
        ? T[K]
        : never
}

const ROUTE_KEY_PARENTHESES_RE = /(:\w+)\([^)]+\)/g
const ROUTE_KEY_SYMBOLS_RE = /(:\w+)[?+*]/g
const ROUTE_KEY_NORMAL_RE = /:\w+/g
const interpolatePath = (route: RouteLocationNormalizedLoaded, match: RouteLocationMatched) => {
  return match.path
    .replace(ROUTE_KEY_PARENTHESES_RE, '$1')
    .replace(ROUTE_KEY_SYMBOLS_RE, '$1')
    .replace(ROUTE_KEY_NORMAL_RE, r => route.params[r.slice(1)]?.toString() || '')
}

export const generateRouteKey = (routeProps: RouterViewSlotProps, override?: string | ((route: RouteLocationNormalizedLoaded) => string)) => {
  const matchedRoute = routeProps.route.matched.find(m => m.components?.default === routeProps.Component.type)
  const source = override ?? matchedRoute?.meta.key ?? (matchedRoute && interpolatePath(routeProps.route, matchedRoute))
  return typeof source === 'function' ? source(routeProps.route) : source
}

export const wrapInKeepAlive = (props: any, children: any) => {
  return { default: () => import.meta.client && props ? h(KeepAlive, props === true ? {} : props, children) : children }
}

/** @since 3.9.0 */
export function toArray<T> (value: T | T[]): T[] {
  return Array.isArray(value) ? value : [value]
}
</file>

<file path="packages/nuxt/src/pages/runtime/validate.ts">
import { createError } from '#app/composables/error'
import { defineNuxtRouteMiddleware } from '#app/composables/router'

export default defineNuxtRouteMiddleware(async (to, from) => {
  if (!to.meta?.validate) { return }

  const result = await Promise.resolve(to.meta.validate(to))
  if (result === true) {
    return
  }

  const error = createError({
    fatal: import.meta.client,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    status: (result && (result.status || result.statusCode)) || 404,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    statusText: (result && (result.statusText || result.statusMessage)) || `Page Not Found: ${to.fullPath}`,
    data: {
      path: to.fullPath,
    },
  })

  // We pretend to have navigated to the invalid route so
  // that the user can return to the previous page with
  // the back button.
  if (typeof window !== 'undefined') {
    window.history.pushState({}, '', from.fullPath)
  }

  return error
})
</file>

<file path="packages/nuxt/src/pages/build.d.ts">
declare module '#build/router.options.mjs' {
  import type { RouterOptions } from '@nuxt/schema'

  export const hashMode: boolean
  const _default: RouterOptions
  export default _default
}

declare module '#build/routes' {
  import type { RouterOptions } from '@nuxt/schema'
  import type { Router, RouterOptions as VueRouterOptions } from 'vue-router'

  export const handleHotUpdate: (_router: Router, _generateRoutes: RouterOptions['routes']) => void

  const _default: VueRouterOptions['routes']
  export default _default
}
</file>

<file path="packages/nuxt/src/pages/module.ts">
import { existsSync, readdirSync } from 'node:fs'
import { mkdir, readFile } from 'node:fs/promises'
import { addBuildPlugin, addComponent, addPlugin, addTemplate, addTypeTemplate, defineNuxtModule, findPath, getLayerDirectories, resolvePath, useNitro } from '@nuxt/kit'
import { dirname, join, relative, resolve } from 'pathe'
import { genImport, genObjectFromRawEntries, genSafeVariableName, genString } from 'knitwork'
import { joinURL } from 'ufo'
import { createRoutesContext } from 'unplugin-vue-router'
import { resolveOptions } from 'unplugin-vue-router/options'
import type { EditableTreeNode, Options as TypedRouterOptions } from 'unplugin-vue-router'
import { addRoute, createRouter as createRou3Router, findAllRoutes } from 'rou3'

import type { NitroRouteConfig, NitroRouteRules } from 'nitropack/types'
import { defu } from 'defu'
import { isEqual } from 'ohash'
import { distDir } from '../dirs.ts'
import { resolveTypePath } from '../core/utils/types.ts'
import { logger } from '../utils.ts'
import { resolvePagesRoutes as _resolvePagesRoutes, defaultExtractionKeys, normalizeRoutes, resolveRoutePaths, toRou3Patterns } from './utils.ts'
import { globRouteRulesFromPages, removePagesRules } from './route-rules.ts'
import { PageMetaPlugin } from './plugins/page-meta.ts'
import { RouteInjectionPlugin } from './plugins/route-injection.ts'
import type { Nuxt, NuxtPage } from 'nuxt/schema'
import type { InlinePreset } from 'unimport'

const OPTIONAL_PARAM_RE = /^\/?:.*(?:\?|\(\.\*\)\*)$/

const runtimeDir = resolve(distDir, 'pages/runtime')

export const pagesImportPresets: InlinePreset[] = [
  { imports: ['definePageMeta'], from: resolve(runtimeDir, 'composables') },
  { imports: ['useLink'], from: 'vue-router' },
]

export const routeRulesPresets: InlinePreset[] = [
  { imports: ['defineRouteRules'], from: resolve(runtimeDir, 'composables') },
]

async function resolveRouterOptions (nuxt: Nuxt, builtInRouterOptions: string) {
  const context = {
    files: [] as Array<{ path: string, optional?: boolean }>,
  }

  for (const layer of nuxt.options._layers) {
    const path = await findPath(resolve(layer.config.srcDir, layer.config.dir?.app || 'app', 'router.options'))
    if (path) { context.files.unshift({ path }) }
  }

  // Add default options at beginning
  context.files.unshift({ path: builtInRouterOptions, optional: true })

  await nuxt.callHook('pages:routerOptions', context)
  return context.files
}

export default defineNuxtModule({
  meta: {
    name: 'nuxt:pages',
    configKey: 'pages',
  },
  defaults: nuxt => ({
    enabled: typeof nuxt.options.pages === 'boolean' ? nuxt.options.pages : undefined as undefined | boolean,
    pattern: `**/*{${nuxt.options.extensions.join(',')}}` as string | string[],
  }),
  async setup (_options, nuxt) {
    const options = typeof _options === 'boolean' ? { enabled: _options ?? nuxt.options.pages, pattern: `**/*{${nuxt.options.extensions.join(',')}}` } : { ..._options }
    options.pattern = Array.isArray(options.pattern) ? [...new Set(options.pattern)] : options.pattern

    let inlineRulesCache: Record<string, NitroRouteConfig> = {}
    let updateRouteConfig: (inlineRules: Record<string, NitroRouteConfig>) => void | Promise<void>
    if (nuxt.options.experimental.inlineRouteRules) {
      nuxt.hook('nitro:init', (nitro) => {
        updateRouteConfig = async (inlineRules) => {
          if (!isEqual(inlineRulesCache, inlineRules)) {
            await nitro.updateConfig({ routeRules: defu(inlineRules, nitro.options._config.routeRules) })
            inlineRulesCache = inlineRules
          }
        }
      })
    }

    const resolvePagesRoutes = async (pattern: string | string[], nuxt: Nuxt) => {
      const pages = await _resolvePagesRoutes(pattern, nuxt)

      if (nuxt.options.experimental.inlineRouteRules) {
        const routeRules = globRouteRulesFromPages(pages)
        await updateRouteConfig?.(routeRules)
      } else {
        // also remove rules when disabled
        removePagesRules(pages)
      }

      return pages
    }

    const useExperimentalTypedPages = nuxt.options.experimental.typedPages
    const builtInRouterOptions = await findPath(resolve(runtimeDir, 'router.options')) || resolve(runtimeDir, 'router.options')

    const pagesDirs = getLayerDirectories(nuxt).map(dirs => dirs.appPages)

    nuxt.options.alias['#vue-router'] = 'vue-router'
    const routerPath = await resolveTypePath('vue-router', '', nuxt.options.modulesDir) || 'vue-router'
    nuxt.hook('prepare:types', ({ tsConfig }) => {
      tsConfig.compilerOptions ||= {}
      tsConfig.compilerOptions.paths ||= {}
      tsConfig.compilerOptions.paths['#vue-router'] = [routerPath]
      delete tsConfig.compilerOptions.paths['#vue-router/*']
    })

    // Disable module (and use universal router) if pages dir do not exists or user has disabled it
    const isNonEmptyDir = (dir: string) => existsSync(dir) && readdirSync(dir).length
    const userPreference = options.enabled
    const isPagesEnabled = async () => {
      if (typeof userPreference === 'boolean') {
        return userPreference
      }
      const routerOptionsFiles = await resolveRouterOptions(nuxt, builtInRouterOptions)
      if (routerOptionsFiles.filter(p => !p.optional).length > 0) {
        return true
      }
      if (pagesDirs.some(dir => isNonEmptyDir(dir))) {
        return true
      }

      const pages = await resolvePagesRoutes(options.pattern, nuxt)
      if (pages.length) {
        if (nuxt.apps.default) {
          nuxt.apps.default.pages = pages
        }
        return true
      }

      return false
    }
    options.enabled = await isPagesEnabled()
    nuxt.options.pages = options
    // For backwards compatibility with `@nuxtjs/i18n` and other modules that serialize `nuxt.options.pages` directly
    // TODO: remove in a future major
    Object.defineProperty(nuxt.options.pages, 'toString', {
      enumerable: false,
      get: () => () => options.enabled,
    })

    if (nuxt.options.dev && options.enabled) {
      // Add plugin to check if pages are enabled without NuxtPage being instantiated
      addPlugin(resolve(runtimeDir, 'plugins/check-if-page-unused'))
    }

    nuxt.hook('app:templates', (app) => {
      if (!nuxt.options.ssr && app.pages?.some(p => p.mode === 'server')) {
        logger.warn('Using server pages with `ssr: false` is not supported with auto-detected component islands. Set `experimental.componentIslands` to `true`.')
      }
    })

    // Restart Nuxt when pages dir is added or removed
    const restartPaths = nuxt.options._layers.flatMap((layer) => {
      const pagesDir = (layer.config.rootDir === nuxt.options.rootDir ? nuxt.options.dir : layer.config.dir)?.pages || 'pages'
      return [
        resolve(layer.config.srcDir || layer.cwd, layer.config.dir?.app || 'app', 'router.options.ts'),
        resolve(layer.config.srcDir || layer.cwd, pagesDir),
      ]
    })

    nuxt.hooks.hook('builder:watch', async (event, relativePath) => {
      const path = resolve(nuxt.options.srcDir, relativePath)
      if (restartPaths.some(p => p === path || path.startsWith(p + '/'))) {
        const newSetting = await isPagesEnabled()
        if (options.enabled !== newSetting) {
          logger.info('Pages', newSetting ? 'enabled' : 'disabled')
          return nuxt.callHook('restart')
        }
      }
    })

    if (!options.enabled) {
      addPlugin(resolve(distDir, 'app/plugins/router'))
      addTemplate({
        filename: 'pages.mjs',
        getContents: () => [
          'export { useRoute } from \'#app/composables/router\'',
          'export const START_LOCATION = Symbol(\'router:start-location\')',
        ].join('\n'),
      })
      // used by `<NuxtLink>`
      addTemplate({
        filename: 'router.options.mjs',
        getContents: () => {
          return [
            'export const hashMode = false',
            'export default {}',
          ].join('\n')
        },
      })
      addTypeTemplate({
        filename: 'types/middleware.d.ts',
        getContents: () => [
          'declare module \'nitropack/types\' {',
          '  interface NitroRouteConfig {',
          '    appMiddleware?: string | string[] | Record<string, boolean>',
          '  }',
          '}',
          'declare module \'nitropack\' {',
          '  interface NitroRouteConfig {',
          '    appMiddleware?: string | string[] | Record<string, boolean>',
          '  }',
          '}',
          'export {}',
        ].join('\n'),
      }, { nuxt: true, nitro: true, node: true })
      addComponent({
        name: 'NuxtPage',
        priority: 10, // built-in that we do not expect the user to override
        filePath: resolve(distDir, 'pages/runtime/page-placeholder'),
      })
      // Prerender index if pages integration is not enabled
      nuxt.hook('nitro:init', (nitro) => {
        if (nuxt.options.dev || !nuxt.options.ssr || !nitro.options.static || !nitro.options.prerender.crawlLinks) { return }

        nitro.options.prerender.routes.push('/')
      })
      return
    }

    if (useExperimentalTypedPages) {
      const declarationFile = resolve(nuxt.options.buildDir, 'types/typed-router.d.ts')

      const typedRouterOptions: TypedRouterOptions = {
        routesFolder: [],
        dts: declarationFile,
        logs: nuxt.options.debug && nuxt.options.debug.router,
        async beforeWriteFiles (rootPage) {
          for (const child of rootPage.children) {
            child.delete()
          }
          const pages = nuxt.apps.default?.pages || await resolvePagesRoutes(options.pattern, nuxt)
          if (nuxt.apps.default) {
            nuxt.apps.default.pages = pages
          }
          const addedPagePaths = new Set<string>()
          function addPage (parent: EditableTreeNode, page: NuxtPage, basePath: string = '') {
            // Avoid duplicate keys in the generated RouteNamedMap type
            const absolutePagePath = joinURL(basePath, page.path)

            // way to add a route without a file, which must be possible
            const route = addedPagePaths.has(absolutePagePath)
              ? parent
              : page.path[0] === '/'
                // @ts-expect-error TODO: either fix types upstream or figure out another
                // way to add a route without a file, which must be possible
                ? rootPage.insert(page.path, page.file)
                // @ts-expect-error TODO: either fix types upstream or figure out another
                // way to add a route without a file, which must be possible
                : parent.insert(page.path, page.file)

            addedPagePaths.add(absolutePagePath)
            if (page.meta) {
              route.addToMeta(page.meta)
            }
            if (page.alias) {
              route.addAlias(page.alias)
            }
            if (page.name) {
              route.name = page.name
            }
            // TODO: implement redirect support
            // if (page.redirect) {}
            if (page.children) {
              for (const child of page.children) {
                addPage(route, child, absolutePagePath)
              }
            }
          }

          for (const page of pages) {
            addPage(rootPage, page)
          }
        },
      }

      nuxt.hook('prepare:types', ({ references }) => {
        // This file will be generated by unplugin-vue-router
        references.push({ path: declarationFile })
        references.push({ types: 'unplugin-vue-router/client' })
      })

      const context = createRoutesContext(resolveOptions(typedRouterOptions))
      await mkdir(dirname(declarationFile), { recursive: true })
      await context.scanPages(false)

      if (nuxt.options._prepare || !nuxt.options.dev) {
        // TODO: could we generate this from context instead?
        const dts = await readFile(declarationFile, 'utf-8')
        addTemplate({
          filename: 'types/typed-router.d.ts',
          getContents: () => dts,
        })
      }

      // Regenerate types/typed-router.d.ts when adding or removing pages
      nuxt.hook('app:templatesGenerated', async (_app, _templates, options) => {
        if (!options?.filter || options.filter({ filename: 'routes.mjs' } as any)) {
          await context.scanPages()
        }
      })
    }

    // Add $router types
    nuxt.hook('prepare:types', ({ references }) => {
      references.push({ types: useExperimentalTypedPages ? 'vue-router/auto-routes' : 'vue-router' })
    })

    // Add vue-router route guard imports
    nuxt.hook('imports:sources', (sources) => {
      const routerImports = sources.find(s => s.from === '#app/composables/router' && s.imports.includes('onBeforeRouteLeave'))
      if (routerImports) {
        routerImports.from = 'vue-router'
      }
    })

    // Regenerate templates when adding or removing pages
    const updateTemplatePaths = getLayerDirectories(nuxt)
      .flatMap(dirs => [
        dirs.appPages,
        dirs.appLayouts,
        dirs.appMiddleware,
      ])

    function isPage (file: string, pages = nuxt.apps.default?.pages): boolean {
      if (!pages) { return false }
      return pages.some(page => page.file === file) || pages.some(page => page.children && isPage(file, page.children))
    }

    nuxt.hooks.hookOnce('app:templates', async (app) => {
      app.pages ||= await resolvePagesRoutes(options.pattern, nuxt)
    })

    nuxt.hook('builder:watch', async (event, relativePath) => {
      const path = resolve(nuxt.options.srcDir, relativePath)
      const shouldAlwaysRegenerate = nuxt.options.experimental.scanPageMeta && isPage(path)

      if (event === 'change' && !shouldAlwaysRegenerate) { return }

      if (shouldAlwaysRegenerate || updateTemplatePaths.some(dir => path.startsWith(dir))) {
        nuxt.apps.default!.pages = await resolvePagesRoutes(options.pattern, nuxt)
      }
    })

    nuxt.hook('app:resolve', (app) => {
      // Add default layout for pages
      if (app.mainComponent === resolve(nuxt.options.appDir, 'components/welcome.vue')) {
        app.mainComponent = resolve(runtimeDir, 'app.vue')
      }
      app.middleware.unshift({
        name: 'validate',
        path: resolve(runtimeDir, 'validate'),
        global: true,
      })
    })

    nuxt.hook('app:resolve', (app) => {
      const nitro = useNitro()
      if (nitro.options.prerender.crawlLinks || Object.values(nitro.options.routeRules).some(rule => rule.prerender)) {
        app.plugins.push({
          src: resolve(runtimeDir, 'plugins/prerender.server'),
          mode: 'server',
        })
      }
    })

    // Record all pages for use in prerendering
    const prerenderRoutes = new Set<string>()

    function processPages (pages: NuxtPage[], currentPath = '/') {
      for (const page of pages) {
        // Skip internal stub routes (redirects, test routes) from prerendering
        if (page._sync) { continue }

        // Add root of optional dynamic paths and catchalls
        if (OPTIONAL_PARAM_RE.test(page.path) && !page.children?.length) {
          prerenderRoutes.add(currentPath)
        }

        // Skip dynamic paths
        if (page.path.includes(':')) { continue }

        const route = joinURL(currentPath, page.path)
        prerenderRoutes.add(route)

        if (page.children) {
          processPages(page.children, route)
        }
      }
    }

    nuxt.hook('pages:resolved', (pages) => {
      if (nuxt.options.dev) { return }

      prerenderRoutes.clear()
      processPages(pages)
    })

    nuxt.hook('nitro:build:before', (nitro) => {
      if (nuxt.options.dev || nuxt.options.router.options.hashMode) { return }

      nitro.options.ssrRoutes = [
        ...nitro.options.ssrRoutes || [],
        ...toRou3Patterns(nuxt.apps.default?.pages || []),
      ]

      // Inject page patterns that explicitly match `prerender: true` route rule
      if (!nitro.options.static && !nitro.options.prerender.crawlLinks) {
        const routeRulesRouter = createRou3Router<NitroRouteRules>()
        for (const [route, rules] of Object.entries(nitro.options.routeRules)) {
          addRoute(routeRulesRouter, undefined, route, rules)
        }
        for (const route of prerenderRoutes) {
          const rules = defu({} as Record<string, any>, ...findAllRoutes(routeRulesRouter, undefined, route).reverse())
          if (rules.prerender) {
            nitro.options.prerender.routes.push(route)
          }
        }
      }

      if (!nitro.options.static || !nitro.options.prerender.crawlLinks) { return }

      // Only hint the first route when `ssr: true` and no routes are provided
      // as the rest will be injected at runtime when this is prerendered
      if (nuxt.options.ssr) {
        const [firstPage] = [...prerenderRoutes].sort()
        nitro.options.prerender.routes.push(firstPage || '/')
        return
      }

      // Prerender all non-dynamic page routes when generating `ssr: false` app
      for (const route of nitro.options.prerender.routes || []) {
        prerenderRoutes.add(route)
      }
      nitro.options.prerender.routes = Array.from(prerenderRoutes)
    })

    nuxt.hook('imports:sources', (sources) => {
      sources.push(...pagesImportPresets)
      if (nuxt.options.experimental.inlineRouteRules) {
        sources.push(...routeRulesPresets)
      }
    })

    const componentStubPath = await resolvePath(resolve(runtimeDir, 'component-stub'))
    if (nuxt.options.test && nuxt.options.dev) {
      // add component testing route so 404 won't be triggered
      nuxt.hook('pages:extend', (routes) => {
        routes.push({
          _sync: true,
          path: '/__nuxt_component_test__/:pathMatch(.*)',
          file: componentStubPath,
        })
      })
    }

    // Add all redirect paths as valid routes to router; we will handle these in a client-side middleware.
    nuxt.hook('pages:extend', (routes) => {
      const nitro = useNitro()
      let resolvedRoutes: string[]
      for (const [path, rule] of Object.entries(nitro.options.routeRules)) {
        if (!rule.redirect) { continue }
        resolvedRoutes ||= routes.flatMap(route => resolveRoutePaths(route))
        // skip if there's already a route matching this path
        if (resolvedRoutes.includes(path)) { continue }
        routes.push({
          _sync: true,
          path: path.replace(/\/[^/]*\*\*/, '/:pathMatch(.*)'),
          file: componentStubPath,
        })
      }
    })

    // Extract macros from pages
    const extraPageMetaExtractionKeys = nuxt.options?.experimental?.extraPageMetaExtractionKeys || []
    const extractedKeys = [
      ...defaultExtractionKeys,
      ...extraPageMetaExtractionKeys,
    ]

    nuxt.hook('modules:done', () => {
      addBuildPlugin(PageMetaPlugin({
        dev: nuxt.options.dev,
        sourcemap: !!nuxt.options.sourcemap.server || !!nuxt.options.sourcemap.client,
        isPage,
        routesPath: resolve(nuxt.options.buildDir, 'routes.mjs'),
        extractedKeys: nuxt.options.experimental.scanPageMeta ? extractedKeys : [],
      }))
    })

    // Add prefetching support for middleware & layouts
    addPlugin(resolve(runtimeDir, 'plugins/prefetch.client'))

    // Add build plugin to ensure template $route is kept in sync with `<NuxtPage>`
    if (nuxt.options.experimental.templateRouteInjection) {
      addBuildPlugin(RouteInjectionPlugin(nuxt), { server: false })
    }

    // Add router plugin
    addPlugin(resolve(runtimeDir, 'plugins/router'))

    const getSources = (pages: NuxtPage[]): string[] => pages
      .filter(p => Boolean(p.file))
      .flatMap(p =>
        [relative(nuxt.options.srcDir, p.file as string), ...(p.children?.length ? getSources(p.children) : [])],
      )

    // Do not prefetch page chunks
    nuxt.hook('build:manifest', (manifest) => {
      if (nuxt.options.dev) { return }
      const sourceFiles = nuxt.apps.default?.pages?.length ? getSources(nuxt.apps.default.pages) : []

      for (const [key, chunk] of Object.entries(manifest)) {
        if (chunk.src && Object.values(nuxt.apps).some(app => app.pages?.some(page => page.mode === 'server' && page.file === join(nuxt.options.srcDir, chunk.src!)))) {
          delete manifest[key]
          continue
        }
        if (chunk.isEntry) {
          chunk.dynamicImports =
            chunk.dynamicImports?.filter(i => !sourceFiles.includes(i))
        }
      }
    })

    const serverComponentRuntime = await findPath(join(distDir, 'components/runtime/server-component')) ?? join(distDir, 'components/runtime/server-component')
    const clientComponentRuntime = await findPath(join(distDir, 'components/runtime/client-component')) ?? join(distDir, 'components/runtime/client-component')

    // Add routes template
    addTemplate({
      filename: 'routes.mjs',
      getContents ({ app }) {
        if (!app.pages) { return ROUTES_HMR_CODE + 'export default []' }
        const { routes, imports } = normalizeRoutes(app.pages, new Set(), {
          serverComponentRuntime,
          clientComponentRuntime,
          overrideMeta: !!nuxt.options.experimental.scanPageMeta,
        })
        return ROUTES_HMR_CODE + [...imports, `export default ${routes}`].join('\n')
      },
    })

    // Add vue-router import for `<NuxtLayout>` integration
    addTemplate({
      filename: 'pages.mjs',
      getContents: () => 'export { START_LOCATION, useRoute } from \'vue-router\'',
    })

    nuxt.options.vite.resolve ||= {}
    nuxt.options.vite.resolve.dedupe ||= []
    nuxt.options.vite.resolve.dedupe.push('vue-router')

    // Add router options template
    addTemplate({
      filename: 'router.options.mjs',
      getContents: async ({ nuxt }) => {
        // Scan and register app/router.options files
        const routerOptionsFiles = await resolveRouterOptions(nuxt, builtInRouterOptions)

        const configRouterOptions = genObjectFromRawEntries(Object.entries(nuxt.options.router.options)
          .map(([key, value]) => [key, genString(value as string)]))

        const hashModes: string[] = []
        for (let index = 0; index < routerOptionsFiles.length; index++) {
          const file = routerOptionsFiles[index]!
          if (file.path !== builtInRouterOptions) {
            hashModes.unshift(`routerOptions${index}.hashMode`)
          }
        }

        return [
          ...routerOptionsFiles.map((file, index) => genImport(file.path, `routerOptions${index}`)),
          `const configRouterOptions = ${configRouterOptions}`,
          `export const hashMode = ${[
            ...hashModes,
            nuxt.options.router.options.hashMode,
          ].join(' ?? ')}`,
          'export default {',
          '...configRouterOptions,',
          ...routerOptionsFiles.map((_, index) => `...routerOptions${index},`),
          '}',
        ].join('\n')
      },
    })

    addTypeTemplate({
      filename: 'types/middleware.d.ts',
      getContents: ({ app }) => {
        const namedMiddleware = app.middleware.filter(mw => !mw.global)
        return [
          'import type { NavigationGuard } from \'vue-router\'',
          `export type MiddlewareKey = ${namedMiddleware.map(mw => genString(mw.name)).join(' | ') || 'never'}`,
          'declare module \'nuxt/app\' {',
          '  interface PageMeta {',
          '    middleware?: MiddlewareKey | NavigationGuard | Array<MiddlewareKey | NavigationGuard>',
          '  }',
          '}',
        ].join('\n')
      },
    })

    addTypeTemplate({
      filename: 'types/nitro-middleware.d.ts',
      getContents: ({ app }) => {
        const namedMiddleware = app.middleware.filter(mw => !mw.global)
        return [
          `export type MiddlewareKey = ${namedMiddleware.map(mw => genString(mw.name)).join(' | ') || 'never'}`,
          'declare module \'nitropack/types\' {',
          '  interface NitroRouteConfig {',
          '    appMiddleware?: MiddlewareKey | MiddlewareKey[] | Record<MiddlewareKey, boolean>',
          '  }',
          '}',
          'declare module \'nitropack\' {',
          '  interface NitroRouteConfig {',
          '    appMiddleware?: MiddlewareKey | MiddlewareKey[] | Record<MiddlewareKey, boolean>',
          '  }',
          '}',
        ].join('\n')
      },
    }, { nuxt: true, nitro: true, node: true })

    addTypeTemplate({
      filename: 'types/layouts.d.ts',
      getContents: ({ app }) => {
        const imports = new Set<string>()
        const interfaceKeyValues = new Map<string, string>()
        for (const layout of Object.values(app.layouts)) {
          const varName = genSafeVariableName(layout.name)
          imports.add(genImport(layout.file, varName))
          interfaceKeyValues.set(layout.name, varName)
        }

        return [
          ...Array.from(imports),
          'import type { ComputedRef, MaybeRef } from \'vue\'',
          'declare module \'nuxt/app\' {',
          '  interface NuxtLayouts {',
          ...Array.from(interfaceKeyValues.entries()).map(([key, value]) => `    '${key}': InstanceType<typeof ${value}>['$props'],`),
          '}',
          '  export type LayoutKey = keyof NuxtLayouts extends never ? string : keyof NuxtLayouts',
          '  interface PageMeta {',
          '    layout?: MaybeRef<LayoutKey | false> | ComputedRef<LayoutKey | false>',
          '  }',
          '}',
        ].join('\n')
      },
    })

    // add page meta types if enabled
    if (nuxt.options.experimental.viewTransition) {
      addTypeTemplate({
        filename: 'types/view-transitions.d.ts',
        getContents: () => {
          return [
            'declare module \'nuxt/app\' {',
            '  interface PageMeta {',
            '    viewTransition?: boolean | \'always\'',
            '  }',
            '}',
            'export {}',
          ].join('\n')
        },
      })
    }

    // Add <NuxtPage>
    addComponent({
      name: 'NuxtPage',
      priority: 10, // built-in that we do not expect the user to override
      filePath: resolve(distDir, 'pages/runtime/page'),
    })
  },
})

const ROUTES_HMR_CODE = /* js */`
if (import.meta.hot) {
  import.meta.hot.accept((mod) => {
    const router = import.meta.hot.data.router
    const generateRoutes = import.meta.hot.data.generateRoutes
    if (!router || !generateRoutes) {
      import.meta.hot.invalidate('[nuxt] Cannot replace routes because there is no active router. Reloading.')
      return
    }
    router.clearRoutes()
    const routes = generateRoutes(mod.default || mod)
    function addRoutes (routes) {
      for (const route of routes) {
        router.addRoute(route)
      }
      router.isReady().then(() => {
        // Resolve the current path against the new routes to get updated meta
        const newRoute = router.resolve(router.currentRoute.value.fullPath)
        // Clear old meta values and assign new ones
        for (const key of Object.keys(router.currentRoute.value.meta)) {
          delete router.currentRoute.value.meta[key]
        }
        Object.assign(router.currentRoute.value.meta, newRoute.meta)
      })
    }
    if (routes && 'then' in routes) {
      routes.then(addRoutes)
    } else {
      addRoutes(routes)
    }
  })
}

export function handleHotUpdate(_router, _generateRoutes) {
  if (import.meta.hot) {
    import.meta.hot.data ||= {}
    import.meta.hot.data.router = _router
    import.meta.hot.data.generateRoutes = _generateRoutes
  }
}
`
</file>

<file path="packages/nuxt/src/pages/route-rules.ts">
import type { NuxtPage } from '@nuxt/schema'
import type { NitroRouteConfig } from 'nitropack/types'

import { pathToNitroGlob } from './utils.ts'

export function globRouteRulesFromPages (pages: NuxtPage[], paths = {} as { [glob: string]: NitroRouteConfig }, prefix = '') {
  for (const page of pages) {
    if (page.rules) {
      if (Object.keys(page.rules).length) {
        const glob = pathToNitroGlob(prefix + page.path)
        if (glob) {
          paths[glob] = page.rules
        }
      }
      // remove rules to prevent exposing in build
      delete page.rules
    }
    if (page.children?.length) {
      globRouteRulesFromPages(page.children, paths, prefix + page.path + '/')
    }
  }
  return paths
}

export function removePagesRules (routes: NuxtPage[]) {
  for (const route of routes) {
    delete route.rules
    if (route.children?.length) {
      removePagesRules(route.children)
    }
  }
}
</file>

<file path="packages/nuxt/src/pages/utils.ts">
import { runInNewContext } from 'node:vm'
import fs from 'node:fs'
import { extname, normalize, relative } from 'pathe'
import { joinURL, withLeadingSlash } from 'ufo'
import { getLayerDirectories, resolveFiles, resolvePath, useNuxt } from '@nuxt/kit'
import { genArrayFromRaw, genDynamicImport, genImport, genSafeVariableName } from 'knitwork'
import escapeRE from 'escape-string-regexp'
import { filename } from 'pathe/utils'
import { hash } from 'ohash'

import { defu } from 'defu'
import { klona } from 'klona'
import { parseAndWalk } from 'oxc-walker'
import { parseSync } from 'oxc-parser'
import type { CallExpression, ExpressionStatement, Node, ObjectProperty } from 'oxc-parser'
import { transformSync } from 'oxc-transform'
import { getLoader, uniqueBy } from '../core/utils/index.ts'
import { logger, toArray } from '../utils.ts'
import type { NuxtPage } from 'nuxt/schema'

const SegmentTokenType = {
  static: 'static',
  dynamic: 'dynamic',
  optional: 'optional',
  catchall: 'catchall',
  group: 'group',
} as const

type SegmentTokenType = typeof SegmentTokenType[keyof typeof SegmentTokenType]

const SegmentParserState = {
  initial: 'initial',
  ...SegmentTokenType,
} as const

type SegmentParserState = typeof SegmentParserState[keyof typeof SegmentParserState]

interface SegmentToken {
  type: SegmentTokenType
  value: string
}

interface ScannedFile {
  relativePath: string
  absolutePath: string
}

const enUSComparator = new Intl.Collator('en-US')
export async function resolvePagesRoutes (pattern: string | string[], nuxt = useNuxt()): Promise<NuxtPage[]> {
  const pagesDirs = getLayerDirectories(nuxt).map(d => d.appPages)

  const scannedFiles: ScannedFile[] = []
  for (const dir of pagesDirs) {
    const files = await resolveFiles(dir, pattern)
    scannedFiles.push(...files.map(file => ({ relativePath: relative(dir, file), absolutePath: file })))
  }

  // sort scanned files using en-US locale to make the result consistent across different system locales

  scannedFiles.sort((a, b) => enUSComparator.compare(a.relativePath, b.relativePath))

  const allRoutes = generateRoutesFromFiles(uniqueBy(scannedFiles, 'relativePath'), {
    shouldUseServerComponents: !!nuxt.options.experimental.componentIslands,
  })

  const pages = uniqueBy(allRoutes, 'path')
  const shouldAugment = nuxt.options.experimental.scanPageMeta || nuxt.options.experimental.typedPages

  if (shouldAugment === false) {
    await nuxt.callHook('pages:extend', pages)
    return pages
  }

  const extraPageMetaExtractionKeys = nuxt.options?.experimental?.extraPageMetaExtractionKeys || []

  const augmentCtx = {
    extraExtractionKeys: new Set([
      'middleware',
      ...extraPageMetaExtractionKeys,
    ]),
    fullyResolvedPaths: new Set(scannedFiles.map(file => file.absolutePath)),
  }
  if (shouldAugment === 'after-resolve') {
    await nuxt.callHook('pages:extend', pages)
    await augmentPages(pages, nuxt.vfs, augmentCtx)
  } else {
    const augmentedPages = await augmentPages(pages, nuxt.vfs, augmentCtx)
    await nuxt.callHook('pages:extend', pages)
    await augmentPages(pages, nuxt.vfs, { pagesToSkip: augmentedPages, ...augmentCtx })
    augmentedPages?.clear()
  }

  await nuxt.callHook('pages:resolved', pages)

  return pages
}

type GenerateRoutesFromFilesOptions = {
  shouldUseServerComponents?: boolean
}

const INDEX_PAGE_RE = /\/index$/
export function generateRoutesFromFiles (files: ScannedFile[], options: GenerateRoutesFromFilesOptions = {}): NuxtPage[] {
  if (!files.length) { return [] }
  const routes: NuxtPage[] = []

  const sortedFiles = [...files].sort((a, b) => a.relativePath.length - b.relativePath.length)

  for (const file of sortedFiles) {
    const segments = file.relativePath
      .replace(new RegExp(`${escapeRE(extname(file.relativePath))}$`), '')
      .split('/')

    const route: NuxtPage = {
      name: '',
      path: '',
      file: file.absolutePath,
      children: [],
    }

    // Array where routes should be added, useful when adding child routes
    let parent = routes

    // Array for collecting route groups
    const routeGroups: string[] = []

    const lastSegment = segments[segments.length - 1]!
    if (lastSegment.endsWith('.server')) {
      segments[segments.length - 1] = lastSegment.replace('.server', '')
      if (options.shouldUseServerComponents) {
        route.mode = 'server'
      }
    } else if (lastSegment.endsWith('.client')) {
      segments[segments.length - 1] = lastSegment.replace('.client', '')
      route.mode = 'client'
    }

    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i]

      const tokens = parseSegment(segment!, file.absolutePath)

      // Skip group segments after collecting their names
      if (tokens.every(token => token.type === SegmentTokenType.group)) {
        const groupNames = tokens.map(t => t.value)

        routeGroups.push(...groupNames)

        continue
      }

      const segmentName = tokens.map(({ value, type }) => type === SegmentTokenType.group ? '' : value).join('')

      // ex: parent/[slug].vue -> parent-slug
      route.name += (route.name && '/') + segmentName

      // ex: parent.vue + parent/child.vue
      const routePath = getRoutePath(tokens, segments[i + 1] !== undefined && segments[i + 1] !== 'index')
      const path = withLeadingSlash(joinURL(route.path, routePath.replace(INDEX_PAGE_RE, '/')))
      const child = parent.find(parentRoute => parentRoute.name === route.name && parentRoute.path === path.replace('([^/]*)*', '(.*)*'))

      if (child && child.children) {
        parent = child.children
        route.path = ''
      } else if (segmentName === 'index' && !route.path) {
        route.path += '/'
      } else if (segmentName !== 'index') {
        route.path += routePath
      }
    }

    // Add route groups to meta
    if (routeGroups.length > 0) {
      route.meta ||= {}
      route.meta.groups = routeGroups
    }

    parent.push(route)
  }

  return prepareRoutes(routes)
}

interface AugmentPagesContext {
  fullyResolvedPaths?: Set<string>
  pagesToSkip?: Set<string>
  augmentedPages?: Set<string>
  extraExtractionKeys?: Set<string>
}

export async function augmentPages (routes: NuxtPage[], vfs: Record<string, string>, ctx: AugmentPagesContext = {}) {
  ctx.augmentedPages ??= new Set()
  for (const route of routes) {
    if (route.file && !ctx.pagesToSkip?.has(route.file)) {
      const fileContent = route.file in vfs
        ? vfs[route.file]!
        : fs.readFileSync(ctx.fullyResolvedPaths?.has(route.file) ? route.file : await resolvePath(route.file), 'utf-8')
      const routeMeta = getRouteMeta(fileContent, route.file, ctx.extraExtractionKeys)
      if (route.meta) {
        routeMeta.meta = defu({}, routeMeta.meta, route.meta)
      }
      if (route.rules) {
        routeMeta.rules = defu({}, routeMeta.rules, route.rules)
      }

      Object.assign(route, routeMeta)
      ctx.augmentedPages.add(route.file)
    }

    if (route.children && route.children.length > 0) {
      await augmentPages(route.children, vfs, ctx)
    }
  }
  return ctx.augmentedPages
}

const SFC_SCRIPT_RE = /<script(?<attrs>[^>]*)>(?<content>[\s\S]*?)<\/script[^>]*>/gi
export function extractScriptContent (sfc: string) {
  const contents: Array<{ loader: 'tsx' | 'ts', code: string }> = []
  for (const match of sfc.matchAll(SFC_SCRIPT_RE)) {
    if (match?.groups?.content) {
      contents.push({
        loader: match.groups.attrs && /[tj]sx/.test(match.groups.attrs) ? 'tsx' : 'ts',
        code: match.groups.content.trim(),
      })
    }
  }

  return contents
}

const PAGE_EXTRACT_RE = /(definePageMeta|defineRouteRules)\([\s\S]*?\)/g
export const defaultExtractionKeys = ['name', 'path', 'props', 'alias', 'redirect', 'middleware'] as const
const DYNAMIC_META_KEY = '__nuxt_dynamic_meta_key' as const

const pageContentsCache: Record<string, string> = {}
const extractCache: Record<string, Partial<Record<keyof NuxtPage, any>>> = {}
export function getRouteMeta (contents: string, absolutePath: string, extraExtractionKeys: Set<string> = new Set()): Partial<Record<keyof NuxtPage, any>> {
  // set/update pageContentsCache, invalidate extractCache on cache mismatch
  if (!(absolutePath in pageContentsCache) || pageContentsCache[absolutePath] !== contents) {
    pageContentsCache[absolutePath] = contents
    delete extractCache[absolutePath]
  }

  if (absolutePath in extractCache && extractCache[absolutePath]) {
    return klona(extractCache[absolutePath])
  }

  const loader = getLoader(absolutePath)
  const scriptBlocks = !loader ? null : loader === 'vue' ? extractScriptContent(contents) : [{ code: contents, loader }]
  if (!scriptBlocks) {
    extractCache[absolutePath] = {}
    return {}
  }

  const extractedData: Partial<Record<keyof NuxtPage, any>> = {}

  const extractionKeys = new Set<keyof NuxtPage>([...defaultExtractionKeys, ...extraExtractionKeys as Set<keyof NuxtPage>])

  for (const script of scriptBlocks) {
    const found: Record<string, boolean> = {}
    // properties track which macros need to be extracted
    for (const macro of script.code.matchAll(PAGE_EXTRACT_RE)) {
      found[macro[1]!] = false
    }

    if (Object.keys(found).length === 0) {
      continue
    }

    const dynamicProperties = new Set<keyof NuxtPage>()

    parseAndWalk(script.code, absolutePath.replace(/\.\w+$/, '.' + script.loader), (node) => {
      if (node.type !== 'ExpressionStatement' || node.expression.type !== 'CallExpression' || node.expression.callee.type !== 'Identifier') { return }

      // function name is one of the extracted macro functions and not yet found
      const fnName = node.expression.callee.name
      if (fnName in found === false || found[fnName] !== false) { return }
      found[fnName] = true

      let code = script.code
      let pageExtractArgument = node.expression.arguments[0]

      // TODO: always true because `extractScriptContent` only detects ts/tsx loader
      if (/tsx?/.test(script.loader)) {
        // slice, transform and parse the `define...` macro node to avoid parsing the whole file
        const transformed = transformSync(absolutePath, script.code.slice(node.start, node.end), { lang: script.loader })
        if (transformed.errors.length) {
          for (const error of transformed.errors) {
            logger.warn(`Error while transforming \`${fnName}()\`` + error.codeframe)
          }
          return
        }

        // we already know that the first statement is a call expression
        pageExtractArgument = ((parseSync('', transformed.code, { lang: 'js' }).program.body[0]! as ExpressionStatement).expression as CallExpression).arguments[0]
        code = transformed.code
      }

      if (pageExtractArgument?.type !== 'ObjectExpression') {
        logger.warn(`\`${fnName}\` must be called with an object literal (reading \`${absolutePath}\`), found ${pageExtractArgument?.type} instead.`)
        return
      }

      if (fnName === 'defineRouteRules') {
        const { value, serializable } = isSerializable(code, pageExtractArgument)
        if (!serializable) {
          logger.warn(`\`${fnName}\` must be called with a serializable object literal (reading \`${absolutePath}\`).`)
          return
        }

        extractedData.rules = value
        return
      }

      if (fnName === 'definePageMeta') {
        for (const key of extractionKeys) {
          const property = pageExtractArgument.properties.find((property): property is ObjectProperty => property.type === 'Property' && property.key.type === 'Identifier' && property.key.name === key)
          if (!property) { continue }

          const { value, serializable } = isSerializable(code, property.value)
          if (!serializable) {
            logger.debug(`Skipping extraction of \`${key}\` metadata as it is not JSON-serializable (reading \`${absolutePath}\`).`)
            dynamicProperties.add(extraExtractionKeys.has(key) ? 'meta' : key)
            continue
          }

          if (extraExtractionKeys.has(key)) {
            extractedData.meta ??= {}
            extractedData.meta[key] = value
          } else {
            extractedData[key] = value
          }
        }

        for (const property of pageExtractArgument.properties) {
          if (property.type !== 'Property') {
            continue
          }
          const isIdentifierOrLiteral = property.key.type === 'Literal' || property.key.type === 'Identifier'
          if (!isIdentifierOrLiteral) {
            continue
          }
          const name = property.key.type === 'Identifier' ? property.key.name : String(property.value)
          if (!extractionKeys.has(name as keyof NuxtPage)) {
            dynamicProperties.add('meta')
            break
          }
        }

        if (dynamicProperties.size) {
          extractedData.meta ??= {}
          extractedData.meta[DYNAMIC_META_KEY] = dynamicProperties
        }
      }
    })
  }

  extractCache[absolutePath] = extractedData
  return klona(extractedData)
}

const ESCAPE_CHARS_RE = /[\\:]/g
function getRoutePath (tokens: SegmentToken[], hasSucceedingSegment = false): string {
  return tokens.reduce((path, token) => {
    switch (token.type) {
      case SegmentTokenType.optional:
        return path + `:${token.value}?`
      case SegmentTokenType.dynamic:
        return path + `:${token.value}()`
      case SegmentTokenType.catchall:
        return path + (hasSucceedingSegment ? `:${token.value}([^/]*)*` : `:${token.value}(.*)*`)
      case SegmentTokenType.group:
        return path
      case SegmentTokenType.static:
      default:
        return path + token.value.replace(ESCAPE_CHARS_RE, '\\$&')
    }
  }, '/')
}

const PARAM_CHAR_RE = /[\w.]/

function parseSegment (segment: string, absolutePath: string) {
  let state: SegmentParserState = SegmentParserState.initial
  let i = 0

  let buffer = ''
  const tokens: SegmentToken[] = []

  function consumeBuffer () {
    if (!buffer) {
      return
    }
    if (state === SegmentParserState.initial) {
      throw new Error('wrong state')
    }

    tokens.push({ type: state, value: buffer })

    buffer = ''
  }

  while (i < segment.length) {
    const c = segment[i]

    switch (state) {
      case SegmentParserState.initial:
        buffer = ''
        if (c === '[') {
          state = SegmentParserState.dynamic
        } else if (c === '(') {
          state = SegmentParserState.group
        } else {
          i--
          state = SegmentParserState.static
        }
        break

      case SegmentParserState.static:
        if (c === '[') {
          consumeBuffer()
          state = SegmentParserState.dynamic
        } else if (c === '(') {
          consumeBuffer()
          state = SegmentParserState.group
        } else {
          buffer += c
        }
        break

      case SegmentParserState.catchall:
      case SegmentParserState.dynamic:
      case SegmentParserState.optional:
      case SegmentParserState.group:
        if (buffer === '...') {
          buffer = ''
          state = SegmentParserState.catchall
        }
        if (c === '[' && state === SegmentParserState.dynamic) {
          state = SegmentParserState.optional
        }
        if (c === ']' && (state !== SegmentParserState.optional || segment[i - 1] === ']')) {
          if (!buffer) {
            throw new Error('Empty param')
          } else {
            consumeBuffer()
          }
          state = SegmentParserState.initial
        } else if (c === ')' && state === SegmentParserState.group) {
          if (!buffer) {
            throw new Error('Empty group')
          } else {
            consumeBuffer()
          }
          state = SegmentParserState.initial
        } else if (c && PARAM_CHAR_RE.test(c)) {
          buffer += c
        } else if (state === SegmentParserState.dynamic || state === SegmentParserState.optional) {
          if (c !== '[' && c !== ']') {
            logger.warn(`'\`${c}\`' is not allowed in a dynamic route parameter and has been ignored. Consider renaming \`${absolutePath}\`.`)
          }
        }
        break
    }
    i++
  }

  if (state === SegmentParserState.dynamic) {
    throw new Error(`Unfinished param "${buffer}"`)
  }

  consumeBuffer()

  return tokens
}

function findRouteByName (name: string, routes: NuxtPage[]): NuxtPage | undefined {
  for (const route of routes) {
    if (route.name === name) {
      return route
    }
    if (route.children && route.children.length > 0) {
      const child = findRouteByName(name, route.children)
      if (child) {
        return child
      }
    }
  }
}

const NESTED_PAGE_RE = /\//g
function prepareRoutes (routes: NuxtPage[], parent?: NuxtPage, names = new Set<string>()) {
  for (const route of routes) {
    // Remove -index
    if (route.name) {
      route.name = route.name
        .replace(INDEX_PAGE_RE, '')
        .replace(NESTED_PAGE_RE, '-')

      if (names.has(route.name)) {
        const existingRoute = findRouteByName(route.name, routes)
        const extra = existingRoute?.name ? `is the same as \`${existingRoute.file}\`` : 'is a duplicate'
        logger.warn(`Route name generated for \`${route.file}\` ${extra}. You may wish to set a custom name using \`definePageMeta\` within the page file.`)
      }
    }

    // Remove leading / if children route
    if (parent && route.path[0] === '/') {
      route.path = route.path.slice(1)
    }

    if (route.children?.length) {
      route.children = prepareRoutes(route.children, route, names)
    }

    if (route.children?.find(childRoute => childRoute.path === '')) {
      delete route.name
    }

    if (route.name) {
      names.add(route.name)
    }
  }

  return routes
}

function serializeRouteValue (value: any, skipSerialisation = false) {
  if (skipSerialisation || value === undefined) { return undefined }
  return JSON.stringify(value)
}

type NormalizedRoute = Partial<Record<Exclude<keyof NuxtPage, 'file'>, string>> & { component?: string }
type NormalizedRouteKeys = (keyof NormalizedRoute)[]
interface NormalizeRoutesOptions {
  overrideMeta?: boolean
  serverComponentRuntime: string
  clientComponentRuntime: string
}
export function normalizeRoutes (routes: NuxtPage[], metaImports: Set<string> = new Set(), options: NormalizeRoutesOptions): { imports: Set<string>, routes: string } {
  return {
    imports: metaImports,
    routes: genArrayFromRaw(routes.map((page) => {
      const markedDynamic = page.meta?.[DYNAMIC_META_KEY] ?? new Set()
      const metaFiltered: Record<string, any> = {}
      let skipMeta = true
      for (const key in page.meta || {}) {
        if (key !== DYNAMIC_META_KEY && page.meta![key] !== undefined) {
          skipMeta = false
          metaFiltered[key] = page.meta![key]
        }
      }
      const skipAlias = toArray(page.alias).every(val => !val)

      const route: NormalizedRoute = {
        path: serializeRouteValue(page.path),
        props: serializeRouteValue(page.props),
        name: serializeRouteValue(page.name),
        meta: serializeRouteValue(metaFiltered, skipMeta),
        alias: serializeRouteValue(toArray(page.alias), skipAlias),
        redirect: serializeRouteValue(page.redirect),
      }

      for (const key of [...defaultExtractionKeys, 'meta'] satisfies NormalizedRouteKeys) {
        if (route[key] === undefined) {
          delete route[key]
        }
      }

      if (page.children?.length) {
        route.children = normalizeRoutes(page.children, metaImports, options).routes
      }

      // Without a file, we can't use `definePageMeta` to extract route-level meta from the file
      if (!page.file) {
        return route
      }

      const file = normalize(page.file)
      const pageImportName = genSafeVariableName(filename(file) + hash(file).replace(/-/g, '_'))
      const metaImportName = pageImportName + 'Meta'
      metaImports.add(genImport(`${file}?macro=true`, [{ name: 'default', as: metaImportName }]))

      if (page._sync) {
        metaImports.add(genImport(file, [{ name: 'default', as: pageImportName }]))
      }

      const pageImport = page._sync && page.mode !== 'client' ? pageImportName : genDynamicImport(file)

      const metaRoute: NormalizedRoute = {
        name: `${metaImportName}?.name ?? ${route.name}`,
        path: `${metaImportName}?.path ?? ${route.path}`,
        props: `${metaImportName}?.props ?? ${route.props ?? false}`,
        meta: `${metaImportName} || {}`,
        alias: `${metaImportName}?.alias || []`,
        redirect: `${metaImportName}?.redirect`,
        component: page.mode === 'server'
          ? `() => createIslandPage(${route.name})`
          : page.mode === 'client'
            ? `() => createClientPage(${pageImport})`
            : pageImport,
      }

      if (page.mode === 'server') {
        metaImports.add(`
let _createIslandPage
async function createIslandPage (name) {
  _createIslandPage ||= await import(${JSON.stringify(options?.serverComponentRuntime)}).then(r => r.createIslandPage)
  return _createIslandPage(name)
};`)
      } else if (page.mode === 'client') {
        metaImports.add(`
let _createClientPage
async function createClientPage(loader) {
  _createClientPage ||= await import(${JSON.stringify(options?.clientComponentRuntime)}).then(r => r.createClientPage)
  return _createClientPage(loader);
}`)
      }

      if (route.children) {
        metaRoute.children = route.children
      }

      if (route.meta) {
        metaRoute.meta = `{ ...(${metaImportName} || {}), ...${route.meta} }`
      }

      if (options?.overrideMeta) {
        // skip and retain fallback if marked dynamic
        // set to extracted value or fallback if none extracted
        for (const key of ['name', 'path'] satisfies NormalizedRouteKeys) {
          if (markedDynamic.has(key)) { continue }
          metaRoute[key] = route[key] ?? `${metaImportName}?.${key}`
        }

        // set to extracted value or delete if none extracted
        for (const key of ['meta', 'alias', 'redirect', 'props'] satisfies NormalizedRouteKeys) {
          if (markedDynamic.has(key)) { continue }

          if (route[key] == null) {
            delete metaRoute[key]
            continue
          }

          metaRoute[key] = route[key]
        }
      } else {
        if (route.alias != null) {
          metaRoute.alias = `${route.alias}.concat(${metaImportName}?.alias || [])`
        }

        if (route.redirect != null) {
          metaRoute.redirect = route.redirect
        }
      }

      return metaRoute
    })),
  }
}

const PATH_TO_NITRO_GLOB_RE = /\/[^:/]*:\w.*$/
export function pathToNitroGlob (path: string) {
  if (!path) {
    return null
  }
  // Ignore pages with multiple dynamic parameters.
  if (path.indexOf(':') !== path.lastIndexOf(':')) {
    return null
  }

  return path.replace(PATH_TO_NITRO_GLOB_RE, '/**')
}

export function resolveRoutePaths (page: NuxtPage, parent = '/'): string[] {
  return [
    joinURL(parent, page.path),
    ...page.children?.flatMap(child => resolveRoutePaths(child, joinURL(parent, page.path))) || [],
  ]
}

export function isSerializable (code: string, node: Node): { value?: any, serializable: boolean } {
  if (node.type === 'ObjectExpression') {
    const valueString = code.slice(node.start, node.end)
    try {
      return {
        value: JSON.parse(runInNewContext(`JSON.stringify(${valueString})`, {})),
        serializable: true,
      }
    } catch {
      return {
        serializable: false,
      }
    }
  }

  if (node.type === 'ArrayExpression') {
    const values: string[] = []
    for (const element of node.elements) {
      if (!element) {
        continue
      }
      const { serializable, value } = isSerializable(code, element)
      if (!serializable) {
        return {
          serializable: false,
        }
      }
      values.push(value)
    }

    return {
      value: values,
      serializable: true,
    }
  }

  if (node.type === 'Literal' && (typeof node.value === 'string' || typeof node.value === 'boolean' || typeof node.value === 'number' || node.value === null)) {
    return {
      value: node.value,
      serializable: true,
    }
  }

  return {
    serializable: false,
  }
}

export function toRou3Patterns (pages: NuxtPage[], prefix = '/'): string[] {
  const routes: string[] = []
  for (const page of pages) {
    // convert to rou3-compatible path (https://github.com/h3js/rou3)
    const path = page.path
      // remove all regex patterns
      .replace(/\([^)]*\)/g, '')
      // catchalls: `:name([^/]*)*` or `:catchall(.*)*`
      .replace(/:(\w+)\*.*/g, (_, name) => `**:${name}`)
      // dynamic paths, including custom patterns, e.g. :id([^/]*)*/suffix
      .replace(/:([^/*]*)/g, (_, name) => `:${name.replace(/\W/g, (r: string) => r === '?' ? '' : '_')}`)

    routes.push(joinURL(prefix, path))

    if (page.children) {
      routes.push(...toRou3Patterns(page.children, joinURL(prefix, path)))
    }
  }
  return routes
}
</file>

<file path="packages/nuxt/src/dirs.ts">
import { fileURLToPath } from 'node:url'
import { dirname, resolve } from 'pathe'

let _distDir = dirname(fileURLToPath(import.meta.url))
if (/(?:chunks|shared)$/.test(_distDir)) { _distDir = dirname(_distDir) }
export const distDir = _distDir
export const pkgDir = resolve(distDir, '..')
</file>

<file path="packages/nuxt/src/index.ts">
export { createNuxt, loadNuxt } from './core/nuxt.ts'
export { build } from './core/builder.ts'
</file>

<file path="packages/nuxt/src/utils.ts">
import { promises as fsp, statSync } from 'node:fs'
import { tryUseNuxt, useLogger } from '@nuxt/kit'
import { reverseResolveAlias } from 'pathe/utils'

/** @since 3.9.0 */
export function toArray<T> (value: T | T[]): T[] {
  return Array.isArray(value) ? value : [value]
}

export async function isDirectory (path: string) {
  return (await fsp.lstat(path)).isDirectory()
}

export function isDirectorySync (path: string) {
  try { return statSync(path).isDirectory() } catch { return false }
}

export function stripExtension (path: string) {
  return path.replace(/\.[^./\\]+$/, '')
}

export function isWhitespace (char: number | string | undefined | null): boolean {
  const c = typeof char === 'string' ? char.charCodeAt(0) : char
  // ' ' (32), '\t' (9), '\n' (10), '\r' (13), '\f' (12)
  return c === 32 || c === 9 || c === 10 || c === 13 || c === 12
}

export const DECLARATION_EXTENSIONS = ['d.ts', 'd.mts', 'd.cts', 'd.vue.ts', 'd.vue.mts', 'd.vue.cts']

export const logger = useLogger('nuxt')

export function resolveToAlias (path: string, nuxt = tryUseNuxt()) {
  return reverseResolveAlias(path, { ...nuxt?.options.alias || {}, ...strippedAtAliases }).pop() || path
}

const strippedAtAliases = {
  '@': '',
  '@@': '',
}
</file>

<file path="packages/nuxt/test/components-fixture/components/client/ComponentWithProps.vue">
<template>
  <div>
    Awesome Component count: {{ count }}
  </div>
</template>

<script setup lang="ts">
defineProps<{
  count?: number
}>()
</script>
</file>

<file path="packages/nuxt/test/components-fixture/components/client/WithClientOnlySetup.vue">
<template>
  <div>
    <NotDotClientComponent>
      <ByeBye />
    </NotDotClientComponent>
    <div>
      <Glob />
    </div>
    {{ hello }}
    <div class="not-client">
      Hello
    </div>
    <DotClientComponent>
      <HelloWorld />
      <Glob />
      <SomeGlob />
      <SomeIsland />
      <NotToBeTreeShaken />
      <ObjectPattern />
      <ObjectPatternDeclaration />
      <AutoImportedNotTreeShakenComponent />
      <AutoImportedComponent />
      <Halllo />
      <Both />
      <AreTreeshaken />
    </DotClientComponent>
    <ClientOnly>
      <div class="should-be-treeshaken">
        this should not be visible
      </div>
      <ClientImport />
      <Treeshaken />
      <ResolvedImport />
      <FromArray />
      <Please />
      <Doo />
      <What />
      <Deep />
      <Pattern />
      <DontRemoveThisSinceItIsUsedInSetup />
    </ClientOnly>
    <ButShouldNotBeTreeShaken />
    <Dont />
    <That />
    <NotToBeTreeShaken />
    <AutoImportedNotTreeShakenComponent />
  </div>
</template>

<script setup>
import { Treeshaken } from 'somepath'
import HelloWorld from '../HelloWorld.vue'
import DontRemoveThisSinceItIsUsedInSetup from './ComponentWithProps.vue'
import { ClientImport, Glob } from '#components'
import { AreTreeshaken, Both } from '#imports'

const hello = 'world'
const ByeBye = defineAsyncComponent(() => import('../some-glob.global.vue'))

const NotDotClientComponent = defineAsyncComponent(() => import('../some.island.vue'))
const SomeIsland = defineAsyncComponent(async () => {
  if (import.meta.client) {
    return (await import('../some.island.vue'))
  }

  return {}
})

const NotToBeTreeShaken = defineAsyncComponent(async () => {
  if (import.meta.client) {
    return (await import('../HelloWorld.vue'))
  }

  return {}
})

const { ObjectPattern } = defineAsyncComponent(async () => {
  if (import.meta.client) {
    return (await import('../HelloWorld.vue'))
  }

  return {}
})

const { ObjectPattern: ObjectPatternDeclaration } = defineAsyncComponent(async () => {
  if (import.meta.client) {
    return (await import('../HelloWorld.vue'))
  }

  return {}
})

const { ObjectPattern: Halllo, ButShouldNotBeTreeShaken } = defineAsyncComponent(async () => {
  if (import.meta.client) {
    return (await import('../HelloWorld.vue'))
  }

  return {}
})
const isThis = {}

const { woooooo, What = isThis } = defineAsyncComponent(async () => {
  if (import.meta.client) {
    return (await import('../HelloWorld.vue'))
  }

  return {}
})

if (import.meta.client) {
  // eslint-disable-next-line no-console
  console.log(woooooo)
}

const { Deep, assignment: { Pattern = ofComponent } } = defineAsyncComponent(async () => {
  if (import.meta.client) {
    return (await import('../HelloWorld.vue'))
  }

  return {}
})

const [FromArray] = defineAsyncComponent(async () => {
  if (import.meta.client) {
    return (await import('../HelloWorld.vue'))
  }

  return {}
})

const [Please, { Dont, Doo }, That] = defineAsyncComponent(async () => {
  if (import.meta.client) {
    return (await import('../HelloWorld.vue'))
  }

  return {}
})

if (import.meta.client) {
  // eslint-disable-next-line no-console
  console.log(DontRemoveThisSinceItIsUsedInSetup.props)
}
</script>

<style scoped>
    .not-client {
        color: "red";
    }
</style>
</file>

<file path="packages/nuxt/test/components-fixture/components/global/Glob.vue">
<template>
  <div>
    Global component from folder
  </div>
</template>
</file>

<file path="packages/nuxt/test/components-fixture/components/islands/Isle.vue">
<template>
  <div>
    Island from folder
  </div>
</template>
</file>

<file path="packages/nuxt/test/components-fixture/components/parent-folder/index.server.vue">
<template>
  <div>
    Awesome Component
  </div>
</template>
</file>

<file path="packages/nuxt/test/components-fixture/components/same-name/same/Same.vue">
<template>
  <div>
    This is Same name component!
  </div>
</template>

<script setup>
</script>
</file>

<file path="packages/nuxt/test/components-fixture/components/HelloWorld.vue">
<template>
  <div>
    This is HelloWorld component!
  </div>
</template>
</file>

<file path="packages/nuxt/test/components-fixture/components/Nuxt3.client.vue">
<!-- eslint-disable vue/multi-word-component-names -->

<template>
  <b style="color: #00C58E">
    From Nuxt 3
  </b>
</template>
</file>

<file path="packages/nuxt/test/components-fixture/components/Nuxt3.server.vue">
<!-- eslint-disable vue/multi-word-component-names -->

<template>
  <b style="color: #00C58E">
    From Nuxt 3
  </b>
</template>
</file>

<file path="packages/nuxt/test/components-fixture/components/some-glob.global.vue">
<template>
  <div>
    Global component from suffix
  </div>
</template>
</file>

<file path="packages/nuxt/test/components-fixture/components/some.island.vue">
<!-- eslint-disable vue/multi-word-component-names -->

<template>
  <div>
    Island defined with suffix
  </div>
</template>
</file>

<file path="packages/nuxt/test/disabled-modules-fixture/layers/base/layer-module-a.ts">
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'layer-module-a',
  },
  setup (_options, nuxt) {
    nuxt.options.appConfig.layerModuleA = true
  },
})
</file>

<file path="packages/nuxt/test/disabled-modules-fixture/layers/base/layer-module-b.ts">
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'layer-module-b',
    configKey: 'layerModuleB',
  },
  setup (_options, nuxt) {
    nuxt.options.appConfig.layerModuleB = true
  },
})
</file>

<file path="packages/nuxt/test/disabled-modules-fixture/layers/base/layer-module-c.ts">
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'layer-module-c',
    configKey: 'layerModuleC',
  },
  setup (_options, nuxt) {
    nuxt.options.appConfig.layerModuleC = true
  },
})
</file>

<file path="packages/nuxt/test/disabled-modules-fixture/layers/base/nuxt.config.ts">
export default defineNuxtConfig({
  modules: [
    import.meta.dirname + '/layer-module-a',
    import.meta.dirname + '/layer-module-b',
    import.meta.dirname + '/layer-module-c',
  ],
})
</file>

<file path="packages/nuxt/test/disabled-modules-fixture/nuxt.config.ts">
export default defineNuxtConfig({
  extends: ['./layers/base'],
  modules: [
    import.meta.dirname + '/project-module',
  ],
})
</file>

<file path="packages/nuxt/test/disabled-modules-fixture/project-module.ts">
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'project-module',
    configKey: 'projectModule',
  },
  setup (_options, nuxt) {
    nuxt.options.appConfig.projectModule = true
  },
})
</file>

<file path="packages/nuxt/test/layers-fixture/custom/modules/module.ts">
export default function customLayerAutoModule () {}
</file>

<file path="packages/nuxt/test/layers-fixture/custom/module.ts">
export default function customLayerModule () {}
</file>

<file path="packages/nuxt/test/layers-fixture/custom/nuxt.config.ts">
export default defineNuxtConfig({
  modules: [
    function customLayerInlineModule () {},
    import.meta.dirname + '/module',
  ],
  css: ['custom.css'],
})
</file>

<file path="packages/nuxt/test/layers-fixture/layers/auto/modules/module.ts">
export default function autoLayerAutoModule () {}
</file>

<file path="packages/nuxt/test/layers-fixture/layers/auto/module.ts">
export default function autoLayerModule () {}
</file>

<file path="packages/nuxt/test/layers-fixture/layers/auto/nuxt.config.ts">
export default defineNuxtConfig({
  modules: [
    function autoLayerInlineModule () {},
    import.meta.dirname + '/module',
  ],
  css: ['duplicate.css', 'auto.css'],
})
</file>

<file path="packages/nuxt/test/layers-fixture/modules/module.ts">
export default function projectAutoModule () {}
</file>

<file path="packages/nuxt/test/layers-fixture/module.ts">
export default function projectModule () {}
</file>

<file path="packages/nuxt/test/layers-fixture/nuxt.config.ts">
export default defineNuxtConfig({
  extends: ['./custom'],
  modules: [
    import.meta.dirname + '/module',
    function projectInlineModule () {},
    function css (_options, nuxt) {
      nuxt.options.css.push('new-css-added-by-module.css')
    },
  ],
  css: ['final-project.css', 'duplicate.css'],
})
</file>

<file path="packages/nuxt/test/nitro/render-index.ts">
// @ts-expect-error untyped
import '#nitro-internal-pollyfills'
import type { NitroApp } from 'nitropack/types'
import { useNitroApp } from 'nitropack/runtime'

const nitroApp = useNitroApp()

async function renderIndex () {
  const text = await (nitroApp as NitroApp).localFetch('/', {}).then(r => r.text())
  // eslint-disable-next-line no-console
  console.log(text)
}

renderIndex()
</file>

<file path="packages/nuxt/test/pages-fixture/pages/index.vue">
<template>
  <div />
</template>
</file>

<file path="packages/nuxt/test/pages-fixture/nuxt.config.ts">
export default defineNuxtConfig({})
</file>

<file path="packages/nuxt/test/app-config.test.ts">
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { _replaceAppConfig } from '../src/app/config.ts'

const mockNuxt = {
  _appConfig: {} as Partial<{
    apiUrl: string
    featureFlags: Record<string, boolean>
    entries: Array<{ label: string }>
  }>,
}

vi.mock('../src/app/nuxt', () => ({
  useNuxtApp: () => mockNuxt,
}))

describe('_replaceAppConfig', () => {
  beforeEach(() => {
    mockNuxt._appConfig = {
      apiUrl: 'https://api.example.com',
      featureFlags: { foo: false },
      entries: [{ label: 'foo' }, { label: 'bar' }],
    }
  })

  it('should remove properties not in new config', () => {
    const newConfig = {
      featureFlags: { baz: true },
      entries: [{ label: 'baz' }],
    }

    _replaceAppConfig(newConfig)
    expect(mockNuxt._appConfig).toEqual({
      featureFlags: { baz: true },
      entries: [{ label: 'baz' }],
    })
  })

  it('should add new properties from new config', () => {
    const newConfig = {
      apiUrl: 'https://api.newexample.com',
      featureFlags: { foo: true, baz: true },
      entries: [{ label: 'foo' }, { label: 'bar' }, { label: 'baz' }],
    }

    _replaceAppConfig(newConfig)

    expect(mockNuxt._appConfig).toEqual({
      apiUrl: 'https://api.newexample.com',
      featureFlags: { foo: true, baz: true },
      entries: [{ label: 'foo' }, { label: 'bar' }, { label: 'baz' }],
    })

    expect(mockNuxt._appConfig.entries?.length).toEqual(3)
  })

  it('should update properties in arrays', () => {
    const newConfig = {
      entries: [{ label: 'updated-foo' }, { label: 'updated-bar' }],
    }

    _replaceAppConfig(newConfig)

    expect(mockNuxt._appConfig.entries).toEqual([
      { label: 'updated-foo' },
      { label: 'updated-bar' },
    ])
  })

  it('should handle replacing arrays with objects and vice versa', () => {
    const newConfig = {
      entries: { first: { label: 'only-entry' } },
    }

    _replaceAppConfig(newConfig)

    expect(mockNuxt._appConfig.entries).toEqual({ first: { label: 'only-entry' } })

    const anotherNewConfig = {
      entries: [{ label: 'restored-entry' }],
    }

    _replaceAppConfig(anotherNewConfig)

    expect(mockNuxt._appConfig.entries).toEqual([{ label: 'restored-entry' }])
  })

  it('should preserve element order in arrays', () => {
    const newConfig = {
      entries: [{ label: 'foo' }, { label: 'baz' }, { label: 'bar' }],
    }

    _replaceAppConfig(newConfig)

    expect(mockNuxt._appConfig.entries).toEqual([
      { label: 'foo' },
      { label: 'baz' },
      { label: 'bar' },
    ])
  })

  it('should preserve object references for unchanged properties', () => {
    const originalFeatureFlags = mockNuxt._appConfig.featureFlags
    const newConfig = {
      apiUrl: 'https://api.example.com',
      featureFlags: { foo: false }, // unchanged
      entries: [{ label: 'new-entry' }],
    }

    _replaceAppConfig(newConfig)

    expect(mockNuxt._appConfig.featureFlags).toBe(originalFeatureFlags)
  })

  it('should preserve object references in arrays for unchanged elements', () => {
    const originalEntries = mockNuxt._appConfig.entries
    const newConfig = {
      entries: [originalEntries![0], { label: 'new-bar' }],
    }

    _replaceAppConfig(newConfig)

    expect(mockNuxt._appConfig.entries![0]).toBe(originalEntries![0])
  })
})
</file>

<file path="packages/nuxt/test/app.test.ts">
import { mkdir, rm, writeFile } from 'node:fs/promises'
import { randomUUID } from 'node:crypto'
import { afterAll, describe, expect, it } from 'vitest'
import { dirname, join, resolve } from 'pathe'
import { findWorkspaceDir } from 'pkg-types'
import { createApp, resolveApp } from '../src/core/app.ts'
import { loadNuxt } from '../src/index.ts'

const repoRoot = await findWorkspaceDir()

describe('resolveApp', () => {
  afterAll(async () => {
    await rm(resolve(repoRoot, '.fixture'), { recursive: true, force: true })
  })
  it('resolves app with default configuration', async () => {
    const app = await getResolvedApp([])
    expect(app).toMatchInlineSnapshot(`
      {
        "components": [],
        "configs": [],
        "dir": "<rootDir>",
        "errorComponent": "<repoRoot>/packages/nuxt/src/app/components/nuxt-error-page.vue",
        "extensions": [
          ".js",
          ".jsx",
          ".mjs",
          ".ts",
          ".tsx",
          ".vue",
        ],
        "layouts": {},
        "mainComponent": "<repoRoot>/packages/nuxt/src/app/components/welcome.vue",
        "middleware": [
          {
            "global": true,
            "name": "manifest-route-rule",
            "path": "<repoRoot>/packages/nuxt/src/app/middleware/route-rules.ts",
          },
        ],
        "plugins": [
          {
            "mode": "client",
            "src": "<repoRoot>/packages/nuxt/src/app/plugins/payload.client.ts",
          },
          {
            "mode": "client",
            "src": "<repoRoot>/packages/nuxt/src/app/plugins/navigation-repaint.client.ts",
          },
          {
            "mode": "client",
            "src": "<repoRoot>/packages/nuxt/src/app/plugins/check-outdated-build.client.ts",
          },
          {
            "mode": "server",
            "src": "<repoRoot>/packages/nuxt/src/app/plugins/revive-payload.server.ts",
          },
          {
            "mode": "client",
            "src": "<repoRoot>/packages/nuxt/src/app/plugins/revive-payload.client.ts",
          },
          {
            "mode": "client",
            "src": "<repoRoot>/packages/nuxt/src/app/plugins/chunk-reload.client.ts",
          },
          {
            "filename": "components.plugin.mjs",
            "getContents": [Function],
            "mode": "all",
            "src": "<rootDir>/.nuxt/components.plugin.mjs",
          },
          {
            "mode": "all",
            "src": "<repoRoot>/packages/nuxt/src/head/runtime/plugins/unhead.ts",
          },
          {
            "mode": "all",
            "src": "<repoRoot>/packages/nuxt/src/app/plugins/router.ts",
          },
        ],
        "rootComponent": "<repoRoot>/packages/nuxt/src/app/components/nuxt-root.vue",
        "templates": [],
      }
    `)
  })

  it('resolves layouts and middleware correctly', async () => {
    const app = await getResolvedApp([
      'middleware/index.ts',
      'middleware/auth/index.ts',
      'middleware/other.ts',
      'layouts/index.vue',
      'layouts/default/index.vue',
      'layouts/other.vue',
    ])
    // Middleware are not resolved in a nested manner
    expect(app.middleware.filter(m => m.path.startsWith('<rootDir>'))).toMatchInlineSnapshot(`
      [
        {
          "global": false,
          "name": "other",
          "path": "<rootDir>/middleware/other.ts",
        },
      ]
    `)
    expect(app.layouts).toMatchInlineSnapshot(`
      {
        "default": {
          "file": "<rootDir>/layouts/default/index.vue",
          "name": "default",
        },
        "other": {
          "file": "<rootDir>/layouts/other.vue",
          "name": "other",
        },
      }
    `)
  })

  it('resolves layer plugins in correct order', async () => {
    const app = await getResolvedApp([
      // layer 1
      'layer1/plugins/02.plugin.ts',
      'layer1/plugins/object-named.ts',
      'layer1/plugins/override-test.ts',
      'layer1/nuxt.config.ts',
      // layer 2
      'layer2/plugins/01.plugin.ts',
      'layer2/plugins/object-named.ts',
      'layer2/plugins/override-test.ts',
      'layer2/nuxt.config.ts',
      // final (user) layer
      'plugins/00.plugin.ts',
      'plugins/object-named.ts',
      {
        name: 'nuxt.config.ts',
        contents: 'export default defineNuxtConfig({ extends: [\'./layer2\', \'./layer1\'] })',
      },
    ])
    const fixturePlugins = app.plugins.filter(p => !('getContents' in p) && p.src.includes('<rootDir>')).map(p => p.src)
    // TODO: support overriding named plugins
    expect(fixturePlugins).toMatchInlineSnapshot(`
      [
        "<rootDir>/layer1/plugins/02.plugin.ts",
        "<rootDir>/layer1/plugins/object-named.ts",
        "<rootDir>/layer1/plugins/override-test.ts",
        "<rootDir>/layer2/plugins/01.plugin.ts",
        "<rootDir>/layer2/plugins/object-named.ts",
        "<rootDir>/layer2/plugins/override-test.ts",
        "<rootDir>/plugins/00.plugin.ts",
        "<rootDir>/plugins/object-named.ts",
      ]
    `)
  })

  it('resolves layer middleware in correct order', async () => {
    const app = await getResolvedApp([
      // layer 1
      'layer1/middleware/global.global.ts',
      'layer1/middleware/named-from-layer.ts',
      'layer1/middleware/named-override.ts',
      'layer1/nuxt.config.ts',
      // layer 2
      'layer2/middleware/global.global.ts',
      'layer2/middleware/named-from-layer.ts',
      'layer2/middleware/named-override.ts',
      'layer2/plugins/override-test.ts',
      'layer2/nuxt.config.ts',
      // final (user) layer
      'middleware/named-override.ts',
      'middleware/named.ts',
      {
        name: 'nuxt.config.ts',
        contents: 'export default defineNuxtConfig({ extends: [\'./layer2\', \'./layer1\'] })',
      },
    ])
    const fixtureMiddleware = app.middleware.filter(p => p.path.includes('<rootDir>')).map(p => p.path)
    // TODO: fix this
    expect(fixtureMiddleware).toMatchInlineSnapshot(`
      [
        "<rootDir>/layer2/middleware/global.global.ts",
        "<rootDir>/layer2/middleware/named-from-layer.ts",
        "<rootDir>/middleware/named-override.ts",
        "<rootDir>/middleware/named.ts",
      ]
    `)
  })

  it('resolves layer layouts correctly', async () => {
    const app = await getResolvedApp([
      // layer 1
      'layer1/layouts/default.vue',
      'layer1/layouts/layer.vue',
      'layer1/nuxt.config.ts',
      // layer 2
      'layer2/layouts/default.vue',
      'layer2/layouts/layer.vue',
      'layer2/nuxt.config.ts',
      // final (user) layer
      'layouts/default.vue',
      {
        name: 'nuxt.config.ts',
        contents: 'export default defineNuxtConfig({ extends: [\'./layer2\', \'./layer1\'] })',
      },
    ])
    expect(app.layouts).toMatchInlineSnapshot(`
      {
        "default": {
          "file": "<rootDir>/layouts/default.vue",
          "name": "default",
        },
        "layer": {
          "file": "<rootDir>/layer2/layouts/layer.vue",
          "name": "layer",
        },
      }
    `)
  })

  it('resolves nested layouts correctly', async () => {
    const app = await getResolvedApp([
      'layouts/default.vue',
      'layouts/some/layout.vue',
      'layouts/SomeOther.vue',
      'layouts/SomeOther/Thing/Index.vue',
      'layouts/thing/thing/thing.vue',
      'layouts/desktop-base/base.vue',
      'layouts/some.vue',
      'layouts/SomeOther/layout.ts',
    ])
    expect(app.layouts).toMatchInlineSnapshot(`
      {
        "default": {
          "file": "<rootDir>/layouts/default.vue",
          "name": "default",
        },
        "desktop-base": {
          "file": "<rootDir>/layouts/desktop-base/base.vue",
          "name": "desktop-base",
        },
        "some": {
          "file": "<rootDir>/layouts/some.vue",
          "name": "some",
        },
        "some-layout": {
          "file": "<rootDir>/layouts/some/layout.vue",
          "name": "some-layout",
        },
        "some-other": {
          "file": "<rootDir>/layouts/SomeOther.vue",
          "name": "some-other",
        },
        "some-other-layout": {
          "file": "<rootDir>/layouts/SomeOther/layout.ts",
          "name": "some-other-layout",
        },
        "some-other-thing": {
          "file": "<rootDir>/layouts/SomeOther/Thing/Index.vue",
          "name": "some-other-thing",
        },
        "thing": {
          "file": "<rootDir>/layouts/thing/thing/thing.vue",
          "name": "thing",
        },
      }
    `)
  })

  it('does not allow parallel access to freshly created app components', async () => {
    const rootDir = resolve(repoRoot, 'node_modules/.fixture', randomUUID())
    await mkdir(join(rootDir, 'app/layouts'), { recursive: true })
    await mkdir(join(rootDir, 'app/middleware'), { recursive: true })
    await mkdir(join(rootDir, 'app/plugins'), { recursive: true })

    await writeFile(join(rootDir, 'nuxt.config.ts'), 'export default {}')
    await writeFile(join(rootDir, 'app/layouts/default.vue'), '<template><div>Default Layout</div></template>')
    await writeFile(join(rootDir, 'app/middleware/global.global.ts'), 'export default defineNuxtRouteMiddleware(() => {})')
    await writeFile(join(rootDir, 'app/plugins/my-plugin.ts'), 'export default defineNuxtPlugin(() => {})')

    const nuxt = await loadNuxt({ cwd: rootDir })
    const _app = createApp(nuxt)
    const app = new Proxy(_app, {
      get (target, p, receiver) {
        return Reflect.get(target, p, receiver)
      },
      set (target, p, newValue, receiver) {
        if (p === 'middleware' || p === 'plugins') {
          expect(newValue).not.toEqual([])
        }
        if (p === 'layouts') {
          expect(newValue).not.toEqual({})
        }
        return Reflect.set(target, p, newValue, receiver)
      },
    })

    await resolveApp(nuxt, app)

    await nuxt.close()
    await rm(rootDir, { recursive: true, force: true })
  })
})

async function getResolvedApp (files: Array<string | { name: string, contents: string }>) {
  const rootDir = resolve(repoRoot, 'node_modules/.fixture', randomUUID())
  await mkdir(rootDir, { recursive: true })
  for (const file of files) {
    const filename = typeof file === 'string' ? join(rootDir, file) : join(rootDir, file.name)
    await mkdir(dirname(filename), { recursive: true })
    await writeFile(filename, typeof file === 'string' ? '' : file.contents || '')
  }

  const nuxt = await loadNuxt({ cwd: rootDir })
  const app = createApp(nuxt)
  await resolveApp(nuxt, app)

  const normaliseToRepo = (id?: string | null) =>
    id?.replace(rootDir, '<rootDir>').replace(repoRoot, '<repoRoot>').replace(/.*node_modules\//, '')

  app.dir = normaliseToRepo(app.dir)!

  const componentKeys = ['rootComponent', 'errorComponent', 'mainComponent'] as const
  for (const _key of componentKeys) {
    const key = _key as typeof componentKeys[number]
    app[key] = normaliseToRepo(app[key])
  }
  for (const plugin of app.plugins) {
    plugin.src = normaliseToRepo(plugin.src)!
    // @ts-expect-error untyped symbol
    delete plugin[Symbol.for('nuxt plugin')]
  }
  for (const mw of app.middleware) {
    mw.path = normaliseToRepo(mw.path)!
  }

  for (const layout of Object.values(app.layouts)) {
    layout.file = normaliseToRepo(layout.file)!
  }

  await nuxt.close()

  return app
}
</file>

<file path="packages/nuxt/test/auto-imports.test.ts">
import { readFileSync } from 'node:fs'
import { fileURLToPath } from 'node:url'
import { describe, expect, it } from 'vitest'
import { findExports } from 'mlly'
import * as VueFunctions from 'vue'
import type { Import } from 'unimport'
import { createUnimport } from 'unimport'
import type { Plugin } from 'vite'
import { registry as scriptRegistry } from '@nuxt/scripts/registry'
import { TransformPlugin } from '../src/imports/transform.ts'
import { defaultPresets, scriptsStubsPreset } from '../src/imports/presets.ts'

describe('imports:transform', () => {
  const imports: Import[] = [
    { name: 'ref', as: 'ref', from: 'vue' },
    { name: 'computed', as: 'computed', from: 'bar' },
    { name: 'foo', as: 'foo', from: 'excluded' },
  ]

  const ctx = createUnimport({
    injectAtEnd: true,
    imports,
  })

  const transformPlugin = TransformPlugin({ ctx, options: { transform: { exclude: [/node_modules/] } } }).raw({}, { framework: 'rollup' }) as Plugin
  const transform = async (source: string) => {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
    const result = await (transformPlugin.transform! as Function).call({ error: null, warn: null } as any, source, '')
    return typeof result === 'string' ? result : result?.code
  }

  it('should correct inject', async () => {
    expect(await transform('const a = ref(0)')).toMatchInlineSnapshot('"import { ref } from \'vue\';\nconst a = ref(0)"')
  })

  it('should ignore existing imported', async () => {
    expect(await transform('import { ref } from "foo"; const a = ref(0)')).to.equal(undefined)
    expect(await transform('import { computed as ref } from "foo"; const a = ref(0)')).to.equal(undefined)
    expect(await transform('import ref from "foo"; const a = ref(0)')).to.equal(undefined)
    expect(await transform('import { z as ref } from "foo"; const a = ref(0)')).to.equal(undefined)
    expect(await transform('let ref = () => {}; const a = ref(0)')).to.equal(undefined)
    expect(await transform('let { ref } = Vue; const a = ref(0)')).to.equal(undefined)
    expect(await transform('let [\ncomputed,\nref\n] = Vue; const a = ref(0); const b = ref(0)')).to.equal(undefined)
  })

  it('should ignore comments', async () => {
    const result = await transform('// import { computed } from "foo"\n;const a = computed(0)')
    expect(result).toMatchInlineSnapshot(`
      "import { computed } from 'bar';
      // import { computed } from "foo"
      ;const a = computed(0)"
    `)
  })

  it('should exclude files from transform', async () => {
    expect(await transform('excluded')).toEqual(undefined)
  })
})

const excludedNuxtHelpers = ['useHydration', 'useHead', 'useSeoMeta', 'useServerSeoMeta', 'useId']

describe('imports:nuxt', () => {
  try {
    const entrypointPath = fileURLToPath(new URL('../src/app/composables/index.ts', import.meta.url))
    const entrypointContents = readFileSync(entrypointPath, 'utf8')

    const names = findExports(entrypointContents).flatMap(i => i.names || i.name)
    for (let name of names) {
      name = name.replace(/\/\*.*\*\//, '').trim()
      if (excludedNuxtHelpers.includes(name)) {
        continue
      }
      it(`should register ${name} globally`, () => {
        expect(defaultPresets.flatMap(a => a.from.startsWith('#app/') ? a.imports : [])).to.include(name)
      })
    }
  } catch (e) {
    it('should import composables', () => {
      console.error(e)
      expect(false).toBe(true)
    })
  }
})

const excludedVueHelpers = [
  // Already globally registered
  'defineEmits',
  'defineExpose',
  'defineModel',
  'defineOptions',
  'defineProps',
  'defineSlots',
  'withDefaults',
  'stop',
  //
  '__esModule',
  'devtools',
  'EffectScope',
  'ReactiveEffect',
  'stop',
  'assertNumber',
  'camelize',
  'capitalize',
  'normalizeClass',
  'normalizeProps',
  'normalizeStyle',
  'toDisplayString',
  'toHandlerKey',
  'BaseTransition',
  'BaseTransitionPropsValidators',
  'Comment',
  'Fragment',
  'KeepAlive',
  'Static',
  'Suspense',
  'Teleport',
  'Text',
  'callWithAsyncErrorHandling',
  'callWithErrorHandling',
  'cloneVNode',
  'compatUtils',
  'createBlock',
  'createCommentVNode',
  'createElementBlock',
  'createElementVNode',
  'createHydrationRenderer',
  'createPropsRestProxy',
  'createRenderer',
  'createSlots',
  'createStaticVNode',
  'createTextVNode',
  'createVNode',
  'getTransitionRawChildren',
  'guardReactiveProps',
  'handleError',
  'initCustomFormatter',
  'isMemoSame',
  'isRuntimeOnly',
  'isVNode',
  'mergeDefaults',
  'mergeModels',
  'mergeProps',
  'openBlock',
  'popScopeId',
  'pushScopeId',
  'queuePostFlushCb',
  'registerRuntimeCompiler',
  'renderList',
  'renderSlot',
  'resolveComponent',
  'resolveDirective',
  'resolveDynamicComponent',
  'resolveFilter',
  'resolveTransitionHooks',
  'setBlockTracking',
  'setDevtoolsHook',
  'setTransitionHooks',
  'ssrContextKey',
  'ssrUtils',
  'toHandlers',
  'transformVNodeArgs',
  'useSSRContext',
  'version',
  'warn',
  'watchPostEffect',
  'watchSyncEffect',
  'withAsyncContext',
  'Transition',
  'TransitionGroup',
  'VueElement',
  'ErrorTypeStrings',
  'createApp',
  'createSSRApp',
  'defineCustomElement',
  'defineSSRCustomElement',
  'hydrate',
  'initDirectivesForSSR',
  'render',
  'vModelCheckbox',
  'vModelDynamic',
  'vModelRadio',
  'vModelSelect',
  'vModelText',
  'vShow',
  'compile',
  'DeprecationTypes',
  'ErrorCodes',
  'TrackOpTypes',
  'TriggerOpTypes',
  'useHost',
  'hydrateOnVisible',
  'hydrateOnMediaQuery',
  'hydrateOnInteraction',
  'hydrateOnIdle',
  'onWatcherCleanup',
  'getCurrentWatcher',
  'patchProp',
  'nodeOps',
  'module.exports',
]

describe('imports:vue', () => {
  for (const name of Object.keys(VueFunctions)) {
    if (excludedVueHelpers.includes(name)) {
      continue
    }
    it(`should register ${name} globally`, () => {
      expect(defaultPresets.find(a => a.from === 'vue')!.imports).toContain(name)
    })
  }
})

describe('imports:nuxt/scripts', async () => {
  const scripts = await scriptRegistry().then(r => r.map(s => s.import?.name).filter(Boolean))
  const globalScripts = new Set([
    'useScript',
    'useScriptEventPage',
    'useScriptTriggerElement',
    'useScriptTriggerConsent',
    // registered separately
    'useScriptGoogleTagManager',
    'useScriptGoogleAnalytics',
  ])
  it.each(scriptsStubsPreset.imports)(`should register %s from @nuxt/scripts`, (name) => {
    if (globalScripts.has(name)) { return }

    expect(scripts).toContain(name)
  })
  it.each(scripts)(`should register %s from @nuxt/scripts`, (name) => {
    expect(scriptsStubsPreset.imports).toContain(name)
  })
})
</file>

<file path="packages/nuxt/test/build-plugins.bench.ts">
import { rm } from 'node:fs/promises'
import { afterAll, beforeAll, bench, describe } from 'vitest'
import { join } from 'pathe'
import type { Nuxt } from '@nuxt/schema'
import { build, loadNuxt } from 'nuxt'
import { findWorkspaceDir } from 'pkg-types'

const repoRoot = await findWorkspaceDir()
const basicTestFixtureDir = join(repoRoot, 'test/fixtures/minimal')

describe('build', () => {
  let nuxt: Nuxt
  beforeAll(async () => {
    await rm(join(basicTestFixtureDir, 'node_modules/build-plugins/.nuxt'), { recursive: true, force: true })
    nuxt = await loadNuxt({
      cwd: basicTestFixtureDir,
      ready: true,
      overrides: {
        buildDir: join(basicTestFixtureDir, 'node_modules/build-plugins/.nuxt'),
        ssr: false,
        sourcemap: false,
        hooks: {
          'build:done': () => {
            throw new Error('bypass nitro build')
          },
        },
      },
    })
  })

  afterAll(() => nuxt?.close())

  bench('initial production build in the minimal test fixture', async () => {
    await build(nuxt).catch((e) => {
      if (!e?.toString().includes('bypass nitro build')) {
        throw e
      }
    })
  })
})
</file>

<file path="packages/nuxt/test/build.bench.ts">
import { rm } from 'node:fs/promises'
import { beforeAll, bench, describe } from 'vitest'
import { join } from 'pathe'
import { build, loadNuxt } from 'nuxt'
import { findWorkspaceDir } from 'pkg-types'

const repoRoot = await findWorkspaceDir()
const basicTestFixtureDir = join(repoRoot, 'test/fixtures/basic')

describe('build', () => {
  beforeAll(async () => {
    await rm(join(basicTestFixtureDir, 'node_modules/build/.nuxt'), { recursive: true, force: true })
  })

  bench('initial dev server build in the basic test fixture', async () => {
    await new Promise((resolve) => {
      loadNuxt({
        cwd: basicTestFixtureDir,
        ready: true,
        overrides: {
          dev: true,
          buildDir: join(basicTestFixtureDir, 'node_modules/build/.nuxt'),
          sourcemap: false,
          builder: {
            async bundle (nuxt) {
              resolve(await nuxt.close())
            },
          },
        },
      }).then(build)
    })
  })
})
</file>

<file path="packages/nuxt/test/builder.test.ts">
import { writeFileSync } from 'node:fs'
import { mkdir, rm } from 'node:fs/promises'

import { join, relative, resolve } from 'pathe'
import { findWorkspaceDir } from 'pkg-types'
import { afterAll, beforeEach, describe, expect, it } from 'vitest'
import { build, loadNuxt } from 'nuxt'

describe('builder:watch', { sequential: true }, async () => {
  const tmpDir = join(await findWorkspaceDir(), '.test/builder-watch')
  beforeEach(async () => {
    await rm(tmpDir, { recursive: true, force: true })
    await mkdir(join(tmpDir, 'project/node_modules'), { recursive: true })
  })
  afterAll(async () => {
    await rm(tmpDir, { recursive: true, force: true })
  })
  const watcherStrategies = ['chokidar', 'chokidar-granular', 'parcel'] as const
  it.each(watcherStrategies)('should restart Nuxt when a file is added with %s strategy', async (watcher) => {
    const rootDir = join(tmpDir, 'project')
    const nuxt = await loadNuxt({
      cwd: rootDir,
      ready: true,
      overrides: {
        experimental: { watcher },
        dev: true,
        watch: ['test', join(rootDir, 'other'), resolve(rootDir, '../higher')],
      },
    })
    let restarts = 0
    const events: string[] = []

    nuxt.hook('restart', () => { restarts++ })
    nuxt.hook('builder:watch', (event, path) => {
      if (event === 'add') {
        events.push(relative(rootDir, path))
      }
    })

    await build(nuxt)

    const watchPromise = new Promise(resolve => nuxt.hooks.hookOnce('builder:watch', resolve))
    writeFileSync(resolve(rootDir, '../higher'), 'something')
    writeFileSync(join(rootDir, 'test'), 'something')
    writeFileSync(join(rootDir, 'other'), 'something')
    await watchPromise

    await nuxt.close()

    expect.soft(restarts).toBe(3)
    expect.soft(events.sort()).toStrictEqual([
      '../higher',
      'other',
      'test',
    ])
  })
})
</file>

<file path="packages/nuxt/test/compiler.test.ts">
import { assert, describe, expect, it } from 'vitest'
import {
  type ExportMetadata,
  type FunctionCallMetadata,
  parseStaticExportIdentifiers,
  parseStaticFunctionCall,
} from '../src/core/utils/parse-utils'
import { parseAndWalk } from 'oxc-walker'

describe('parseFunctionCall', () => {
  function getFirstParsedFunctionCall (code: string, functions: RegExp): FunctionCallMetadata | null {
    let result: FunctionCallMetadata | null = null

    parseAndWalk(code, 'file.ts', {
      enter (node) {
        if (node.type !== 'CallExpression' && node.type !== 'ChainExpression') {
          return
        }
        const res = parseStaticFunctionCall(node, functions)
        if (res) {
          result = res
          this.skip()
        }
      },
    })

    return result
  }

  function expectFunctionCallMeta (meta: FunctionCallMetadata | null, expected: {
    name: string
    namespace?: string | null
  }) {
    expect(meta).not.toBeNull()
    expect(meta?.name).toBe(expected.name)
    expect(meta?.namespace || null).toBe(expected.namespace || null)
    if (meta?.node.type === 'Identifier' && !meta.namespace) {
      expect(meta.node.name).toBe(expected.name)
    } else if (meta?.node.type === 'MemberExpression') {
      if (meta.node.property.type === 'Identifier') {
        expect(meta.node.property.name).toBe(expected.name)
      } else if (meta.node.property.type === 'Literal') {
        expect(meta.node.property.value).toBe(expected.name)
      } else {
        assert.fail(`Unexpected node property type ${meta.node.property.type}`)
      }
    }
    expect(meta?.callExpression.type).toBe('CallExpression')
  }

  it('should parse simple function call', () => {
    const code = `const data = useFetch('key')`
    const result = getFirstParsedFunctionCall(code, /useFetch/)
    expectFunctionCallMeta(result, { name: 'useFetch' })

    const code2 = `const data = useFetch()`
    const result2 = getFirstParsedFunctionCall(code2, /useFetch/)
    expectFunctionCallMeta(result2, { name: 'useFetch' })
  })

  it('should parse member call', () => {
    const code = `const x = factories.createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should parse bracket member call', () => {
    const code = `const x = factories['createUseFetch']()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should parse optional-chained member call', () => {
    const code = `const x = factories?.createUseFetch?.()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should parse optional-chained bracket call', () => {
    const code = `const x = factories?.['createUseFetch']?.()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })

    const code2 = `const x = factories?.['createUseFetch']()`
    const result2 = getFirstParsedFunctionCall(code2, /createUseFetch/)
    expectFunctionCallMeta(result2, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should parse call with await', () => {
    const code = `async function f(){ return await createUseFetch() }`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch' })
  })

  it('should parse optional chain under await', () => {
    const code = `async function f(){ return await factories?.createUseFetch?.() }`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should be robust to global regex (/g) by not relying on lastIndex', () => {
    const code = `createUseFetch(); createUseFetch();`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/g)
    expectFunctionCallMeta(result, { name: 'createUseFetch' })
  })

  it('should parse inside template expressions', () => {
    const code = 'const s = `${factories.createUseFetch()}`'
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should parse chained call result usage', () => {
    const code = `const y = (factories.createUseFetch())('key')`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should handle parenthesized callee', () => {
    const code = `(createUseFetch)()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    // callee is a ParenthesizedExpression, not Identifier
    expectFunctionCallMeta(result, { name: 'createUseFetch' })
  })

  it('should handle parenthesized optional call', () => {
    const code = `(createUseFetch)?.()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch' })

    const code2 = `const x = (factories.createUseFetch)?.()`
    const result2 = getFirstParsedFunctionCall(code2, /createUseFetch/)
    expectFunctionCallMeta(result2, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should handle a TS as-cast callee', () => {
    const code = `const x = (createUseFetch as any)()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch' })
  })

  it('should handle a TS as-cast in member expression object', () => {
    const code = `const x = (factories as any).createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should handle a TS non-null assertion callee', () => {
    const code = `const x = (createUseFetch!)()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch' })
  })

  it('should handle a TS non-null assertion in member expression object', () => {
    const code = `const x = (factories!).createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should handle a TS type-assertion in parenthesized expression callee', () => {
    const code = `const x = (<any>createUseFetch)()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch' })
  })

  it('should handle a TS type-assertion in member expression object', () => {
    const code = `const x = (<any>factories).createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should ignore similar names that do not match the filter', () => {
    const code = `createUseFetchX(); factories.createUseFetchX(); factories['createUseFetchX']()`
    const result = getFirstParsedFunctionCall(code, /\bcreateUseFetch\b/)
    expect(result).toBeNull()
  })

  it('should work with anchors in filter', () => {
    const code = `factories.createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /^createUseFetch$/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'factories' })
  })

  it('should handle calling class static methods', () => {
    const code = `class C{ static createUseFetch(){} } C.createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch', namespace: 'C' })
  })

  // non-statically analyzable cases:

  it('should return null for member expression object that is a call', () => {
    const code = `const x = getFactory().createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for multi-level member expression object', () => {
    const code = `const x = pkg.factories.createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should ignore non-matching calls', () => {
    const code = `fn(); other();`
    const result = getFirstParsedFunctionCall(code, /doesNotExist/)
    expect(result).toBeNull()
  })

  it('should return null for dynamic expression calls', () => {
    const code = `const x = (ok ? factories.createUseFetch : noop)()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for sequence callee', () => {
    const code = `(0, createUseFetch)()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for logical callee', () => {
    const code = `(ok && createUseFetch)()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for conditional callee', () => {
    const code = `(ok ? createUseFetch : other)()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for `this` member object', () => {
    const code = `this.createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for `super` member object', () => {
    const code = `class A extends B { m(){ super.createUseFetch() } }`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for private field call', () => {
    const code = `class X{ #createUseFetch(){}; f(obj){ obj.#createUseFetch() } }`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for template literal access on namespace', () => {
    const code = 'const x = factories[`createUseFetch`]()'
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for computed binary expression access on namespace', () => {
    const code = 'const x = factories["create" + "UseFetch"]()'
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for identifier template tag', () => {
    const code = 'const x = createUseFetch`tagged`'
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    // TaggedTemplateExpression, not CallExpression
    expect(result).toBeNull()
  })

  it('should return null for constructor call', () => {
    const code = `const x = new createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    // NewExpression, not CallExpression
    expect(result).toBeNull()
  })

  it('should return null for dynamic import', () => {
    const code = `async function f(){ return import('createUseFetch') }`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should handle identifier inside ChainExpression root', () => {
    const code = `createUseFetch?.()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expectFunctionCallMeta(result, { name: 'createUseFetch' })
  })

  it('should return null for multi-level optional chain: pkg?.factories?.createUseFetch()', () => {
    const code = `pkg?.factories?.createUseFetch()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it('should return null for call made via bind', () => {
    const code = `createUseFetch.bind(null)()`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })

  it ('should return null for call made via call', () => {
    const code = `createUseFetch.call(null)`
    const result = getFirstParsedFunctionCall(code, /createUseFetch/)
    expect(result).toBeNull()
  })
})

describe('parseExport', () => {
  function getAllParsedExports (code: string, exportedNameFilter?: RegExp) {
    const results: ExportMetadata[] = []

    parseAndWalk(code, 'file.ts', {
      enter (node) {
        if (node.type === 'ExportNamedDeclaration' || node.type === 'ExportDefaultDeclaration' || node.type === 'TSExportAssignment') {
          results.push(...parseStaticExportIdentifiers(node, exportedNameFilter))
        }
      },
    })

    return results
  }

  it('should handle named exports', () => {
    const code = `
      export const a = 1
      export let b = 1
      export var c = 1
      export function d() {}
      export class E {}
      const f = 'f'
      export const foo = () => {}, bar = () => {}
      export const baz = (arg1) => {}
      export { f }
      const g = 'g'
      const h = 'h'
      export { g as renamed, h as default }
    `
    expect(getAllParsedExports(code)).toMatchInlineSnapshot(`
      [
        {
          "exportedName": "a",
          "localName": "a",
        },
        {
          "exportedName": "b",
          "localName": "b",
        },
        {
          "exportedName": "c",
          "localName": "c",
        },
        {
          "exportedName": "d",
          "localName": "d",
        },
        {
          "exportedName": "E",
          "localName": "E",
        },
        {
          "exportedName": "foo",
          "localName": "foo",
        },
        {
          "exportedName": "bar",
          "localName": "bar",
        },
        {
          "exportedName": "baz",
          "localName": "baz",
        },
        {
          "exportedName": "f",
          "localName": "f",
        },
        {
          "exportedName": "renamed",
          "localName": "g",
        },
        {
          "exportedName": "default",
          "localName": "h",
        },
      ]
    `)
  })

  it('should filter out named export exported names', () => {
    const code = `
      export const a = 1
      export const _a = 1
      export let b = 1
      export let _b = 1
      export var c = 1
      export var _c = 1
      export function d() {}
      export function _d() {}
      export class E {}
      export class _E {}
      const f = 'f'
      const _f = 'f'
      export const foo = () => {}, bar = () => {}
      export const _foo = () => {}, _bar = () => {}
      export { f }
      export { _f }
      const g = 'g'
      const _g = 'g'
      export { _g as renamed }
      export { g as _renamed }
    `
    expect(getAllParsedExports(code, /^(?!_).+/)).toMatchInlineSnapshot(`
      [
        {
          "exportedName": "a",
          "localName": "a",
        },
        {
          "exportedName": "b",
          "localName": "b",
        },
        {
          "exportedName": "c",
          "localName": "c",
        },
        {
          "exportedName": "d",
          "localName": "d",
        },
        {
          "exportedName": "E",
          "localName": "E",
        },
        {
          "exportedName": "foo",
          "localName": "foo",
        },
        {
          "exportedName": "bar",
          "localName": "bar",
        },
        {
          "exportedName": "f",
          "localName": "f",
        },
        {
          "exportedName": "renamed",
          "localName": "_g",
        },
      ]
    `)
  })

  it('should handle default export', () => {
    expect(getAllParsedExports('export default function foo() {}')).toMatchInlineSnapshot(`
      [
        {
          "exportedName": "default",
          "localName": "foo",
        },
      ]
    `)
    expect(getAllParsedExports('export default class Foo {}')).toMatchInlineSnapshot(`
      [
        {
          "exportedName": "default",
          "localName": "Foo",
        },
      ]
    `)
    expect(getAllParsedExports('export default () => {}')).toMatchInlineSnapshot(`[]`)
    expect(getAllParsedExports('const foo = \'foo\'; export default foo')).toMatchInlineSnapshot(`
      [
        {
          "exportedName": "default",
          "localName": "foo",
        },
      ]
    `)
    expect(getAllParsedExports('const foo = \'foo\'; export = foo')).toMatchInlineSnapshot(`
      [
        {
          "exportedName": "default",
          "localName": "foo",
        },
      ]
    `)
  })

  it('shouldn\'t filter default export local name', () => {
    const code = `
      const _default = 'default'
      export { _default as default }
    `
    expect(getAllParsedExports(code, /^(?!_).+/)).toMatchInlineSnapshot(`
      [
        {
          "exportedName": "default",
          "localName": "_default",
        },
      ]
    `)

    const code2 = `
      function _foo() {}
      export default _foo
    `
    expect(getAllParsedExports(code2, /^(?!_).+/)).toMatchInlineSnapshot(`
      [
        {
          "exportedName": "default",
          "localName": "_foo",
        },
      ]
    `)

    const code3 = `
      class _Bar {}
      export default _Bar
    `
    expect(getAllParsedExports(code3, /^(?!_).+/)).toMatchInlineSnapshot(`
      [
        {
          "exportedName": "default",
          "localName": "_Bar",
        },
      ]
    `)

    const code4 = `
      export default function _baz() {}
    `
    expect(getAllParsedExports(code4, /^(?!_).+/)).toMatchInlineSnapshot(`
      [
        {
          "exportedName": "default",
          "localName": "_baz",
        },
      ]
    `)
  })

  it('should ignore non-supported exports', () => {
    const code = `
      export const { a, b } = obj
      export const [x, y] = arr
      export default 42
      export { a + b as sum }
      export * from 'module'
      export { a } from 'module'
    `
    expect(getAllParsedExports(code)).toMatchInlineSnapshot(`[]`)
  })

  it('should ignore non-export nodes', () => {
    const code = `
      import { x } from 'module'
      const a = 1
      function f() {}
      class C {}
    `
    expect(getAllParsedExports(code)).toMatchInlineSnapshot(`[]`)
  })

  it('ignores type-exports', () => {
    const code = `
      export type T = { a: number }
      export interface I { b: string }
      type U = number | string
      export type { U }
      export type { U as V }
      export { type U }
      export { type U as V }
    `
    expect(getAllParsedExports(code)).toMatchInlineSnapshot(`[]`)
  })
})
</file>

<file path="packages/nuxt/test/component-layer-priority.test.ts">
import { fileURLToPath } from 'node:url'
import { normalize } from 'pathe'
import { withoutTrailingSlash } from 'ufo'
import { describe, expect, it } from 'vitest'
import { loadNuxt } from '../src/index.ts'
import { buildNuxt } from '@nuxt/kit'
import type { ComponentsDir } from 'nuxt/schema'

const layerFixtureDir = withoutTrailingSlash(normalize(fileURLToPath(new URL('./layers-fixture', import.meta.url))))

describe('components layer priority', () => {
  it('assigns priorities to component dirs based on layer order', async () => {
    const captured: ComponentsDir[] = []

    const nuxt = await loadNuxt({
      cwd: layerFixtureDir,
      ready: true,
      overrides: {
        builder: {
          bundle: () => {
            nuxt.hooks.removeAllHooks()
            return Promise.resolve()
          },
        },
      },
    })

    nuxt.hook('components:dirs', (dirs) => {
      captured.push(...dirs as any[])
    })

    await buildNuxt(nuxt)

    const dirs = captured.map(dir => [
      dir.path.replace(layerFixtureDir, '<root>'),
      dir.priority,
    ])

    expect(Object.fromEntries(dirs)).toStrictEqual({
      // user project: highest priority
      '<root>/components': 3,
      '<root>/components/global': 3,
      '<root>/components/islands': 3,
      // local layer
      '<root>/layers/auto/components': 2,
      '<root>/layers/auto/components/global': 2,
      '<root>/layers/auto/components/islands': 2,
      // explicitly extended layer
      '<root>/custom/components': 1,
      '<root>/custom/components/global': 1,
      '<root>/custom/components/islands': 1,
    })

    await nuxt.close()
  })
})
</file>

<file path="packages/nuxt/test/component-loader.test.ts">
import { describe, expect, it } from 'vitest'
import { kebabCase, pascalCase } from 'scule'
import { rollup } from 'rollup'
import vuePlugin from '@vitejs/plugin-vue'
import vuePluginJsx from '@vitejs/plugin-vue-jsx'
import type { AddComponentOptions } from '@nuxt/kit'
import { LoaderPlugin } from '../src/components/plugins/loader.ts'
import { LazyHydrationTransformPlugin } from '../src/components/plugins/lazy-hydration-transform.ts'

describe('components:loader', () => {
  it('should correctly resolve components', async () => {
    const sfc = `
    <template>
      <MyComponent />
      <LazyMyComponent />
      <RouterLink />
      <NamedComponent />
    </template>

    <script setup>
    const NamedComponent = resolveComponent('MyComponent')
    </script>
    `
    const code = await transform(sfc, '/pages/index.vue')
    expect(code).toMatchInlineSnapshot(`
      "import __nuxt_component_0 from '../components/MyComponent.vue';
      import { defineAsyncComponent, resolveComponent, createElementBlock, openBlock, Fragment, createVNode, unref } from 'vue';

      const __nuxt_component_0_lazy = defineAsyncComponent(() => import('../components/MyComponent.vue').then(c => c.default || c));


      const _sfc_main = {
        __name: 'index',
        setup(__props) {

          const NamedComponent = __nuxt_component_0;
          
      return (_ctx, _cache) => {
        const _component_MyComponent = __nuxt_component_0;
        const _component_LazyMyComponent = __nuxt_component_0_lazy;
        const _component_RouterLink = resolveComponent("RouterLink");

        return (openBlock(), createElementBlock(Fragment, null, [
          createVNode(_component_MyComponent),
          createVNode(_component_LazyMyComponent),
          createVNode(_component_RouterLink),
          createVNode(unref(NamedComponent))
        ], 64 /* STABLE_FRAGMENT */))
      }
      }

      };

      export { _sfc_main as default };"
    `)
  })

  it('should correctly resolve components with minifyWhitespace (esbuild) #32290', async () => {
    const content = `import { createHotContext as __vite__createHotContext } from "/_nuxt/@vite/client";import.meta.hot = __vite__createHotContext("/app.vue");import { recordPosition as _tracerRecordPosition } from "vite-plugin-vue-tracer/dist/client/record.mjs"
import{defineComponent as _defineComponent}from"vue";const _sfc_main=_defineComponent({__name:"app",setup(__props,{expose:__expose}){__expose();console.log("111");const __returned__={};Object.defineProperty(__returned__,"__isScriptSetup",{enumerable:false,value:true});return __returned__}});import{resolveComponent as _resolveComponent,createVNode as _createVNode,openBlock as _openBlock,createElementBlock as _createElementBlock}from"/_nuxt/node_modules/.pnpm/vue@3.5.16_typescript@5.8.3/node_modules/vue/dist/vue.runtime.esm-bundler.js?v=cbc061e8";function _sfc_render(_ctx,_cache,$props,$setup,$data,$options){const _component_NuxtRouteAnnouncer=_resolveComponent("MyComponent");const _component_NuxtWelcome=_resolveComponent("MyComponent");return _openBlock(),_tracer(2,2,_createElementBlock("div",null,[_tracer(3,4,_createVNode(_component_NuxtRouteAnnouncer)),_tracer(4,4,_createVNode(_component_NuxtWelcome))]))}_sfc_main.__hmrId="938b83b0";typeof __VUE_HMR_RUNTIME__!=="undefined"&&__VUE_HMR_RUNTIME__.createRecord(_sfc_main.__hmrId,_sfc_main);import.meta.hot.on("file-changed",({file})=>{__VUE_HMR_RUNTIME__.CHANGED_FILE=file});import.meta.hot.accept(mod=>{if(!mod)return;const{default:updated,_rerender_only}=mod;if(_rerender_only){__VUE_HMR_RUNTIME__.rerender(updated.__hmrId,updated.render)}else{__VUE_HMR_RUNTIME__.reload(updated.__hmrId,updated)}});import _export_sfc from"/_nuxt/@id/__x00__plugin-vue:export-helper";export default _export_sfc(_sfc_main,[["render",_sfc_render],["__file","/project/workspace/app.vue"]]);

function _tracer(line, column, vnode) { return _tracerRecordPosition("app.vue", line, column, vnode) }
`
    const code = await ((plugin.raw({}, { framework: 'vite' }) as { transform: (code: string, id: string) => { code: string } | null }).transform(
      content,
      '/app.vue',
    ))
    expect(code).toMatchInlineSnapshot(`
      {
        "code": "import { default as __nuxt_component_0 } from "/components/MyComponent.vue";
      import { createHotContext as __vite__createHotContext } from "/_nuxt/@vite/client";import.meta.hot = __vite__createHotContext("/app.vue");import { recordPosition as _tracerRecordPosition } from "vite-plugin-vue-tracer/dist/client/record.mjs"
      import{defineComponent as _defineComponent}from"vue";const _sfc_main=_defineComponent({__name:"app",setup(__props,{expose:__expose}){__expose();console.log("111");const __returned__={};Object.defineProperty(__returned__,"__isScriptSetup",{enumerable:false,value:true});return __returned__}});import{resolveComponent as _resolveComponent,createVNode as _createVNode,openBlock as _openBlock,createElementBlock as _createElementBlock}from"/_nuxt/node_modules/.pnpm/vue@3.5.16_typescript@5.8.3/node_modules/vue/dist/vue.runtime.esm-bundler.js?v=cbc061e8";function _sfc_render(_ctx,_cache,$props,$setup,$data,$options){const _component_NuxtRouteAnnouncer=__nuxt_component_0;const _component_NuxtWelcome=__nuxt_component_0;return _openBlock(),_tracer(2,2,_createElementBlock("div",null,[_tracer(3,4,_createVNode(_component_NuxtRouteAnnouncer)),_tracer(4,4,_createVNode(_component_NuxtWelcome))]))}_sfc_main.__hmrId="938b83b0";typeof __VUE_HMR_RUNTIME__!=="undefined"&&__VUE_HMR_RUNTIME__.createRecord(_sfc_main.__hmrId,_sfc_main);import.meta.hot.on("file-changed",({file})=>{__VUE_HMR_RUNTIME__.CHANGED_FILE=file});import.meta.hot.accept(mod=>{if(!mod)return;const{default:updated,_rerender_only}=mod;if(_rerender_only){__VUE_HMR_RUNTIME__.rerender(updated.__hmrId,updated.render)}else{__VUE_HMR_RUNTIME__.reload(updated.__hmrId,updated)}});import _export_sfc from"/_nuxt/@id/__x00__plugin-vue:export-helper";export default _export_sfc(_sfc_main,[["render",_sfc_render],["__file","/project/workspace/app.vue"]]);

      function _tracer(line, column, vnode) { return _tracerRecordPosition("app.vue", line, column, vnode) }
      ",
        "map": undefined,
      }
    `)

    expect(code?.code).toContain('__nuxt_component_0')
  })

  it('should work in jsx', async () => {
    const component = `
    import { defineComponent } from 'vue'
    export default defineComponent({
      setup () {
        const NamedComponent = resolveComponent('MyComponent')
        return () => <div>
          <MyComponent />
          <LazyMyComponent />
          <RouterLink />
          <NamedComponent />
        </div>
      }
    })
    `
    const code = await transform(component, '/pages/about.tsx')
    expect(code).toMatchInlineSnapshot(`
      "import __nuxt_component_0 from '../components/MyComponent.vue';
      import { defineAsyncComponent, defineComponent, createVNode, resolveComponent } from 'vue';

      const __nuxt_component_0_lazy = defineAsyncComponent(() => import('../components/MyComponent.vue').then(c => c.default || c));
      var about = /* @__PURE__ */ defineComponent({
        setup() {
          const NamedComponent = __nuxt_component_0;
          return () => createVNode("div", null, [createVNode(__nuxt_component_0, null, null), createVNode(__nuxt_component_0_lazy, null, null), createVNode(resolveComponent("RouterLink"), null, null), createVNode(NamedComponent, null, null)]);
        }
      });

      export { about as default };"
    `)
  })

  it('should auto-import JSX components with h() calls', async () => {
    const component = `
    import { h } from 'vue'
    export default {
      render() {
        return h('div', [
          h(MyComponent, { foo: 'bar' }),
          h(MyComponent, null, 'Hello')
        ])
      }
    }
    `
    const code = await transform(component, '/pages/jsx-h.tsx')
    expect(code).toContain('import __nuxt_component_0 from \'../components/MyComponent.vue\'')
    expect(code).toContain('h(__nuxt_component_0,')
  })

  it('should auto-import JSX components in various contexts', async () => {
    const component = `
    import { h, defineComponent } from 'vue'
    export default defineComponent({
      setup() {
        return () => h('div', [
          h(MyComponent),
          h(MyComponent, {}),
          h(MyComponent, { prop: true }),
          h(MyComponent, null, ['children']),
        ])
      }
    })
    `
    const code = await transform(component, '/pages/contexts.tsx')
    expect(code).toContain('import __nuxt_component_0 from \'../components/MyComponent.vue\'')
    // Should replace all h(MyComponent) instances
    const matches = code.match(/h\(__nuxt_component_0/g)
    expect(matches).toHaveLength(4)
  })

  it('should handle multiple different JSX components', async () => {
    const component = `
    import { h } from 'vue'
    export default {
      render() {
        return h('div', [
          h(MyComponent, { id: 1 }),
          h(OtherComponent, { id: 2 }),
          h(MyComponent, { id: 3 })
        ])
      }
    }
    `
    const code = await transform(component, '/pages/multiple.tsx')
    expect(code).toContain('import __nuxt_component_0 from \'../components/MyComponent.vue\'')
    // MyComponent should appear twice
    const myComponentMatches = code.match(/h\(__nuxt_component_0/g)
    expect(myComponentMatches).toHaveLength(2)
    // OtherComponent should not be replaced (not in components list)
    expect(code).toContain('h(OtherComponent,')
  })

  it('should not replace h() calls with lowercase component names', async () => {
    const component = `
    import { h } from 'vue'
    export default {
      render() {
        return h('div', [
          h(myComponent),
          h(myOtherComponent)
        ])
      }
    }
    `
    const code = await transform(component, '/pages/lowercase.tsx')
    // Should not auto-import lowercase identifiers
    expect(code).not.toContain('import __nuxt_component')
    expect(code).toContain('h(myComponent')
    expect(code).toContain('h(myOtherComponent')
  })

  it('should handle JSX with lazy components in JSX syntax', async () => {
    const component = `
    import { defineComponent } from 'vue'
    export default defineComponent({
      setup() {
        return () => <div>
          <LazyMyComponent foo="bar" />
        </div>
      }
    })
    `
    const code = await transform(component, '/pages/lazy-jsx.tsx')
    expect(code).toContain('defineAsyncComponent')
    expect(code).toContain('__nuxt_component_0_lazy')
    expect(code).toContain('createVNode(__nuxt_component_0_lazy,')
  })

  it('should correctly resolve lazy hydration components', async () => {
    const sfc = `
    <template>
      <LazyMyComponent :hydrate-on-idle="3000" />
      <LazyMyComponent :hydrate-on-visible="{threshold: 0.2}" />
      <LazyMyComponent :hydrate-on-interaction="['click','mouseover']" />
      <LazyMyComponent hydrate-on-media-query="(max-width: 500px)" />
      <LazyMyComponent :hydrate-after="3000" />
      <LazyMyComponent :hydrateAfter="3000" />
      <LazyMyComponent :hydrate-on-idle>
        <LazyMyComponent hydrate-when="true" />
      </LazyMyComponent>
      <LazyMyComponent hydrate-on-visible />
      <LazyMyComponent hydrate-never />
    </template>
    `
    const lines = await transform(sfc, '/pages/index.vue').then(r => r.split('\n'))
    const imports = lines.filter(l => l.startsWith('import'))
    expect(imports.join('\n')).toMatchInlineSnapshot(`
      "import { createLazyIdleComponent, createLazyVisibleComponent, createLazyInteractionComponent, createLazyMediaQueryComponent, createLazyTimeComponent, createLazyIfComponent, createLazyNeverComponent } from '../client-runtime.mjs';
      import { createElementBlock, openBlock, Fragment, createVNode, withCtx } from 'vue';"
    `)
    const components = lines.filter(l => l.startsWith('const __nuxt_component'))
    expect(components.join('\n')).toMatchInlineSnapshot(`
      "const __nuxt_component_0_lazy_idle = createLazyIdleComponent("components/MyComponent.vue", () => import('../components/MyComponent.vue').then(c => c.default || c));
      const __nuxt_component_0_lazy_visible = createLazyVisibleComponent("components/MyComponent.vue", () => import('../components/MyComponent.vue').then(c => c.default || c));
      const __nuxt_component_0_lazy_event = createLazyInteractionComponent("components/MyComponent.vue", () => import('../components/MyComponent.vue').then(c => c.default || c));
      const __nuxt_component_0_lazy_media = createLazyMediaQueryComponent("components/MyComponent.vue", () => import('../components/MyComponent.vue').then(c => c.default || c));
      const __nuxt_component_0_lazy_time = createLazyTimeComponent("components/MyComponent.vue", () => import('../components/MyComponent.vue').then(c => c.default || c));
      const __nuxt_component_0_lazy_if = createLazyIfComponent("components/MyComponent.vue", () => import('../components/MyComponent.vue').then(c => c.default || c));
      const __nuxt_component_0_lazy_never = createLazyNeverComponent("components/MyComponent.vue", () => import('../components/MyComponent.vue').then(c => c.default || c));"
    `)
  })

  it.each([
    ['hydrate-on-idle', 'createLazyIdleComponent'],
    ['hydrate-on-visible', 'createLazyVisibleComponent'],
    ['hydrate-on-interaction', 'createLazyInteractionComponent'],
    ['hydrate-on-media-query', 'createLazyMediaQueryComponent'],
    ['hydrate-after', 'createLazyTimeComponent'],
    ['hydrate-when', 'createLazyIfComponent'],
    ['hydrate-never', 'createLazyNeverComponent'],
    ['hydrateOnIdle', 'createLazyIdleComponent'],
    ['hydrateOnVisible', 'createLazyVisibleComponent'],
    ['hydrateOnInteraction', 'createLazyInteractionComponent'],
    ['hydrateOnMediaQuery', 'createLazyMediaQueryComponent'],
    ['hydrateAfter', 'createLazyTimeComponent'],
    ['hydrateWhen', 'createLazyIfComponent'],
    ['hydrateNever', 'createLazyNeverComponent'],
  ])('should correctly resolve lazy hydration components %s', async (prop, component) => {
    const sfc = `
    <template>
      <LazyMyComponent ${prop} />
    </template>
    `
    const result = await transform(sfc, '/pages/index.vue').then(r => r.split('\n'))
    expect(result.join('\n')).toContain(component)
  })
})
const components = ([{ name: 'MyComponent', filePath: '/components/MyComponent.vue' }] as AddComponentOptions[]).map(opts => ({
  export: opts.export || 'default',
  chunkName: 'components/' + kebabCase(opts.name),
  global: opts.global ?? false,
  kebabName: kebabCase(opts.name || ''),
  pascalName: pascalCase(opts.name || ''),
  prefetch: false,
  preload: false,
  mode: 'all' as const,
  shortPath: opts.filePath,
  priority: 0,
  meta: {},
  ...opts,
}))

const plugin = LoaderPlugin({
  clientDelayedComponentRuntime: '/client-runtime.mjs',
  serverComponentRuntime: '/server-runtime.mjs',
  getComponents: () => components,
  srcDir: '/',
  mode: 'server',
})

async function transform (code: string, filename: string) {
  const bundle = await rollup({
    input: filename,
    plugins: [
      {
        name: 'entry',
        resolveId (id) {
          if (id === filename) {
            return id
          }
        },
        load (id) {
          if (id === filename) {
            return code
          }
        },
      },
      LazyHydrationTransformPlugin({ getComponents: () => components }).rollup(),
      vuePlugin(),
      vuePluginJsx(),
      plugin.rollup(),
    ],
  })
  const { output: [chunk] } = await bundle.generate({})
  return chunk.code.trim()
}
</file>

<file path="packages/nuxt/test/component-names.test.ts">
import { describe, expect, it } from 'vitest'
import type { Component } from '@nuxt/schema'
import { compileScript, parse } from '@vue/compiler-sfc'

import { ComponentNamePlugin } from '../src/components/plugins/component-names.ts'

describe('component names', () => {
  const components = [
    {
      filePath: 'test.ts',
      pascalName: 'TestMe',
    },
    {
      filePath: 'test.vue',
      pascalName: 'TestMe',
    },
  ] as [Component, Component]

  const transformPlugin = ComponentNamePlugin({ sourcemap: false, getComponents: () => components }).raw({}, {} as any) as { transform: { handler: (code: string, id: string) => { code: string } | null } }

  it('should ignore files that are not components ', () => {
    const res = transformPlugin.transform.handler('export default {}', 'some-other-file.ts')
    expect(res?.code).toBeUndefined()
  })

  it('should process simple default exports', () => {
    const res = transformPlugin.transform.handler('export default {}', 'test.vue')
    expect(res?.code).toMatchInlineSnapshot(`"export default Object.assign({}, { __name: "TestMe" })"`)
  })

  it('should add correct default component names', () => {
    const sfc = `
<script setup>
onMounted(() => {
  window.a = 32
})
</script>
    `
    const res = compileScript(parse(sfc).descriptor, { id: 'test.vue' })
    const { code } = transformPlugin.transform.handler(res.content, components[0].filePath) ?? {}
    expect(code?.trim()).toMatchInlineSnapshot(`
      "export default Object.assign({
        setup(__props, { expose: __expose }) {
        __expose();

      onMounted(() => {
        window.a = 32
      })

      const __returned__ = {  }
      Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
      return __returned__
      }

      }, { __name: "TestMe" })"
    `)
  })
})
</file>

<file path="packages/nuxt/test/components-transform.test.ts">
import { fileURLToPath } from 'node:url'
import { describe, expect, it } from 'vitest'
import type { Component, Nuxt } from '@nuxt/schema'
import { kebabCase } from 'scule'
import { join, normalize } from 'pathe'
import { findWorkspaceDir } from 'pkg-types'

import { TransformPlugin } from '../src/components/plugins/transform.ts'

const pkgPath = fileURLToPath(new URL('./node_modules/package-fixture', import.meta.url))
const virtualFilePath = join(pkgPath, 'foo', 'bar', 'baz')

describe('components:transform', () => {
  it('should transform #components imports', async () => {
    const transform = createTransformer([
      createComponent('Foo'),
      createComponent('Bar', { export: 'Bar' }),
    ])

    const code = await transform('import { Foo, Bar } from \'#components\'', '/app.vue')
    expect(code).toMatchInlineSnapshot(`
      "
      import Foo from '/Foo.vue';
      import { Bar } from '/Bar.vue';
      "
    `)
  })

  it('should ignore #components import mapping inside packages that use it internally', async () => {
    const transform = createTransformer([
      createComponent('Foo'),
      createComponent('Bar', { export: 'Bar' }),
    ])

    const code = await transform('import { Internal, Private } from \'#components\'', virtualFilePath)
    expect(code).toMatchInlineSnapshot(`undefined`)
  })

  it('should correctly resolve server-only components', async () => {
    const transform = createTransformer([
      createComponent('Foo', { mode: 'server' }),
    ])

    const code = await transform('import { Foo, LazyFoo } from \'#components\'', '/app.vue')
    expect(code).toMatchInlineSnapshot(`
      "
      import Foo from '/Foo.vue?nuxt_component=server&nuxt_component_name=Foo&nuxt_component_export=default';
      import LazyFoo from '/Foo.vue?nuxt_component=server,async&nuxt_component_name=Foo&nuxt_component_export=default';
      "
    `)

    expect(await transform('', '/Foo.vue?nuxt_component=server&nuxt_component_name=Foo&nuxt_component_export=default')).toMatchInlineSnapshot(`
      "import { createServerComponent } from "<repo>/nuxt/src/components/runtime/server-component"
      export default createServerComponent("Foo")"
    `)
    expect(await transform('', '/Foo.vue?nuxt_component=server,async&nuxt_component_name=Foo&nuxt_component_export=default')).toMatchInlineSnapshot(`
      "import { createServerComponent } from "<repo>/nuxt/src/components/runtime/server-component"
      export default createServerComponent("Foo")"
    `)
    expect(await transform('', '/Foo.vue?nuxt_component=server&nuxt_component_name=Foo&nuxt_component_export=Foo')).toMatchInlineSnapshot(`
      "import { createServerComponent } from "<repo>/nuxt/src/components/runtime/server-component"
      export const Foo = createServerComponent("Foo")"
    `)
  })

  it('should correctly resolve client-only components', async () => {
    const transform = createTransformer([
      createComponent('Foo', { mode: 'client' }),
    ])

    const code = await transform('import { Foo, LazyFoo } from \'#components\'', '/app.vue')
    expect(code).toMatchInlineSnapshot(`
      "
      import Foo from '/Foo.vue?nuxt_component=client&nuxt_component_name=Foo&nuxt_component_export=default';
      import LazyFoo from '/Foo.vue?nuxt_component=client,async&nuxt_component_name=Foo&nuxt_component_export=default';
      "
    `)

    expect(await transform('', '/Foo.vue?nuxt_component=client&nuxt_component_name=Foo&nuxt_component_export=default')).toMatchInlineSnapshot(`
      "import { default as __component } from "/Foo.vue";
      import { createClientOnly } from "#app/components/client-only"
      export default createClientOnly(__component)"
    `)
    expect(await transform('', '/Foo.vue?nuxt_component=client,async&nuxt_component_name=Foo&nuxt_component_export=default')).toMatchInlineSnapshot(`
      "import { defineAsyncComponent } from "vue"
      import { createClientOnly } from "#app/components/client-only"
      export default defineAsyncComponent(() => import("/Foo.vue").then(r => createClientOnly(r["default"] || r.default || r)))"
    `)
    expect(await transform('', '/Foo.vue?nuxt_component=client,async&nuxt_component_name=Foo&nuxt_component_export=Foo')).toMatchInlineSnapshot(`
      "import { defineAsyncComponent } from "vue"
      import { createClientOnly } from "#app/components/client-only"
      export const Foo = defineAsyncComponent(() => import("/Foo.vue").then(r => createClientOnly(r["Foo"] || r.default || r)))"
    `)
  })
})

const repoRoot = await findWorkspaceDir()

function createTransformer (components: Component[], mode: 'client' | 'server' | 'all' = 'all') {
  const stubNuxt = {
    options: {
      buildDir: '/',
      sourcemap: {
        server: false,
        client: false,
      },
    },
  } as Nuxt
  const plugins = TransformPlugin(stubNuxt, {
    mode,
    getComponents: () => components,
    serverComponentRuntime: '<repo>/nuxt/src/components/runtime/server-component',
  }).vite()

  return async (code: string, id: string) => {
    let transformResult: string | undefined
    for (const plugin of plugins as any[]) {
      const result = await plugin.transform.handler(transformResult || code, id)
      transformResult = (typeof result === 'string' ? result : result?.code) || transformResult
    }
    return transformResult?.replaceAll(normalize(repoRoot), '<repo>/')
  }
}

function createComponent (pascalName: string, options: Partial<Component> = {}) {
  return {
    filePath: `/${pascalName}.vue`,
    pascalName,
    export: 'default',
    chunkName: `components/${pascalName.toLowerCase()}`,
    kebabName: kebabCase(pascalName),
    mode: 'all',
    prefetch: false,
    preload: false,
    shortPath: `components/${pascalName}.vue`,
    ...options,
  } satisfies Component
}
</file>

<file path="packages/nuxt/test/components-tree-shake.test.ts">
import { readFileSync } from 'node:fs'
import path from 'node:path'
import process from 'node:process'
import { describe, expect, it, vi } from 'vitest'
import * as VueCompilerSFC from 'vue/compiler-sfc'
import type { Plugin } from 'vite'
import { createLogger } from 'vite'
import type { Options } from '@vitejs/plugin-vue'
import _vuePlugin from '@vitejs/plugin-vue'
import { TreeShakeTemplatePlugin } from '../src/components/plugins/tree-shake.ts'
import { componentsFixtureDir, normalizeLineEndings } from './utils.ts'

// mock due to differences of results between windows and linux
vi.spyOn(path, 'relative').mockImplementation((from: string, to: string) => {
  if (to.includes('SomeComponent')) {
    return to
  }
  return path.resolve(from, to)
})

function vuePlugin (options: Options) {
  return {
    ..._vuePlugin(options),
    handleHotUpdate () {},
    configureDevServer () {},
  }
}

const WithClientOnly = normalizeLineEndings(readFileSync(path.resolve(componentsFixtureDir, './components/client/WithClientOnlySetup.vue')).toString())

const treeshakeTemplatePlugin = TreeShakeTemplatePlugin({
  sourcemap: false,
  getComponents () {
    return [{
      pascalName: 'NotDotClientComponent',
      kebabName: 'not-dot-client-component',
      export: 'default',
      filePath: 'dummypath',
      shortPath: 'dummypath',
      chunkName: '123',
      prefetch: false,
      preload: false,
      mode: 'client',
    }, {
      pascalName: 'DotClientComponent',
      kebabName: 'dot-client-component',
      export: 'default',
      filePath: 'dummypath',
      shortPath: 'dummypath',
      chunkName: '123',
      prefetch: false,
      preload: false,
      mode: 'client',
    }]
  },
}).raw({}, { framework: 'rollup' }) as Plugin

const treeshake = async (source: string): Promise<string> => {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  const result = await (treeshakeTemplatePlugin.transform! as Function)(source, 'test.ts')
  return typeof result === 'string' ? result : result?.code
}

async function SFCCompile (name: string, source: string, options: Options, ssr = false): Promise<string> {
  const plugin = vuePlugin({
    compiler: VueCompilerSFC,
    ...options,
  })
  // @ts-expect-error Types are not correct as they are too generic
  plugin.configResolved!({
    logger: createLogger(),
    isProduction: options.isProduction,
    command: 'build',
    root: process.cwd(),
    build: { sourcemap: false },
    define: {},
  })
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  const result = await ((plugin.transform as any)!.handler as Function)(source, name, { ssr })

  return typeof result === 'string' ? result : result?.code
}

const stateToTest: { index: number, name: string, options: Partial<Options & { devServer: { config: { server: any } } }> }[] = [
  {
    index: 0,
    name: 'prod',
    options: {
      isProduction: true,
    },
  },
  {
    index: 1,
    name: 'dev',
    options: {
      isProduction: false,
      devServer: {
        config: {
          // trigger dev behavior
          server: false,
        },
      },
    },
  },
]

describe('treeshake client only in ssr', () => {
  vi.spyOn(process, 'cwd').mockImplementation(() => '')
  it.each(stateToTest)(`should treeshake ClientOnly correctly in $name`, async (state) => {
    // add index to avoid using vite vue plugin cache
    const clientResult = await SFCCompile(`SomeComponent${state.index}.vue`, WithClientOnly, state.options)

    const ssrResult = await SFCCompile(`SomeComponent${state.index}.vue`, WithClientOnly, state.options, true)

    const treeshaken = await treeshake(ssrResult)
    const [_, scopeId] = clientResult.match(/['"]__scopeId['"],\s*['"](data-v-[^'"]+)['"]/)!

    // ensure the id is correctly passed between server and client
    expect(clientResult).toContain(`'__scopeId',"${scopeId}"`)
    expect(treeshaken).toContain(`<div ${scopeId}>`)

    expect(clientResult).toContain('should-be-treeshaken')
    expect(treeshaken).not.toContain('should-be-treeshaken')

    expect(treeshaken).not.toContain('import HelloWorld from \'../HelloWorld.vue\'')
    expect(clientResult).toContain('import HelloWorld from \'../HelloWorld.vue\'')

    expect(treeshaken).not.toContain('import { Treeshaken } from \'somepath\'')
    expect(clientResult).toContain('import { Treeshaken } from \'somepath\'')

    // remove resolved import
    expect(treeshaken).not.toContain('const _component_ResolvedImport =')
    expect(clientResult).toContain('const _component_ResolvedImport =')

    // treeshake multi line variable declaration
    expect(clientResult).toContain('const SomeIsland = defineAsyncComponent(async () => {')
    expect(treeshaken).not.toContain('const SomeIsland = defineAsyncComponent(async () => {')
    expect(treeshaken).not.toContain('return (await import(\'./../some.island.vue\'))')
    expect(treeshaken).toContain('const NotToBeTreeShaken = defineAsyncComponent(async () => {')

    // treeshake object and array declaration
    expect(treeshaken).not.toContain('const { ObjectPattern } = await import(\'nuxt.com\')')
    expect(treeshaken).not.toContain('const { ObjectPattern: ObjectPatternDeclaration } = await import(\'nuxt.com\')')
    expect(treeshaken).toContain('const {  ButShouldNotBeTreeShaken } = defineAsyncComponent(async () => {')
    expect(treeshaken).toContain('const [ { Dont, }, That] = defineAsyncComponent(async () => {')

    // treeshake object that has an assignment pattern
    expect(treeshaken).toContain('const { woooooo, } = defineAsyncComponent(async () => {')
    expect(treeshaken).not.toContain('const { Deep, assignment: { Pattern = ofComponent } } = defineAsyncComponent(async () => {')

    // expect no empty ObjectPattern on treeshaking
    expect(treeshaken).not.toContain('const {  } = defineAsyncComponent')
    expect(treeshaken).not.toContain('import {  } from')

    // expect components used in setup to not be removed
    expect(treeshaken).toContain('import DontRemoveThisSinceItIsUsedInSetup from \'./ComponentWithProps.vue\'')

    // expect import of ClientImport to be treeshaken but not Glob since it is also used outside <ClientOnly>
    expect(treeshaken).not.toContain('ClientImport')
    expect(treeshaken).toContain('import {  Glob } from \'#components\'')

    // treeshake .client slot
    expect(treeshaken).not.toContain('ByeBye')
    // don't treeshake variables that has the same name as .client components
    expect(treeshaken).toContain('NotDotClientComponent')
    expect(treeshaken).not.toContain('(DotClientComponent')

    expect(treeshaken).not.toContain('AutoImportedComponent')
    expect(treeshaken).toContain('AutoImportedNotTreeShakenComponent')

    expect(treeshaken).not.toContain('Both')
    expect(treeshaken).not.toContain('AreTreeshaken')

    if (state.options.isProduction === false) {
      // treeshake at inlined template
      expect(treeshaken).not.toContain('ssrRenderComponent($setup["HelloWorld"]')
      expect(treeshaken).toContain('ssrRenderComponent($setup["Glob"]')
    } else {
      // treeshake unref
      expect(treeshaken).not.toContain('ssrRenderComponent(_unref(HelloWorld')
      expect(treeshaken).toContain('ssrRenderComponent(_unref(Glob')
    }
    expect(treeshaken.replace(/data-v-\w{8}/g, 'data-v-one-hash').replace(/scoped=\w{8}/g, 'scoped=one-hash')).toMatchSnapshot()
  })

  it('should not treeshake reused component #26137', async () => {
    const treeshaken = await treeshake(`import { resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode } from "vue"
    import { ssrRenderComponent as _ssrRenderComponent, ssrRenderAttrs as _ssrRenderAttrs } from "vue/server-renderer"

    export function ssrRender(_ctx, _push, _parent, _attrs) {
      const _component_AppIcon = _resolveComponent("AppIcon")
      const _component_ClientOnly = _resolveComponent("ClientOnly")

      _push(\`<div\${_ssrRenderAttrs(_attrs)}>\`)
      _push(_ssrRenderComponent(_component_AppIcon, { name: "caret-left" }, null, _parent))
      _push(_ssrRenderComponent(_component_ClientOnly, null, {
        default: _withCtx((_, _push, _parent, _scopeId) => {
          if (_push) {
            _push(\`<span\${_scopeId}>TEST</span>\`)
            _push(_ssrRenderComponent(_component_AppIcon, { name: "caret-up" }, null, _parent, _scopeId))
          } else {
            return [
              _createVNode("span", null, "TEST"),
              _createVNode(_component_AppIcon, { name: "caret-up" })
            ]
          }
        }),
        _: 1 /* STABLE */
      }, _parent))
      _push(\`</div>\`)
    }`)

    expect(treeshaken).toContain('resolveComponent("AppIcon")')
    expect(treeshaken).not.toContain('caret-up')
  })
})
</file>

<file path="packages/nuxt/test/devonly.test.ts">
import { describe, expect, it } from 'vitest'
import { DevOnlyPlugin } from '../src/core/plugins/dev-only.ts'
import { normalizeLineEndings } from './utils.ts'

const pluginVite = DevOnlyPlugin({}).raw({}, { framework: 'vite' }) as { transform: { handler: (code: string, id: string) => { code: string } | null } }

const viteTransform = async (source: string, id: string) => {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  const result = await (pluginVite.transform.handler as Function)(source, id)
  return typeof result === 'string' ? result : result?.code
}

describe('test devonly transform ', () => {
  it('test dev only treeshaking', async () => {
    const result = await viteTransform(`<template>
    <div>
      <LazyDevOnly>
        <SomeDevOnlyComponent></SomeDevOnlyComponent>
      </LazyDevOnly>
    </div>
    <SomeComponent>
      <lazy-dev-only>
        test
      </lazy-dev-only>
    </SomeComponent>
    <div>
      <DevOnly>
        <SomeDevOnlyComponent></SomeDevOnlyComponent>
      </DevOnly>
    </div>
    <SomeComponent>
      <dev-only>
        test
      </dev-only>
    </SomeComponent>
    </template>`, 'some id')

    expect(normalizeLineEndings(result)).toMatchInlineSnapshot(`
      "<template>
          <div>
            
          </div>
          <SomeComponent>
            
          </SomeComponent>
          <div>
            
          </div>
          <SomeComponent>
            
          </SomeComponent>
          </template>"
    `)

    expect(result).not.toContain('dev-only')
    expect(result).not.toContain('DevOnly')
    expect(result).not.toContain('lazy-dev-only')
    expect(result).not.toContain('LazyDevOnly')
  })

  it('should not remove class -> nuxt#24491', async () => {
    const source = `<template>
    <DevOnly>
      <div class="red">This is red.</div>
      <template #fallback>
        <div class="red">This should also be red.</div>
      </template>
    </DevOnly>
  </template>
  `

    const result = await viteTransform(source, 'some id')

    expect(result).toMatchInlineSnapshot(`
      "<template>
          
              <div class="red">This should also be red.</div>
            
        </template>
        "
    `)
  })
})
</file>

<file path="packages/nuxt/test/disabled-modules.test.ts">
import { fileURLToPath } from 'node:url'
import { describe, expect, it } from 'vitest'
import { normalize } from 'pathe'
import { withoutTrailingSlash } from 'ufo'
import { loadNuxt } from '../src'

const fixtureDir = withoutTrailingSlash(normalize(fileURLToPath(new URL('./disabled-modules-fixture', import.meta.url))))

describe('disable modules with false', () => {
  it('loads all modules when no module is disabled', async () => {
    const nuxt = await loadNuxt({
      cwd: fixtureDir,
    })
    await nuxt.close()

    const moduleNames = nuxt.options._installedModules
      .map(m => m.meta.name ?? m.module.name)
      .filter(name => name?.startsWith('layer-module') || name?.startsWith('project-module'))

    // All modules should be installed
    expect(moduleNames).toContain('layer-module-a')
    expect(moduleNames).toContain('layer-module-b')
    expect(moduleNames).toContain('layer-module-c')
    expect(moduleNames).toContain('project-module')

    // All module setups should have run
    expect(nuxt.options.appConfig.layerModuleA).toBe(true)
    expect(nuxt.options.appConfig.layerModuleB).toBe(true)
    expect(nuxt.options.appConfig.layerModuleC).toBe(true)
  })

  it('disables a single module from layer', async () => {
    const nuxt = await loadNuxt({
      cwd: fixtureDir,
      overrides: {
        'layer-module-a': false,
      } as Record<string, unknown>,
    })
    await nuxt.close()

    const moduleNames = nuxt.options._installedModules
      .map(m => m.meta.name ?? m.module.name)
      .filter(name => name?.startsWith('layer-module') || name?.startsWith('project-module'))

    // Module is still registered (for type generation)
    expect(moduleNames).toContain('layer-module-a')
    expect(moduleNames).toContain('layer-module-b')
    expect(moduleNames).toContain('layer-module-c')
    expect(moduleNames).toContain('project-module')

    // But disabled module's setup was NOT executed
    expect(nuxt.options.appConfig.layerModuleA).toBeUndefined()
    // Other modules' setup should have run
    expect(nuxt.options.appConfig.layerModuleB).toBe(true)
    expect(nuxt.options.appConfig.layerModuleC).toBe(true)
  })

  it('disables multiple modules from layer', async () => {
    const nuxt = await loadNuxt({
      cwd: fixtureDir,
      overrides: {
        'layer-module-a': false,
        'layerModuleC': false,
      } as Record<string, unknown>,
    })
    await nuxt.close()

    const moduleNames = nuxt.options._installedModules
      .map(m => m.meta.name ?? m.module.name)
      .filter(name => name?.startsWith('layer-module') || name?.startsWith('project-module'))

    // All modules are still registered (for type generation)
    expect(moduleNames).toContain('layer-module-a')
    expect(moduleNames).toContain('layer-module-b')
    expect(moduleNames).toContain('layer-module-c')
    expect(moduleNames).toContain('project-module')

    // But disabled modules' setup was NOT executed
    expect(nuxt.options.appConfig.layerModuleA).toBeUndefined()
    expect(nuxt.options.appConfig.layerModuleC).toBeUndefined()
    // Other modules' setup should have run
    expect(nuxt.options.appConfig.layerModuleB).toBe(true)
  })

  it('disables project modules', async () => {
    const nuxt = await loadNuxt({
      cwd: fixtureDir,
      overrides: {
        'projectModule': false,
      } as Record<string, unknown>,
    })
    await nuxt.close()

    const moduleNames = nuxt.options._installedModules
      .map(m => m.meta.name ?? m.module.name)
      .filter(name => name?.startsWith('layer-module') || name?.startsWith('project-module'))

    // Project module is still registered (for type generation)
    expect(moduleNames).toContain('project-module')
    // But disabled module's setup was NOT executed
    expect(nuxt.options.appConfig.projectModule).toBeUndefined()
  })

  it('disables all modules from layer when all are set to false', async () => {
    const nuxt = await loadNuxt({
      cwd: fixtureDir,
      overrides: {
        'layer-module-a': false,
        'layerModuleB': false,
        'layerModuleC': false,
      } as Record<string, unknown>,
    })
    await nuxt.close()

    const moduleNames = nuxt.options._installedModules
      .map(m => m.meta.name ?? m.module.name)
      .filter(name => name?.startsWith('layer-module') || name?.startsWith('project-module'))

    // All modules are still registered (for type generation)
    expect(moduleNames).toContain('layer-module-a')
    expect(moduleNames).toContain('layer-module-b')
    expect(moduleNames).toContain('layer-module-c')
    expect(moduleNames).toContain('project-module')

    // But all disabled modules' setup was NOT executed
    expect(nuxt.options.appConfig.layerModuleA).toBeUndefined()
    expect(nuxt.options.appConfig.layerModuleB).toBeUndefined()
    expect(nuxt.options.appConfig.layerModuleC).toBeUndefined()
  })
})
</file>

<file path="packages/nuxt/test/extract-async-data-handlers.test.ts">
import { describe, expect, it } from 'vitest'
import { ExtractAsyncDataHandlersPlugin } from '../src/core/plugins/extract-async-data-handlers.ts'
import { clean } from './utils.ts'

describe('extract async data handlers plugin', () => {
  const defaultOptions = {
    enabled: true,
    sourcemap: false,
    rootDir: '/app',
  }

  function createTransform (options = defaultOptions) {
    const plugin = ExtractAsyncDataHandlersPlugin(options).raw({}, { framework: 'rollup' }) as {
      load: (id: string) => { code: string } | undefined
      transform: { handler: (code: string, id: string) => { code: string } | undefined }
    }
    const fn = (code: string, id = '/app/test.ts') => {
      const result = plugin.transform.handler(code, id)
      return result?.code ? clean(result.code) : result?.code
    }
    return Object.assign(fn, { load: (id: string) => clean(plugin.load(id)?.code) || undefined })
  }

  describe('basic functionality', () => {
    it('should not transform when no async data functions are present', async () => {
      const transform = createTransform()
      const code = `
        const data = ref('hello')
        const count = computed(() => data.value.length)
      `
      const result = await transform(code)
      expect(result).toBeUndefined()
      expect(transform.load('/app/async-data-chunk-0.js')).toBeUndefined()
    })
  })

  describe('useAsyncData transformation', () => {
    it('should extract simple arrow function handler', async () => {
      const transform = createTransform()
      const code = `
        const { data } = await useAsyncData('key', async () => {
          return await $fetch('/api/data')
        })
      `
      const result = await transform(code)

      expect(result).toMatchInlineSnapshot(`"const { data } = await useAsyncData('key', () => import('/app/async-data-chunk-0.js').then(r => (r.default || r)()))"`)

      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(
        `
        "export default async function () { 
                  return await $fetch('/api/data')
                 }"
      `,
      )
    })

    it('should extract function with external variable references', async () => {
      const transform = createTransform()
      const code = `
        const userId = ref(123)
        const { data } = await useAsyncData('user', async () => {
          return await $fetch(\`/api/users/\${userId.value}\`)
        })
      `
      const result = await transform(code)

      expect(result).toMatchInlineSnapshot(`
        "const userId = ref(123)
        const { data } = await useAsyncData('user', () => import('/app/async-data-chunk-0.js').then(r => (r.default || r)(userId)))"
      `)

      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(
        `
        "export default async function (userId) { 
                  return await $fetch(\`/api/users/\${userId.value}\`)
                 }"
      `,
      )
    })

    it('should correctly handle variables in scope', async () => {
      const transform = createTransform()
      const code = `
        useAsyncData(async () => {
          const distTags = {}
          return [].map(tag => distTags[tag])
        })
      `
      const result = await transform(code)
      expect(result).toMatchInlineSnapshot(`"useAsyncData(() => import('/app/async-data-chunk-0.js').then(r => (r.default || r)()))"`)

      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(
        `
        "export default async function () { 
                  const distTags = {}
                  return [].map(tag => distTags[tag])
                 }"
      `,
      )
    })

    it('should correctly handle auto-imported functions in scope', async () => {
      const transform = createTransform()
      const code = `
        const { data: page } = await useAsyncData(() => queryCollection('landing').path('/enterprise/jobs').first())
      `
      const result = await transform(code)
      expect(result).toMatchInlineSnapshot(
        `"const { data: page } = await useAsyncData(() => import('/app/async-data-chunk-0.js').then(r => (r.default || r)()))"`,
      )
      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(
        `"export default async function () { return queryCollection('landing').path('/enterprise/jobs').first() }"`,
      )
    })

    it('should handle imported functions in handlers', async () => {
      const transform = createTransform()
      const code = `
        import { $fetch } from 'ofetch'
        
        const { data } = await useAsyncData('key', async () => {
          return await $fetch('/api/data')
        })
      `
      const result = await transform(code)

      expect(result).toMatchInlineSnapshot(`
        "import { $fetch } from 'ofetch'
        const { data } = await useAsyncData('key', () => import('/app/async-data-chunk-0.js').then(r => (r.default || r)()))"
      `)

      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(
        `
        "import { $fetch } from 'ofetch'
        export default async function () { 
                  return await $fetch('/api/data')
                 }"
      `,
      )
    })

    it('should handle block statement function bodies', async () => {
      const transform = createTransform()
      const code = `
        const { data } = await useAsyncData('key', async () => {
          const response = await $fetch('/api/data')
          return response.data
        })
      `
      const result = await transform(code)

      expect(result).toMatchInlineSnapshot(`"const { data } = await useAsyncData('key', () => import('/app/async-data-chunk-0.js').then(r => (r.default || r)()))"`)

      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(
        `
        "export default async function () { 
                  const response = await $fetch('/api/data')
                  return response.data
                 }"
      `,
      )
    })

    it('should handle expression function bodies', async () => {
      const transform = createTransform()
      const code = `
        const { data } = await useAsyncData('key', async () => $fetch('/api/data'))
      `
      const result = await transform(code)

      expect(result).toMatchInlineSnapshot(`"const { data } = await useAsyncData('key', () => import('/app/async-data-chunk-0.js').then(r => (r.default || r)()))"`)

      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(
        `"export default async function () { return $fetch('/api/data') }"`,
      )
    })
  })

  describe('useLazyAsyncData transformation', () => {
    it('should extract useLazyAsyncData handlers', async () => {
      const transform = createTransform()
      const code = `
        const { data } = await useLazyAsyncData('key', async () => {
          return await $fetch('/api/data')
        })
      `
      const result = await transform(code)

      expect(result).toMatchInlineSnapshot(`"const { data } = await useLazyAsyncData('key', () => import('/app/async-data-chunk-0.js').then(r => (r.default || r)()))"`)

      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(
        `
        "export default async function () { 
                  return await $fetch('/api/data')
                 }"
      `,
      )
    })
  })

  describe('edge cases', () => {
    it('should not transform when handler is not a function', async () => {
      const transform = createTransform()
      const code = `
        const handler = async () => $fetch('/api/data')
        const { data } = await useAsyncData('key', handler)
      `
      const result = await transform(code)

      expect(result).toBeUndefined()
      expect(transform.load('/app/async-data-chunk-0.js')).toBeUndefined()
    })

    it('should not transform when no handler is provided', async () => {
      const transform = createTransform()
      const code = `
        const { data } = await useAsyncData('key')
      `
      const result = await transform(code)

      expect(result).toBeUndefined()
      expect(transform.load('/app/async-data-chunk-0.js')).toBeUndefined()
    })

    it('should handle multiple useAsyncData calls', async () => {
      const transform = createTransform()
      const code = `
        const { data: users } = await useAsyncData('users', async () => {
          return await $fetch('/api/users')
        })
        
        const { data: posts } = await useAsyncData('posts', async () => {
          return await $fetch('/api/posts')
        })
      `
      const result = await transform(code)

      expect(result).toMatchInlineSnapshot(`
        "const { data: users } = await useAsyncData('users', () => import('/app/async-data-chunk-0.js').then(r => (r.default || r)()))
        const { data: posts } = await useAsyncData('posts', () => import('/app/async-data-chunk-1.js').then(r => (r.default || r)()))"
      `)
      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(`
        "export default async function () { 
                  return await $fetch('/api/users')
                 }"
      `)
      expect(transform.load('/app/async-data-chunk-1.js')).toMatchInlineSnapshot(`
        "export default async function () { 
                  return await $fetch('/api/posts')
                 }"
      `)
    })

    it('should handle Vue SFC script blocks', async () => {
      const transform = createTransform()
      const code = `
        <template>
          <div>{{ data }}</div>
        </template>
        
        <script setup>
        const { data } = await useAsyncData('key', async () => {
          return await $fetch('/api/data')
        })
        </script>
      `
      const result = await transform(code, '/app/test.vue')

      expect(result).toBeDefined()
      expect(result).toContain('() => import(')
    })
  })

  describe('variable scope handling', () => {
    it('should not capture property names as variables (regression test for TDZ errors)', async () => {
      const transform = createTransform()
      // This test case previously caused TDZ ReferenceError because property names
      // like "data" in "response.data" or "foo" in "{ foo: 42 }" were incorrectly
      // treated as variable references and captured as parameters
      const code = `
        const { data } = await useAsyncData('test', async () => {
          const response = await $fetch('/api')
          const obj = { foo: response.data.bar }
          return obj.foo
        })
      `
      const result = await transform(code)

      // Should not capture any parameters (no external variable references)
      expect(result).toMatchInlineSnapshot(
        `"const { data } = await useAsyncData('test', () => import('/app/async-data-chunk-0.js').then(r => (r.default || r)()))"`,
      )
      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(`
        "export default async function () { 
                  const response = await $fetch('/api')
                  const obj = { foo: response.data.bar }
                  return obj.foo
                 }"
      `)
    })

    it('should capture variables from outer scope', async () => {
      const transform = createTransform()
      const code = `
        const apiUrl = ref('/api/data')
        const params = { limit: 10 }
        
        const { data } = await useAsyncData('key', async () => {
          return await $fetch(apiUrl.value, { query: params })
        })
      `
      const result = await transform(code)

      expect(result).toMatchInlineSnapshot(`
        "const apiUrl = ref('/api/data')
        const params = { limit: 10 }
        const { data } = await useAsyncData('key', () => import('/app/async-data-chunk-0.js').then(r => (r.default || r)(apiUrl, params)))"
      `)

      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(`
        "export default async function (apiUrl, params) { 
                  return await $fetch(apiUrl.value, { query: params })
                 }"
      `)
    })

    it('should not capture variables declared within the function', async () => {
      const transform = createTransform()
      const code = `
        const { data } = await useAsyncData('key', async () => {
          const localVar = 'local'
          return await $fetch('/api/data', { headers: { 'x-local': localVar } })
        })
      `
      const result = await transform(code)

      expect(result).toMatchInlineSnapshot(`"const { data } = await useAsyncData('key', () => import('/app/async-data-chunk-0.js').then(r => (r.default || r)()))"`)
      expect(transform.load('/app/async-data-chunk-0.js')).toMatchInlineSnapshot(`
        "export default async function () { 
                  const localVar = 'local'
                  return await $fetch('/api/data', { headers: { 'x-local': localVar } })
                 }"
      `)
    })
  })
})
</file>

<file path="packages/nuxt/test/import-protection.test.ts">
import { normalize } from 'pathe'
import { describe, expect, it } from 'vitest'
import { ImpoundPlugin } from 'impound'
import { createImportProtectionPatterns } from '../src/core/plugins/import-protection.ts'
import type { NuxtOptions } from '../schema.ts'

const testsToTriggerOn = [
  ['~/nuxt.config', 'app.vue', true],
  ['./nuxt.config', 'app.vue', true],
  ['./nuxt.config.ts', 'app.vue', true],
  ['nuxt.config.ts', 'app.vue', true],
  ['./.nuxt/nuxt.config', 'app.vue', false],
  ['.nuxt/nuxt.config', 'app.vue', false],
  ['nuxt', 'components/Component.vue', true],
  ['nuxt3', 'components/Component.vue', true],
  ['nuxt-nightly', 'components/Component.vue', true],
  ['/root/node_modules/@vue/composition-api', 'components/Component.vue', true],
  ['@vue/composition-api', 'components/Component.vue', true],
  ['@nuxt/kit', 'components/Component.vue', true],
  ['nuxt/config', 'components/Component.vue', true],
  ['nuxt/kit', 'components/Component.vue', true],
  ['nuxt/schema', 'components/Component.vue', true],
  ['/root/node_modules/@nuxt/kit', 'components/Component.vue', true],
  ['some-nuxt-module', 'components/Component.vue', true],
  ['some-nuxt-module/runtime/something.vue', 'components/Component.vue', false],
  ['/root/src/server/api/test.ts', 'components/Component.vue', true],
  ['src/server/api/test.ts', 'components/Component.vue', true],
  ['node_modules/nitropack/node_modules/crossws/dist/adapters/bun.mjs', 'node_modules/nitropack/dist/presets/bun/runtime/bun.mjs', false],
] as const

describe('import protection', () => {
  it.each(testsToTriggerOn)('should protect %s', async (id, importer, isProtected) => {
    const result = await transformWithImportProtection(id, importer, 'nuxt-app')
    if (!isProtected) {
      expect(result).toBeNull()
    } else {
      expect(result).toBeDefined()
      expect(normalize(result)).contains('mocked-exports')
    }
  })
})

const transformWithImportProtection = (id: string, importer: string, context: 'nitro-app' | 'nuxt-app' | 'shared') => {
  const plugin = ImpoundPlugin.rollup({
    cwd: '/root',
    patterns: createImportProtectionPatterns({
      options: {
        _installedModules: [
          // @ts-expect-error an incomplete module
          { entryPath: 'some-nuxt-module' },
        ],
        srcDir: '/root/src/',
        serverDir: '/root/src/server',
      } satisfies Partial<NuxtOptions> as NuxtOptions,
    }, { context }),
  })

  return (plugin as any).resolveId.call({ error: () => {} }, id, importer)
}
</file>

<file path="packages/nuxt/test/island-transform.test.ts">
import { describe, expect, it, vi } from 'vitest'
import type { Component } from '@nuxt/schema'
import { IslandsTransformPlugin } from '../src/components/plugins/islands-transform.ts'
import { normalizeLineEndings } from './utils.ts'

const getComponents = () => [{
  filePath: '/root/hello.server.vue',
  mode: 'server',
  pascalName: 'HelloWorld',
  island: true,
  kebabName: 'hello-world',
  chunkName: 'components/hello-world',
  export: 'default',
  shortPath: '',
  prefetch: false,
  preload: false,
}] as Component[]

const pluginWebpack = IslandsTransformPlugin({
  getComponents,
  selectiveClient: true,
}).raw({}, { framework: 'webpack', webpack: { compiler: {} as any } }) as { transform: { handler: (code: string, id: string) => { code: string } | null } }

const viteTransform = async (source: string, id: string, selectiveClient = false) => {
  const vitePlugin = IslandsTransformPlugin({
    getComponents,
    selectiveClient,
  }).raw({}, { framework: 'vite' }) as { transform: { handler: (code: string, id: string) => { code: string } | null } }

  const result = await vitePlugin.transform.handler(source, id)
  return typeof result === 'string' ? result : result!.code
}

const webpackTransform = async (source: string, id: string) => {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  const result = await (pluginWebpack.transform.handler! as Function)(source, id)
  return typeof result === 'string' ? result : result?.code
}

describe('islandTransform - server and island components', () => {
  describe('slots', () => {
    it('expect slot transform to match inline snapshot', async () => {
      const result = await viteTransform(`<template>
      <div>
        <slot />

        <slot name="named" :some-data="someData" />
        <slot
          name="other"
          :some-data="someData"
        />
      </div>
      </template>
      <script setup lang="ts">
      const someData = 'some data'

      </script>`,
      'hello.server.vue')

      expect(normalizeLineEndings(result)).toMatchInlineSnapshot(`
        "<template>
              <div>
                <NuxtTeleportSsrSlot name="default" :props="undefined"><slot /></NuxtTeleportSsrSlot>

                <NuxtTeleportSsrSlot name="named" :props="[{ [\`some-data\`]: someData }]"><slot name="named" :some-data="someData" /></NuxtTeleportSsrSlot>
                <NuxtTeleportSsrSlot name="other" :props="[{ [\`some-data\`]: someData }]"><slot
                  name="other"
                  :some-data="someData"
                /></NuxtTeleportSsrSlot>
              </div>
              </template>
              <script setup lang="ts">
        import { mergeProps as __mergeProps } from 'vue'
        import { vforToArray as __vforToArray } from '#app/components/utils'
        import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
        import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'
              const someData = 'some data'

              </script>"
      `)
    })

    it('generates bindings when props are needed to be merged', async () => {
      const result = await viteTransform(`<script setup lang="ts">
withDefaults(defineProps<{ things?: any[]; somethingElse?: string }>(), {
  things: () => [],
  somethingElse: "yay",
});
</script>

<template>
  <template v-for="thing in things">
    <slot name="thing" v-bind="thing" />
  </template>
</template>
`, 'hello.server.vue')

      expect(normalizeLineEndings(result)).toMatchInlineSnapshot(`
        "<script setup lang="ts">
        import { mergeProps as __mergeProps } from 'vue'
        import { vforToArray as __vforToArray } from '#app/components/utils'
        import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
        import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'
        withDefaults(defineProps<{ things?: any[]; somethingElse?: string }>(), {
          things: () => [],
          somethingElse: "yay",
        });
        </script>

        <template>
          <template v-for="thing in things">
            <NuxtTeleportSsrSlot name="thing" :props="[__mergeProps(thing, {  })]"><slot name="thing" v-bind="thing" /></NuxtTeleportSsrSlot>
          </template>
        </template>
        "
      `)
    })

    it('expect slot fallback transform to match inline snapshot', async () => {
      const result = await viteTransform(`<template>
      <div>
        <slot :some-data="someData">
          <div>fallback</div>
        </slot>
      </div>
      </template>
      <script setup lang="ts">
      const someData = 'some data'

      </script>`,
      'hello.server.vue')

      expect(normalizeLineEndings(result)).toMatchInlineSnapshot(`
        "<template>
              <div>
                <NuxtTeleportSsrSlot name="default" :props="[{ [\`some-data\`]: someData }]"><slot :some-data="someData"/><template #fallback>
                  <div>fallback</div>
                </template></NuxtTeleportSsrSlot>
              </div>
              </template>
              <script setup lang="ts">
        import { mergeProps as __mergeProps } from 'vue'
        import { vforToArray as __vforToArray } from '#app/components/utils'
        import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
        import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'
              const someData = 'some data'

              </script>"
      `)
    })

    it('expect slot transform with fallback and no name to match inline snapshot #23209', async () => {
      const result = await viteTransform(`<template>
      <div>
        <UCard>
          <template #header>
            <h3>Partial Hydration Example - Server - {{ count }}</h3>
          </template>
          <template #default>
            <p>message: {{ message }}</p>
            <p>Below is the slot I want to be hydrated on the client</p>
            <div>
              <slot>
                This is the default content of the slot, I should not see this after
                the client loading has completed.
              </slot>
            </div>
            <p>Above is the slot I want to be hydrated on the client</p>
          </template>
        </UCard>
      </div>
    </template>

    <script setup lang="ts">
    export interface Props {
      count?: number;
    }
    const props = withDefaults(defineProps<Props>(), { count: 0 });

    const message = "Hello World";
    </script>
    `,
      'hello.server.vue')

      expect(normalizeLineEndings(result)).toMatchInlineSnapshot(`
        "<template>
              <div>
                <UCard>
                  <template #header>
                    <h3>Partial Hydration Example - Server - {{ count }}</h3>
                  </template>
                  <template #default>
                    <p>message: {{ message }}</p>
                    <p>Below is the slot I want to be hydrated on the client</p>
                    <div>
                      <NuxtTeleportSsrSlot name="default" :props="undefined"><slot/><template #fallback>
                        This is the default content of the slot, I should not see this after
                        the client loading has completed.
                      </template></NuxtTeleportSsrSlot>
                    </div>
                    <p>Above is the slot I want to be hydrated on the client</p>
                  </template>
                </UCard>
              </div>
            </template>

            <script setup lang="ts">
        import { mergeProps as __mergeProps } from 'vue'
        import { vforToArray as __vforToArray } from '#app/components/utils'
        import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
        import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'
            export interface Props {
              count?: number;
            }
            const props = withDefaults(defineProps<Props>(), { count: 0 });

            const message = "Hello World";
            </script>
            "
      `)
    })

    it('expect v-if/v-else/v-else-if to be set in teleport component wrapper', async () => {
      const result = await viteTransform(`<script setup lang="ts">
      const foo = true;
      </script>
      <template>
      <slot v-if="foo" />
      <slot v-else-if="test" />
      <slot v-else />
      </template>
      `, 'WithVif.vue', true)

      expect(normalizeLineEndings(result)).toMatchInlineSnapshot(`
        "<script setup lang="ts">
        import { mergeProps as __mergeProps } from 'vue'
        import { vforToArray as __vforToArray } from '#app/components/utils'
        import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
        import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'
              const foo = true;
              </script>
              <template>
              <NuxtTeleportSsrSlot v-if="foo" name="default" :props="undefined"><slot  /></NuxtTeleportSsrSlot>
              <NuxtTeleportSsrSlot v-else-if="test" name="default" :props="undefined"><slot  /></NuxtTeleportSsrSlot>
              <NuxtTeleportSsrSlot v-else name="default" :props="undefined"><slot  /></NuxtTeleportSsrSlot>
              </template>
              "
      `)
    })
  })

  describe('nuxt-client', () => {
    describe('vite', () => {
      it('test transform with vite', async () => {
        const result = await viteTransform(`<template>
        <div>
          <HelloWorld />
          <HelloWorld nuxt-client />
        </div>
      </template>

      <script setup lang="ts">
      import HelloWorld from './HelloWorld.vue'
      </script>
      `, 'hello.server.vue', true)

        expect(normalizeLineEndings(result)).toMatchInlineSnapshot(`
          "<template>
                  <div>
                    <HelloWorld />
                    <NuxtTeleportIslandComponent :nuxt-client="true"><HelloWorld /></NuxtTeleportIslandComponent>
                  </div>
                </template>

                <script setup lang="ts">
          import { mergeProps as __mergeProps } from 'vue'
          import { vforToArray as __vforToArray } from '#app/components/utils'
          import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
          import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'
                import HelloWorld from './HelloWorld.vue'
                </script>
                "
        `)
      })

      it('test dynamic nuxt-client', async () => {
        const result = await viteTransform(`<template>
        <div>
          <HelloWorld />
          <HelloWorld :nuxt-client="nuxtClient" />
        </div>
      </template>

      <script setup lang="ts">
      import HelloWorld from './HelloWorld.vue'

      const nuxtClient = false
      </script>
      `, 'hello.server.vue', true)

        expect(normalizeLineEndings(result)).toMatchInlineSnapshot(`
          "<template>
                  <div>
                    <HelloWorld />
                    <NuxtTeleportIslandComponent :nuxt-client="nuxtClient"><HelloWorld /></NuxtTeleportIslandComponent>
                  </div>
                </template>

                <script setup lang="ts">
          import { mergeProps as __mergeProps } from 'vue'
          import { vforToArray as __vforToArray } from '#app/components/utils'
          import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
          import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'
                import HelloWorld from './HelloWorld.vue'

                const nuxtClient = false
                </script>
                "
        `)
      })

      it('should not transform if disabled', async () => {
        const result = await viteTransform(`<template>
        <div>
          <HelloWorld />
          <HelloWorld :nuxt-client="nuxtClient" />
        </div>
      </template>

      <script setup lang="ts">
      import HelloWorld from './HelloWorld.vue'

      const nuxtClient = false
      </script>
      `, 'hello.server.vue', false)

        expect(normalizeLineEndings(result)).toMatchInlineSnapshot(`
          "<template>
                  <div>
                    <HelloWorld />
                    <HelloWorld :nuxt-client="nuxtClient" />
                  </div>
                </template>

                <script setup lang="ts">
          import { mergeProps as __mergeProps } from 'vue'
          import { vforToArray as __vforToArray } from '#app/components/utils'
          import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
          import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'
                import HelloWorld from './HelloWorld.vue'

                const nuxtClient = false
                </script>
                "
        `)
      })

      it('should add import if there is no scripts in the SFC', async () => {
        const result = await viteTransform(`<template>
        <div>
          <HelloWorld />
          <HelloWorld nuxt-client />
        </div>
      </template>

      `, 'hello.server.vue', true)

        expect(result).toMatchInlineSnapshot(`
          "<script setup>
          import { mergeProps as __mergeProps } from 'vue'
          import { vforToArray as __vforToArray } from '#app/components/utils'
          import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
          import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'</script><template>
                  <div>
                    <HelloWorld />
                    <NuxtTeleportIslandComponent :nuxt-client="true"><HelloWorld /></NuxtTeleportIslandComponent>
                  </div>
                </template>

                "
        `)
        expect(result).toContain('import NuxtTeleportIslandComponent from \'#app/components/nuxt-teleport-island-component\'')
      })

      it('should move v-if to the wrapper component', async () => {
        const result = await viteTransform(`<template>
        <div>
        <HelloWorld v-if="false" nuxt-client />
        <HelloWorld v-else-if="true" nuxt-client />
        <HelloWorld v-else nuxt-client />
        </div>
      </template>
      `, 'hello.server.vue', true)

        expect(result).toMatchInlineSnapshot(`
          "<script setup>
          import { mergeProps as __mergeProps } from 'vue'
          import { vforToArray as __vforToArray } from '#app/components/utils'
          import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
          import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'</script><template>
                  <div>
                  <NuxtTeleportIslandComponent v-if="false" :nuxt-client="true"><HelloWorld  /></NuxtTeleportIslandComponent>
                  <NuxtTeleportIslandComponent v-else-if="true" :nuxt-client="true"><HelloWorld  /></NuxtTeleportIslandComponent>
                  <NuxtTeleportIslandComponent v-else :nuxt-client="true"><HelloWorld  /></NuxtTeleportIslandComponent>
                  </div>
                </template>
                "
        `)
      })
    })

    describe('webpack', () => {
      it('test transform with webpack', async () => {
        const spyOnWarn = vi.spyOn(console, 'warn')
        const result = await webpackTransform(`<template>
        <div>
          <!-- should not be wrapped by NuxtTeleportIslandComponent -->
          <HelloWorld />

          <!-- should be not wrapped by NuxtTeleportIslandComponent for now -->
          <HelloWorld nuxt-client />
        </div>
      </template>

      <script setup lang="ts">
      import HelloWorld from './HelloWorld.vue'

      const someData = 'some data'
      </script>
      `, 'hello.server.vue')
        expect(normalizeLineEndings(result)).toMatchInlineSnapshot(`
          "<template>
                  <div>
                    <!-- should not be wrapped by NuxtTeleportIslandComponent -->
                    <HelloWorld />

                    <!-- should be not wrapped by NuxtTeleportIslandComponent for now -->
                    <HelloWorld nuxt-client />
                  </div>
                </template>

                <script setup lang="ts">
          import { mergeProps as __mergeProps } from 'vue'
          import { vforToArray as __vforToArray } from '#app/components/utils'
          import NuxtTeleportIslandComponent from '#app/components/nuxt-teleport-island-component'
          import NuxtTeleportSsrSlot from '#app/components/nuxt-teleport-island-slot'
                import HelloWorld from './HelloWorld.vue'

                const someData = 'some data'
                </script>
                "
        `)

        expect(spyOnWarn).toHaveBeenCalledWith('The `nuxt-client` attribute and client components within islands are only supported with Vite. file: hello.server.vue')
      })
    })
  })
})
</file>

<file path="packages/nuxt/test/keyed-functions.test.ts">
import type { KeyedFunction } from '@nuxt/schema'
import { describe, expect, it, vi } from 'vitest'
import { KeyedFunctionsPlugin } from '../src/core/plugins/keyed-functions'
import { logger } from '../src/utils'
import type { Import } from 'unimport'

describe('keyed functions plugin', () => {
  const keyedFunctions: KeyedFunction[] = [
    {
      name: 'useKey',
      source: '#app',
      argumentLength: 1,
    },
    {
      name: 'useKey',
      source: '#app/useKeyTwo',
      argumentLength: 2,
    },
    {
      name: 'useKeyTwo',
      source: '#app',
      argumentLength: 2,
    },
    {
      name: 'useKeyTwo', // duplicate entry
      source: '#app',
      argumentLength: 2,
    },
    {
      name: 'useKeyTwoRenamed',
      source: 'renamed.ts',
      argumentLength: 2,
    },
    {
      name: 'default',
      source: '#app/defaultExport',
      argumentLength: 1,
    },
    {
      name: 'default',
      source: 'composables/use-default-key.ts',
      argumentLength: 1,
    },
    // TODO: remove entries without source in Nuxt 5
    // @ts-expect-error - `source` wasn't required before
    {
      name: 'useAutoImported',
      argumentLength: 1,
    },
    {
      name: 'useRegexKey',
      argumentLength: 1,
      // @ts-expect-error - regex was supported before
      source: /regex/,
    },
  ]

  const autoImports: Import[] = [
    {
      from: '#app',
      name: 'useAutoImported',
      as: 'useAutoImported',
    },
  ]

  const transformPlugin = KeyedFunctionsPlugin({ sourcemap: false, keyedFunctions, alias: {}, getAutoImports: () => Promise.resolve(autoImports) }).raw({}, {} as any) as { transform: { handler: (code: string, id: string) => Promise<{ code: string } | null> } }

  it('should add hash when there is none already provided', async () => {
    const code = `
import { useKey, useKeyTwo } from '#app'
useKey()
useKeyTwo(() => {})
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey, useKeyTwo } from '#app'
      useKey('$HJiaryoL2y' /* nuxt-injected */)
      useKeyTwo(() => {}, '$yysMIARJHe' /* nuxt-injected */)"
    `)
  })

  it('should use different hash for each call of the same function', async () => {
    const code = `
import { useKey } from '#app'
useKey()
useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey } from '#app'
      useKey('$HJiaryoL2y' /* nuxt-injected */)
      useKey('$yysMIARJHe' /* nuxt-injected */)"
    `)
  })

  it('should not add hash when one exists', async () => {
    const code = `
import { useKey, useKeyTwo } from '#app'
useKey('$existingKey')
useKeyTwo(() => {}, '$existingKey')
`
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should add add hash to function from default import', async () => {
    const code = `
import useDefaultKey from 'composables/use-default-key.ts'
useDefaultKey()`
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import useDefaultKey from 'composables/use-default-key.ts'
      useDefaultKey('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })

  it('should add hash to function from default import with different name', async () => {
    const code = `
    import useRenamedFunctionThatIsNotInKeyedFunctions from 'composables/use-default-key.ts'
    useRenamedFunctionThatIsNotInKeyedFunctions()`
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import useRenamedFunctionThatIsNotInKeyedFunctions from 'composables/use-default-key.ts'
          useRenamedFunctionThatIsNotInKeyedFunctions('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })

  it('should add hash to function from default import when renamed', async () => {
    const code = `
import { default as useRenamedDefault } from '#app/defaultExport'
useRenamedDefault()`
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { default as useRenamedDefault } from '#app/defaultExport'
      useRenamedDefault('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })

  it('should correctly identify same-name functions from different sources', async () => {
    const code = `
    import { useKey as useKeyOne } from '#app'
    import { useKey as useKeyTwo } from '#app/useKeyTwo'
    useKeyOne()
    useKeyTwo('first')
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey as useKeyOne } from '#app'
          import { useKey as useKeyTwo } from '#app/useKeyTwo'
          useKeyOne('$HJiaryoL2y' /* nuxt-injected */)
          useKeyTwo('first', '$yysMIARJHe' /* nuxt-injected */)"
    `)
  })

  it('should warn if there are duplicate entries in keyed functions', () => {
    vi.stubGlobal('__TEST_DEV__', true)

    const warn = vi.spyOn(logger, 'warn').mockImplementation(() => {})

    KeyedFunctionsPlugin({ sourcemap: false, keyedFunctions, alias: {}, getAutoImports: () => Promise.resolve(autoImports) }).raw({}, {} as any)

    expect(warn).toHaveBeenCalledWith(expect.stringMatching(
      /\[nuxt:compiler\] \[keyed-functions\] Duplicate function name `useKeyTwo` with the same source `#app` found. Overwriting the existing entry./,
    ))
    warn.mockRestore()
    vi.unstubAllGlobals()
  })

  it('should handle multi-line parameters', async () => {
    const code = `
import { useKey, useKeyTwo } from '#app'
useKey(
)
useKeyTwo(
  () => {}
)

useKeyTwo(


  () => {}
)

useKeyTwo(
  () => {
  })
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey, useKeyTwo } from '#app'
      useKey(
      '$HJiaryoL2y' /* nuxt-injected */)
      useKeyTwo(
        () => {}
      , '$yysMIARJHe' /* nuxt-injected */)

      useKeyTwo(


        () => {}
      , '$Cy7hQH5X5O' /* nuxt-injected */)

      useKeyTwo(
        () => {
        }, '$Fl_F5LB-IM' /* nuxt-injected */)"
    `)
  })

  it('should handle trailing commas in parameters', async () => {
    const code = `
import { useKeyTwo } from '#app'
useKeyTwo(
  () => {},
)

useKeyTwo(
  () => {}
  ,)

useKeyTwo(

  () => {}

  ,
  )
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKeyTwo } from '#app'
      useKeyTwo(
        () => {},
      '$HJiaryoL2y' /* nuxt-injected */)

      useKeyTwo(
        () => {}
        ,'$yysMIARJHe' /* nuxt-injected */)

      useKeyTwo(

        () => {}

        ,
        '$Cy7hQH5X5O' /* nuxt-injected */)"
    `)
  })

  it('should not add hash for non-matching function names', async () => {
    const code = `
import { useKeyThree } from '#app'
useKeyThree()
`
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should add hash in child scopes', async () => {
    const code = `
import { useKey } from '#app'
function foo() {
  useKey()

  if (true) {
    useKey()
  }
}
`
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey } from '#app'
      function foo() {
        useKey('$HJiaryoL2y' /* nuxt-injected */)

        if (true) {
          useKey('$yysMIARJHe' /* nuxt-injected */)
        }
      }"
    `)
  })

  it('should handle function shadowing', async () => {
    const code = `
import { useKey } from '#app'

function foo() {
  useKey()
  function useKey() { return 'local' }
}

useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey } from '#app'

      function foo() {
        useKey()
        function useKey() { return 'local' }
      }

      useKey('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })

  it('should handle variable shadowing', async () => {
    const code = `
import { useKey } from '#app'

function foo() {
  const useKey = () => 'local'
  useKey()
}

useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey } from '#app'

      function foo() {
        const useKey = () => 'local'
        useKey()
      }

      useKey('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })

  it('should handle function parameters shadowing', async () => {
    const code = `
import { useKey } from '#app'

function foo(useKey) {
  useKey()
}

const bar = useKey => useKey()

useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey } from '#app'

      function foo(useKey) {
        useKey()
      }

      const bar = useKey => useKey()

      useKey('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })

  it('should add hash when processing file in `source` for exported functions', async () => {
    const code = `
useKeyTwo()
export const useKey = (arg1) => {}
useKey()
export function useKeyTwo(arg1, arg2) {}
    `
    expect((await transformPlugin.transform.handler(code, '#app'))?.code.trim()).toMatchInlineSnapshot(`
      "useKeyTwo('$QQV3F06xQZ' /* nuxt-injected */)
      export const useKey = (arg1) => {}
      useKey('$Bil3ev-zNC' /* nuxt-injected */)
      export function useKeyTwo(arg1, arg2) {}"
    `)
  })

  it('should not add hash to non-exported matching functions in `source`', async () => {
    const code = `
useKeyTwo()
const useKey = (arg1) => {}
useKey()
function useKeyTwo(arg1, arg2) {}
    `
    expect((await transformPlugin.transform.handler(code, '#app'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should handle standalone export declaration in `source`', async () => {
    const code = `
useKey()
function useKey(arg) {}
export { useKey }
`
    expect((await transformPlugin.transform.handler(code, '#app'))?.code.trim()).toMatchInlineSnapshot(`
      "useKey('$QQV3F06xQZ' /* nuxt-injected */)
      function useKey(arg) {}
      export { useKey }"
    `)
  })

  it('should not add hash to matching function names in `source` when renamed in export', async () => {
    const code = `
function useRenamedKey(arg) {}
useKey()
useRenamedKey()
function useKey(arg) {}
export { useKey as useRenamedKey }
`
    // we renamed the export, so the defined `useKey` is not exported and therefore should not get a hash
    // `useRenamedKey`, on the other hand, is not defined in keyed functions, so it should not get a hash either
    expect((await transformPlugin.transform.handler(code, '#app'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should add hash to original function in `source` with when renamed in export', async () => {
    const code = `
    foo()
    function foo(arg) {}
    function bar() {
      const foo = () => 'local'
      // still respects shadowing
      foo()
    }
    foo()
    export { foo as useKey }
    `

    expect((await transformPlugin.transform.handler(code, '#app'))?.code.trim()).toMatchInlineSnapshot(`
      "foo('$QQV3F06xQZ' /* nuxt-injected */)
          function foo(arg) {}
          function bar() {
            const foo = () => 'local'
            // still respects shadowing
            foo()
          }
          foo('$Bil3ev-zNC' /* nuxt-injected */)
          export { foo as useKey }"
    `)
  })

  it('should add hash to imported keyed function in `source` when renamed in export', async () => {
    const code = `
import { useKey } from '#app'
useKey('add-key-after')
export { useKey as useKeyTwoRenamed }
    `
    expect((await transformPlugin.transform.handler(code, 'renamed.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey } from '#app'
      useKey('add-key-after', '$Ja9NP0cDY0' /* nuxt-injected */)
      export { useKey as useKeyTwoRenamed }"
    `)
  })

  it('should handle shadowing in `source`', async () => {
    const code = `
useKey()
function useKey(arg) {}
function foo() {
  useKey()
  function useKey() { return 'local' }
  useKey()
}
function bar() {
  const useKey = () => 'local'
  useKey()
}
useKey()
export { useKey }
    `
    expect((await transformPlugin.transform.handler(code, '#app'))?.code.trim()).toMatchInlineSnapshot(`
      "useKey('$QQV3F06xQZ' /* nuxt-injected */)
      function useKey(arg) {}
      function foo() {
        useKey()
        function useKey() { return 'local' }
        useKey()
      }
      function bar() {
        const useKey = () => 'local'
        useKey()
      }
      useKey('$Bil3ev-zNC' /* nuxt-injected */)
      export { useKey }"
    `)
  })

  it('should not add key to default export if no default was specified for `source`', async () => {
    const code = `
useKey()
function useKey(arg) {}
export default useKey
    `
    expect((await transformPlugin.transform.handler(code, '#app'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should not add key to anonymous default export if no default was specified for `source`', async () => {
    const code = `
useKey()
export default function useKey(arg) {}
    `
    expect((await transformPlugin.transform.handler(code, '#app'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should handle default export in `source`', async () => {
    const code = `
useFoo()
function useFoo(arg) {}
export default useFoo
    `
    expect((await transformPlugin.transform.handler(code, '#app/defaultExport'))?.code.trim()).toMatchInlineSnapshot(`
      "useFoo('$gvnasIOzix' /* nuxt-injected */)
      function useFoo(arg) {}
      export default useFoo"
    `)
  })

  it('should handle arrow function default export in `source`', async () => {
    const code = `
const useFoo = (arg) => {}
useFoo()
export default useFoo
    `
    expect((await transformPlugin.transform.handler(code, '#app/defaultExport'))?.code.trim()).toMatchInlineSnapshot(`
      "const useFoo = (arg) => {}
      useFoo('$gvnasIOzix' /* nuxt-injected */)
      export default useFoo"
    `)
  })

  it('should handle anonymous default export in `source`', async () => {
    const code = `
useFoo()
export default function useFoo(arg) {}
    `
    expect((await transformPlugin.transform.handler(code, '#app/defaultExport'))?.code.trim()).toMatchInlineSnapshot(`
      "useFoo('$gvnasIOzix' /* nuxt-injected */)
      export default function useFoo(arg) {}"
    `)
  })

  it('should not add hash for imports from other sources', async () => {
    const code = `
import { useKey } from 'some-other-source'
import { useKeyTwo } from '#application' // deliberately using an alias starting with #app
useKey()
useKeyTwo()
`
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should add hash when renamed in import', async () => {
    const code = `
    import { useKey as useRenamedKey } from '#app'
    import { useKeyTwo as shouldNotAddHash } from './somewhere-else'

    useRenamedKey()
    shouldNotAddHash()
    `

    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey as useRenamedKey } from '#app'
          import { useKeyTwo as shouldNotAddHash } from './somewhere-else'

          useRenamedKey('$HJiaryoL2y' /* nuxt-injected */)
          shouldNotAddHash()"
    `)
  })

  it('should add hash for default import', async () => {
    const code = `
import useDefault from '#app/defaultExport'
useDefault()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import useDefault from '#app/defaultExport'
      useDefault('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })

  it('should add hash for renamed default import', async () => {
    const code = `
import { default as useRenamedDefault } from '#app/defaultExport'
useRenamedDefault()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { default as useRenamedDefault } from '#app/defaultExport'
      useRenamedDefault('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })

  it('should not add hash for non-matching default import', async () => {
    const code = `
import useDefault from '#app'
useDefault()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should add hash for namespace import', async () => {
    const code = `
import * as app from '#app'
app.useKey()
useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import * as app from '#app'
      app.useKey('$HJiaryoL2y' /* nuxt-injected */)
      useKey()"
    `)
  })

  it('should handle namespace shadowing', async () => {
    const code = `
import * as app from '#app'
function foo() {
  const app = { useKey: () => 'local' }
  app.useKey()
}
app.useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import * as app from '#app'
      function foo() {
        const app = { useKey: () => 'local' }
        app.useKey()
      }
      app.useKey('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })

  it('should not add hash for non-matching namespace import', async () => {
    const code = `
import * as other from 'some-other-source'
other.useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should handle bracket access on namespace', async () => {
    const code = `
import * as app from '#app'
app['useKey']()
useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import * as app from '#app'
      app['useKey']('$HJiaryoL2y' /* nuxt-injected */)
      useKey()"
    `)
  })

  it('should not add hash for dynamic bracket access on namespace', async () => {
    const code = `
import * as app from '#app'
app['useKey']() // has key
const keyName = 'useKey'
app[keyName]()
app['use' + 'Key']()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import * as app from '#app'
      app['useKey']('$HJiaryoL2y' /* nuxt-injected */) // has key
      const keyName = 'useKey'
      app[keyName]()
      app['use' + 'Key']()"
    `)
  })

  it('should not add hash for template literal access on a namespace', async () => {
    const code = `
import * as app from '#app'
app[\`useKey\`]()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should not add hash for dynamic import', async () => {
    const code = `
const mod = await import('#app')
mod.useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should not add hash for destructured namespace', async () => {
    const code = `
import * as app from '#app'
const { useKey } = app
useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should not add hash for type-only imports', async () => {
    const code = `
import type { useKey } from '#app'
useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should handle mixed imports', async () => {
    const code = `
import useDefault, { useKey as useRenamedKey, useKeyTwo } from '#app'
import useDefaultKey from '#app/defaultExport'
useDefault()
useDefaultKey()
useRenamedKey()
useKeyTwo(() => {})
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import useDefault, { useKey as useRenamedKey, useKeyTwo } from '#app'
      import useDefaultKey from '#app/defaultExport'
      useDefault()
      useDefaultKey('$HJiaryoL2y' /* nuxt-injected */)
      useRenamedKey('$yysMIARJHe' /* nuxt-injected */)
      useKeyTwo(() => {}, '$Cy7hQH5X5O' /* nuxt-injected */)"
    `)
  })

  it('should handle renamed same-name function from different source', async () => {
    const code = `
import { useKey } from '#app'
import { useKey as useOtherKey } from 'some-other-source'
useKey()
useOtherKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey } from '#app'
      import { useKey as useOtherKey } from 'some-other-source'
      useKey('$HJiaryoL2y' /* nuxt-injected */)
      useOtherKey()"
    `)
  })

  it('should not add key to tagged templates', async () => {
    const code = `
import { useKeyTwo } from '#app'
useKeyTwo\`template string\`
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should not add key to a conditional callee', async () => {
    const code = `
import { useKey } from '#app'
(Math.random() > 0.5 ? useKey : () => {})()
Math.random() > 0.5 ? useKey() : null
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey } from '#app'
      (Math.random() > 0.5 ? useKey : () => {})()
      Math.random() > 0.5 ? useKey('$HJiaryoL2y' /* nuxt-injected */) : null"
    `)
  })

  it('should not add key to `call` or `apply`', async () => {
    const code = `
import { useKeyTwo } from '#app'
useKeyTwo.call(this)
useKeyTwo.apply(this, [])
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should always add key when there is a spread element in the arguments', async () => {
    const code = `
import { useKey, useKeyTwo } from '#app'
useKey(...args)
useKeyTwo(...args)
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useKey, useKeyTwo } from '#app'
      useKey(...args, '$HJiaryoL2y' /* nuxt-injected */)
      useKeyTwo(...args, '$yysMIARJHe' /* nuxt-injected */)"
    `)
  })

  it('should not add key when accessed as a deep property', async () => {
    const code = `
import * as app from '#app'
const pkg = { app }

pkg.app.useKey()
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should not add key when processing the same file multiple times (webpack problem)', async () => {
    const code = `
    import { useKeyTwo } from '#app'
    useKeyTwo('$HJiaryoL2y' /* nuxt-injected */)
    `

    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  // backwards compatibility
  it('should inject keys for auto-imported functions', async () => {
    const code = `
    import { useAutoImported } from '#app'
    useAutoImported()
    `

    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useAutoImported } from '#app'
          useAutoImported('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })

  it('should inject keys for regex-matched function sources', async () => {
    const code = `
    import { useRegexKey } from 'some-regex-matched-source'
    useRegexKey()
    `

    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useRegexKey } from 'some-regex-matched-source'
          useRegexKey('$HJiaryoL2y' /* nuxt-injected */)"
    `)
  })
})

describe('core keyed functions', () => {
  const keyedFunctions: KeyedFunction[] = [
    // these entries need to 100% match the ones defined in
    // packages/schema/src/config/build.ts
    // because some values are hard-coded in the plugin implementation
    { name: 'callOnce', argumentLength: 3, source: '#app/composables/once' },
    { name: 'defineNuxtComponent', argumentLength: 2, source: '#app/composables/component' },
    { name: 'useState', argumentLength: 2, source: '#app/composables/state' },
    { name: 'useFetch', argumentLength: 3, source: '#app/composables/fetch' },
    { name: 'useAsyncData', argumentLength: 3, source: '#app/composables/asyncData' },
    { name: 'useLazyAsyncData', argumentLength: 3, source: '#app/composables/asyncData' },
    { name: 'useLazyFetch', argumentLength: 3, source: '#app/composables/fetch' },
  ]
  const transformPlugin = KeyedFunctionsPlugin({ sourcemap: false, keyedFunctions, alias: {}, getAutoImports: () => Promise.resolve([]) }).raw({}, {} as any) as { transform: { handler: (code: string, id: string) => Promise<{ code: string } | null> } }

  it('should detect string type keys and not add a hash', async () => {
    const code = `
    import { useState } from '#app/composables/state'
    useState('stringKey')
    useState(\`templateStringKey\`)
    useState(\`template\${dynamic}StringKey\`)
    useState("doubleQuotedStringKey")
    `
    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
  })

  it('should add a hash when key type cannot be determined statically', async () => {
    const code = `
    import { useState } from '#app/composables/state'
    useState('some' + 'key')
    useState(someVariable)
    useState(getKey())
    useState(obj.prop)
    useState(obj['prop'])
    useState(obj.met())
    `

    expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
      "import { useState } from '#app/composables/state'
          useState('some' + 'key', '$HJiaryoL2y' /* nuxt-injected */)
          useState(someVariable, '$yysMIARJHe' /* nuxt-injected */)
          useState(getKey(), '$Cy7hQH5X5O' /* nuxt-injected */)
          useState(obj.prop, '$Fl_F5LB-IM' /* nuxt-injected */)
          useState(obj['prop'], '$1GDT7saTf0' /* nuxt-injected */)
          useState(obj.met(), '$8YFL1gGJy8' /* nuxt-injected */)"
    `)
  })

  // --- useState ---
  describe('useState', () => {
    it('should add hash when none was provided', async () => {
      const code = `
import { useState } from '#app/composables/state'
useState(() => 1)
      `
      expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
        "import { useState } from '#app/composables/state'
        useState(() => 1, '$HJiaryoL2y' /* nuxt-injected */)"
      `)
    })

    it('should not add hash when one was provided as the first argument', async () => {
      const code = `
import { useState } from '#app/composables/state'
useState('key')
useState('$existingKey', () => 1)
      `

      expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
    })
  })

  // --- useFetch / useLazyFetch ---
  describe('useFetch', () => {
    it('should always add a hash', async () => {
      const code = `
import { useFetch, useLazyFetch } from '#app/composables/fetch'
useFetch('/api/data')
useFetch(() => '/api/data')
useFetch(url)
useFetch('/api/data', { method: 'POST' })
useFetch(() => '/api/data', { method: 'POST' })
useFetch(url, options)

useLazyFetch('/api/data')
useLazyFetch(() => '/api/data')
useLazyFetch(url)
useLazyFetch('/api/data', { method: 'POST' })
useLazyFetch(() => '/api/data', { method: 'POST' })
useLazyFetch(url, options)
      `

      expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
        "import { useFetch, useLazyFetch } from '#app/composables/fetch'
        useFetch('/api/data', '$HJiaryoL2y' /* nuxt-injected */)
        useFetch(() => '/api/data', '$yysMIARJHe' /* nuxt-injected */)
        useFetch(url, '$Cy7hQH5X5O' /* nuxt-injected */)
        useFetch('/api/data', { method: 'POST' }, '$Fl_F5LB-IM' /* nuxt-injected */)
        useFetch(() => '/api/data', { method: 'POST' }, '$1GDT7saTf0' /* nuxt-injected */)
        useFetch(url, options, '$8YFL1gGJy8' /* nuxt-injected */)

        useLazyFetch('/api/data', '$-6Jq0e1X0N' /* nuxt-injected */)
        useLazyFetch(() => '/api/data', '$PysQIWKhwV' /* nuxt-injected */)
        useLazyFetch(url, '$wjhr0zrAT4' /* nuxt-injected */)
        useLazyFetch('/api/data', { method: 'POST' }, '$H_jcqrI1sJ' /* nuxt-injected */)
        useLazyFetch(() => '/api/data', { method: 'POST' }, '$_jtliZGAeJ' /* nuxt-injected */)
        useLazyFetch(url, options, '$TtqJmekP-n' /* nuxt-injected */)"
      `)
    })
  })

  // --- useAsyncData / useLazyAsyncData ---
  describe('useAsyncData', () => {
    it('should add key when there was none provided', async () => {
      const code = `
import { useAsyncData, useLazyAsyncData } from '#app/composables/asyncData'
useAsyncData(() => $fetch('/api/data'))
useAsyncData(() => $fetch('/api/data'), { server: false })
      `

      expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`
        "import { useAsyncData, useLazyAsyncData } from '#app/composables/asyncData'
        useAsyncData(() => $fetch('/api/data'), '$HJiaryoL2y' /* nuxt-injected */)
        useAsyncData(() => $fetch('/api/data'), { server: false }, '$yysMIARJHe' /* nuxt-injected */)"
      `)
    })

    it('should not add key when one was provided as the first or last argument', async () => {
      const code = `
import { useAsyncData, useLazyAsyncData } from '#app/composables/asyncData'
useAsyncData('key', () => $fetch('/api/data'))
useAsyncData('key', () => $fetch('/api/data'), { server: false })

useLazyAsyncData('key', () => $fetch('/api/data'))
useLazyAsyncData('key', () => $fetch('/api/data'), { server: false })
      `
      expect((await transformPlugin.transform.handler(code, 'plugin.ts'))?.code.trim()).toMatchInlineSnapshot(`undefined`)
    })
  })
})
</file>

<file path="packages/nuxt/test/lazy-hydration-macro-transform.test.ts">
import { describe, expect, it } from 'vitest'
import { kebabCase, pascalCase } from 'scule'
import { rollup } from 'rollup'
import vuePlugin from '@vitejs/plugin-vue'
import vuePluginJsx from '@vitejs/plugin-vue-jsx'
import type { AddComponentOptions } from '@nuxt/kit'

import { LoaderPlugin } from '../src/components/plugins/loader.ts'
import { LazyHydrationTransformPlugin } from '../src/components/plugins/lazy-hydration-transform.ts'
import { LazyHydrationMacroTransformPlugin } from '../src/components/plugins/lazy-hydration-macro-transform.ts'

describe('lazy hydration macro transform', () => {
  it ('should correctly transform lazy hydration macro in sfc', async () => {
    const sfc = `
    <script setup>
    const LazyHydrationVisibleMyComponent = defineLazyHydrationComponent('visible', () => import('~/components/MyComponent.vue'))
    const LazyHydrationIdleMyComponent = defineLazyHydrationComponent('idle', () => import('~/components/MyComponent.vue'))
    const LazyHydrationInteractionMyComponent = defineLazyHydrationComponent('interaction', () => import('~/components/MyComponent.vue'))
    const LazyHydrationMediaQueryMyComponent = defineLazyHydrationComponent('mediaQuery', () => import('~/components/MyComponent.vue'))
    const LazyHydrationIfMyComponent = defineLazyHydrationComponent('if', () => import('~/components/MyComponent.vue'))
    const LazyHydrationTimeMyComponent = defineLazyHydrationComponent('time', () => import('~/components/MyComponent.vue'))
    const LazyHydrationNeverMyComponent = defineLazyHydrationComponent('never', () => import('~/components/MyComponent.vue'))
    </script>

    <template>
      <LazyHydrationVisibleMyComponent />
      <LazyHydrationIdleMyComponent />
      <LazyHydrationInteractionMyComponent />
      <LazyHydrationMediaQueryMyComponent />
      <LazyHydrationIfMyComponent />
      <LazyHydrationTimeMyComponent />
      <LazyHydrationNeverMyComponent />
    </template>
    `

    const code = await transform(sfc, '/pages/index.vue')
    expect(code).toContain(`import { createLazyVisibleComponent, createLazyIdleComponent, createLazyInteractionComponent, createLazyMediaQueryComponent, createLazyIfComponent, createLazyTimeComponent, createLazyNeverComponent } from '../client-runtime.mjs';`)

    const components = code.split('\n').map(line => line.trim()).filter(line => line.startsWith('const LazyHydration')).join('\n')
    expect(components).toMatchInlineSnapshot(`
      "const LazyHydrationVisibleMyComponent = createLazyVisibleComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationIdleMyComponent = createLazyIdleComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationInteractionMyComponent = createLazyInteractionComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationMediaQueryMyComponent = createLazyMediaQueryComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationIfMyComponent = createLazyIfComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationTimeMyComponent = createLazyTimeComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationNeverMyComponent = createLazyNeverComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));"
    `)
  })

  it ('should correctly transform lazy hydration macro in sfc with non-auto-imported components', async () => {
    const sfc = `
    <script setup>
    const LazyHydrationIfMyComponent = defineLazyHydrationComponent('if', () => import('~/components/MyComponent.vue'))
    </script>

    <template>
      <LazyHydrationIfMyComponent />
    </template>
    `

    const code = await transform(sfc, '/pages/index.vue', true)
    expect(code).toContain(`import { createLazyIfComponent } from '../client-runtime.mjs';`)

    const component = code.split('\n').map(line => line.trim()).find(line => line.startsWith('const LazyHydration'))
    expect(component).toMatchInlineSnapshot(`
      "const LazyHydrationIfMyComponent = createLazyIfComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));"
    `)
  })

  it ('should correctly transform lazy hydration macro in jsx', async () => {
    const component = `
    import { defineComponent } from 'vue'
    export default defineComponent({
      setup () {
        const LazyHydrationVisibleMyComponent = defineLazyHydrationComponent('visible', () => import('~/components/MyComponent.vue'))
        const LazyHydrationIdleMyComponent = defineLazyHydrationComponent('idle', () => import('~/components/MyComponent.vue'))
        const LazyHydrationInteractionMyComponent = defineLazyHydrationComponent('interaction', () => import('~/components/MyComponent.vue'))
        const LazyHydrationMediaQueryMyComponent = defineLazyHydrationComponent('mediaQuery', () => import('~/components/MyComponent.vue'))
        const LazyHydrationIfMyComponent = defineLazyHydrationComponent('if', () => import('~/components/MyComponent.vue'))
        const LazyHydrationTimeMyComponent = defineLazyHydrationComponent('time', () => import('~/components/MyComponent.vue'))
        const LazyHydrationNeverMyComponent = defineLazyHydrationComponent('never', () => import('~/components/MyComponent.vue'))

        return () => <>
          <LazyHydrationVisibleMyComponent />
          <LazyHydrationIdleMyComponent />
          <LazyHydrationInteractionMyComponent />
          <LazyHydrationMediaQueryMyComponent />
          <LazyHydrationIfMyComponent />
          <LazyHydrationTimeMyComponent />
          <LazyHydrationNeverMyComponent />
        </>
      }
    })
    `

    const code = await transform(component, '/pages/index.tsx')
    expect(code).toContain(`import { createLazyVisibleComponent, createLazyIdleComponent, createLazyInteractionComponent, createLazyMediaQueryComponent, createLazyIfComponent, createLazyTimeComponent, createLazyNeverComponent } from '../client-runtime.mjs';`)

    const components = code.split('\n').map(line => line.trim()).filter(line => line.startsWith('const LazyHydration')).join('\n')
    expect(components).toMatchInlineSnapshot(`
      "const LazyHydrationVisibleMyComponent = createLazyVisibleComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationIdleMyComponent = createLazyIdleComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationInteractionMyComponent = createLazyInteractionComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationMediaQueryMyComponent = createLazyMediaQueryComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationIfMyComponent = createLazyIfComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationTimeMyComponent = createLazyTimeComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationNeverMyComponent = createLazyNeverComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));"
    `)
  })

  it ('should correctly transform lazy hydration macro in ts', async () => {
    const component = `
    import { defineComponent, h } from 'vue'
    export default defineComponent({
      setup () {
        const LazyHydrationVisibleMyComponent = defineLazyHydrationComponent('visible', () => import('~/components/MyComponent.vue'))
        const LazyHydrationIdleMyComponent = defineLazyHydrationComponent('idle', () => import('~/components/MyComponent.vue'))
        const LazyHydrationInteractionMyComponent = defineLazyHydrationComponent('interaction', () => import('~/components/MyComponent.vue'))
        const LazyHydrationMediaQueryMyComponent = defineLazyHydrationComponent('mediaQuery', () => import('~/components/MyComponent.vue'))
        const LazyHydrationIfMyComponent = defineLazyHydrationComponent('if', () => import('~/components/MyComponent.vue'))
        const LazyHydrationTimeMyComponent = defineLazyHydrationComponent('time', () => import('~/components/MyComponent.vue'))
        const LazyHydrationNeverMyComponent = defineLazyHydrationComponent('never', () => import('~/components/MyComponent.vue'))

        return () => h('div', undefined, [
          h(LazyHydrationVisibleMyComponent),
          h(LazyHydrationIdleMyComponent),
          h(LazyHydrationInteractionMyComponent),
          h(LazyHydrationMediaQueryMyComponent),
          h(LazyHydrationIfMyComponent),
          h(LazyHydrationTimeMyComponent),
          h(LazyHydrationNeverMyComponent),
        ])
      }
    })
    `

    const code = await transform(component, '/pages/index.tsx')
    expect(code).toContain(`import { createLazyVisibleComponent, createLazyIdleComponent, createLazyInteractionComponent, createLazyMediaQueryComponent, createLazyIfComponent, createLazyTimeComponent, createLazyNeverComponent } from '../client-runtime.mjs';`)

    const components = code.split('\n').map(line => line.trim()).filter(line => line.startsWith('const LazyHydration')).join('\n')
    expect(components).toMatchInlineSnapshot(`
      "const LazyHydrationVisibleMyComponent = createLazyVisibleComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationIdleMyComponent = createLazyIdleComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationInteractionMyComponent = createLazyInteractionComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationMediaQueryMyComponent = createLazyMediaQueryComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationIfMyComponent = createLazyIfComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationTimeMyComponent = createLazyTimeComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));
      const LazyHydrationNeverMyComponent = createLazyNeverComponent("components/MyComponent.vue", () => import('~/components/MyComponent.vue'));"
    `)
  })

  it('should handle arrow functions with block statements', async () => {
    const sfc = `
    <script setup>
    const LazyHydrationVisibleMyComponent = defineLazyHydrationComponent('visible', () => {
      return import('~/components/MyComponent.vue')
    })
    const LazyHydrationIdleMyComponent = defineLazyHydrationComponent('idle', () => {
      // Some comment
      return import('~/components/MyComponent.vue')
    })
    </script>

    <template>
      <LazyHydrationVisibleMyComponent />
      <LazyHydrationIdleMyComponent />
    </template>
    `

    const code = await transform(sfc, '/pages/index.vue')
    expect(code).toContain(`import { createLazyVisibleComponent, createLazyIdleComponent } from '../client-runtime.mjs';`)

    const components = code.split('\n').map(line => line.trim()).filter(line => line.startsWith('const LazyHydration')).join('\n')
    expect(components).toContain(`const LazyHydrationVisibleMyComponent = createLazyVisibleComponent("components/MyComponent.vue"`)
    expect(components).toContain(`const LazyHydrationIdleMyComponent = createLazyIdleComponent("components/MyComponent.vue"`)
  })

  it('should handle async/await patterns', async () => {
    const sfc = `
    <script setup>
    const LazyHydrationVisibleMyComponent = defineLazyHydrationComponent('visible', async () => await import('~/components/MyComponent.vue'))
    const LazyHydrationIdleMyComponent = defineLazyHydrationComponent('idle', async () => {
      return await import('~/components/MyComponent.vue')
    })
    </script>

    <template>
      <LazyHydrationVisibleMyComponent />
      <LazyHydrationIdleMyComponent />
    </template>
    `

    const code = await transform(sfc, '/pages/index.vue')
    expect(code).toContain(`import { createLazyVisibleComponent, createLazyIdleComponent } from '../client-runtime.mjs';`)

    const components = code.split('\n').map(line => line.trim()).filter(line => line.startsWith('const LazyHydration')).join('\n')
    expect(components).toContain(`const LazyHydrationVisibleMyComponent = createLazyVisibleComponent("components/MyComponent.vue"`)
    expect(components).toContain(`const LazyHydrationIdleMyComponent = createLazyIdleComponent("components/MyComponent.vue"`)
  })

  it('should handle parenthesized expressions', async () => {
    const sfc = `
    <script setup>
    const LazyHydrationVisibleMyComponent = defineLazyHydrationComponent('visible', () => (import('~/components/MyComponent.vue')))
    const LazyHydrationIdleMyComponent = defineLazyHydrationComponent('idle', () => {
      return (import('~/components/MyComponent.vue'))
    })
    </script>

    <template>
      <LazyHydrationVisibleMyComponent />
      <LazyHydrationIdleMyComponent />
    </template>
    `

    const code = await transform(sfc, '/pages/index.vue')
    expect(code).toContain(`import { createLazyVisibleComponent, createLazyIdleComponent } from '../client-runtime.mjs';`)

    const components = code.split('\n').map(line => line.trim()).filter(line => line.startsWith('const LazyHydration')).join('\n')
    expect(components).toContain(`const LazyHydrationVisibleMyComponent = createLazyVisibleComponent("components/MyComponent.vue"`)
    expect(components).toContain(`const LazyHydrationIdleMyComponent = createLazyIdleComponent("components/MyComponent.vue"`)
  })

  it('should handle member expressions and method chaining', async () => {
    const sfc = `
    <script setup>
    const LazyHydrationVisibleMyComponent = defineLazyHydrationComponent('visible', () => import('~/components/MyComponent.vue').then(m => m.default))
    const LazyHydrationIdleMyComponent = defineLazyHydrationComponent('idle', () => {
      return import('~/components/MyComponent.vue').then(m => m.default)
    })
    </script>

    <template>
      <LazyHydrationVisibleMyComponent />
      <LazyHydrationIdleMyComponent />
    </template>
    `

    const code = await transform(sfc, '/pages/index.vue')
    expect(code).toContain(`import { createLazyVisibleComponent, createLazyIdleComponent } from '../client-runtime.mjs';`)

    const components = code.split('\n').map(line => line.trim()).filter(line => line.startsWith('const LazyHydration')).join('\n')
    expect(components).toContain(`const LazyHydrationVisibleMyComponent = createLazyVisibleComponent("components/MyComponent.vue"`)
    expect(components).toContain(`const LazyHydrationIdleMyComponent = createLazyIdleComponent("components/MyComponent.vue"`)
  })

  it('should handle conditional expressions', async () => {
    const sfc = `
    <script setup>
    const LazyHydrationVisibleMyComponent = defineLazyHydrationComponent('visible', () => 
      process.env.NODE_ENV === 'development' 
        ? import('~/components/MyComponent.vue')
        : import('~/components/MyComponent.vue')
    )
    </script>

    <template>
      <LazyHydrationVisibleMyComponent />
    </template>
    `

    const code = await transform(sfc, '/pages/index.vue')
    expect(code).toContain(`import { createLazyVisibleComponent } from '../client-runtime.mjs';`)

    const component = code.split('\n').map(line => line.trim()).find(line => line.startsWith('const LazyHydration'))
    expect(component).toContain(`createLazyVisibleComponent("components/MyComponent.vue"`)
  })

  it('should handle complex nested patterns', async () => {
    const sfc = `
    <script setup>
    const LazyHydrationVisibleMyComponent = defineLazyHydrationComponent('visible', async () => {
      return await (import('~/components/MyComponent.vue')).then(m => m.default)
    })
    </script>

    <template>
      <LazyHydrationVisibleMyComponent />
    </template>
    `

    const code = await transform(sfc, '/pages/index.vue')
    expect(code).toContain(`import { createLazyVisibleComponent } from '../client-runtime.mjs';`)

    const components = code.split('\n').map(line => line.trim()).filter(line => line.startsWith('const LazyHydration')).join('\n')
    expect(components).toContain(`createLazyVisibleComponent("components/MyComponent.vue"`)
  })
})

async function transform (code: string, filename: string, noComponents?: boolean) {
  const components = noComponents
    ? []
    : ([{ name: 'MyComponent', filePath: '/components/MyComponent.vue' }] as AddComponentOptions[]).map(opts => ({
        export: opts.export || 'default',
        chunkName: 'components/' + kebabCase(opts.name),
        global: opts.global ?? false,
        kebabName: kebabCase(opts.name || ''),
        pascalName: pascalCase(opts.name || ''),
        prefetch: false,
        preload: false,
        mode: 'all' as const,
        shortPath: opts.filePath,
        priority: 0,
        meta: {},
        ...opts,
      }))

  const bundle = await rollup({
    input: filename,
    plugins: [
      {
        name: 'entry',
        resolveId (id) {
          if (id === filename) {
            return id
          }
        },
        load (id) {
          if (id === filename) {
            return code
          }
        },
      },
      LazyHydrationTransformPlugin({ getComponents: () => components }).rollup(),
      vuePlugin(),
      vuePluginJsx(),
      LoaderPlugin({
        clientDelayedComponentRuntime: '/client-runtime.mjs',
        serverComponentRuntime: '/server-runtime.mjs',
        getComponents: () => components,
        srcDir: '/',
        mode: 'server',
      }).rollup(),
      LazyHydrationMacroTransformPlugin({
        clientDelayedComponentRuntime: '/client-runtime.mjs',
        srcDir: '/',
        alias: {
          '~/': '/',
        },
      }).rollup(),
    ],
  })
  const { output: [chunk] } = await bundle.generate({})
  return chunk.code.trim()
}
</file>

<file path="packages/nuxt/test/load-nuxt.bench.ts">
import { rm } from 'node:fs/promises'
import { beforeAll, bench, describe } from 'vitest'
import { join } from 'pathe'
import { loadNuxt } from 'nuxt'
import { findWorkspaceDir } from 'pkg-types'

const repoRoot = await findWorkspaceDir()

const emptyDir = join(repoRoot, 'node_modules/fixture')
const basicTestFixtureDir = join(repoRoot, 'test/fixtures/basic')

describe('loadNuxt', () => {
  beforeAll(async () => {
    await Promise.all([
      rm(join(emptyDir, 'node_modules/load-nuxt/.nuxt'), { recursive: true, force: true }),
      rm(join(basicTestFixtureDir, 'node_modules/load-nuxt/.nuxt'), { recursive: true, force: true }),
    ])
  })

  bench('loadNuxt in an empty directory', async () => {
    const nuxt = await loadNuxt({
      cwd: emptyDir,
      ready: true,
      overrides: {
        buildDir: join(emptyDir, 'node_modules/load-nuxt/.nuxt'),
      },
    })
    await nuxt.close()
  })

  bench('loadNuxt in the basic test fixture', async () => {
    const nuxt = await loadNuxt({
      cwd: basicTestFixtureDir,
      ready: true,
      overrides: {
        buildDir: join(basicTestFixtureDir, 'node_modules/load-nuxt/.nuxt'),
      },
    })
    await nuxt.close()
  })
})
</file>

<file path="packages/nuxt/test/load-nuxt.test.ts">
import { fileURLToPath } from 'node:url'
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'
import { normalize } from 'pathe'
import { withoutTrailingSlash } from 'ufo'
import { logger, tryUseNuxt, useNuxt } from '@nuxt/kit'
import { findWorkspaceDir } from 'pkg-types'
import { loadNuxt } from '../src/index.ts'
import type { NuxtConfig } from '../schema.ts'

const repoRoot = await findWorkspaceDir()

vi.stubGlobal('console', {
  ...console,
  error: vi.fn(console.error),
  warn: vi.fn(console.warn),
})

const loggerWarn = vi.spyOn(logger, 'warn')
vi.mock('pkg-types', async (og) => {
  const originalPkgTypes = (await og<typeof import('pkg-types')>())
  return {
    ...originalPkgTypes,
    readPackageJSON: vi.fn(originalPkgTypes.readPackageJSON),
  }
})

beforeEach(() => {
  loggerWarn.mockClear()
})
afterEach(() => {
  vi.clearAllMocks()
})

describe('loadNuxt', () => {
  it('respects hook overrides', async () => {
    let hookRan = false
    const nuxt = await loadNuxt({
      cwd: repoRoot,
      ready: true,
      overrides: {
        hooks: {
          ready () {
            hookRan = true
          },
        },
      },
    })
    await nuxt.close()
    expect(hookRan).toBe(true)
  })

  it('ensures layer CSS remains in order', async () => {
    const layerFixtureDir = withoutTrailingSlash(normalize(fileURLToPath(new URL('./layers-fixture', import.meta.url))))
    const nuxt = await loadNuxt({
      cwd: layerFixtureDir,
      overrides: {
        css: ['override.css'],
      },
    })
    await nuxt.close()

    expect(nuxt.options.css).toMatchInlineSnapshot(`
      [
        "custom.css",
        "auto.css",
        "final-project.css",
        "duplicate.css",
        "override.css",
        "new-css-added-by-module.css",
      ]
    `)
  })

  it('load multiple nuxt', async () => {
    await Promise.all([
      loadNuxt({
        cwd: repoRoot,
      }),
      loadNuxt({
        cwd: repoRoot,
      }),
    ])
    expect(loggerWarn).not.toHaveBeenCalled()
  })

  it('expect hooks to get the correct context outside of initNuxt', async () => {
    const nuxt = await loadNuxt({
      cwd: repoRoot,
    })

    // @ts-expect-error - random hook
    nuxt.hook('test', () => {
      expect(useNuxt().__name).toBe(nuxt.__name)
    })

    expect(tryUseNuxt()?.__name).not.toBe(nuxt.__name)

    // second nuxt context
    const second = await loadNuxt({
      cwd: repoRoot,
    })

    expect(second.__name).not.toBe(nuxt.__name)
    expect(tryUseNuxt()?.__name).not.toBe(nuxt.__name)

    // @ts-expect-error - random hook
    await nuxt.callHook('test')

    expect(loggerWarn).not.toHaveBeenCalled()
  })

  it('ensures layer modules remain in order', async () => {
    const layerFixtureDir = withoutTrailingSlash(normalize(fileURLToPath(new URL('./layers-fixture', import.meta.url))))
    const nuxt = await loadNuxt({ cwd: layerFixtureDir })
    await nuxt.close()

    const modules = nuxt.options._installedModules.map(item => item.meta.name ?? item.module.name)

    expect(modules).toMatchInlineSnapshot(`
      [
        "customLayerInlineModule",
        "customLayerModule",
        "customLayerAutoModule",
        "autoLayerInlineModule",
        "autoLayerModule",
        "autoLayerAutoModule",
        "projectModule",
        "projectInlineModule",
        "css",
        "projectAutoModule",
        "@nuxt/devtools",
        "nuxt:pages",
        "nuxt:meta",
        "nuxt:components",
        "nuxt:imports",
        "nuxt:nuxt-config-schema",
        "@nuxt/telemetry",
      ]
    `)
  })

  it('includes layer server directories in nitro tsconfig', async () => {
    const layerFixtureDir = withoutTrailingSlash(
      normalize(fileURLToPath(new URL('./layers-fixture', import.meta.url))),
    )

    const nuxt = await loadNuxt({ cwd: layerFixtureDir, ready: true })

    const tsConfigInclude = (nuxt as any)._nitro?.options.typescript?.tsConfig?.include ?? []

    const hasLayerServer = tsConfigInclude.some((p: string) =>
      p.replace(/\\/g, '/').includes('layers/auto/server'),
    )

    expect(hasLayerServer).toBe(true)

    await nuxt.close()
  })

  it('includes #server alias in nitro tsconfig paths', async () => {
    const nuxt = await loadNuxt({ cwd: repoRoot, ready: true })

    const tsConfigPaths = (nuxt as any)._nitro?.options.typescript?.tsConfig?.compilerOptions?.paths ?? {}

    expect(tsConfigPaths).toHaveProperty('#server')
    expect(tsConfigPaths).toHaveProperty('#server/*')

    await nuxt.close()
  })
})

const pagesDetectionTests: [test: string, overrides: NuxtConfig, result: NuxtConfig['pages']][] = [
  ['pages dir', {}, { enabled: true }],
  ['pages dir empty', { dir: { pages: 'empty-dir' } }, { enabled: false }],
  ['user config', { pages: false }, { enabled: false }],
  ['user config', { pages: { enabled: false } }, { enabled: false }],
  ['user config', { pages: { enabled: true, pattern: '**/*{.vue}' } }, { enabled: true, pattern: '**/*{.vue}' }],
]

const pagesFixtureDir = withoutTrailingSlash(normalize(fileURLToPath(new URL('./pages-fixture', import.meta.url))))
describe('pages detection', () => {
  it.each(pagesDetectionTests)('%s `%s`', async (_, overrides, result) => {
    const nuxt = await loadNuxt({ cwd: pagesFixtureDir, overrides, ready: true })
    // @ts-expect-error should resolve to object?
    expect(nuxt.options.pages).toMatchObject(result)
    await nuxt.close()
  })
})
</file>

<file path="packages/nuxt/test/naming.test.ts">
import { describe, expect, it } from 'vitest'
import { pascalCase } from 'scule'
import { getNameFromPath, resolveComponentNameSegments } from '../src/core/utils/index.ts'

describe('getNameFromPath', () => {
  const cases: Record<string, string> = {
    'base.vue': 'base',
    'base/base.vue': 'base',
    'base/base-layout.vue': 'base-layout',
    'base-1-layout': 'base-1-layout',
  }
  it.each(Object.keys(cases))('correctly deduplicates segments - %s', (filename) => {
    expect(getNameFromPath(filename)).toEqual(cases[filename])
  })
})

const tests: Array<[string, string[], string]> = [
  ['WithClientOnlySetup', ['Client'], 'ClientWithClientOnlySetup'],
  ['ItemHolderItem', ['Item', 'Holder', 'Item'], 'ItemHolderItem'],
  ['Item', ['Item'], 'Item'],
  ['Item', ['Item', 'Item'], 'Item'],
  ['ItemTest', ['Item', 'Test'], 'ItemTest'],
  ['ThingItemTest', ['Item', 'Thing'], 'ItemThingItemTest'],
  ['Item', ['Thing', 'Item'], 'ThingItem'],
  ['Item', ['Item', 'Holder', 'Item'], 'ItemHolderItem'],
  ['ItemHolder', ['Item', 'Holder', 'Item'], 'ItemHolderItemHolder'],
  ['ThingItemTest', ['Item', 'Thing', 'Foo'], 'ItemThingFooThingItemTest'],
  ['ItemIn', ['Item', 'Holder', 'Item', 'In'], 'ItemHolderItemIn'],
  ['Item', ['Item', 'Holder', 'Test'], 'ItemHolderTestItem'],
  ['ItemHolderItem', ['Item', 'Holder', 'Item', 'Holder'], 'ItemHolderItemHolderItem'],
  ['Icones', ['Icon'], 'IconIcones'],
  ['Icon', ['Icones'], 'IconesIcon'],
  ['IconHolder', ['IconHolder'], 'IconHolder'],
  ['GameList', ['Desktop', 'ShareGame', 'Review', 'Detail'], 'DesktopShareGameReviewDetailGameList'],
  ['base-1-layout', [], 'Base1Layout'],
]

describe('components:resolveComponentNameSegments', () => {
  it.each(tests)('resolves %s with prefix parts %s and filename %s', (fileName, prefixParts: string[], result) => {
    expect(pascalCase(resolveComponentNameSegments(fileName, prefixParts))).toBe(result)
  })
})
</file>

<file path="packages/nuxt/test/nitro-ssr-routes.test.ts">
import { describe, expect, it } from 'vitest'

import { pageTests } from './pages.test.ts'
import { toRou3Patterns } from '../src/pages/utils.ts'

describe('nitro-ssr-routes', () => {
  it('should resolve SSR routes correctly', () => {
    const paths = pageTests.map(test => test.output!).filter(Boolean).flat()
    expect(toRou3Patterns(paths)).toMatchInlineSnapshot(`
      [
        "/",
        "/parent",
        "/parent/child",
        "/parent",
        "/parent/child",
        "/parent/:child",
        "/parent-:child",
        "/**:stories",
        "/stories/:id",
        "/stories/:id",
        "/**:stories",
        "/snake_case",
        "/kebab-case",
        "/:foo",
        "/:foo",
        "/",
        "/:slug",
        "/:bar",
        "/opt/:slug",
        "/nonopt/:slug",
        "/optional/:opt",
        "/:sub/route-:slug",
        "/optional/prefix-:opt",
        "/optional/:opt_postfix",
        "/optional/prefix-:opt_postfix",
        "/",
        "/**:slug",
        "/**:slug/:id",
        "/:a1_1a",
        "/:b2_2b",
        "/:b2__2b",
        "/:c33c",
        "/:d44d",
        "/",
        "/test\\:name",
        "/测试",
        "/文档",
        "/文档/介绍",
        "/خاص\\:____",
        "/a&b",
        "/a\\\\b",
        "/:foo",
        "/:foo",
        "/param",
        "/param/sibling",
        "/param",
        "/param/sibling",
        "/param",
        "/wrapper-expose/other",
        "/wrapper-expose/other/sibling",
        "/wrapper-expose/other",
        "/",
        "/all",
        "/page1",
        "/page1/:id",
        "/page1",
        "/",
        "/",
        "/",
        "/",
        "/page-with-meta",
        "/**:id",
        "/**:id",
        "/page-with-meta",
        "/page-with-props",
        "/",
        "/about",
        "/about",
        "/about",
      ]
    `)
  })
})
</file>

<file path="packages/nuxt/test/nuxt-link.test.ts">
import { describe, expect, it, vi } from 'vitest'
import type { RouteLocation, RouteLocationRaw } from 'vue-router'
import { withQuery } from 'ufo'
import type { NuxtLinkOptions, NuxtLinkProps } from '../src/app/components/nuxt-link.ts'
import { defineNuxtLink } from '../src/app/components/nuxt-link.ts'
import { useRuntimeConfig } from '../src/app/nuxt.ts'

// mocks `useRuntimeConfig()`
vi.mock('../src/app/nuxt', () => ({
  useRuntimeConfig: vi.fn(() => ({
    app: {
      baseURL: '/',
    },
  })),
}))

// Mocks `h()`
vi.mock('vue', async () => {
  const vue: Record<string, unknown> = await vi.importActual('vue')
  return {
    ...vue,
    resolveComponent: (name: string) => name,
    h: (...args: any[]) => args,
  }
})

// Mocks Nuxt `useRouter()`
vi.mock('../src/app/composables/router', () => ({
  resolveRouteObject (to: Exclude<RouteLocationRaw, string>) {
    return withQuery(to.path || '', to.query || {}) + (to.hash || '')
  },
  useRouter: () => ({
    resolve: (route: string | RouteLocation): Partial<RouteLocation> & { href: string } => {
      if (typeof route === 'string') {
        return { path: route, href: route }
      }
      return {
        path: route.path || `/${route.name?.toString()}`,
        query: route.query || undefined,
        hash: route.hash || undefined,
        href: route.path || `/${route.name?.toString()}`,
      }
    },
  }),
}))

// Helpers for test visibility
const EXTERNAL = 'a'
const INTERNAL = 'RouterLink'

// Renders a `<NuxtLink />`
const nuxtLink = (
  props: NuxtLinkProps = {},
  nuxtLinkOptions: Partial<NuxtLinkOptions> = {},
): { type: string, props: Record<string, unknown>, slots: unknown } => {
  const component = defineNuxtLink({ componentName: 'NuxtLink', ...nuxtLinkOptions })

  const [type, _props, slots] = (
    component as unknown as { setup: (props: NuxtLinkProps, context: { slots: Record<string, () => unknown> }) => () => [string, Record<string, unknown>, unknown] }
  ).setup(props, { slots: { default: () => null } })()

  return { type, props: _props, slots }
}

describe('nuxt-link:to', () => {
  it('renders link with `to` prop', () => {
    expect(nuxtLink({ to: '/to' }).props.to).toBe('/to')
  })

  it('renders link with `href` prop', () => {
    expect(nuxtLink({ href: '/href' }).props.to).toBe('/href')
  })

  it('renders link with `to` prop and warns about `href` prop conflict', () => {
    const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(vi.fn() as any)

    expect(nuxtLink({ to: '/to', href: '/href' }).props.to).toBe('/to')
    // TODO: Uncomment when `dev` mode for tests is available
    // expect(consoleWarnSpy).toHaveBeenCalledOnce()

    consoleWarnSpy.mockRestore()
  })

  it('without to and href', () => {
    const link = nuxtLink()
    expect(link.props.href).toBe(null)
    expect(link.props.rel).toBe(null)
  })
})

describe('nuxt-link:isExternal', () => {
  it('returns based on `to` value', () => {
    // Internal
    expect(nuxtLink({ to: '/foo' }).type).toBe(INTERNAL)
    expect(nuxtLink({ to: '/foo/bar' }).type).toBe(INTERNAL)
    expect(nuxtLink({ to: '/foo/bar?baz=qux' }).type).toBe(INTERNAL)

    // External
    expect(nuxtLink({ to: 'https://nuxtjs.org' }).type).toBe(EXTERNAL)
    expect(nuxtLink({ to: '//nuxtjs.org' }).type).toBe(EXTERNAL)
    expect(nuxtLink({ to: 'tel:0123456789' }).type).toBe(EXTERNAL)
    expect(nuxtLink({ to: 'mailto:hello@nuxtlabs.com' }).type).toBe(EXTERNAL)
  })

  it('returns `false` when `to` is a route location object', () => {
    expect(nuxtLink({ to: { path: '/to' } }).type).toBe(INTERNAL)
  })

  it('returns `true` when `to` has a `target`', () => {
    expect(nuxtLink({ to: { path: '/to' }, target: '_blank' }).type).toBe(EXTERNAL)
  })

  it('honors `external` prop', () => {
    expect(nuxtLink({ to: '/to', external: true }).type).toBe(EXTERNAL)
    expect(nuxtLink({ to: '/to', external: false }).type).toBe(INTERNAL)
  })

  it('returns `true` when using the `target` prop', () => {
    expect(nuxtLink({ to: '/foo', target: '_blank' }).type).toBe(EXTERNAL)
    expect(nuxtLink({ to: '/foo/bar', target: '_blank' }).type).toBe(EXTERNAL)
    expect(nuxtLink({ to: '/foo/bar?baz=qux', target: '_blank' }).type).toBe(EXTERNAL)
  })

  it('returns `true` if link starts with hash', () => {
    expect(nuxtLink({ href: '#hash' }).type).toBe(EXTERNAL)
    expect(nuxtLink({ to: '#hash' }).type).toBe(EXTERNAL)
  })
})

describe('nuxt-link:propsOrAttributes', () => {
  describe('`isExternal` is `true`', () => {
    describe('href', () => {
      it('forwards `to` value', () => {
        expect(nuxtLink({ to: 'https://nuxtjs.org' }).props.href).toBe('https://nuxtjs.org')
      })

      it('resolves route location object', () => {
        expect(nuxtLink({ to: { path: '/to' }, external: true }).props.href).toBe('/to')
      })

      it('resolves route location object with name', () => {
        expect(nuxtLink({ to: { name: 'to' }, external: true }).props.href).toBe('/to')
      })

      it('applies trailing slash behaviour', () => {
        expect(nuxtLink({ to: { path: '/to' }, external: true }, { trailingSlash: 'append' }).props.href).toBe('/to/')
        expect(nuxtLink({ to: '/to', external: true }, { trailingSlash: 'append' }).props.href).toBe('/to/')
      })
    })

    describe('target', () => {
      it('forwards `target` prop', () => {
        expect(nuxtLink({ to: 'https://nuxtjs.org', target: '_blank' }).props.target).toBe('_blank')
        expect(nuxtLink({ to: 'https://nuxtjs.org', target: null }).props.target).toBe(null)
      })

      it('defaults to `null`', () => {
        expect(nuxtLink({ to: 'https://nuxtjs.org' }).props.target).toBe(null)
      })

      it('prefixes target="_blank" internal links with baseURL', () => {
        vi.mocked(useRuntimeConfig).withImplementation(() => {
          return {
            app: {
              baseURL: '/base',
            },
          } as any
        }, () => {
          expect(nuxtLink({ to: '/', target: '_blank' }).props.href).toBe('/base')
          expect(nuxtLink({ to: '/base', target: '_blank' }).props.href).toBe('/base/base')
          expect(nuxtLink({ to: '/to', target: '_blank' }).props.href).toBe('/base/to')
          expect(nuxtLink({ to: '/base/to', target: '_blank' }).props.href).toBe('/base/base/to')
          expect(nuxtLink({ to: '//base/to', target: '_blank' }).props.href).toBe('//base/to')
          expect(nuxtLink({ to: '//to.com/thing', target: '_blank' }).props.href).toBe('//to.com/thing')
          expect(nuxtLink({ to: 'https://test.com/to', target: '_blank' }).props.href).toBe('https://test.com/to')

          expect(nuxtLink({ to: '/', target: '_blank' }, { trailingSlash: 'append' }).props.href).toBe('/base/')
          expect(nuxtLink({ to: '/base/', target: '_blank' }, { trailingSlash: 'remove' }).props.href).toBe('/base/base')
        })
      })

      it('excludes the baseURL for external links', () => {
        vi.mocked(useRuntimeConfig).withImplementation(() => {
          return {
            app: {
              baseURL: '/base',
            },
          } as any
        }, () => {
          expect(nuxtLink({ to: 'http://nuxtjs.org/app/about', target: '_blank' }).props.href).toBe('http://nuxtjs.org/app/about')
          expect(nuxtLink({ to: '//nuxtjs.org/app/about', target: '_blank' }).props.href).toBe('//nuxtjs.org/app/about')
          expect(nuxtLink({ to: { path: '/' }, external: true }).props.href).toBe('/')
          expect(nuxtLink({ to: '/', external: true }).props.href).toBe('/')
        })
      })
    })

    describe('rel', () => {
      it('uses framework\'s default', () => {
        expect(nuxtLink({ to: 'https://nuxtjs.org' }).props.rel).toBe('noopener noreferrer')
      })

      it('uses user\'s default', () => {
        expect(nuxtLink({ to: 'https://nuxtjs.org' }, { externalRelAttribute: 'foo' }).props.rel).toBe('foo')
        expect(nuxtLink({ to: 'https://nuxtjs.org' }, { externalRelAttribute: null }).props.rel).toBe(null)
      })

      it('uses and favors `rel` prop', () => {
        expect(nuxtLink({ to: 'https://nuxtjs.org', rel: 'foo' }).props.rel).toBe('foo')
        expect(nuxtLink({ to: 'https://nuxtjs.org', rel: 'foo' }, { externalRelAttribute: 'bar' }).props.rel).toBe('foo')
        expect(nuxtLink({ to: 'https://nuxtjs.org', rel: null }, { externalRelAttribute: 'bar' }).props.rel).toBe(null)
        expect(nuxtLink({ to: 'https://nuxtjs.org', rel: '' }, { externalRelAttribute: 'bar' }).props.rel).toBe(null)
      })

      it('honors `noRel` prop', () => {
        expect(nuxtLink({ to: 'https://nuxtjs.org', noRel: true }).props.rel).toBe(null)
        expect(nuxtLink({ to: 'https://nuxtjs.org', noRel: false }).props.rel).toBe('noopener noreferrer')
      })

      it('honors `noRel` prop and warns about `rel` prop conflict', () => {
        const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(vi.fn() as any)

        expect(nuxtLink({ to: 'https://nuxtjs.org', noRel: true, rel: 'foo' }).props.rel).toBe(null)
        // TODO: Uncomment when `dev` mode for tests is available
        // expect(consoleWarnSpy).toHaveBeenCalledOnce()

        consoleWarnSpy.mockRestore()
      })
    })
  })

  describe('`isExternal` is `false`', () => {
    describe('to', () => {
      it('forwards `to` prop', () => {
        expect(nuxtLink({ to: '/to' }).props.to).toBe('/to')
        expect(nuxtLink({ to: { path: '/to' } }).props.to).toEqual({ path: '/to' })
        expect(nuxtLink({ to: { name: 'to' } }).props.to).toEqual({ name: 'to' })
      })
    })

    describe('activeClass', () => {
      it('uses framework\'s default', () => {
        expect(nuxtLink({ to: '/to' }).props.activeClass).toBe(undefined)
      })

      it('uses user\'s default', () => {
        expect(nuxtLink({ to: '/to' }, { activeClass: 'activeClass' }).props.activeClass).toBe('activeClass')
      })

      it('uses and favors `activeClass` prop', () => {
        expect(nuxtLink({ to: '/to', activeClass: 'propActiveClass' }).props.activeClass).toBe('propActiveClass')
        expect(nuxtLink({ to: '/to', activeClass: 'propActiveClass' }, { activeClass: 'activeClass' }).props.activeClass).toBe('propActiveClass')
      })
    })

    describe('exactActiveClass', () => {
      it('uses framework\'s default', () => {
        expect(nuxtLink({ to: '/to' }).props.exactActiveClass).toBe(undefined)
      })

      it('uses user\'s default', () => {
        expect(nuxtLink({ to: '/to' }, { exactActiveClass: 'exactActiveClass' }).props.exactActiveClass).toBe('exactActiveClass')
      })

      it('uses and favors `exactActiveClass` prop', () => {
        expect(nuxtLink({ to: '/to', exactActiveClass: 'propExactActiveClass' }).props.exactActiveClass).toBe('propExactActiveClass')
        expect(nuxtLink({ to: '/to', exactActiveClass: 'propExactActiveClass' }, { exactActiveClass: 'exactActiveClass' }).props.exactActiveClass).toBe('propExactActiveClass')
      })
    })

    describe('replace', () => {
      it('forwards `replace` prop', () => {
        expect(nuxtLink({ to: '/to', replace: true }).props.replace).toBe(true)
        expect(nuxtLink({ to: '/to', replace: false }).props.replace).toBe(false)
      })
    })

    describe('ariaCurrentValue', () => {
      it('forwards `ariaCurrentValue` prop', () => {
        expect(nuxtLink({ to: '/to', ariaCurrentValue: 'page' }).props.ariaCurrentValue).toBe('page')
        expect(nuxtLink({ to: '/to', ariaCurrentValue: 'step' }).props.ariaCurrentValue).toBe('step')
      })
    })

    describe('trailingSlashBehavior', () => {
      it('append slash using options', () => {
        const appendSlashOptions: NuxtLinkOptions = { trailingSlash: 'append' }

        expect(nuxtLink({ to: '/to' }, appendSlashOptions).props.to).toEqual('/to/')
        expect(nuxtLink({ to: '/to/' }, appendSlashOptions).props.to).toEqual('/to/')
        expect(nuxtLink({ to: '/to#abc' }, appendSlashOptions).props.to).toEqual('/to/#abc')
        expect(nuxtLink({ to: { name: 'to' } }, appendSlashOptions).props.to).toHaveProperty('path', '/to/')
        expect(nuxtLink({ to: { path: '/to' } }, appendSlashOptions).props.to).toHaveProperty('path', '/to/')
        expect(nuxtLink({ to: { path: '/to#abc' } }, appendSlashOptions).props.to).toHaveProperty('path', '/to/#abc')
        expect(nuxtLink({ href: '/to' }, appendSlashOptions).props.to).toEqual('/to/')
        expect(nuxtLink({ href: '/to#abc' }, appendSlashOptions).props.to).toEqual('/to/#abc')
        expect(nuxtLink({ to: '/to?param=1' }, appendSlashOptions).props.to).toEqual('/to/?param=1')
        expect(nuxtLink({ to: '/to?param=1#abc' }, appendSlashOptions).props.to).toEqual('/to/?param=1#abc')
        expect(nuxtLink({ href: 'mailto:test@example.com' }, appendSlashOptions).props.href).toEqual('mailto:test@example.com')
      })

      it('remove slash using options', () => {
        const removeSlashOptions: NuxtLinkOptions = { trailingSlash: 'remove' }

        expect(nuxtLink({ to: '/to' }, removeSlashOptions).props.to).toEqual('/to')
        expect(nuxtLink({ to: '/to/' }, removeSlashOptions).props.to).toEqual('/to')
        expect(nuxtLink({ to: '/to/#abc' }, removeSlashOptions).props.to).toEqual('/to#abc')
        expect(nuxtLink({ to: { name: 'to' } }, removeSlashOptions).props.to).toHaveProperty('path', '/to')
        expect(nuxtLink({ to: { path: '/to/' } }, removeSlashOptions).props.to).toHaveProperty('path', '/to')
        expect(nuxtLink({ to: { path: '/to/#abc' } }, removeSlashOptions).props.to).toHaveProperty('path', '/to#abc')
        expect(nuxtLink({ href: '/to/' }, removeSlashOptions).props.to).toEqual('/to')
        expect(nuxtLink({ to: '/to/?param=1' }, removeSlashOptions).props.to).toEqual('/to?param=1')
        expect(nuxtLink({ to: '/to/?param=1#abc' }, removeSlashOptions).props.to).toEqual('/to?param=1#abc')
        expect(nuxtLink({ href: 'mailto:test@example.com' }, removeSlashOptions).props.href).toEqual('mailto:test@example.com')
      })

      it('prop overrides option: append', () => {
        const removeSlashOptions: NuxtLinkOptions = { trailingSlash: 'remove' }
        // Prop takes priority
        expect(nuxtLink({ to: '/to', trailingSlash: 'append' }, removeSlashOptions).props.to).toEqual('/to/')
        expect(nuxtLink({ to: '/to/', trailingSlash: 'append' }, removeSlashOptions).props.to).toEqual('/to/')
        expect(nuxtLink({ to: { path: '/to' }, trailingSlash: 'append' }, removeSlashOptions).props.to).toHaveProperty('path', '/to/')
        // External links
        expect(nuxtLink({ to: '/to', external: true, trailingSlash: 'append' }, removeSlashOptions).props.href).toBe('/to/')
      })

      it('prop overrides option: remove', () => {
        const appendSlashOptions: NuxtLinkOptions = { trailingSlash: 'append' }
        // Prop takes priority
        expect(nuxtLink({ to: '/to/', trailingSlash: 'remove' }, appendSlashOptions).props.to).toEqual('/to')
        expect(nuxtLink({ to: '/to', trailingSlash: 'remove' }, appendSlashOptions).props.to).toEqual('/to')
        expect(nuxtLink({ to: { path: '/to/' }, trailingSlash: 'remove' }, appendSlashOptions).props.to).toHaveProperty('path', '/to')
        // External links
        expect(nuxtLink({ to: '/to/', external: true, trailingSlash: 'remove' }, appendSlashOptions).props.href).toBe('/to')
      })

      it('uses option when prop is not provided', () => {
        const appendSlashOptions: NuxtLinkOptions = { trailingSlash: 'append' }
        const removeSlashOptions: NuxtLinkOptions = { trailingSlash: 'remove' }

        // Use append option
        expect(nuxtLink({ to: '/to' }, appendSlashOptions).props.to).toEqual('/to/')
        // Use remove option
        expect(nuxtLink({ to: '/to/' }, removeSlashOptions).props.to).toEqual('/to')
        // External links with options
        expect(nuxtLink({ to: '/to', external: true }, appendSlashOptions).props.href).toBe('/to/')
        expect(nuxtLink({ to: '/to/', external: true }, removeSlashOptions).props.href).toBe('/to')
      })
    })
  })
})
</file>

<file path="packages/nuxt/test/page-metadata.test.ts">
import { describe, expect, it, vi } from 'vitest'
import type { MockedFunction } from 'vitest'
import { compileScript, parse } from '@vue/compiler-sfc'
import { klona } from 'klona'
import { parse as toAst } from 'acorn'

import { PageMetaPlugin } from '../src/pages/plugins/page-meta.ts'
import { getRouteMeta, normalizeRoutes } from '../src/pages/utils.ts'
import type { NuxtPage } from '../schema.ts'

const filePath = '/app/pages/index.vue'

vi.mock('klona', { spy: true })

describe('page metadata', () => {
  it('should not extract metadata from empty files', () => {
    expect(getRouteMeta('', filePath)).toEqual({})
    expect(getRouteMeta('<template><div>Hi</div></template>', filePath)).toEqual({})
  })

  it('should extract metadata from JS/JSX files', () => {
    const fileContents = `definePageMeta({ name: 'bar' })`
    for (const ext of ['js', 'jsx', 'ts', 'tsx', 'mjs', 'cjs']) {
      const meta = getRouteMeta(fileContents, `/app/pages/index.${ext}`)
      expect(meta).toStrictEqual({
        name: 'bar',
      })
    }
  })

  it('should parse JSX files', () => {
    const fileContents = `
export default {
  setup () {
    definePageMeta({ name: 'bar' })
    return () => <div></div>
  }
}
    `
    const meta = getRouteMeta(fileContents, `/app/pages/index.jsx`)
    expect(meta).toStrictEqual({
      name: 'bar',
    })
  })

  it('should parse lang="jsx" from vue files', () => {
    const fileContents = `
  <script setup lang="jsx">
  const foo = <></>;
  definePageMeta({ name: 'bar' })
  </script>`

    const meta = getRouteMeta(fileContents, `/app/pages/index.vue`)
    expect(meta).toStrictEqual({
      name: 'bar',
    })
  })

  it('should handle experimental decorators', () => {
    const fileContents = `
<script setup lang="ts">
function something (_method: () => unknown) {
  return () => 'decorated'
}
class SomeClass {
  @something
  public someMethod () {
    return 'initial'
  }
}
definePageMeta({ name: 'bar' })
</script>
    `
    const meta = getRouteMeta(fileContents, `/app/pages/index.vue`)
    expect(meta).toStrictEqual({
      name: 'bar',
    })
  })

  it('should use and invalidate cache', () => {
    const _klona = klona as unknown as MockedFunction<typeof klona>
    _klona.mockImplementation(obj => obj)
    const fileContents = `<script setup>definePageMeta({ foo: 'bar' })</script>`
    const meta = getRouteMeta(fileContents, filePath)
    expect(meta === getRouteMeta(fileContents, filePath)).toBeTruthy()
    expect(meta === getRouteMeta(fileContents, '/app/pages/other.vue')).toBeFalsy()
    expect(meta === getRouteMeta('<template><div>Hi</div></template>' + fileContents, filePath)).toBeFalsy()
    _klona.mockReset()
  })

  it('should not share state between page metadata', () => {
    const fileContents = `<script setup>definePageMeta({ foo: 'bar' })</script>`
    const meta = getRouteMeta(fileContents, filePath)
    expect(meta === getRouteMeta(fileContents, filePath)).toBeFalsy()
  })

  it('should extract serialisable metadata', () => {
    const meta = getRouteMeta(`
    <script setup>
    definePageMeta({
      path: '/some-custom-path',
      validate: () => true,
      middleware: [
        function () {},
      ],
      otherValue: {
        foo: 'bar',
      },
      // 'name', 'props' and 'alias' are part of 'defaultExtractionKeys'; they're extracted from the component, so we should test the AST walking for different value types
      name: 'some-custom-name',
      props: {
        foo: 'bar',
      },
      alias: ['/alias'],
    })
    </script>
    `, filePath)

    expect(meta).toMatchInlineSnapshot(`
      {
        "alias": [
          "/alias",
        ],
        "meta": {
          "__nuxt_dynamic_meta_key": Set {
            "middleware",
            "meta",
          },
        },
        "name": "some-custom-name",
        "path": "/some-custom-path",
        "props": {
          "foo": "bar",
        },
      }
    `)
  })

  it('should extract metadata containing TS expressions', () => {
    const meta = getRouteMeta(`
    <script setup lang="ts">
    type PageName = 'name-from-page-meta' | 'whatever';

    definePageMeta({
      name: 'name-from-page-meta' as PageName,
      path: ('/some-custom-path') as const,
      props: <{ foo: string }>{
        foo: 'bar' satisfies string,
      },
    } as const);
    </script>
    `, filePath)

    expect(meta).toMatchInlineSnapshot(`
      {
        "name": "name-from-page-meta",
        "path": "/some-custom-path",
        "props": {
          "foo": "bar",
        },
      }
    `)
  })

  it('should not extract non-serialisable meta', () => {
    const meta = getRouteMeta(`
    <script setup>
    definePageMeta({
      redirect: () => '/',
    })
    </script>
    `, filePath)

    expect(meta).toMatchInlineSnapshot(`
      {
        "meta": {
          "__nuxt_dynamic_meta_key": Set {
            "redirect",
          },
        },
      }
    `)
  })

  it('should extract serialisable metadata from files with multiple blocks', () => {
    const meta = getRouteMeta(`
    <script lang="ts">
    export default {
      name: 'thing'
    }
    </script>
    <script setup>
    definePageMeta({
      name: 'some-custom-name',
      path: '/some-custom-path',
      validate: () => true,
      middleware: [
        function () {},
      ],
      otherValue: {
        foo: 'bar',
      },
    })
    </script>
    `, filePath)

    expect(meta).toMatchInlineSnapshot(`
      {
        "meta": {
          "__nuxt_dynamic_meta_key": Set {
            "middleware",
            "meta",
          },
        },
        "name": "some-custom-name",
        "path": "/some-custom-path",
      }
    `)
  })

  it('should extract serialisable metadata in options api', () => {
    const meta = getRouteMeta(`
    <script>
    export default {
      setup() {
        definePageMeta({
          name: 'some-custom-name',
          path: '/some-custom-path',
          middleware: (from, to) => console.warn('middleware'),
        })
      },
    };
    </script>
    `, filePath)

    expect(meta).toMatchInlineSnapshot(`
      {
        "meta": {
          "__nuxt_dynamic_meta_key": Set {
            "middleware",
          },
        },
        "name": "some-custom-name",
        "path": "/some-custom-path",
      }
    `)
  })

  it('should extract serialisable metadata all quoted', () => {
    const meta = getRouteMeta(`
    <script setup>
    definePageMeta({
      "otherValue": {
        foo: 'bar',
      },
    })
    </script>
    `, filePath)

    expect(meta).toMatchInlineSnapshot(`
      {
        "meta": {
          "__nuxt_dynamic_meta_key": Set {
            "meta",
          },
        },
      }
    `)
  })

  it('should extract configured extra meta and add it into the page meta', () => {
    const meta = getRouteMeta(`
    <script setup>
    definePageMeta({
      foo: 'bar',
      bar: true,
    })
    </script>
    `, filePath, new Set(['bar', 'foo']))

    expect(meta).toMatchInlineSnapshot(`
      {
        "meta": {
          "bar": true,
          "foo": "bar",
        },
      }
    `)
  })

  it('should not set default extraction keys into NuxtPage.meta', () => {
    const meta = getRouteMeta(`
    <script setup>
    definePageMeta({
      alias: '/alias',
      bar: true,
    })
    </script>
    `, filePath, new Set(['bar']))

    expect(meta).toMatchInlineSnapshot(`
      {
        "alias": "/alias",
        "meta": {
          "bar": true,
        },
      }
    `)
  })
})

describe('normalizeRoutes', () => {
  it('should produce valid route objects when used with extracted meta', () => {
    const page: NuxtPage = { path: '/', file: filePath }
    Object.assign(page, getRouteMeta(`
      <script setup>
      definePageMeta({
        name: 'some-custom-name',
        path: ref('/some-custom-path'), /* dynamic */
        validate: () => true,
        redirect: '/',
        middleware: [
          function () {},
        ],
        otherValue: {
          foo: 'bar',
        },
      })
      </script>
      `, filePath))

    page.meta ||= {}
    page.meta.layout = 'test'
    page.meta.foo = 'bar'

    const { routes, imports } = normalizeRoutes([page], new Set(), {
      clientComponentRuntime: '<client-component-runtime>',
      serverComponentRuntime: '<server-component-runtime>',
      overrideMeta: true,
    })
    expect({ routes, imports }).toMatchInlineSnapshot(`
      {
        "imports": Set {
          "import { default as indexndqPXFtP262szLmLJV4PriPTgAg5k_7f05QyTfosBXQMeta } from "/app/pages/index.vue?macro=true";",
        },
        "routes": "[
        {
          name: "some-custom-name",
          path: indexndqPXFtP262szLmLJV4PriPTgAg5k_7f05QyTfosBXQMeta?.path ?? "/",
          meta: { ...(indexndqPXFtP262szLmLJV4PriPTgAg5k_7f05QyTfosBXQMeta || {}), ...{"layout":"test","foo":"bar"} },
          redirect: "/",
          component: () => import("/app/pages/index.vue")
        }
      ]",
      }
    `)
  })

  it('should produce valid route objects when used without extracted meta', () => {
    const page: NuxtPage = { path: '/', file: filePath }
    page.meta ||= {}
    page.meta.layout = 'test'
    page.meta.foo = 'bar'

    const { routes, imports } = normalizeRoutes([page], new Set(), {
      clientComponentRuntime: '<client-component-runtime>',
      serverComponentRuntime: '<server-component-runtime>',
      overrideMeta: false,
    })
    expect({ routes, imports }).toMatchInlineSnapshot(`
      {
        "imports": Set {
          "import { default as indexndqPXFtP262szLmLJV4PriPTgAg5k_7f05QyTfosBXQMeta } from "/app/pages/index.vue?macro=true";",
        },
        "routes": "[
        {
          name: indexndqPXFtP262szLmLJV4PriPTgAg5k_7f05QyTfosBXQMeta?.name ?? undefined,
          path: indexndqPXFtP262szLmLJV4PriPTgAg5k_7f05QyTfosBXQMeta?.path ?? "/",
          props: indexndqPXFtP262szLmLJV4PriPTgAg5k_7f05QyTfosBXQMeta?.props ?? false,
          meta: { ...(indexndqPXFtP262szLmLJV4PriPTgAg5k_7f05QyTfosBXQMeta || {}), ...{"layout":"test","foo":"bar"} },
          alias: indexndqPXFtP262szLmLJV4PriPTgAg5k_7f05QyTfosBXQMeta?.alias || [],
          redirect: indexndqPXFtP262szLmLJV4PriPTgAg5k_7f05QyTfosBXQMeta?.redirect,
          component: () => import("/app/pages/index.vue")
        }
      ]",
      }
    `)
  })
})

describe('rewrite page meta', () => {
  const transformPlugin = PageMetaPlugin({ extractedKeys: ['extracted'] }).raw({}, {} as any) as { transform: { handler: (code: string, id: string) => { code: string } | null } }

  it('should throw when multiple definePageMeta', () => {
    const sfc = `
<script setup lang="ts">

 definePageMeta({ name: 'hi' })

 definePageMeta({
 layout: 'hi'
})

</script>
      `
    const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })
    expect(() => transformPlugin.transform.handler(res.content, 'component.vue?macro=true')).toThrowErrorMatchingInlineSnapshot(`[Error: Multiple \`definePageMeta\` calls are not supported. File: component.vue]`)
  })

  it('should extract metadata from vue components', () => {
    const sfc = `
<script setup lang="ts">
definePageMeta({
  name: 'hi',
  other: 'value'
})
</script>
      `
    const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })
    expect(transformPlugin.transform.handler(res.content, 'component.vue?macro=true')?.code).toMatchInlineSnapshot(`
      "const __nuxt_page_meta = {
        name: 'hi',
        other: 'value'
      }
      export default __nuxt_page_meta"
    `)
  })

  it('should extract local functions', () => {
    const sfc = `
<script setup lang="ts">
function isNumber(value) {
  return value && !isNaN(Number(value))
}

function validateIdParam (route) {
  return isNumber(route.params.id)
}

definePageMeta({
  validate: validateIdParam,
  test: () => 'hello',
})
</script>
      `
    const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })
    expect(transformPlugin.transform.handler(res.content, 'component.vue?macro=true')?.code).toMatchInlineSnapshot(`
      "function isNumber(value) {
        return value && !isNaN(Number(value))
      }
      function validateIdParam (route) {
        return isNumber(route.params.id)
      }
      const __nuxt_page_meta = {
        validate: validateIdParam,
        test: () => 'hello',
      }
      export default __nuxt_page_meta"
    `)
  })

  it('should extract user imports', () => {
    const sfc = `
<script setup lang="ts">
import { validateIdParam } from './utils.ts'

definePageMeta({
  validate: validateIdParam,
  dynamic: ref(true),
})
</script>
      `
    const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })
    expect(transformPlugin.transform.handler(res.content, 'component.vue?macro=true')?.code).toMatchInlineSnapshot(`
      "import { validateIdParam } from './utils.ts'

      const __nuxt_page_meta = {
        validate: validateIdParam,
        dynamic: ref(true),
      }
      export default __nuxt_page_meta"
    `)
  })

  it('should not import static identifiers when shadowed in the same scope', () => {
    const sfc = `
<script setup lang="ts">
import { useState } from '#app/composables/state'

definePageMeta({
  middleware: () => {
    const useState = (key) => ({ value: { isLoggedIn: false } })
    const auth = useState('auth')
    if (!auth.value.isLoggedIn) {
      return navigateTo('/login')
    }
  },
})
</script>
      `
    const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })
    expect(transformPlugin.transform.handler(res.content, 'component.vue?macro=true')?.code).toMatchInlineSnapshot(`
      "const __nuxt_page_meta = {
        middleware: () => {
          const useState = (key) => ({ value: { isLoggedIn: false } })
          const auth = useState('auth')
          if (!auth.value.isLoggedIn) {
            return navigateTo('/login')
          }
        },
      }
      export default __nuxt_page_meta"
    `)
  })

  it('should not import static identifiers when shadowed in parent scope', () => {
    const sfc = `
<script setup lang="ts">
import { useState } from '#app/composables/state'

definePageMeta({
  middleware: () => {
    function isLoggedIn() {
      const auth = useState('auth')
      return auth.value.isLoggedIn
    }

    const useState = (key) => ({ value: { isLoggedIn: false } })
    if (!isLoggedIn()) {
      return navigateTo('/login')
    }
  },
})
</script>
      `
    const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })
    expect(transformPlugin.transform.handler(res.content, 'component.vue?macro=true')?.code).toMatchInlineSnapshot(`
      "const __nuxt_page_meta = {
        middleware: () => {
          function isLoggedIn() {
            const auth = useState('auth')
            return auth.value.isLoggedIn
          }

          const useState = (key) => ({ value: { isLoggedIn: false } })
          if (!isLoggedIn()) {
            return navigateTo('/login')
          }
        },
      }
      export default __nuxt_page_meta"
    `)
  })

  it('should import static identifiers when a shadowed and a non-shadowed one is used', () => {
    const sfc = `
<script setup lang="ts">
import { useState } from '#app/composables/state'

definePageMeta({
  middleware: [
    () => {
      const useState = (key) => ({ value: { isLoggedIn: false } })
      const auth = useState('auth')
      if (!auth.value.isLoggedIn) {
        return navigateTo('/login')
      }
    },
    () => {
      const auth = useState('auth')
      if (!auth.value.isLoggedIn) {
        return navigateTo('/login')
      }
    }
  ]
})
</script>
      `
    const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })
    expect(transformPlugin.transform.handler(res.content, 'component.vue?macro=true')?.code).toMatchInlineSnapshot(`
      "import { useState } from '#app/composables/state'

      const __nuxt_page_meta = {
        middleware: [
          () => {
            const useState = (key) => ({ value: { isLoggedIn: false } })
            const auth = useState('auth')
            if (!auth.value.isLoggedIn) {
              return navigateTo('/login')
            }
          },
          () => {
            const auth = useState('auth')
            if (!auth.value.isLoggedIn) {
              return navigateTo('/login')
            }
          }
        ]
      }
      export default __nuxt_page_meta"
    `)
  })

  it('should import static identifiers when a shadowed and a non-shadowed one is used in the same scope', () => {
    const sfc = `
<script setup lang="ts">
import { useState } from '#app/composables/state'

definePageMeta({
  middleware: () => {
    const auth1 = useState('auth')
    const useState = (key) => ({ value: { isLoggedIn: false } })
    const auth2 = useState('auth')
    if (!auth1.value.isLoggedIn || !auth2.value.isLoggedIn) {
      return navigateTo('/login')
    }
  },
})
</script>
      `
    const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })
    expect(transformPlugin.transform.handler(res.content, 'component.vue?macro=true')?.code).toMatchInlineSnapshot(`
      "import { useState } from '#app/composables/state'

      const __nuxt_page_meta = {
        middleware: () => {
          const auth1 = useState('auth')
          const useState = (key) => ({ value: { isLoggedIn: false } })
          const auth2 = useState('auth')
          if (!auth1.value.isLoggedIn || !auth2.value.isLoggedIn) {
            return navigateTo('/login')
          }
        },
      }
      export default __nuxt_page_meta"
    `)
  })

  it('should work when keeping names = true', () => {
    const sfc = `
<script setup lang="ts">
import { foo } from './utils.ts'

const checkNum = (value) => {
  return !isNaN(Number(foo(value)))
}

function isNumber (value) {
  return value && checkNum(value)
}

definePageMeta({
  validate: ({ params }) => {
    return isNumber(params.id)
  },
})
</script>
      `
    const compiled = compileScript(parse(sfc).descriptor, { id: 'component.vue' })
    expect(transformPlugin.transform.handler(compiled.content, 'component.vue?macro=true')?.code).toMatchInlineSnapshot(`
      "import { foo } from './utils.ts'
      const checkNum = (value) => {
        return !isNaN(Number(foo(value)))
      }
      function isNumber (value) {
        return value && checkNum(value)
      }
      const __nuxt_page_meta = {
        validate: ({ params }) => {
          return isNumber(params.id)
        },
      }
      export default __nuxt_page_meta"
    `)
  })

  it('should throw for await expressions', () => {
    const sfc = `
<script setup lang="ts">
const asyncValue = await Promise.resolve('test')

definePageMeta({
  key: asyncValue,
})
</script>
      `
    const compiled = compileScript(parse(sfc).descriptor, { id: 'component.vue' })

    let wasErrorThrown = false

    try {
      transformPlugin.transform.handler(compiled.content, 'component.vue?macro=true')
    } catch (e) {
      if (e instanceof Error) {
        expect(e.message).toMatch(/await in definePageMeta/)
        wasErrorThrown = true
      }
    }

    expect(wasErrorThrown).toBe(true)
  })

  it('should only add definitions for reference identifiers', () => {
    const sfc = `
<script setup lang="ts">
const foo = 'foo'
const bar = { bar: 'bar' }.bar, baz = { baz: 'baz' }.baz, x = { foo }
const test = 'test'
const prop = 'prop'
const num = 1

const val = 'val'

const useVal = () => ({ val: 'val' })

function recursive () {
  recursive()
}

const route = useRoute()

definePageMeta({
  middleware: [
    () => {
      console.log(bar, baz)
      recursive()

      const val = useVal().val
      const obj = {
        num,
        prop: 'prop',
      }

      const c = class test {
        prop = 'prop'
        test () {}
      }

      const someFunction = () => {
        const someValue = 'someValue'
        console.log(someValue)
      }

      console.log(hoisted.value, val)
    },
  ],
  validate: (route) => {
    return route.params.id === 'test'
  }
})

// the order of a ref relative to the 'definePageMeta' call should be preserved (in contrast to a simple const)
// this tests whether the extraction handles all variables in the upper scope
const hoisted = ref('hoisted')

</script>
      `
    const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })
    expect(transformPlugin.transform.handler(res.content, 'component.vue?macro=true')?.code).toMatchInlineSnapshot(`
      "const foo = 'foo'
      const num = 1
      const bar = { bar: 'bar' }.bar, baz = { baz: 'baz' }.baz, x = { foo }
      const useVal = () => ({ val: 'val' })
      function recursive () {
        recursive()
      }
      const hoisted = ref('hoisted')
      const __nuxt_page_meta = {
        middleware: [
          () => {
            console.log(bar, baz)
            recursive()

            const val = useVal().val
            const obj = {
              num,
              prop: 'prop',
            }

            const c = class test {
              prop = 'prop'
              test () {}
            }

            const someFunction = () => {
              const someValue = 'someValue'
              console.log(someValue)
            }

            console.log(hoisted.value, val)
          },
        ],
        validate: (route) => {
          return route.params.id === 'test'
        }
      }
      export default __nuxt_page_meta"
    `)
  })

  describe('strip extracted metadata', () => {
    it.each([
      {
        input: `
<script setup>
definePageMeta({
  foo :'foo',
  extracted: 'value', })
</script>
      `,
      },
      {
        input: `
<script setup>
definePageMeta({
  extracted: 'value',foo :'foo'})
</script>
      `,
      },
      {
        input: `
<script setup>
definePageMeta({
  extracted: 'value',
})
</script>
      `,
      },
      {
        input: `
<script setup>
definePageMeta({
  extracted: 'value'
})
</script>
      `,
      },
    ])(`should strip extracted metadata from the script block`, ({ input }) => {
      const res = compileScript(parse(input).descriptor, { id: 'component.vue' })
      const result = transformPlugin.transform.handler(res.content, 'component.vue?macro=true')?.code
      expect.soft(result).not.contain('extracted')
      if (input.includes('foo')) {
        expect.soft(result).contain('foo')
      }
      // verify for valid JS
      expect(() => toAst(result!, { ecmaVersion: 'latest', sourceType: 'module' })).not.toThrow()
    })
  })
})
</file>

<file path="packages/nuxt/test/pages.test.ts">
import type { TestAPI } from 'vitest'
import { describe, expect, it, vi } from 'vitest'
import type { RouteLocationNormalizedLoaded } from 'vue-router'
import { augmentPages, generateRoutesFromFiles, normalizeRoutes, pathToNitroGlob } from '../src/pages/utils.ts'
import type { RouterViewSlotProps } from '../src/pages/runtime/utils.ts'
import { generateRouteKey } from '../src/pages/runtime/utils.ts'
import type { NuxtPage } from 'nuxt/schema'

describe('pages:generateRoutesFromFiles', () => {
  vi.mock('knitwork', async (original) => {
    return {
      ...(await original<typeof import('knitwork')>()),
      genArrayFromRaw: (val: any) => val,
      genSafeVariableName: (..._args: string[]) => {
        return 'mock'
      },
    }
  })

  const normalizedResults: Record<string, any> = {}
  const normalizedOverrideMetaResults: Record<string, any> = {}

  const enUSComparator = new Intl.Collator('en-US')
  function sortRoutes (routes: NuxtPage[]) {
    for (const route of routes) {
      route.children &&= sortRoutes([...route.children])
    }
    return [...routes].sort((a, b) => enUSComparator.compare(b.path, a.path))
  }

  for (const test of pageTests) {
    const _it = test.it || it
    _it(test.description, async () => {
      let result
      if (test.files) {
        const vfs = Object.fromEntries(
          test.files.map(file => [file.path, 'template' in file ? file.template : '']),
        ) as Record<string, string>

        try {
          const files = test.files.map(file => ({
            shouldUseServerComponents: true,
            absolutePath: file.path,
            relativePath: file.path.replace(/^(?:pages|layer\/pages)\//, ''),
          })).sort((a, b) => enUSComparator.compare(a.relativePath, b.relativePath))

          result = generateRoutesFromFiles(files).map((route, index) => {
            return {
              ...route,
              meta: test.files![index]!.meta ?? route.meta,
            }
          })

          await augmentPages(result, vfs, { extraExtractionKeys: new Set(['extracted']) })
        } catch (error: any) {
          expect(error.message).toEqual(test.error)
        }
      } else {
        result = test.output ?? []
      }

      if (result) {
        expect.soft(sortRoutes(result)).toEqual(test.output ? sortRoutes(test.output) : undefined)

        normalizedResults[test.description] = normalizeRoutes(result, new Set(), {
          clientComponentRuntime: '<client-component-runtime>',
          serverComponentRuntime: '<server-component-runtime>',
          overrideMeta: false,
        }).routes

        normalizedOverrideMetaResults[test.description] = normalizeRoutes(result, new Set(), {
          clientComponentRuntime: '<client-component-runtime>',
          serverComponentRuntime: '<server-component-runtime>',
          overrideMeta: true,
        }).routes
      }
    })
  }

  it('should consistently normalize routes', async () => {
    await expect(normalizedResults).toMatchFileSnapshot('./__snapshots__/pages-override-meta-disabled.test.ts.snap')
  })

  it('should consistently normalize routes when overriding meta', async () => {
    await expect(normalizedOverrideMetaResults).toMatchFileSnapshot('./__snapshots__/pages-override-meta-enabled.test.ts.snap')
  })
})

describe('pages:generateRouteKey', () => {
  const defaultComponent = { type: {} }
  const getRouteProps = (matchedRoute = {}) => ({
    Component: defaultComponent,
    route: {
      meta: { key: 'route-meta-key' },
      params: {
        id: 'foo',
        optional: 'bar',
        array: ['a', 'b'],
      },
      matched: [
        {
          components: { default: {} },
          meta: { key: 'other-meta-key' },
        },
        {
          components: { default: defaultComponent.type },
          meta: { key: 'matched-meta-key' },
          ...matchedRoute,
        },
      ],
    },
  } as unknown as RouterViewSlotProps)

  const tests: Array<{
    description: string
    route: RouterViewSlotProps
    override?: string | ((route: RouteLocationNormalizedLoaded) => string)
    output?: string | false
    it?: TestAPI
  }> = [
    { description: 'should handle overrides', override: 'key', route: getRouteProps(), output: 'key' },
    { description: 'should handle overrides', override: route => route.meta.key as string, route: getRouteProps(), output: 'route-meta-key' },
    {
      description: 'should handle overrides',
      // @ts-expect-error testing behaviour with invalid prop
      override: false,
      route: getRouteProps(),
      output: false,
    },
    {
      description: 'should key dynamic routes without keys',
      route: getRouteProps({
        path: '/test/:id',
        meta: {},
      }),
      output: '/test/foo',
    },
    {
      description: 'should key dynamic routes without keys',
      route: getRouteProps({
        path: '/test/:id(\\d+)',
        meta: {},
      }),
      output: '/test/foo',
    },
    {
      description: 'should key dynamic routes with optional params',
      route: getRouteProps({
        path: '/test/:optional?',
        meta: {},
      }),
      output: '/test/bar',
    },
    {
      description: 'should key dynamic routes with optional params',
      route: getRouteProps({
        path: '/test/:optional(\\d+)?',
        meta: {},
      }),
      output: '/test/bar',
    },
    {
      description: 'should key dynamic routes with optional params',
      route: getRouteProps({
        path: '/test/:undefined(\\d+)?',
        meta: {},
      }),
      output: '/test/',
    },
    {
      description: 'should key dynamic routes with array params',
      route: getRouteProps({
        path: '/:array+',
        meta: {},
      }),
      output: '/a,b',
    },
    {
      description: 'should key dynamic routes with array params',
      route: getRouteProps({
        path: '/test/:array*',
        meta: {},
      }),
      output: '/test/a,b',
    },
    {
      description: 'should key dynamic routes with array params',
      route: getRouteProps({
        path: '/test/:other*',
        meta: {},
      }),
      output: '/test/',
    },
  ]

  for (const test of tests) {
    const _it = test.it || it
    _it(test.description, () => {
      expect(generateRouteKey(test.route, test.override)).to.deep.equal(test.output)
    })
  }
})

const pathToNitroGlobTests = {
  '/': '/',
  '/:id': '/**',
  '/:id()': '/**',
  '/:id?': '/**',
  '/some-:id?': '/**',
  '/other/some-:id?': '/other/**',
  '/other/some-:id()-more': '/other/**',
  '/other/nested': '/other/nested',
}

describe('pages:pathToNitroGlob', () => {
  it.each(Object.entries(pathToNitroGlobTests))('should convert %s to %s', (path, expected) => {
    expect(pathToNitroGlob(path)).to.equal(expected)
  })
})

describe('page:extends', () => {
  const DYNAMIC_META_KEY = '__nuxt_dynamic_meta_key' as const
  it('should preserve distinct metadata for multiple routes referencing the same file', async () => {
    const files: NuxtPage[] = [
      { path: 'home', file: `pages/index.vue` },
      { path: 'home1', file: `pages/index.vue`, meta: { test: true } },
      { path: 'home2', file: `pages/index.vue`, meta: { snap: true } },
    ]
    const vfs = Object.fromEntries(
      files.map(file => [file.file, `
            <script setup lang="ts">
            definePageMeta({
              hello: 'world'
            })
            </script>
          `]),
    ) as Record<string, string>
    await augmentPages(files, vfs)
    expect(files).toEqual([
      {
        path: 'home',
        file: `pages/index.vue`,
        meta: { [DYNAMIC_META_KEY]: new Set(['meta']) },
      },
      {
        path: 'home1',
        file: `pages/index.vue`,
        meta: { [DYNAMIC_META_KEY]: new Set(['meta']), test: true },
      },
      {
        path: 'home2',
        file: `pages/index.vue`,
        meta: { [DYNAMIC_META_KEY]: new Set(['meta']), snap: true },
      },
    ])
  })
})

const pagesDir = 'pages'
const layerDir = 'layer/pages'
const DYNAMIC_META_KEY = '__nuxt_dynamic_meta_key' as const

export const pageTests: Array<{
  description: string
  files?: Array<{ path: string, template?: string, meta?: Record<string, any> }>
  output?: NuxtPage[]
  it?: TestAPI
  normalized?: Record<string, any>[]
  error?: string
}> = [
  {
    description: 'should generate correct routes for index pages',
    files: [
      { path: `${pagesDir}/index.vue` },
      { path: `${pagesDir}/parent/index.vue` },
      { path: `${pagesDir}/parent/child/index.vue` },
    ],
    output: [
      {
        name: 'index',
        path: '/',
        file: `${pagesDir}/index.vue`,
        children: [],
      },
      {
        name: 'parent',
        path: '/parent',
        file: `${pagesDir}/parent/index.vue`,
        children: [],
      },
      {
        name: 'parent-child',
        path: '/parent/child',
        file: `${pagesDir}/parent/child/index.vue`,
        children: [],
      },
    ],
  },
  {
    description: 'should generate correct routes for parent/child',
    files: [
      { path: `${pagesDir}/parent.vue` },
      { path: `${pagesDir}/parent/child.vue` },
    ],
    output: [
      {
        name: 'parent',
        path: '/parent',
        file: `${pagesDir}/parent.vue`,
        children: [
          {
            name: 'parent-child',
            path: 'child',
            file: `${pagesDir}/parent/child.vue`,
            children: [],
          },
        ],
      },
    ],
  },
  {
    description: 'should not generate colliding route names when hyphens are in file name',
    files: [
      { path: `${pagesDir}/parent/[child].vue` },
      { path: `${pagesDir}/parent-[child].vue` },
    ],
    output: [
      {
        name: 'parent-child',
        path: '/parent/:child()',
        file: `${pagesDir}/parent/[child].vue`,
        children: [],
      },
      {
        name: 'parent-child',
        path: '/parent-:child()',
        file: `${pagesDir}/parent-[child].vue`,
        children: [],
      },
    ],
  },
  {
    description: 'should generate correct id for catchall (order 1)',
    files: [
      { path: `${pagesDir}/[...stories].vue` },
      { path: `${pagesDir}/stories/[id].vue` },
    ],
    output: [
      {
        name: 'stories',
        path: '/:stories(.*)*',
        file: `${pagesDir}/[...stories].vue`,
        children: [],
      },
      {
        name: 'stories-id',
        path: '/stories/:id()',
        file: `${pagesDir}/stories/[id].vue`,
        children: [],
      },
    ],
  },
  {
    description: 'should generate correct id for catchall (order 2)',
    files: [
      { path: `${pagesDir}/stories/[id].vue` },
      { path: `${pagesDir}/[...stories].vue` },
    ],
    output: [
      {
        name: 'stories-id',
        path: '/stories/:id()',
        file: `${pagesDir}/stories/[id].vue`,
        children: [],
      },
      {
        name: 'stories',
        path: '/:stories(.*)*',
        file: `${pagesDir}/[...stories].vue`,
        children: [],
      },
    ],
  },
  {
    description: 'should generate correct route for snake_case file',
    files: [
      { path: `${pagesDir}/snake_case.vue` },
    ],
    output: [
      {
        name: 'snake_case',
        path: '/snake_case',
        file: `${pagesDir}/snake_case.vue`,
        children: [],
      },
    ],
  },
  {
    description: 'should generate correct route for kebab-case file',
    files: [{ path: `${pagesDir}/kebab-case.vue` }],
    output: [
      {
        name: 'kebab-case',
        path: '/kebab-case',
        file: `${pagesDir}/kebab-case.vue`,
        children: [],
      },
    ],
  },
  {
    description: 'should generate correct dynamic routes',
    files: [
      { path: `${pagesDir}/index.vue` },
      { path: `${pagesDir}/[slug].vue` },
      { path: `${pagesDir}/[[foo]]` },
      { path: `${pagesDir}/[[foo]]/index.vue` },
      { path: `${pagesDir}/optional/[[opt]].vue` },
      { path: `${pagesDir}/optional/prefix-[[opt]].vue` },
      { path: `${pagesDir}/optional/[[opt]]-postfix.vue` },
      { path: `${pagesDir}/optional/prefix-[[opt]]-postfix.vue` },
      { path: `${pagesDir}/[bar]/index.vue` },
      { path: `${pagesDir}/nonopt/[slug].vue` },
      { path: `${pagesDir}/opt/[[slug]].vue` },
      { path: `${pagesDir}/[[sub]]/route-[slug].vue` },
    ],
    output: [
      {
        children: [
          {

            name: 'foo',
            path: '',
            file: `${pagesDir}/[[foo]]/index.vue`,
            children: [],
          },
        ],
        file: `${pagesDir}/[[foo]]`,
        path: '/:foo?',
      },
      {
        name: 'index',
        path: '/',
        file: `${pagesDir}/index.vue`,
        children: [],
      },
      {
        children: [],
        name: 'slug',
        file: `${pagesDir}/[slug].vue`,
        path: '/:slug()',
      },
      {
        children: [],
        name: 'bar',
        file: `${pagesDir}/[bar]/index.vue`,
        path: '/:bar()',
      },
      {
        name: 'opt-slug',
        path: '/opt/:slug?',
        file: `${pagesDir}/opt/[[slug]].vue`,
        children: [],
      },
      {
        name: 'nonopt-slug',
        path: '/nonopt/:slug()',
        file: `${pagesDir}/nonopt/[slug].vue`,
        children: [],
      },
      {
        children: [],
        path: '/optional/:opt?',
        name: 'optional-opt',
        file: `${pagesDir}/optional/[[opt]].vue`,
      },
      {
        name: 'sub-route-slug',
        path: '/:sub?/route-:slug()',
        file: `${pagesDir}/[[sub]]/route-[slug].vue`,
        children: [],
      },
      {
        children: [],
        path: '/optional/prefix-:opt?',
        name: 'optional-prefix-opt',
        file: `${pagesDir}/optional/prefix-[[opt]].vue`,
      },

      {
        children: [],
        path: '/optional/:opt?-postfix',
        name: 'optional-opt-postfix',
        file: `${pagesDir}/optional/[[opt]]-postfix.vue`,
      },
      {
        children: [],
        path: '/optional/prefix-:opt?-postfix',
        name: 'optional-prefix-opt-postfix',
        file: `${pagesDir}/optional/prefix-[[opt]]-postfix.vue`,
      },
    ],
  },
  {
    description: 'should generate correct catch-all route',
    files: [{ path: `${pagesDir}/[...slug].vue` }, { path: `${pagesDir}/index.vue` }, { path: `${pagesDir}/[...slug]/[id].vue` }],
    output: [
      {
        name: 'index',
        path: '/',
        file: `${pagesDir}/index.vue`,
        children: [],
      },
      {
        name: 'slug',
        path: '/:slug(.*)*',
        file: `${pagesDir}/[...slug].vue`,
        children: [
          {
            name: 'slug-id',
            path: ':id()',
            file: `${pagesDir}/[...slug]/[id].vue`,
            children: [],
          }],
      },
    ],
  },
  {
    description: 'should throw unfinished param error for dynamic route',
    files: [{ path: `${pagesDir}/[slug.vue` }],
    error: 'Unfinished param "slug"',
  },
  {
    description: 'should throw empty param error for dynamic route',
    files: [
      { path: `${pagesDir}/[].vue` },
    ],
    error: 'Empty param',
  },
  {
    description: 'should only allow "_" & "." as special character for dynamic route',
    files: [
      { path: `${pagesDir}/[a1_1a].vue` },
      { path: `${pagesDir}/[b2.2b].vue` },
      { path: `${pagesDir}/[b2]_[2b].vue` },
      { path: `${pagesDir}/[[c3@3c]].vue` },
      { path: `${pagesDir}/[[d4-4d]].vue` },
    ],
    output: [
      {
        name: 'a1_1a',
        path: '/:a1_1a()',
        file: `${pagesDir}/[a1_1a].vue`,
        children: [],
      },
      {
        name: 'b2.2b',
        path: '/:b2.2b()',
        file: `${pagesDir}/[b2.2b].vue`,
        children: [],
      },
      {
        name: 'b2_2b',
        path: '/:b2()_:2b()',
        file: `${pagesDir}/[b2]_[2b].vue`,
        children: [],
      },
      {
        name: 'c33c',
        path: '/:c33c?',
        file: `${pagesDir}/[[c3@3c]].vue`,
        children: [],
      },
      {
        name: 'd44d',
        path: '/:d44d?',
        file: `${pagesDir}/[[d4-4d]].vue`,
        children: [],
      },
    ],
  },
  {
    description: 'should properly override route name if definePageMeta name override is defined.',
    files: [
      {
        path: `${pagesDir}/index.vue`,
        template: `
            <script setup lang="ts">
            definePageMeta({
              name: 'home'
            })
            </script>
          `,
      },
    ],
    output: [
      {
        name: 'home',
        path: '/',
        file: `${pagesDir}/index.vue`,
        children: [],
      },
    ],
  },
  {
    description: 'should allow pages with `:` in their path',
    files: [
      { path: `${pagesDir}/test:name.vue` },
    ],
    output: [
      {
        name: 'test:name',
        path: '/test\\:name',
        file: `${pagesDir}/test:name.vue`,
        children: [],
      },
    ],
  },
  {
    description: 'should handle unicode and special characters in page paths',
    files: [
      { path: `${pagesDir}/测试.vue` },
      { path: `${pagesDir}/文档.vue` },
      { path: `${pagesDir}/文档/介绍.vue` },
      { path: `${pagesDir}/خاص:جديد.vue` },
    ],
    output: [
      { name: '测试', path: '/测试', file: `${pagesDir}/测试.vue`, children: [] },
      { name: '文档', path: '/文档', file: `${pagesDir}/文档.vue`, children: [
        { name: '文档-介绍', path: '介绍', file: `${pagesDir}/文档/介绍.vue`, children: [] },
      ] },
      { name: 'خاص:جديد', path: '/خاص\\:جديد', file: `${pagesDir}/خاص:جديد.vue`, children: [] },
    ],
  },
  {
    description: 'should escape special chars in static paths',
    files: [
      { path: `${pagesDir}/a&b.vue` },
      { path: `${pagesDir}/a\\b.vue` },
    ],
    output: [
      { name: 'a&b', path: '/a&b', file: `${pagesDir}/a&b.vue`, children: [] },
      { name: 'a\\b', path: '/a\\\\b', file: `${pagesDir}/a\\b.vue`, children: [] },
    ],
  },
  {
    description: 'should not merge required param as a child of optional param',
    files: [
      { path: `${pagesDir}/[[foo]].vue` },
      { path: `${pagesDir}/[foo].vue` },
    ],
    output: [
      {
        name: 'foo',
        path: '/:foo()',
        file: `${pagesDir}/[foo].vue`,
        children: [],
      },
      {
        name: 'foo',
        path: '/:foo?',
        file: `${pagesDir}/[[foo]].vue`,
        children: [
        ],
      },
    ],
  },
  {
    description: 'should correctly merge nested routes',
    files: [
      { path: `${pagesDir}/param.vue` },
      { path: `${layerDir}/param/index.vue` },
      { path: `${pagesDir}/param/index/index.vue` },
      { path: `${layerDir}/param/index/sibling.vue` },
      { path: `${pagesDir}/wrapper-expose/other.vue` },
      { path: `${layerDir}/wrapper-expose/other/index.vue` },
      { path: `${pagesDir}/wrapper-expose/other/sibling.vue` },
      { path: `${pagesDir}/param/sibling.vue` },
    ],
    output: [
      {
        children: [
          {
            children: [
              {
                children: [],
                file: `${pagesDir}/param/index/index.vue`,
                name: 'param-index',
                path: '',
              },
              {
                children: [],
                file: `${layerDir}/param/index/sibling.vue`,
                name: 'param-index-sibling',
                path: 'sibling',
              },
            ],
            file: `${layerDir}/param/index.vue`,
            path: '',
          },
          {
            children: [],
            file: `${pagesDir}/param/sibling.vue`,
            name: 'param-sibling',
            path: 'sibling',
          },
        ],
        file: `${pagesDir}/param.vue`,
        path: '/param',
      },
      {
        children: [
          {
            children: [],
            file: `${layerDir}/wrapper-expose/other/index.vue`,
            name: 'wrapper-expose-other',
            path: '',
          },
          {
            children: [],
            file: `${pagesDir}/wrapper-expose/other/sibling.vue`,
            name: 'wrapper-expose-other-sibling',
            path: 'sibling',
          },
        ],
        file: `${pagesDir}/wrapper-expose/other.vue`,
        path: '/wrapper-expose/other',
      },
    ],
  },
  {
    description: 'should handle trailing slashes with index routes',
    files: [
      { path: `${pagesDir}/index/index.vue` },
      { path: `${pagesDir}/index/index/all.vue` },
    ],
    output: [
      {
        children: [
          {
            children: [],
            file: `${pagesDir}/index/index/all.vue`,
            name: 'index-index-all',
            path: 'all',
          },
        ],
        file: `${pagesDir}/index/index.vue`,
        name: 'index',
        path: '/',
      },
    ],
  },
  {
    description: 'should generate correct routes for nested pages',
    files: [
      { path: `${pagesDir}/page1/index.vue` },
      { path: `${pagesDir}/page1/[id].vue` },
      { path: `${pagesDir}/page1.vue` },
    ],
    output: [
      {
        children: [
          {
            children: [],
            file: `${pagesDir}/page1/[id].vue`,
            name: 'page1-id',
            path: ':id()',
          },
          {
            children: [],
            file: `${pagesDir}/page1/index.vue`,
            name: 'page1',
            path: '',
          },
        ],
        file: `${pagesDir}/page1.vue`,
        path: '/page1',
      },
    ],
  },
  {
    description: 'should use fallbacks when normalized with `overrideMeta: true`',
    files: [
      {
        path: `${pagesDir}/index.vue`,
        template: `
            <script setup lang="ts">
            const routeName = ref('home')
            const routeAliases = ref(['sweet-home'])
            definePageMeta({
              name: routeName.value,
              alias: routeAliases.value,
              hello: 'world',
              redirect: () => '/'
            })
            </script>
          `,
      },
    ],
    output: [
      {
        name: 'index',
        path: '/',
        file: `${pagesDir}/index.vue`,
        meta: { [DYNAMIC_META_KEY]: new Set(['name', 'alias', 'redirect', 'meta']) },
        children: [],
      },
    ],
  },
  {
    description: 'should extract serializable values and override fallback when normalized with `overrideMeta: true`',
    files: [
      {
        path: `${pagesDir}/index.vue`,
        template: `
            <script setup lang="ts">
            definePageMeta({
              name: 'home',
              alias: ['sweet-home'],
              redirect: '/',
              hello: 'world'
            })
            </script>
          `,
      },
    ],
    output: [
      {
        name: 'home',
        path: '/',
        file: `${pagesDir}/index.vue`,
        alias: ['sweet-home'],
        redirect: '/',
        children: [],
        meta: { [DYNAMIC_META_KEY]: new Set(['meta']) },
      },
    ],
  },
  {
    description: 'route without file',
    output: [
      {
        name: 'home',
        path: '/',
        alias: ['sweet-home'],
        meta: { hello: 'world' },
      },
    ],
  },
  {
    description: 'pushed route, skips generation from file',
    output: [
      {
        name: 'pushed-route',
        path: '/',
        alias: ['pushed-route-alias'],
        meta: { someMetaData: true },
        file: `${pagesDir}/route-file.vue`,
      },
    ],
  },
  {
    description: 'route.meta generated from file',
    files: [
      {
        path: `${pagesDir}/page-with-meta.vue`,
        meta: {
          test: 1,
        },
      },
    ],
    output: [
      {
        name: 'page-with-meta',
        path: '/page-with-meta',
        file: `${pagesDir}/page-with-meta.vue`,
        children: [],
        meta: { test: 1 },
      },
    ],
  },
  {
    description: 'should use more performant regexp when catchall is used in middle of path',
    files: [
      {
        path: `${pagesDir}/[...id]/suffix.vue`,
      },
      {
        path: `${pagesDir}/[...id]/index.vue`,
      },
    ],
    output: [
      {
        name: 'id',
        meta: undefined,
        path: '/:id(.*)*',
        file: `${pagesDir}/[...id]/index.vue`,
        children: [],
      },
      {
        name: 'id-suffix',
        meta: undefined,
        path: '/:id([^/]*)*/suffix',
        file: `${pagesDir}/[...id]/suffix.vue`,
        children: [],
      },
    ],
  },
  {
    description: 'should merge route.meta with meta from file',
    files: [
      {
        path: `${pagesDir}/page-with-meta.vue`,
        meta: {
          test: 1,
          extracted: { foo: 'foo' },
        },
        template: `
            <script setup lang="ts">
            definePageMeta({
              hello: 'world',
              extracted: { bar: 'bar' },
            })
            </script>
          `,
      },
    ],
    output: [
      {
        name: 'page-with-meta',
        path: '/page-with-meta',
        file: `${pagesDir}/page-with-meta.vue`,
        children: [],
        meta: { [DYNAMIC_META_KEY]: new Set(['meta']), test: 1, extracted: { foo: 'foo', bar: 'bar' } },
      },
    ],
  },
  {
    description: 'route.meta props generate by file',
    files: [
      {
        path: `${pagesDir}/page-with-props.vue`,
        template: `
            <script setup lang="ts">
            definePageMeta({
              props: true
            })
            </script>
          `,
      },
    ],
    output: [
      {
        name: 'page-with-props',
        path: '/page-with-props',
        file: `${pagesDir}/page-with-props.vue`,
        children: [],
        props: true,
      },
    ],
  },
  {
    description: 'should handle route groups',
    files: [
      { path: `${pagesDir}/(foo)/index.vue` },
      { path: `${pagesDir}/(foo)/about.vue` },
      { path: `${pagesDir}/(bar)/about/index.vue` },
      { path: `${pagesDir}/(bar)/about/(foo)/index.vue` },
    ],
    output: [
      {
        name: 'index',
        path: '/',
        file: `${pagesDir}/(foo)/index.vue`,
        meta: { groups: ['foo'] },
        children: [],
      },
      {
        path: '/about',
        file: `${pagesDir}/(foo)/about.vue`,
        meta: { groups: ['foo'] },
        children: [
          {
            path: '',
            file: `${pagesDir}/(bar)/about/index.vue`,
            meta: { groups: ['bar'] },
            children: [
              {
                name: 'about',
                path: '',
                file: `${pagesDir}/(bar)/about/(foo)/index.vue`,
                meta: { groups: ['bar', 'foo'] },
                children: [],
              },
            ],
          },
        ],
      },
    ],
  },
]
</file>

<file path="packages/nuxt/test/plugin-metadata.test.ts">
import { describe, expect, it, vi } from 'vitest'

import { RemovePluginMetadataPlugin, extractMetadata } from '../src/core/plugins/plugin-metadata.ts'
import { checkForCircularDependencies } from '../src/core/app.ts'

describe('plugin-metadata', () => {
  const properties = Object.entries({
    name: 'test',
    enforce: 'post',
    hooks: { 'app:mounted': () => {} },
    setup: () => { return { provide: { jsx: '[JSX]' } } },
    order: 1,
  })
  it.each(properties)('should extract metadata from object-syntax plugins', (k, value) => {
    const obj = [...properties.filter(([key]) => key !== k), [k, value]]

    const meta = extractMetadata([
      'export default defineNuxtPlugin({',
      ...obj.map(([key, value]) => `${key}: ${typeof value === 'function' ? value.toString().replace('"[JSX]"', '() => <span>JSX</span>') : JSON.stringify(value)},`),
      '})',
    ].join('\n'), 'tsx')

    expect(meta).toEqual({
      'name': 'test',
      'order': 1,
    })
  })

  const transformPlugin: any = RemovePluginMetadataPlugin({
    options: { sourcemap: { client: true } },
    apps: { default: { plugins: [{ src: 'my-plugin.mjs', order: 10 }] } },
  } as any).raw({}, {} as any)

  it('should overwrite invalid plugins', () => {
    const invalidPlugins = [
      'export const plugin = {}',
    ]
    for (const plugin of invalidPlugins) {
      expect(transformPlugin.transform(plugin, 'my-plugin.mjs').code).toBe('export default () => {}')
    }
  })

  it('should remove order/name properties from object-syntax plugins', () => {
    const plugin = `
      export default defineNuxtPlugin({
        name: 'test',
        enforce: 'post',
        setup: () => {},
      }, { order: 10, name: test })
    `
    expect(transformPlugin.transform(plugin, 'my-plugin.mjs').code).toMatchInlineSnapshot(`
      "
            export default defineNuxtPlugin({
              setup: () => {},
            }, { })
          "
    `)
  })
})

describe('plugin sanity checking', () => {
  it('non-existent depends are warned', () => {
    vi.spyOn(console, 'error')
    checkForCircularDependencies([
      {
        name: 'A',
        src: '',
      },
      {
        name: 'B',
        dependsOn: ['D'],
        src: '',
      },
      {
        name: 'C',
        src: '',
      },
    ])
    expect(console.error).toBeCalledWith('Plugin `B` depends on `D` but they are not registered.')
    vi.restoreAllMocks()
  })

  it('circular dependencies are warned', () => {
    vi.spyOn(console, 'error')
    checkForCircularDependencies([
      {
        name: 'A',
        dependsOn: ['B'],
        src: '',
      },
      {
        name: 'B',
        dependsOn: ['C'],
        src: '',
      },
      {
        name: 'C',
        dependsOn: ['A'],
        src: '',
      },
    ])
    expect(console.error).toBeCalledWith('Circular dependency detected in plugins: A -> B -> C -> A')
    expect(console.error).toBeCalledWith('Circular dependency detected in plugins: B -> C -> A -> B')
    expect(console.error).toBeCalledWith('Circular dependency detected in plugins: C -> A -> B -> C')
    vi.restoreAllMocks()
  })
})
</file>

<file path="packages/nuxt/test/plugin-utils.test.ts">
import { isValidIslandKey } from '#app/plugins/utils'
import { describe, expect, it } from 'vitest'
import { hash } from 'ohash'
import { randomUUID } from 'node:crypto'

describe('isValidIslandKey util', () => {
  it('should accept valid island keys', () => {
    // Valid keys following the componentName_hashId pattern
    expect(isValidIslandKey('MyComponent_abc123')).toBe(true)
    expect(isValidIslandKey('UserCard_def456')).toBe(true)
    expect(isValidIslandKey('NavBar_xyz789')).toBe(true)
    expect(isValidIslandKey('A_1')).toBe(true)
    expect(isValidIslandKey('Component123_hash456')).toBe(true)
    expect(isValidIslandKey('my-component_hash123')).toBe(true)
    expect(isValidIslandKey('Component-Name_hash123')).toBe(true)
    const sampleHash = hash({ props: randomUUID() }).replace(/[-_]/g, '')
    expect(isValidIslandKey('ComponentName_' + sampleHash)).toBe(true)
  })

  it('should reject invalid island keys', () => {
    // Empty or null/undefined
    expect(isValidIslandKey('')).toBe(false)
    expect(isValidIslandKey(null as any)).toBe(false)
    expect(isValidIslandKey(undefined as any)).toBe(false)

    // Missing underscore separator
    expect(isValidIslandKey('ComponentName')).toBe(false)
    expect(isValidIslandKey('hash123')).toBe(false)

    // Invalid characters
    expect(isValidIslandKey('Component/Name_hash123')).toBe(false)
    expect(isValidIslandKey('Component\\Name_hash123')).toBe(false)
    expect(isValidIslandKey('Component..Name_hash123')).toBe(false)
    expect(isValidIslandKey('Component Name_hash123')).toBe(false)
    expect(isValidIslandKey('Component<script>_hash123')).toBe(false)
    expect(isValidIslandKey('Component"_hash123')).toBe(false)
    expect(isValidIslandKey('Component\'_hash123')).toBe(false)

    // Starting with invalid characters
    expect(isValidIslandKey('123Component_hash123')).toBe(false)
    expect(isValidIslandKey('_Component_hash123')).toBe(false)
    expect(isValidIslandKey('-Component_hash123')).toBe(false)

    // Path traversal attempts
    expect(isValidIslandKey('../Component_hash123')).toBe(false)
    expect(isValidIslandKey('../../Component_hash123')).toBe(false)
    expect(isValidIslandKey('Component_../hash123')).toBe(false)
    expect(isValidIslandKey('Component_../../hash123')).toBe(false)

    // URL/protocol attempts
    expect(isValidIslandKey('http://evil.com_hash123')).toBe(false)
    expect(isValidIslandKey('file:///etc/passwd_hash123')).toBe(false)
    expect(isValidIslandKey('Component_http://evil.com')).toBe(false)

    const longKey = 'A'.repeat(95) + '_' + 'B'.repeat(10)
    expect(isValidIslandKey(longKey)).toBe(false)

    expect(isValidIslandKey('Component_Name_hash123')).toBe(false)
    expect(isValidIslandKey('Component__hash123')).toBe(false)
  })

  it('should handle edge cases', () => {
    // Maximum allowed length (100 chars)
    const maxLengthKey = 'A'.repeat(94) + '_' + 'B'.repeat(5) // 100 chars total
    expect(isValidIslandKey(maxLengthKey)).toBe(true)

    // Just over maximum length
    const overLengthKey = 'A'.repeat(95) + '_' + 'B'.repeat(6) // 102 chars total
    expect(isValidIslandKey(overLengthKey)).toBe(false)

    // Minimum valid length
    expect(isValidIslandKey('A_1')).toBe(true)

    // Single character component name with long hash
    expect(isValidIslandKey('A_' + 'B'.repeat(97))).toBe(true) // 100 chars total
  })

  it('should reject non-string inputs', () => {
    expect(isValidIslandKey(123 as any)).toBe(false)
    expect(isValidIslandKey({} as any)).toBe(false)
    expect(isValidIslandKey([] as any)).toBe(false)
    expect(isValidIslandKey(true as any)).toBe(false)
    expect(isValidIslandKey(Symbol('test') as any)).toBe(false)
  })
})
</file>

<file path="packages/nuxt/test/prehydrate.test.ts">
import { describe, expect, it } from 'vitest'

import { PrehydrateTransformPlugin } from '../src/core/plugins/prehydrate.ts'

describe('prehydrate', () => {
  const transformPlugin = PrehydrateTransformPlugin().raw({}, {} as any) as { transform: { handler: (code: string, id: string) => { code: string } | null } }

  it('should extract and minify code in onPrehydrate', async () => {
    const snippet = `
onPrehydrate(() => {
  console.log('hello world')
})
    `
    const snippet2 = `
export default {
  async setup () {
    onPrehydrate(() => {
      console.log('hello world')
    })
  }
}
    `

    for (const item of [snippet, snippet2]) {
      const { code } = await transformPlugin.transform.handler(item, 'test.ts') ?? {}
      expect(code).toContain(`onPrehydrate("(()=>{console.log(\`hello world\`)})")`)
    }
  })

  it('should add hash if required', async () => {
    const snippet = `
onPrehydrate((attr) => {
  console.log('hello world')
})
    `

    const { code } = await transformPlugin.transform.handler(snippet, 'test.ts') ?? {}
    expect(code?.trim()).toMatchInlineSnapshot(`"onPrehydrate("(e=>{console.log(\`hello world\`)})", "LPWqofgLVF")"`)
  })
})
</file>

<file path="packages/nuxt/test/render.bench.ts">
import { fileURLToPath } from 'node:url'
import { rm } from 'node:fs/promises'
import { beforeAll, bench, describe, expect } from 'vitest'
import { join } from 'pathe'
import { x } from 'tinyexec'
import { build, loadNuxt } from 'nuxt'
import { findWorkspaceDir } from 'pkg-types'

const repoRoot = await findWorkspaceDir()
const basicTestFixtureDir = join(repoRoot, 'test/fixtures/basic')
const outputDir = join(repoRoot, 'node_modules/.test/render')

describe.todo('render', () => {
  beforeAll(async () => {
    await rm(join(basicTestFixtureDir, 'node_modules/render/.nuxt'), { recursive: true, force: true })
    const nuxt = await loadNuxt({
      cwd: basicTestFixtureDir,
      ready: true,
      overrides: {
        buildDir: join(basicTestFixtureDir, 'node_modules/render/.nuxt'),
        nitro: {
          output: {
            dir: outputDir,
          },
        },
        sourcemap: false,
      },
    })
    nuxt.hook('nitro:build:before', (nitro) => {
      nitro.options.entry = fileURLToPath(new URL('./nitro/render-index', import.meta.url))
    })
    await build(nuxt)
    await nuxt.close()
  }, 200_000)

  bench('index route in the basic test fixture', async () => {
    const res = await x('node', [join(outputDir, 'server/index.mjs')], {
      nodeOptions: { stdio: 'pipe' },
    })
    expect(res.stdout).toContain('Hello Nuxt 3!')
  })
})
</file>

<file path="packages/nuxt/test/route-injection.test.ts">
import { describe, expect, it } from 'vitest'
import { compileScript, compileTemplate, parse } from '@vue/compiler-sfc'
import type { Nuxt } from '@nuxt/schema'
import { RouteInjectionPlugin } from '../src/pages/plugins/route-injection.ts'

describe('route-injection:transform', () => {
  const injectionPlugin = RouteInjectionPlugin({ options: { sourcemap: { client: false, server: false } } } as Nuxt).raw({}, { framework: 'rollup' }) as { transform: { handler: (code: string, id: string) => { code: string } | null } }

  const transform = async (source: string) => {
    const result = await injectionPlugin.transform.handler.call({ error: null, warn: null } as any, source, 'test.vue')
    const code: string = typeof result === 'string' ? result : result!.code
    let depth = 0
    return code.split('\n').map((l) => {
      l = l.trim()
      if (l.match(/^[}\]]/)) { depth-- }
      const res = ''.padStart(depth * 2, ' ') + l
      if (l.match(/[{[]$/)) { depth++ }
      return res
    }).join('\n')
  }

  it('should correctly inject route in template', async () => {
    const sfc = `<template>{{ $route.path }}</template>`
    const res = compileTemplate({
      filename: 'test.vue',
      id: 'test.vue',
      source: sfc,
    })
    const transformResult = await transform(res.code)
    expect(transformResult).toMatchInlineSnapshot(`
      "import { PageRouteSymbol as __nuxt_route_symbol } from '#app/components/injections';
      import { toDisplayString as _toDisplayString, createTextVNode as _createTextVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

      export function render(_ctx, _cache) {
        return (_openBlock(), _createElementBlock("template", null, [
          _createTextVNode(_toDisplayString((_ctx._.provides[__nuxt_route_symbol] || _ctx.$route).path), 1 /* TEXT */)
        ]))
      }"
    `)
  })

  it('should correctly inject route in options api', async () => {
    const sfc = `
      <template>{{ thing }}</template>
      <script>
      export default {
        computed: {
          thing () {
            return this.$route.path
          }
        }
      }
      </script>
    `

    const res = compileScript(parse(sfc).descriptor, { id: 'test.vue' })
    const transformResult = await transform(res.content)
    expect(transformResult).toMatchInlineSnapshot(`
      "import { PageRouteSymbol as __nuxt_route_symbol } from '#app/components/injections';

      export default {
        computed: {
          thing () {
            return (this._.provides[__nuxt_route_symbol] || this.$route).path
          }
        }
      }
      "
    `)
  })
})
</file>

<file path="packages/nuxt/test/route-rules.test.ts">
import { describe, expect, it } from 'vitest'

import { globRouteRulesFromPages, removePagesRules } from '../src/pages/route-rules.ts'

describe('routeRules from page meta', () => {
  const getPages = () => [
    {
      path: '/',
      rules: { prerender: true },
    },
    // parent without routeRules
    {
      path: '/users',
      children: [{ path: ':id', rules: { prerender: true } }],
    },
    // nested paths
    {
      path: '/some',
      children: [
        {
          path: 'nested',
          children: [{ path: 'page', rules: { prerender: true } }],
        },
      ],
    },
    // page with empty routeRules
    {
      path: '/contact',
      rules: {},
    },
  ]

  it('extracts route rules from pages', () => {
    const pages = getPages()
    const result = globRouteRulesFromPages(pages)
    expect(result).toEqual({
      '/': { prerender: true },
      '/some/nested/page': { prerender: true },
      '/users/**': { prerender: true },
    })
  })

  it('removes route rules from pages', () => {
    const pages = getPages()
    removePagesRules(pages)
    expect(pages).toEqual([
      { path: '/' },
      { path: '/users', children: [{ path: ':id' }] },
      {
        path: '/some',
        children: [{ path: 'nested', children: [{ path: 'page' }] }],
      },
      { path: '/contact' },
    ])
  })
})
</file>

<file path="packages/nuxt/test/scan-components.test.ts">
import { resolve } from 'pathe'
import { consola } from 'consola'
import { expect, it, vi } from 'vitest'

import { scanComponents } from '../src/components/scan.ts'
import { componentsFixtureDir } from './utils.ts'
import type { ComponentsDir } from 'nuxt/schema'

const rFixture = (...p: string[]) => resolve(componentsFixtureDir, ...p)

vi.mock('@nuxt/kit', () => ({
  isIgnored: () => false,
  useLogger: () => consola.create({}).withTag('nuxt'),
}))

const dirs: ComponentsDir[] = [
  {
    path: rFixture('components/islands'),
    extensions: [
      'vue',
    ],
    pattern: '**/*.{vue,}',
    ignore: [
      '**/*.stories.{js,ts,jsx,tsx}',
      '**/*{M,.m,-m}ixin.{js,ts,jsx,tsx}',
      '**/*.d.ts',
    ],
    transpile: false,
    island: true,
  },
  {
    path: rFixture('components/global'),
    extensions: [
      'vue',
    ],
    pattern: '**/*.{vue,}',
    ignore: [
      '**/*.stories.{js,ts,jsx,tsx}',
      '**/*{M,.m,-m}ixin.{js,ts,jsx,tsx}',
      '**/*.d.ts',
    ],
    transpile: false,
    global: true,
  },
  {
    path: rFixture('components'),
    extensions: [
      'vue',
    ],
    pattern: '**/*.{vue,}',
    ignore: [
      '**/*.stories.{js,ts,jsx,tsx}',
      '**/*{M,.m,-m}ixin.{js,ts,jsx,tsx}',
      '**/*.d.ts',
    ],
    transpile: false,
  },
  {
    path: rFixture('components'),
    extensions: [
      'vue',
    ],
    pattern: '**/*.{vue,}',
    ignore: [
      '**/*.stories.{js,ts,jsx,tsx}',
      '**/*{M,.m,-m}ixin.{js,ts,jsx,tsx}',
      '**/*.d.ts',
    ],
    transpile: false,
  },
  {
    path: rFixture('components'),
    extensions: [
      'vue',
    ],
    prefix: 'nuxt',
    pattern: '**/*.{vue,}',
    ignore: [
      '**/*.stories.{js,ts,jsx,tsx}',
      '**/*{M,.m,-m}ixin.{js,ts,jsx,tsx}',
      '**/*.d.ts',
    ],
    transpile: false,
  },
]
const expectedComponents = [
  {
    chunkName: 'components/isle-server',
    declarationPath: rFixture('components/islands/Isle.vue'),
    export: 'default',
    global: undefined,
    island: true,
    kebabName: 'isle',
    mode: 'server',
    pascalName: 'Isle',
    prefetch: false,
    preload: false,
    priority: 1,
    shortPath: 'components/islands/Isle.vue',
  },
  {
    chunkName: 'components/glob',
    declarationPath: rFixture('components/global/Glob.vue'),
    export: 'default',
    global: true,
    island: undefined,
    kebabName: 'glob',
    mode: 'all',
    pascalName: 'Glob',
    prefetch: false,
    preload: false,
    priority: 1,
    shortPath: 'components/global/Glob.vue',
  },
  {
    mode: 'all',
    pascalName: 'HelloWorld',
    kebabName: 'hello-world',
    chunkName: 'components/hello-world',
    declarationPath: rFixture('components/HelloWorld.vue'),
    shortPath: 'components/HelloWorld.vue',
    export: 'default',
    global: undefined,
    island: undefined,
    prefetch: false,
    preload: false,
    priority: 1,
  },
  {
    mode: 'client',
    pascalName: 'Nuxt3',
    kebabName: 'nuxt3',
    chunkName: 'components/nuxt3-client',
    declarationPath: rFixture('components/Nuxt3.client.vue'),
    shortPath: 'components/Nuxt3.client.vue',
    export: 'default',
    global: undefined,
    island: undefined,
    prefetch: false,
    preload: false,
    priority: 1,
  },
  {
    mode: 'server',
    pascalName: 'Nuxt3',
    kebabName: 'nuxt3',
    chunkName: 'components/nuxt3-server',
    declarationPath: rFixture('components/Nuxt3.server.vue'),
    shortPath: 'components/Nuxt3.server.vue',
    export: 'default',
    global: undefined,
    island: undefined,
    prefetch: false,
    preload: false,
    priority: 1,
  },
  {
    chunkName: 'components/client-component-with-props',
    declarationPath: rFixture('components/client/ComponentWithProps.vue'),
    export: 'default',
    global: undefined,
    island: undefined,
    kebabName: 'client-component-with-props',
    mode: 'all',
    pascalName: 'ClientComponentWithProps',
    prefetch: false,
    preload: false,
    priority: 1,
    shortPath: 'components/client/ComponentWithProps.vue',
  },
  {
    chunkName: 'components/client-with-client-only-setup',
    declarationPath: rFixture('components/client/WithClientOnlySetup.vue'),
    export: 'default',
    global: undefined,
    island: undefined,
    kebabName: 'client-with-client-only-setup',
    mode: 'all',
    pascalName: 'ClientWithClientOnlySetup',
    prefetch: false,
    preload: false,
    priority: 1,
    shortPath: 'components/client/WithClientOnlySetup.vue',
  },
  {
    mode: 'server',
    pascalName: 'ParentFolder',
    kebabName: 'parent-folder',
    chunkName: 'components/parent-folder-server',
    declarationPath: rFixture('components/parent-folder/index.server.vue'),
    shortPath: 'components/parent-folder/index.server.vue',
    export: 'default',
    global: undefined,
    island: undefined,
    prefetch: false,
    preload: false,
    priority: 1,
  },
  {
    chunkName: 'components/same-name-same',
    declarationPath: rFixture('components/same-name/same/Same.vue'),
    export: 'default',
    global: undefined,
    island: undefined,
    kebabName: 'same-name-same',
    mode: 'all',
    pascalName: 'SameNameSame',
    prefetch: false,
    preload: false,
    priority: 1,
    shortPath: 'components/same-name/same/Same.vue',
  },
  {
    chunkName: 'components/some-glob',
    declarationPath: rFixture('components/some-glob.global.vue'),
    export: 'default',
    global: true,
    island: undefined,
    kebabName: 'some-glob',
    mode: 'all',
    pascalName: 'SomeGlob',
    prefetch: false,
    preload: false,
    priority: 1,
    shortPath: 'components/some-glob.global.vue',
  },
  {
    chunkName: 'components/some-server',
    declarationPath: rFixture('components/some.island.vue'),
    export: 'default',
    global: undefined,
    island: true,
    kebabName: 'some',
    mode: 'server',
    pascalName: 'Some',
    prefetch: false,
    preload: false,
    priority: 1,
    shortPath: 'components/some.island.vue',
  },
]

const srcDir = rFixture('.')

it('components:scanComponents', async () => {
  const scannedComponents = await scanComponents(dirs, srcDir)
  for (const c of scannedComponents) {
    // @ts-expect-error filePath is not optional but we don't want it to be in the snapshot
    delete c.filePath
    // @ts-expect-error _scanned is added internally but we don't want it to be in the snapshot
    delete c._scanned
  }
  expect(scannedComponents).deep.eq(expectedComponents)
})
</file>

<file path="packages/nuxt/test/shared-dir-config.test.ts">
import { describe, expect, it } from 'vitest'
import { join } from 'pathe'
import type { NuxtConfig } from '@nuxt/schema'
import { loadNuxt } from '../src/index.ts'
import { findWorkspaceDir } from 'pkg-types'

const repoRoot = await findWorkspaceDir()
const fixtureDir = join(repoRoot, 'test/fixtures/basic')

describe('loadNuxt', () => {
  it('adds shared directories for layers to nitro auto-imports in v4', async () => {
    const importDirs = await getNitroImportDirs()
    expect(normalizePaths(importDirs)).toMatchInlineSnapshot(`
      [
        "<rootDir>/shared/utils",
        "<rootDir>/shared/types",
        "<rootDir>/extends/bar/shared/utils",
        "<rootDir>/extends/bar/shared/types",
        "<rootDir>/layers/bar/shared/utils",
        "<rootDir>/layers/bar/shared/types",
        "<rootDir>/extends/node_modules/foo/shared/utils",
        "<rootDir>/extends/node_modules/foo/shared/types",
      ]
    `)
  })
})

function normalizePaths (arr: unknown[]) {
  const normalized = []
  for (const dir of arr) {
    normalized.push(typeof dir === 'string' ? dir.replace(fixtureDir, '<rootDir>') : dir)
  }
  return normalized
}

async function getNitroImportDirs (overrides?: NuxtConfig) {
  const importDirs: unknown[] = []
  const nuxt = await loadNuxt({
    cwd: fixtureDir,
    ready: true,
    overrides: {
      ...overrides,
      hooks: {
        'nitro:config' (config) {
          if (config.imports) {
            importDirs.push(...config.imports.dirs || [])
          }
        },
      },
    },
  })
  await nuxt.close()
  return importDirs
}
</file>

<file path="packages/nuxt/test/tree-shake.test.ts">
import { describe, expect, it } from 'vitest'

import { TreeShakeComposablesPlugin } from '../src/core/plugins/tree-shake.ts'
import { clean } from './utils.ts'

describe('tree-shake', () => {
  const transformPlugin: any = TreeShakeComposablesPlugin({
    sourcemap: false,
    composables: { 'vue': ['onMounted'] },
  }).raw({}, {} as any)

  it('should tree shake composables from source code', () => {
    const code = `
      onMounted(() => {})
      console.log('Hello World')
    `
    const { code: result } = transformPlugin.transform.handler(code, 'test.js')
    expect(clean(result)).toMatchInlineSnapshot(`
      " false && /*@__PURE__*/ onMounted(() => {})
      console.log('Hello World')"
    `)
  })

  it('should tree-shake explicitly-imported composables', () => {
    const code = `
      import { onMounted as _onMounted } from 'vue'
      _onMounted(() => {})
      console.log('Hello World')
    `
    const { code: result } = transformPlugin.transform.handler(code, 'test.js')
    expect(clean(result)).toMatchInlineSnapshot(`
      "import { onMounted as _onMounted } from 'vue'
       false && /*@__PURE__*/ _onMounted(() => {})
      console.log('Hello World')"
    `)
  })

  it('should not error when tree-shaking composables within other tree-shaken composables', () => {
    const code = `
      import { onMounted } from 'vue'
      onMounted(() => {
        onMounted(() => {})
      })
      onMounted(() => {})
    `
    const { code: result } = transformPlugin.transform.handler(code, 'test.js')
    expect(clean(result)).toMatchInlineSnapshot(`
      "import { onMounted } from 'vue'
       false && /*@__PURE__*/ onMounted(() => {
        onMounted(() => {})
      })
       false && /*@__PURE__*/ onMounted(() => {})"
    `)
  })

  it('should tree-shake explicitly-imported composables from #imports', () => {
    const code = `
      import { onMounted } from '#imports'
      onMounted(() => {})
      console.log('Hello World')
    `
    const { code: result } = transformPlugin.transform.handler(code, 'test.js')
    expect(clean(result)).toMatchInlineSnapshot(`
      "import { onMounted } from '#imports'
       false && /*@__PURE__*/ onMounted(() => {})
      console.log('Hello World')"
    `)
  })

  it('should not tree-shake composables from other paths', () => {
    const code = `
      import { onMounted } from 'other-path'
      onMounted(() => {})
      console.log('Hello World')
    `
    const result = transformPlugin.transform.handler(code, 'test.js')
    expect(result).toBeUndefined()
  })

  it('should not tree-shake object properties', () => {
    const code = `
      console.log({
        onMounted(_) {}
      })
    `
    const result = transformPlugin.transform.handler(code, 'test.js')
    expect(result).toBeUndefined()
  })

  it('should handle shadowing of outer-scope composables', () => {
    const code = `
      import { onMounted } from '#imports'

      onMounted(() => console.log('treeshake this'))

      function foo() {
        onMounted()

        function onMounted() {
          console.log('do not treeshake this')
        }
      }
    `
    const { code: result } = transformPlugin.transform.handler(code, 'test.js')
    expect(clean(result)).toMatchInlineSnapshot(`
      "import { onMounted } from '#imports'
       false && /*@__PURE__*/ onMounted(() => console.log('treeshake this'))
      function foo() {
        onMounted()
        function onMounted() {
          console.log('do not treeshake this')
        }
      }"
    `)
  })

  it('should handle variable shadowing', () => {
    const code = `
      import { onMounted } from '#imports'

      onMounted()

      function test() {
        const onMounted = () => 'local'
        onMounted()
      }
    `
    const { code: result } = transformPlugin.transform.handler(code, 'test.js')
    expect(clean(result)).toMatchInlineSnapshot(`
      "import { onMounted } from '#imports'
       false && /*@__PURE__*/ onMounted()
      function test() {
        const onMounted = () => 'local'
        onMounted()
      }"
    `)
  })

  it('should handle usage in function parameter', () => {
    const code = `
      import { onMounted } from '#imports'
      test(123, onMounted(), 456)
    `
    const { code: result } = transformPlugin.transform.handler(code, 'test.js')
    expect(clean(result)).toMatchInlineSnapshot(`
      "import { onMounted } from '#imports'
      test(123,  false && /*@__PURE__*/ onMounted(), 456)"
    `)
  })

  it('should handle assignments', () => {
    const code = `
      import { onMounted } from '#imports'

      let a
      a = onMounted()
      b = 3
    `
    const { code: result } = transformPlugin.transform.handler(code, 'test.js')
    expect(clean(result)).toMatchInlineSnapshot(`
      "import { onMounted } from '#imports'
      let a
      a =  false && /*@__PURE__*/ onMounted()
      b = 3"
    `)
  })

  it('should handle conditional/test/logical contexts', () => {
    const code = `
    import { onMounted } from 'vue'
    if (onMounted()) {}
    onMounted() && doThing()
    doThing() || onMounted()
    const x = cond ? onMounted() : 0
  `
    const { code: result } = transformPlugin.transform.handler(code, 'test.js')
    expect(clean(result)).toMatchInlineSnapshot(`
      "import { onMounted } from 'vue'
      if ( false && /*@__PURE__*/ onMounted()) {}
       false && /*@__PURE__*/ onMounted() && doThing()
      doThing() ||  false && /*@__PURE__*/ onMounted()
      const x = cond ?  false && /*@__PURE__*/ onMounted() : 0"
    `)
  })

  it('should handle sequence in expression statement', () => {
    const code = `
    import { onMounted } from 'vue'
    (foo(), onMounted(), bar())
  `
    const { code: result } = transformPlugin.transform.handler(code, 'test.js')
    expect(clean(result)).toMatchInlineSnapshot(`
      "import { onMounted } from 'vue'
      (foo(),  false && /*@__PURE__*/ onMounted(), bar())"
    `)
  })
})
</file>

<file path="packages/nuxt/test/unctx-transform.test.ts">
import { describe, expect, it } from 'vitest'

import { UnctxTransformPlugin } from '../src/core/plugins/unctx.ts'

describe('unctx transform in nuxt', () => {
  it('should transform nuxt plugins', async () => {
    const code = `
      export default defineNuxtPlugin({
        async setup () {
          await Promise.resolve()
        }
      })
    `
    expect(await transform(code)).toMatchInlineSnapshot(`
      "/* _processed_nuxt_unctx_transform */
      import { executeAsync as __executeAsync } from "unctx";
      export default defineNuxtPlugin({
        async setup () {let __temp, __restore;
          ;(([__temp,__restore]=__executeAsync(()=>Promise.resolve())),await __temp,__restore());
        }
      },1)"
    `)
  })

  it('should transform vue components using defineNuxtComponent', async () => {
    const code = `
      definePageMeta({
        async middleware() {
          await Promise.resolve()
        }
      })
      export default defineNuxtComponent({
        async setup () {
          await Promise.resolve()
        }
      })
    `
    expect(await transform(code, 'app.ts')).toMatchInlineSnapshot(`
      "/* _processed_nuxt_unctx_transform */
      import { executeAsync as __executeAsync } from "unctx";
      definePageMeta({
        async middleware() {let __temp, __restore;
          ;(([__temp,__restore]=__executeAsync(()=>Promise.resolve())),await __temp,__restore());
        }
      })
      export default defineNuxtComponent({
        async setup () {let __temp, __restore;
          ;(([__temp,__restore]=__executeAsync(()=>Promise.resolve())),await __temp,__restore());
        }
      })"
    `)
  })
})

function transform (code: string, id = 'app.vue') {
  const transformerOptions = {
    helperModule: 'unctx',
    asyncFunctions: ['defineNuxtPlugin', 'defineNuxtRouteMiddleware'],
    objectDefinitions: {
      defineNuxtComponent: ['asyncData', 'setup'],
      defineNuxtPlugin: ['setup'],
      definePageMeta: ['middleware', 'validate'],
    },
  }
  const plugin = UnctxTransformPlugin({ sourcemap: false, transformerOptions }).raw({}, {} as any) as any
  return plugin.transformInclude(id) ? Promise.resolve(plugin.transform.handler(code)).then((r: any) => r?.code.replace(/^ {6}/gm, '').trim()) : null
}
</file>

<file path="packages/nuxt/test/unhead-imports.test.ts">
// @vitest-environment node
import process from 'node:process'
import { describe, expect, it } from 'vitest'
import { compileScript, parse } from '@vue/compiler-sfc'
import { UnheadImportsPlugin } from '../src/head/plugins/unhead-imports.ts'

describe('UnheadImportsPlugin', () => {
  // Helper function to transform code
  function transform (code: string, id = 'app.vue') {
    const plugin = UnheadImportsPlugin({ rootDir: import.meta.dirname, sourcemap: false }).raw({}, {} as any) as any
    return plugin.transformInclude(id) ? Promise.resolve(plugin.transform.handler(code, id)).then((r: any) => r?.code.replace(/^ {6}/gm, '').trim()) : null
  }

  describe('transformInclude', () => {
    // @ts-expect-error untyped
    const transformInclude = UnheadImportsPlugin({ rootDir: process.cwd(), sourcemap: false }).raw({}, {} as any).transformInclude

    it('should include JS files', () => {
      expect(transformInclude('/project/components/MyComponent.js')).toBe(true)
    })

    it('should include TypeScript files', () => {
      expect(transformInclude('/project/components/MyComponent.ts')).toBe(true)
    })

    it('should include Vue files', () => {
      expect(transformInclude('/project/components/MyComponent.vue')).toBe(true)
    })

    it('should exclude virtual files', () => {
      expect(transformInclude('virtual:my-plugin')).toBe(false)
    })

    it('should exclude files from unhead libraries', () => {
      expect(transformInclude('/project/node_modules/@unhead/vue/index.js')).toBe(false)
      expect(transformInclude('/project/node_modules/unhead/index.js')).toBe(false)
    })
  })

  describe('transform', () => {
    it('should not transform code that does not include @unhead/vue', async () => {
      const code = `import { renderSSRHead } from '@unhead/ssr'`
      const result = await transform(code, '/project/components/MyComponent.vue')
      expect(result).toBeUndefined()
    })

    it('should transform imports from @unhead/vue in .vue files', async () => {
      const sfc = `
<script lang="ts" setup>
import { useHead } from '@unhead/vue'
useHead({ title: 'My Page' })
</script>
`
      const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })

      const result = await transform(res.content, '/project/components/MyComponent.vue')

      expect(result).toBeDefined()
      expect(result).toContain('import { useHead } from "#app/composables/head"')
      expect(result).not.toContain('import { useHead } from "@unhead/vue"')
    })

    it('should transform imports from @unhead/vue in JS files', async () => {
      const code = `import { useHead } from '@unhead/vue'`
      const result = await transform(code, '/project/composables/head.ts')

      expect(result).toBeDefined()
      expect(result).toContain('import { useHead } from "#app/composables/head"')
      expect(result).not.toContain('import { useHead } from "@unhead/vue"')
    })

    it('should handle mixed imports correctly', async () => {
      const code = `
import { useHead } from '@unhead/vue'
import { useSeoMeta } from '#app/composables/head'
      `
      const result = await transform(code, '/project/components/MyComponent.vue')

      expect(result).toBeDefined()
      expect(result).toContain('import { useHead, useSeoMeta } from "#app/composables/head"')
      // Since we're not mocking the AST parsing, we need to rely on the actual behavior
      // of the plugin for handling imports from #app/composables/head
    })

    it('should handle renamed imports correctly', async () => {
      const code = `import { useHead as useHeadAlias } from '@unhead/vue'`
      const result = await transform(code, '/project/components/MyComponent.vue')

      expect(result).toBeDefined()
      expect(result).toContain('import { useHead as useHeadAlias } from "#app/composables/head"')
      expect(result).not.toContain('import { useHead as useHeadAlias } from "@unhead/vue"')
    })

    it('should handle multiple imports correctly', async () => {
      const code = `import { useHead, useSeoMeta } from '@unhead/vue'`
      const result = await transform(code, '/project/components/MyComponent.vue')

      expect(result).toBeDefined()
      expect(result).toContain('import { useHead, useSeoMeta } from "#app/composables/head"')
      expect(result).not.toContain('import { useHead, useSeoMeta } from "@unhead/vue"')
    })
  })

  describe('Integration tests', () => {
    it('should handle a Vue component correctly', async () => {
      const sfc = `
<template>
  <div>
    <h1>{{ title }}</h1>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { useHead } from '@unhead/vue'

const title = ref('Hello World')

useHead({
  title: 'My Page'
})
</script>
      `
      const res = compileScript(parse(sfc).descriptor, { id: 'component.vue' })

      const result = await transform(res.content, '/project/components/MyComponent.vue')

      expect(result).toBeDefined()
      expect(result).toContain('import { useHead } from "#app/composables/head"')
      expect(result).not.toContain('import { useHead } from "@unhead/vue"')
    })

    it('should handle a Nuxt plugin correctly', async () => {
      const code = `
import { useHead } from '@unhead/vue'

export default defineNuxtPlugin((nuxtApp) => {
  useHead({
    titleTemplate: '%s - My Site'
  })
})
      `

      const result = await transform(code, '/project/plugins/head.ts')

      expect(result).toBeDefined()
      expect(result).toContain('import { useHead } from "#app/composables/head"')
      expect(result).not.toContain('import { useHead } from "@unhead/vue"')
    })

    it('should handle TypeScript file in a nested directory correctly', async () => {
      const code = `
import { useHead } from '@unhead/vue'

export function setupHead() {
  useHead({
    meta: [
      { name: 'description', content: 'My website description' }
    ]
  })
}
      `

      const result = await transform(code, '/project/utils/head/setup.ts')

      expect(result).toBeDefined()
      expect(result).toContain('import { useHead } from "#app/composables/head"')
      expect(result).not.toContain('import { useHead } from "@unhead/vue"')
    })

    it('should handle multiple imports from different sources', async () => {
      const code = `
import { useHead, useSeoMeta } from '@unhead/vue'
import { ref, computed } from 'vue'
import { useRouter } from 'vue-router'
      `

      const result = await transform(code, '/project/pages/index.vue')

      expect(result).toBeDefined()
      expect(result).toContain('import { useHead, useSeoMeta } from "#app/composables/head"')
      expect(result).not.toContain('@unhead/vue')
    })

    it('should handle imports across multiple lines', async () => {
      const code = `
import {
  useHead,
  useSeoMeta
} from '@unhead/vue'
      `

      const result = await transform(code, '/project/components/Header.vue')

      expect(result).toBeDefined()
      // The actual behavior will depend on how the AST parser handles multi-line imports
      // This test will verify the behavior is consistent
    })

    it('should handle different quote styles in imports', async () => {
      const code = `import { useHead } from "@unhead/vue"`
      const result = await transform(code, '/project/components/MyComponent.vue')

      expect(result).toBeDefined()
      expect(result).toContain('import { useHead } from "#app/composables/head"')
      expect(result).not.toContain('import { useHead } from "@unhead/vue"')
    })
  })
})
</file>

<file path="packages/nuxt/test/utils.ts">
import { fileURLToPath } from 'node:url'

export const componentsFixtureDir = fileURLToPath(new URL('components-fixture', import.meta.url))

export function normalizeLineEndings (str: string, normalized = '\n') {
  return str.replace(/\r?\n/g, normalized)
}

export function clean (string?: string) {
  const lines = string?.split('\n').filter(l => l.trim()) || []
  const indent = lines.reduce((prev, curr) => {
    const length = curr.match(/^\s+/)?.[0].length ?? 0
    return length < prev ? length : prev
  }, Infinity)

  const re = new RegExp(`^\\s{${indent}}`)
  return lines.map(l => l.replace(re, '')).join('\n')
}
</file>

<file path="packages/nuxt/test/virtual.test.ts">
import { describe, expect, it } from 'vitest'
import type { Nuxt } from '@nuxt/schema'
import { rollup } from 'rollup'

import { VirtualFSPlugin } from '../src/core/plugins/virtual.ts'

describe('virtual fs plugin', () => {
  it('should support loading files virtually', async () => {
    const code = await generateCode('export { foo } from "#build/foo"', {
      vfs: {
        '/.nuxt/foo': 'export const foo = "hello world"',
      },
    })
    expect(code).toMatchInlineSnapshot(`
      "const foo = "hello world";

      export { foo };"
    `)
  })

  it('should support loading virtual files by suffix', async () => {
    const code = await generateCode('export { foo } from "#build/foo"', {
      mode: 'client',
      vfs: {
        '/.nuxt/foo.server.ts': 'export const foo = "foo server file"',
        '/.nuxt/foo.client.ts': 'export const foo = "foo client file"',
      },
    })
    expect(code).toMatchInlineSnapshot(`
      "const foo = "foo client file";

      export { foo };"
    `)
  })

  it('should support loading files referenced relatively', async () => {
    const code = await generateCode('export { foo } from "#build/foo"', {
      vfs: {
        '/.nuxt/foo': 'export { foo } from "./bar"',
        '/.nuxt/bar': 'export const foo = "relative import"',
      },
    })
    expect(code).toMatchInlineSnapshot(`
      "const foo = "relative import";

      export { foo };"
    `)
  })
})

async function generateCode (input: string, options: { mode?: 'client' | 'server', vfs: Record<string, string> }) {
  const stubNuxt = {
    options: {
      extensions: ['.ts', '.js'],
      buildDir: '/.nuxt',
      alias: {
        '~': '/',
        '#build': '/.nuxt',
      },
    },
    vfs: options.vfs,
  } as unknown as Nuxt

  const bundle = await rollup({
    input: 'entry.ts',
    plugins: [
      {
        name: 'entry',
        resolveId (id) {
          if (id === 'entry.ts') {
            return id
          }
        },
        load (id) {
          if (id === 'entry.ts') {
            return input
          }
        },
      },
      VirtualFSPlugin(stubNuxt, { mode: options.mode || 'client', alias: stubNuxt.options.alias }).rollup(),
    ],
  })
  const { output: [chunk] } = await bundle.generate({})
  return chunk.code.trim()
}
</file>

<file path="packages/nuxt/.attw.json">
{
  "ignoreRules": ["cjs-resolves-to-esm", "false-esm", "internal-resolution-error"]
}
</file>

<file path="packages/nuxt/.gitignore">
src/app/components/error-404.vue
src/app/components/error-500.vue
src/app/components/error-dev.vue
src/app/components/welcome.vue
src/core/runtime/nitro/handlers/error-500.ts
src/core/runtime/nitro/handlers/error-dev.ts
src/core/runtime/nitro/templates/error-500.ts
src/core/runtime/nitro/templates/error-dev.ts
</file>

<file path="packages/nuxt/app.d.ts">
export * from './dist/app/index.ts'
</file>

<file path="packages/nuxt/build.config.ts">
import type { BuildEntry } from 'unbuild'
import { defineBuildConfig } from 'unbuild'
import { addRollupTimingsPlugin } from '../../debug/build-config.ts'

export default defineBuildConfig({
  declaration: true,
  entries: [
    // Core
    { input: 'src/index' },
    // App
    { input: 'src/app/', outDir: 'dist/app/', ext: 'js' },
    // Runtime dirs
    ...[
      'core',
      'head',
      'components',
      'pages',
    ].map(name => ({ input: `src/${name}/runtime/`, outDir: `dist/${name}/runtime`, format: 'esm', ext: 'js' } as BuildEntry)),
  ],
  hooks: {
    'mkdist:entry:options' (_ctx, _entry, mkdistOptions) {
      mkdistOptions.addRelativeDeclarationExtensions = true
    },
    'rollup:options' (ctx, options) {
      addRollupTimingsPlugin(options)
    },
  },
  dependencies: [
    '@nuxt/cli',
    'vue-router',
    'ofetch',
  ],
  externals: [
    'nuxt',
    'nuxt/schema',
    '@vue/shared',
    '@unhead/vue',
  ],
})
</file>

<file path="packages/nuxt/config.cjs">
function defineNuxtConfig (config) {
  return config
}

module.exports = {
  defineNuxtConfig,
}
</file>

<file path="packages/nuxt/config.d.ts">
import type { ConfigLayerMeta, DefineConfig } from 'c12'
import type { NuxtConfig } from 'nuxt/schema'

export { NuxtConfig } from 'nuxt/schema'

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface DefineNuxtConfig extends DefineConfig<NuxtConfig, ConfigLayerMeta> {}
export declare const defineNuxtConfig: DefineNuxtConfig
</file>

<file path="packages/nuxt/config.js">
function defineNuxtConfig (config) {
  return config
}

export { defineNuxtConfig }
</file>

<file path="packages/nuxt/index.d.ts">
declare global {
  var __NUXT_VERSION__: string
  var __NUXT_ASYNC_CONTEXT__: boolean

  interface Navigator {
    connection?: {
      type: 'bluetooth' | 'cellular' | 'ethernet' | 'none' | 'wifi' | 'wimax' | 'other' | 'unknown'
      effectiveType: 'slow-2g' | '2g' | '3g' | '4g'
    }
  }

  interface Window {
    cookieStore?: {
      addEventListener: (type: 'change', listener: (event: any) => void) => void
      removeEventListener: (type: 'change', listener: (event: any) => void) => void
    }
  }
}

export {}
</file>

<file path="packages/nuxt/kit.d.ts">
export * from '@nuxt/kit'
</file>

<file path="packages/nuxt/kit.js">
export * from '@nuxt/kit'
</file>

<file path="packages/nuxt/meta.d.ts">
export const runtimeDependencies: string[]
</file>

<file path="packages/nuxt/meta.js">
export const runtimeDependencies = [
  // other deps
  'devalue',
  'klona',
  // unjs ecosystem
  'defu',
  'ufo',
  'h3',
  'destr',
  'consola',
  'hookable',
  'unctx',
  'cookie-es',
  'perfect-debounce',
  'ohash',
  'pathe',
  'uncrypto',
]
</file>

<file path="packages/nuxt/package.json">
{
  "name": "nuxt",
  "version": "4.2.2",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nuxt/nuxt.git",
    "directory": "packages/nuxt"
  },
  "homepage": "https://nuxt.com",
  "description": "Nuxt is a free and open-source framework with an intuitive and extendable way to create type-safe, performant and production-grade full-stack web applications and websites with Vue.js.",
  "license": "MIT",
  "type": "module",
  "types": "./types.d.ts",
  "bin": {
    "nuxi": "bin/nuxt.mjs",
    "nuxt": "bin/nuxt.mjs"
  },
  "exports": {
    ".": {
      "types": "./types.d.mts",
      "import": "./dist/index.mjs"
    },
    "./config": {
      "types": "./config.d.ts",
      "import": "./config.js",
      "require": "./config.cjs"
    },
    "./schema": "./schema.js",
    "./kit": "./kit.js",
    "./meta": "./meta.js",
    "./app": "./dist/app/index.js",
    "./package.json": "./package.json"
  },
  "imports": {
    "#app": "./dist/app/index.js",
    "#app/nuxt": "./dist/app/nuxt.js",
    "#unhead/composables": "./dist/head/runtime/composables.js"
  },
  "files": [
    "app.d.ts",
    "bin",
    "types.d.ts",
    "types.d.mts",
    "dist",
    "config.*",
    "kit.*",
    "meta.*",
    "schema.*"
  ],
  "scripts": {
    "prepack": "unbuild",
    "build:stub": "unbuild --stub",
    "test:attw": "attw --pack"
  },
  "dependencies": {
    "@dxup/nuxt": "^0.3.2",
    "@nuxt/cli": "^3.31.3",
    "@nuxt/devtools": "^3.1.1",
    "@nuxt/kit": "workspace:*",
    "@nuxt/nitro-server": "workspace:*",
    "@nuxt/schema": "workspace:*",
    "@nuxt/telemetry": "^2.6.6",
    "@nuxt/vite-builder": "workspace:*",
    "@unhead/vue": "^2.1.1",
    "@vue/shared": "^3.5.26",
    "c12": "^3.3.3",
    "chokidar": "^5.0.0",
    "compatx": "^0.2.0",
    "consola": "^3.4.2",
    "cookie-es": "^2.0.0",
    "defu": "^6.1.4",
    "destr": "^2.0.5",
    "devalue": "^5.6.1",
    "errx": "^0.1.0",
    "escape-string-regexp": "^5.0.0",
    "exsolve": "^1.0.8",
    "h3": "^1.15.4",
    "hookable": "^5.5.3",
    "ignore": "^7.0.5",
    "impound": "^1.0.0",
    "jiti": "^2.6.1",
    "klona": "^2.0.6",
    "knitwork": "^1.3.0",
    "magic-string": "^0.30.21",
    "mlly": "^1.8.0",
    "nanotar": "^0.2.0",
    "nypm": "^0.6.2",
    "ofetch": "^1.5.1",
    "ohash": "^2.0.11",
    "on-change": "^6.0.1",
    "oxc-minify": "^0.106.0",
    "oxc-parser": "^0.106.0",
    "oxc-transform": "^0.106.0",
    "oxc-walker": "^0.6.0",
    "pathe": "^2.0.3",
    "perfect-debounce": "^2.0.0",
    "pkg-types": "^2.3.0",
    "rou3": "^0.7.12",
    "scule": "^1.3.0",
    "semver": "^7.7.3",
    "std-env": "^3.10.0",
    "tinyglobby": "^0.2.15",
    "ufo": "^1.6.1",
    "ultrahtml": "^1.6.0",
    "uncrypto": "^0.1.3",
    "unctx": "^2.5.0",
    "unimport": "^5.6.0",
    "unplugin": "^2.3.11",
    "unplugin-vue-router": "^0.19.2",
    "untyped": "^2.0.0",
    "vue": "^3.5.26",
    "vue-router": "^4.6.4"
  },
  "devDependencies": {
    "@nuxt/scripts": "0.13.2",
    "@parcel/watcher": "2.5.1",
    "@types/estree": "1.0.8",
    "@vitejs/plugin-vue": "6.0.3",
    "@vitejs/plugin-vue-jsx": "5.1.3",
    "@vue/compiler-sfc": "3.5.26",
    "unbuild": "3.6.1",
    "vite": "7.3.0",
    "vitest": "3.2.4",
    "vue-bundle-renderer": "2.2.0",
    "vue-sfc-transformer": "0.1.17"
  },
  "peerDependencies": {
    "@parcel/watcher": "^2.1.0",
    "@types/node": ">=18.12.0"
  },
  "peerDependenciesMeta": {
    "@parcel/watcher": {
      "optional": true
    },
    "@types/node": {
      "optional": true
    }
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="packages/nuxt/schema.d.ts">
export * from '@nuxt/schema'
</file>

<file path="packages/nuxt/schema.js">
export * from '@nuxt/schema'
</file>

<file path="packages/nuxt/types.d.mts">
import type { SchemaDefinition } from 'nuxt/schema'
import type { DefineNuxtConfig } from 'nuxt/config'

export * from './dist/index.js'

declare global {
  const defineNuxtConfig: DefineNuxtConfig
  const defineNuxtSchema: (schema: SchemaDefinition) => SchemaDefinition

  interface ImportMeta {
    url: string
    readonly env: ImportMetaEnv
  }
}
</file>

<file path="packages/nuxt/types.d.ts">
import type { SchemaDefinition } from 'nuxt/schema'
import type { DefineNuxtConfig } from 'nuxt/config'

export * from './dist/index.ts'

declare global {
  const defineNuxtConfig: DefineNuxtConfig
  const defineNuxtSchema: (schema: SchemaDefinition) => SchemaDefinition

  interface ImportMeta {
    url: string
    readonly env: ImportMetaEnv
  }
}
</file>

<file path="packages/rspack/.attw.json">
{
  "ignoreRules": ["cjs-resolves-to-esm"]
}
</file>

<file path="packages/rspack/build.config.ts">
import { defineBuildConfig } from 'unbuild'
import { addRollupTimingsPlugin } from '../../debug/build-config.ts'
import config from '../webpack/build.config.ts'

export default defineBuildConfig({
  ...config[0],
  externals: [
    '@rspack/core',
    '#builder',
    'webpack', /* types - unbuild bug */
    '@nuxt/schema',
  ],
  hooks: {
    'rollup:options' (ctx, options) {
      addRollupTimingsPlugin(options)
    },
  },
  entries: [
    {
      input: '../webpack/src/index',
      name: 'index',
      declaration: true,
    },
    {
      input: '../webpack/src/loaders/vue-module-identifier',
      name: 'loaders/vue-module-identifier',
      declaration: false,
    },
  ],
})
</file>

<file path="packages/rspack/builder.mjs">
import webpack from '@rspack/core'

export { default as WebpackBarPlugin } from 'webpackbar/rspack'

export const builder = 'rspack'
export { webpack }
export const MiniCssExtractPlugin = webpack.CssExtractRspackPlugin

export { TsCheckerRspackPlugin as TsCheckerPlugin } from 'ts-checker-rspack-plugin'
</file>

<file path="packages/rspack/package.json">
{
  "name": "@nuxt/rspack-builder",
  "version": "4.2.2",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nuxt/nuxt.git",
    "directory": "packages/rspack"
  },
  "description": "rspack bundler for Nuxt",
  "homepage": "https://nuxt.com",
  "license": "MIT",
  "type": "module",
  "types": "./dist/index.d.ts",
  "imports": {
    "#builder": "./builder.mjs",
    "#vue-module-identifier": "./dist/loaders/vue-module-identifier.mjs"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs"
    },
    "./dist/*": "./dist/*"
  },
  "files": [
    "dist",
    "builder.mjs"
  ],
  "scripts": {
    "prepack": "unbuild",
    "build:stub": "unbuild --stub",
    "test:attw": "attw --pack"
  },
  "dependencies": {
    "@nuxt/friendly-errors-webpack-plugin": "^2.6.0",
    "@nuxt/kit": "workspace:*",
    "@rspack/core": "^1.7.0",
    "@vue/compiler-sfc": "3.5.26",
    "autoprefixer": "^10.4.23",
    "css-loader": "^7.1.2",
    "css-minimizer-webpack-plugin": "^7.0.4",
    "cssnano": "^7.1.2",
    "defu": "^6.1.4",
    "esbuild-loader": "^4.4.2",
    "escape-string-regexp": "^5.0.0",
    "exsolve": "^1.0.8",
    "file-loader": "^6.2.0",
    "h3": "^1.15.4",
    "jiti": "^2.6.1",
    "knitwork": "^1.3.0",
    "magic-string": "^0.30.21",
    "memfs": "^4.51.1",
    "mlly": "^1.8.0",
    "ohash": "^2.0.11",
    "pathe": "^2.0.3",
    "pify": "^6.1.0",
    "postcss": "^8.5.6",
    "postcss-import": "^16.1.1",
    "postcss-import-resolver": "^2.0.0",
    "postcss-loader": "^8.2.0",
    "postcss-url": "^10.1.3",
    "pug-plain-loader": "^1.1.0",
    "seroval": "^1.4.2",
    "std-env": "^3.10.0",
    "time-fix-plugin": "^2.0.7",
    "tinyglobby": "^0.2.15",
    "ts-checker-rspack-plugin": "^1.2.3",
    "ufo": "^1.6.1",
    "unenv": "^2.0.0-rc.24",
    "unplugin": "^2.3.11",
    "url-loader": "^4.1.1",
    "vue-bundle-renderer": "^2.2.0",
    "vue-loader": "^17.4.2",
    "webpack-bundle-analyzer": "^5.1.0",
    "webpack-dev-middleware": "^7.4.5",
    "webpack-hot-middleware": "^2.26.1",
    "webpackbar": "^7.0.0"
  },
  "devDependencies": {
    "@nuxt/schema": "workspace:*",
    "@types/webpack-bundle-analyzer": "4.7.0",
    "@types/webpack-hot-middleware": "2.25.12",
    "rollup": "4.54.0",
    "unbuild": "3.6.1",
    "vue": "3.5.26"
  },
  "peerDependencies": {
    "nuxt": "workspace:*",
    "vue": "^3.3.4"
  },
  "engines": {
    "node": "^20.9.0 || >=22.0.0"
  }
}
</file>

<file path="packages/schema/src/config/adhoc.ts">
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  components: {
    $resolve: (val) => {
      if (Array.isArray(val)) {
        return { dirs: val }
      }
      if (val === false) {
        return { dirs: [] }
      }
      return {
        dirs: [{ path: '~/components/global', global: true }, '~/components'],
        ...typeof val === 'object' ? val : {},
      }
    },
  },

  imports: {
    global: false,
    scan: true,
    dirs: [],
  },

  pages: undefined,

  telemetry: undefined,

  devtools: {},
})
</file>

<file path="packages/schema/src/config/app.ts">
import process from 'node:process'
import { defu } from 'defu'
import { resolve } from 'pathe'
import { defineResolvers } from '../utils/definition.ts'
import type { AppHeadMetaObject } from '../types/head.ts'
import type { NuxtAppConfig } from '../types/config.ts'

export default defineResolvers({
  vue: {
    transformAssetUrls: {
      video: ['src', 'poster'],
      source: ['src'],
      img: ['src'],
      image: ['xlink:href', 'href'],
      use: ['xlink:href', 'href'],
    },
    compilerOptions: {},
    runtimeCompiler: {
      $resolve: (val) => {
        return typeof val === 'boolean' ? val : false
      },
    },
    propsDestructure: true,

    config: {},
  },
  app: {
    baseURL: {
      $resolve: (val) => {
        if (typeof val === 'string') {
          return val
        }
        return process.env.NUXT_APP_BASE_URL || '/'
      },
    },
    buildAssetsDir: {
      $resolve: (val) => {
        if (typeof val === 'string') {
          return val
        }
        return process.env.NUXT_APP_BUILD_ASSETS_DIR || '/_nuxt/'
      },
    },

    cdnURL: {
      $resolve: async (val, get) => {
        if (await get('dev')) {
          return ''
        }
        return process.env.NUXT_APP_CDN_URL || (typeof val === 'string' ? val : '')
      },
    },

    head: {
      $resolve: (_val) => {
        const val: Partial<NuxtAppConfig['head']> = _val && typeof _val === 'object' ? _val : {}

        type NormalizedMetaObject = Required<Pick<AppHeadMetaObject, 'meta' | 'link' | 'style' | 'script' | 'noscript'>>

        const resolved: NuxtAppConfig['head'] & NormalizedMetaObject = defu(val, {
          meta: [],
          link: [],
          style: [],
          script: [],
          noscript: [],
        } satisfies NormalizedMetaObject)

        // provides default charset and viewport if not set
        if (!resolved.meta.find(m => m?.charset)?.charset) {
          resolved.meta.unshift({ charset: resolved.charset || 'utf-8' })
        }
        if (!resolved.meta.find(m => m?.name === 'viewport')?.content) {
          resolved.meta.unshift({ name: 'viewport', content: resolved.viewport || 'width=device-width, initial-scale=1' })
        }

        resolved.meta = resolved.meta.filter(Boolean)
        resolved.link = resolved.link.filter(Boolean)
        resolved.style = resolved.style.filter(Boolean)
        resolved.script = resolved.script.filter(Boolean)
        resolved.noscript = resolved.noscript.filter(Boolean)

        return resolved
      },
    },
    layoutTransition: false,
    pageTransition: false,
    viewTransition: {
      $resolve: async (val, get) => {
        if (val === 'always' || typeof val === 'boolean') {
          return val
        }

        return await get('experimental').then(e => e.viewTransition) ?? false
      },
    },
    keepalive: false,
    rootId: {
      $resolve: val => val === false ? false : (val && typeof val === 'string' ? val : '__nuxt'),
    },
    rootTag: {
      $resolve: val => val && typeof val === 'string' ? val : 'div',
    },
    rootAttrs: {
      $resolve: async (val, get) => {
        const rootId = await get('app.rootId')
        return {
          id: rootId === false ? undefined : (rootId || '__nuxt'),
          ...typeof val === 'object' ? val : {},
        }
      },
    },
    teleportTag: {
      $resolve: val => val && typeof val === 'string' ? val : 'div',
    },
    teleportId: {
      $resolve: val => val === false ? false : (val && typeof val === 'string' ? val : 'teleports'),
    },
    teleportAttrs: {
      $resolve: async (val, get) => {
        const teleportId = await get('app.teleportId')
        return {
          id: teleportId === false ? undefined : (teleportId || 'teleports'),
          ...typeof val === 'object' ? val : {},
        }
      },
    },
    spaLoaderTag: {
      $resolve: val => val && typeof val === 'string' ? val : 'div',
    },
    spaLoaderAttrs: {
      id: '__nuxt-loader',
    },
  },
  spaLoadingTemplate: {
    $resolve: async (val, get) => {
      if (typeof val === 'string') {
        return resolve(await get('srcDir'), val)
      }
      if (typeof val === 'boolean') {
        return val
      }
      return null
    },
  },
  plugins: [],
  css: {
    $resolve: (val) => {
      if (!Array.isArray(val)) {
        return []
      }
      const css: string[] = []
      for (const item of val) {
        if (typeof item === 'string') {
          css.push(item)
        }
      }
      return css
    },
  },
  unhead: {
    legacy: false,
    renderSSRHeadOptions: {
      $resolve: val => ({
        omitLineBreaks: true,
        ...typeof val === 'object' ? val : {},
      }),
    },
  },
})
</file>

<file path="packages/schema/src/config/build.ts">
import { defu } from 'defu'
import { join } from 'pathe'
import { isTest } from 'std-env'
import type { Nuxt } from '../types/nuxt.ts'
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  builder: {
    $resolve: (val) => {
      if (val && typeof val === 'object' && 'bundle' in val) {
        return val as { bundle: (nuxt: Nuxt) => Promise<void> }
      }
      const map = {
        rspack: '@nuxt/rspack-builder',
        vite: '@nuxt/vite-builder',
        webpack: '@nuxt/webpack-builder',
      }
      type Builder = 'vite' | 'webpack' | 'rspack'
      if (typeof val === 'string' && val in map) {
        // TODO: improve normalisation inference
        return map[val as keyof typeof map] as Builder
      }
      return map.vite as Builder
    },
  },
  sourcemap: {
    $resolve: async (val, get) => {
      if (typeof val === 'boolean') {
        return { server: val, client: val }
      }
      return {
        server: true,
        client: await get('dev'),
        ...typeof val === 'object' ? val : {},
      }
    },
  },
  logLevel: {
    $resolve: (val) => {
      if (val && typeof val === 'string' && !['silent', 'info', 'verbose'].includes(val)) {
        console.warn(`Invalid \`logLevel\` option: \`${val}\`. Must be one of: \`silent\`, \`info\`, \`verbose\`.`)
      }
      return val && typeof val === 'string' ? val as 'silent' | 'info' | 'verbose' : (isTest ? 'silent' : 'info')
    },
  },
  build: {
    transpile: {
      $resolve: (val) => {
        const transpile: Array<string | RegExp | ((ctx: { isClient?: boolean, isServer?: boolean, isDev: boolean }) => string | RegExp | false)> = []
        if (Array.isArray(val)) {
          for (const pattern of val) {
            if (!pattern) {
              continue
            }
            if (typeof pattern === 'string' || typeof pattern === 'function' || pattern instanceof RegExp) {
              transpile.push(pattern)
            }
          }
        }
        return transpile
      },
    },
    templates: [],
    analyze: {
      $resolve: async (val, get) => {
        const [rootDir, analyzeDir] = await Promise.all([get('rootDir'), get('analyzeDir')])
        return {
          template: 'treemap',
          projectRoot: rootDir,
          filename: join(analyzeDir, '{name}.html'),
          ...typeof val === 'boolean' ? { enabled: val } : typeof val === 'object' ? val : {},
        }
      },
    },
  },
  optimization: {
    keyedComposables: {
      $resolve: val => [
        { name: 'callOnce', argumentLength: 3, source: '#app/composables/once' },
        { name: 'defineNuxtComponent', argumentLength: 2, source: '#app/composables/component' },
        { name: 'useState', argumentLength: 2, source: '#app/composables/state' },
        { name: 'useFetch', argumentLength: 3, source: '#app/composables/fetch' },
        { name: 'useAsyncData', argumentLength: 3, source: '#app/composables/asyncData' },
        { name: 'useLazyAsyncData', argumentLength: 3, source: '#app/composables/asyncData' },
        { name: 'useLazyFetch', argumentLength: 3, source: '#app/composables/fetch' },
        ...Array.isArray(val) ? val : [],
      ].filter(Boolean),
    },
    treeShake: {
      composables: {
        server: {
          $resolve: async (val, get) => defu(typeof val === 'object' ? val as Record<string, string[]> || {} : {},
            await get('dev')
              ? {}
              : {
                  'vue': ['onMounted', 'onUpdated', 'onUnmounted', 'onBeforeMount', 'onBeforeUpdate', 'onBeforeUnmount', 'onRenderTracked', 'onRenderTriggered', 'onActivated', 'onDeactivated'],
                  '#app': ['definePayloadReviver', 'definePageMeta'],
                },
          ),
        },
        client: {
          $resolve: async (val, get) => defu(typeof val === 'object' ? val as Record<string, string[]> || {} : {},
            await get('dev')
              ? {}
              : {
                  'vue': ['onRenderTracked', 'onRenderTriggered', 'onServerPrefetch'],
                  '#app': ['definePayloadReducer', 'definePageMeta', 'onPrehydrate'],
                },
          ),
        },
      },
    },
    asyncTransforms: {
      asyncFunctions: ['defineNuxtPlugin', 'defineNuxtRouteMiddleware'],
      objectDefinitions: {
        defineNuxtComponent: ['asyncData', 'setup'],
        defineNuxtPlugin: ['setup'],
        definePageMeta: ['middleware', 'validate'],
      },
    },
  },
})
</file>

<file path="packages/schema/src/config/common.ts">
import process from 'node:process'
import { existsSync } from 'node:fs'
import { readdir } from 'node:fs/promises'
import { randomUUID } from 'node:crypto'
import { relative, resolve } from 'pathe'
import { isDebug, isDevelopment, isTest } from 'std-env'
import { defu } from 'defu'
import { findWorkspaceDir } from 'pkg-types'

import type { NuxtDebugOptions } from '../types/debug.ts'
import type { NuxtModule } from '../types/module.ts'
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  extends: undefined,
  compatibilityDate: undefined,
  theme: undefined,
  rootDir: {
    $resolve: val => typeof val === 'string' ? resolve(val) : process.cwd(),
  },
  workspaceDir: {
    $resolve: async (val, get) => {
      const rootDir = await get('rootDir')
      return val && typeof val === 'string'
        ? resolve(rootDir, val)
        : await findWorkspaceDir(rootDir, {
            gitConfig: 'closest',
            try: true,
          }).catch(() => rootDir)
    },
  },
  srcDir: {
    $resolve: async (val, get) => {
      if (val && typeof val === 'string') {
        return resolve(await get('rootDir'), val)
      }

      const rootDir = await get('rootDir')

      const srcDir = resolve(rootDir, 'app')
      if (!existsSync(srcDir)) {
        return rootDir
      }

      const srcDirFiles = new Set<string>()
      const files = await readdir(srcDir).catch(() => [])
      for (const file of files) {
        if (file !== 'spa-loading-template.html' && !file.startsWith('router.options')) {
          srcDirFiles.add(file)
        }
      }
      if (srcDirFiles.size === 0) {
        for (const file of ['app.vue', 'App.vue']) {
          if (existsSync(resolve(rootDir, file))) {
            return rootDir
          }
        }
        const keys = ['assets', 'layouts', 'middleware', 'pages', 'plugins'] as const
        const dirs = await Promise.all(keys.map(key => get(`dir.${key}`)))
        for (const dir of dirs) {
          if (existsSync(resolve(rootDir, dir))) {
            return rootDir
          }
        }
      }
      return srcDir
    },
  },
  serverDir: {
    $resolve: async (val, get) => {
      const rootDir = await get('rootDir')
      return resolve(rootDir, val && typeof val === 'string' ? val : 'server')
    },
  },
  buildDir: {
    $resolve: async (val, get) => {
      const rootDir = await get('rootDir')
      return resolve(rootDir, val && typeof val === 'string' ? val : '.nuxt')
    },
  },
  appId: {
    $resolve: val => val && typeof val === 'string' ? val : 'nuxt-app',
  },
  buildId: {
    $resolve: async (val, get): Promise<string> => {
      if (typeof val === 'string') { return val }

      const [isDev, isTest] = await Promise.all([get('dev') as Promise<boolean>, get('test') as Promise<boolean>])
      return isDev ? 'dev' : isTest ? 'test' : randomUUID()
    },
  },
  modulesDir: {
    $default: ['node_modules'],
    $resolve: async (val, get) => {
      const rootDir = await get('rootDir')
      const modulesDir = new Set<string>([resolve(rootDir, 'node_modules')])
      if (Array.isArray(val)) {
        for (const dir of val) {
          if (dir && typeof dir === 'string') {
            modulesDir.add(resolve(rootDir, dir))
          }
        }
      }
      return [...modulesDir]
    },
  },
  analyzeDir: {
    $resolve: async (val, get) => val && typeof val === 'string'
      ? resolve(await get('rootDir'), val)
      : resolve(await get('buildDir'), 'analyze'),
  },
  dev: {
    $resolve: val => typeof val === 'boolean' ? val : Boolean(isDevelopment),
  },
  test: {
    $resolve: val => typeof val === 'boolean' ? val : Boolean(isTest),
  },
  debug: {
    $resolve: (val) => {
      val ??= isDebug
      if (val === true) {
        return {
          templates: true,
          modules: true,
          watchers: true,
          hooks: {
            client: true,
            server: true,
          },
          nitro: true,
          router: true,
          hydration: true,
        } satisfies Required<NuxtDebugOptions>
      }
      if (val && typeof val === 'object') {
        return val
      }
      return false
    },
  },
  ssr: {
    $resolve: val => typeof val === 'boolean' ? val : true,
  },
  modules: {
    $resolve: (val) => {
      const modules: Array<string | NuxtModule | [NuxtModule | string, Record<string, any>]> = []
      if (Array.isArray(val)) {
        for (const mod of val) {
          if (!mod) {
            continue
          }
          if (typeof mod === 'string' || typeof mod === 'function' || (Array.isArray(mod) && mod[0])) {
            modules.push(mod)
          }
        }
      }
      return modules
    },
  },
  dir: {
    app: {
      $resolve: async (val, get) => {
        const [srcDir, rootDir] = await Promise.all([get('srcDir'), get('rootDir')])
        return resolve(await get('srcDir'), val && typeof val === 'string' ? val : (srcDir === rootDir ? 'app' : '.'))
      },
    },
    assets: 'assets',
    layouts: 'layouts',
    middleware: 'middleware',
    modules: {
      $resolve: async (val, get) => {
        return resolve(await get('rootDir'), val && typeof val === 'string' ? val : 'modules')
      },
    },
    pages: 'pages',
    plugins: 'plugins',
    shared: {
      $resolve: (val) => {
        return val && typeof val === 'string' ? val : 'shared'
      },
    },
    public: {
      $resolve: async (val, get) => {
        return resolve(await get('rootDir'), val && typeof val === 'string' ? val : 'public')
      },
    },
  },
  extensions: {
    $resolve: (val): string[] => {
      const extensions = ['.js', '.jsx', '.mjs', '.ts', '.tsx', '.vue']
      if (Array.isArray(val)) {
        for (const item of val) {
          if (item && typeof item === 'string') {
            extensions.push(item)
          }
        }
      }
      return extensions
    },
  },
  alias: {
    $resolve: async (val, get) => {
      const [srcDir, rootDir, buildDir, sharedDir, serverDir] = await Promise.all([get('srcDir'), get('rootDir'), get('buildDir'), get('dir.shared'), get('serverDir')])
      const srcWithTrailingSlash = withTrailingSlash(srcDir)
      const rootWithTrailingSlash = withTrailingSlash(rootDir)
      return {
        '~': srcWithTrailingSlash,
        '@': srcWithTrailingSlash,
        '~~': rootWithTrailingSlash,
        '@@': rootWithTrailingSlash,
        '#shared': withTrailingSlash(resolve(rootDir, sharedDir)),
        '#server': withTrailingSlash(serverDir),
        '#build': withTrailingSlash(buildDir),
        '#internal/nuxt/paths': resolve(buildDir, 'paths.mjs'),
        ...typeof val === 'object' ? val : {},
      }
    },
  },
  ignoreOptions: undefined,
  ignorePrefix: {
    $resolve: val => val && typeof val === 'string' ? val : '-',
  },
  ignore: {
    $resolve: async (val, get): Promise<string[]> => {
      const [rootDir, ignorePrefix, analyzeDir, buildDir] = await Promise.all([get('rootDir'), get('ignorePrefix'), get('analyzeDir'), get('buildDir')])
      const ignore = new Set<string>([
        '**/*.stories.{js,cts,mts,ts,jsx,tsx}', // ignore storybook files
        '**/*.{spec,test}.{js,cts,mts,ts,jsx,tsx}', // ignore tests
        '**/*.d.{cts,mts,ts}', // ignore type declarations
        '**/*.d.vue.{cts,mts,ts}',
        '**/.{pnpm-store,vercel,netlify,output,git,cache,data}',
        '**/*.sock',
        relative(rootDir, analyzeDir),
        relative(rootDir, buildDir),
      ])
      if (ignorePrefix) {
        ignore.add(`**/${ignorePrefix}*.*`)
      }
      if (Array.isArray(val)) {
        for (const pattern of val) {
          if (pattern) {
            ignore.add(pattern)
          }
        }
      }
      return [...ignore]
    },
  },
  watch: {
    $resolve: (val) => {
      if (Array.isArray(val)) {
        return val.filter((b: unknown) => typeof b === 'string' || b instanceof RegExp)
      }
      return []
    },
  },
  watchers: {
    rewatchOnRawEvents: undefined,
    webpack: {
      aggregateTimeout: 1000,
    },
    chokidar: {
      ignoreInitial: true,
      ignorePermissionErrors: true,
    },
  },
  hooks: undefined,
  runtimeConfig: {
    $resolve: async (_val, get) => {
      const val = _val && typeof _val === 'object' ? _val : {}
      const [app, buildId] = await Promise.all([get('app'), get('buildId')])
      provideFallbackValues(val)
      return defu(val, {
        public: {},
        app: {
          buildId,
          baseURL: app.baseURL,
          buildAssetsDir: app.buildAssetsDir,
          cdnURL: app.cdnURL,
        },
      })
    },
  },
  appConfig: {
    nuxt: {},
  },

  $schema: {},
})

function provideFallbackValues (obj: Record<string, any>) {
  for (const key in obj) {
    if (typeof obj[key] === 'undefined' || obj[key] === null) {
      obj[key] = ''
    } else if (typeof obj[key] === 'object') {
      provideFallbackValues(obj[key])
    }
  }
}

function withTrailingSlash (str: string) {
  return str.replace(/\/?$/, '/')
}
</file>

<file path="packages/schema/src/config/dev.ts">
import process from 'node:process'
import { defineResolvers } from '../utils/definition.ts'
import { template as loadingTemplate } from '../../../ui-templates/dist/templates/loading.ts'

export default defineResolvers({
  devServer: {
    https: false,
    port: Number(process.env.NUXT_PORT || process.env.NITRO_PORT || process.env.PORT || 3000),
    host: process.env.NUXT_HOST || process.env.NITRO_HOST || process.env.HOST || undefined,
    url: 'http://localhost:3000',
    loadingTemplate,
    cors: {
      origin: [/^https?:\/\/(?:(?:[^:]+\.)?localhost|127\.0\.0\.1|\[::1\])(?::\d+)?$/],
    },
  },
})
</file>

<file path="packages/schema/src/config/esbuild.ts">
import { defu } from 'defu'
import type { TransformOptions } from 'esbuild'
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  esbuild: {
    options: {
      target: {
        $resolve: async (val, get) => {
          if (typeof val === 'string') {
            return val
          }
          // https://github.com/vitejs/vite-plugin-vue/issues/528
          const useDecorators = await get('experimental').then(r => r?.decorators === true)
          if (useDecorators) {
            return 'es2024'
          }
          return 'esnext'
        },
      },
      jsxFactory: 'h',
      jsxFragment: 'Fragment',
      tsconfigRaw: {
        $resolve: async (_val, get) => {
          const val: NonNullable<Exclude<TransformOptions['tsconfigRaw'], string>> = typeof _val === 'string' ? JSON.parse(_val) : (_val && typeof _val === 'object' ? _val : {})

          const useDecorators = await get('experimental').then(r => r?.decorators === true)
          if (!useDecorators) {
            return val
          }
          // Force experimentalDecorators to false if decorators are enabled
          return defu({
            compilerOptions: {
              experimentalDecorators: false,
            },
          } satisfies TransformOptions['tsconfigRaw'], val)
        },
      },
    },
  },
})
</file>

<file path="packages/schema/src/config/experimental.ts">
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  future: {
    compatibilityVersion: {
      // force resolution to `4` no matter what users pass
      $resolve: val => typeof val === 'number' ? val as 4 | 5 : 4,
    },
    multiApp: false,
    typescriptBundlerResolution: {
      async $resolve (val, get) {
        // @ts-expect-error TODO: remove in v3.10
        val = typeof val === 'boolean' ? val : await (get('experimental')).then(e => e?.typescriptBundlerResolution as string | undefined)
        if (typeof val === 'boolean') { return val }
        const setting = await get('typescript.tsConfig').then(r => r?.compilerOptions?.moduleResolution)
        if (setting) {
          return setting.toLowerCase() === 'bundler'
        }
        return true
      },
    },
  },
  features: {
    inlineStyles: {
      async $resolve (_val, get) {
        const val = typeof _val === 'boolean' || typeof _val === 'function'
          ? _val
          // @ts-expect-error TODO: legacy property - remove in v3.10
          : await (get('experimental')).then(e => e?.inlineSSRStyles) as undefined | boolean
        if (
          val === false ||
          (await get('dev')) ||
          (await get('ssr')) === false
        ) {
          return false
        }
        // Enabled by default for prod with ssr (for vue components)
        return val ?? ((id?: string) => !!id && id.includes('.vue'))
      },
    },
    devLogs: {
      async $resolve (val, get) {
        if (typeof val === 'boolean' || val === 'silent') {
          return val
        }
        const [isDev, isTest] = await Promise.all([get('dev'), get('test')])
        return isDev && !isTest
      },
    },
    noScripts: {
      async $resolve (val, get) {
        const isValidLiteral = (val: unknown): val is 'production' | 'all' => {
          return typeof val === 'string' && ['production', 'all'].includes(val)
        }
        return val === true
          ? 'production'
          : val === false || isValidLiteral(val)
            ? val
            // @ts-expect-error TODO: legacy property - remove in v3.10
            : (await (get('experimental')).then(e => e?.noScripts as boolean | undefined && 'production') ?? false)
      },
    },
  },
  experimental: {
    decorators: false,
    asyncEntry: {
      $resolve: val => typeof val === 'boolean' ? val : false,
    },

    // TODO: Remove when nitro has support for mocking traced dependencies
    // https://github.com/nitrojs/nitro/issues/1118
    externalVue: true,
    serverAppConfig: false,
    emitRouteChunkError: {
      $resolve: (val) => {
        if (val === true) {
          return 'manual'
        }
        if (val === 'reload') {
          return 'automatic'
        }
        if (val === false) {
          return false
        }

        const validOptions = new Set(['manual', 'automatic', 'automatic-immediate'] as const)
        type EmitRouteChunkError = typeof validOptions extends Set<infer Option> ? Option : never
        if (typeof val === 'string' && validOptions.has(val as EmitRouteChunkError)) {
          return val as EmitRouteChunkError
        }

        return 'automatic'
      },
    },
    templateRouteInjection: true,
    restoreState: false,
    renderJsonPayloads: true,
    noVueServer: false,
    payloadExtraction: true,
    clientFallback: false,
    crossOriginPrefetch: false,
    viewTransition: false,
    writeEarlyHints: false,
    componentIslands: {
      $resolve: (val) => {
        if (val === 'local+remote') {
          return { remoteIsland: true }
        }
        if (val === 'local') {
          return true
        }
        return val ?? 'auto'
      },
    },
    localLayerAliases: true,
    typedPages: false,
    appManifest: true,
    checkOutdatedBuildInterval: 1000 * 60 * 60,
    watcher: {
      $resolve: async (val, get) => {
        const validOptions = new Set(['chokidar', 'parcel', 'chokidar-granular'] as const)
        type WatcherOption = typeof validOptions extends Set<infer Option> ? Option : never
        if (typeof val === 'string' && validOptions.has(val as WatcherOption)) {
          return val as WatcherOption
        }
        const [srcDir, rootDir] = await Promise.all([get('srcDir'), get('rootDir')])
        if (srcDir === rootDir) {
          return 'chokidar-granular' as const
        }
        return 'chokidar' as const
      },
    },
    asyncContext: false,
    headNext: true,
    inlineRouteRules: false,
    scanPageMeta: {
      $resolve (val) {
        return typeof val === 'boolean' || val === 'after-resolve' ? val : 'after-resolve'
      },
    },
    extraPageMetaExtractionKeys: [],
    sharedPrerenderData: {
      $resolve (val) {
        return typeof val === 'boolean' ? val : true
      },
    },
    cookieStore: true,
    defaults: {
      nuxtLink: {
        componentName: 'NuxtLink',
        prefetch: true,
        prefetchOn: {
          visibility: true,
        },
      },
      useAsyncData: {
        deep: false,
      },
      useFetch: {},
    },
    clientNodeCompat: false,
    navigationRepaint: true,
    buildCache: false,
    normalizeComponentNames: {
      $resolve: (val) => {
        return typeof val === 'boolean' ? val : true
      },
    },
    spaLoadingTemplateLocation: {
      $resolve: (val) => {
        const validOptions = new Set(['body', 'within'] as const)
        type SpaLoadingTemplateLocation = typeof validOptions extends Set<infer Option> ? Option : never
        return typeof val === 'string' && validOptions.has(val as SpaLoadingTemplateLocation) ? val as SpaLoadingTemplateLocation : 'body'
      },
    },
    browserDevtoolsTiming: {
      $resolve: async (val, get) => typeof val === 'boolean' ? val : await get('dev'),
    },
    chromeDevtoolsProjectSettings: true,
    debugModuleMutation: {
      $resolve: async (val, get) => {
        return typeof val === 'boolean' ? val : Boolean(await get('debug'))
      },
    },
    lazyHydration: {
      $resolve: (val) => {
        return typeof val === 'boolean' ? val : true
      },
    },
    templateImportResolution: true,
    purgeCachedData: {
      $resolve: (val) => {
        return typeof val === 'boolean' ? val : true
      },
    },
    granularCachedData: {
      $resolve: (val) => {
        return typeof val === 'boolean' ? val : true
      },
    },
    alwaysRunFetchOnKeyChange: {
      $resolve: (val) => {
        return typeof val === 'boolean' ? val : false
      },
    },
    parseErrorData: {
      $resolve: (val) => {
        return typeof val === 'boolean' ? val : true
      },
    },
    enforceModuleCompatibility: false,
    pendingWhenIdle: {
      $resolve: (val) => {
        return typeof val === 'boolean' ? val : false
      },
    },
    entryImportMap: true,
    extractAsyncDataHandlers: {
      $resolve: (val) => {
        return typeof val === 'boolean' ? val : false
      },
    },
    viteEnvironmentApi: {
      $resolve: async (val, get) => {
        return typeof val === 'boolean' ? val : (await get('future.compatibilityVersion')) >= 5
      },
    },
  },
})
</file>

<file path="packages/schema/src/config/generate.ts">
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  // @ts-expect-error TODO: remove in nuxt v5
  generate: {
    routes: [],
    exclude: [],
  },
})
</file>

<file path="packages/schema/src/config/index.ts">
import adhoc from './adhoc.ts'
import app from './app.ts'
import build from './build.ts'
import common from './common.ts'
import dev from './dev.ts'
import esbuild from './esbuild.ts'
import oxc from './oxc.ts'
import experimental from './experimental.ts'
import generate from './generate.ts'
import internal from './internal.ts'
import nitro from './nitro.ts'
import postcss from './postcss.ts'
import router from './router.ts'
import typescript from './typescript.ts'
import vite from './vite.ts'
import webpack from './webpack.ts'

export default {
  ...adhoc,
  ...app,
  ...build,
  ...common,
  ...dev,
  ...experimental,
  ...generate,
  ...internal,
  ...nitro,
  ...postcss,
  ...router,
  ...typescript,
  ...esbuild,
  ...oxc,
  ...vite,
  ...webpack,
}
</file>

<file path="packages/schema/src/config/internal.ts">
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  _majorVersion: 4,
  _legacyGenerate: false,
  _start: false,
  _build: false,
  _generate: false,
  _prepare: false,
  _cli: false,
  _requiredModules: {},
  _loadOptions: undefined,
  _nuxtConfigFile: undefined,
  _nuxtConfigFiles: [],
  appDir: '',
  _installedModules: [],
  _modules: [],
})
</file>

<file path="packages/schema/src/config/nitro.ts">
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  server: {
    builder: {
      $resolve: (val) => {
        if (typeof val === 'string') {
          return val
        }
        if (val && typeof val === 'object' && 'bundle' in val) {
          return val
        }
        return '@nuxt/nitro-server'
      },
    },
  },
  nitro: {
    runtimeConfig: {
      $resolve: async (val, get) => {
        const runtimeConfig = await get('runtimeConfig')
        return {
          ...runtimeConfig,
          app: {
            ...runtimeConfig.app,
            baseURL: runtimeConfig.app.baseURL.startsWith('./')
              ? runtimeConfig.app.baseURL.slice(1)
              : runtimeConfig.app.baseURL,
          },
          nitro: {
            envPrefix: 'NUXT_',
            ...runtimeConfig.nitro,
          },
        }
      },
    },
    routeRules: {
      $resolve: async (val, get) => {
        return {
          ...await get('routeRules'),
          ...(val && typeof val === 'object' ? val : {}),
        }
      },
    },
  },
  routeRules: {},
  serverHandlers: [],
  devServerHandlers: [],
})
</file>

<file path="packages/schema/src/config/oxc.ts">
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  oxc: {
    transform: {
      options: {
        target: {
          $resolve: async (val, get) => {
            if (typeof val === 'string') {
              return val
            }
            // https://github.com/vitejs/vite-plugin-vue/issues/528
            const useDecorators = await get('experimental').then(
              r => r?.decorators === true,
            )
            if (useDecorators) {
              return 'es2024'
            }
            return 'esnext'
          },
        },
        jsxFactory: 'h',
        jsxFragment: 'Fragment',
      },
    },
  },
})
</file>

<file path="packages/schema/src/config/postcss.ts">
import { defineResolvers } from '../utils/definition.ts'

const ensureItemIsLast = (item: string) => (arr: string[]) => {
  const index = arr.indexOf(item)
  if (index !== -1) {
    arr.splice(index, 1)
    arr.push(item)
  }
  return arr
}

const orderPresets = {
  cssnanoLast: ensureItemIsLast('cssnano'),
  autoprefixerLast: ensureItemIsLast('autoprefixer'),
  autoprefixerAndCssnanoLast (names: string[]) {
    return orderPresets.cssnanoLast(orderPresets.autoprefixerLast(names))
  },
}

export default defineResolvers({
  postcss: {
    order: {
      $resolve: (val) => {
        if (typeof val === 'string') {
          if (!(val in orderPresets)) {
            throw new Error(`[nuxt] Unknown PostCSS order preset: ${val}`)
          }
          return orderPresets[val as keyof typeof orderPresets]
        }
        if (typeof val === 'function') {
          return val as (names: string[]) => string[]
        }
        if (Array.isArray(val)) {
          return val
        }
        return orderPresets.autoprefixerAndCssnanoLast
      },
    },
    plugins: {
      autoprefixer: {},
      cssnano: {
        $resolve: async (val, get) => {
          if (val || val === false) {
            return val
          }
          if (await get('dev')) {
            return false
          }
          return {}
        },
      },
    },
  },
})
</file>

<file path="packages/schema/src/config/router.ts">
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  router: {
    options: {
      hashMode: false,
      scrollBehaviorType: 'auto',
    },
  },
})
</file>

<file path="packages/schema/src/config/typescript.ts">
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  typescript: {
    strict: true,
    builder: {
      $resolve: (val) => {
        const validBuilderTypes = new Set(['vite', 'webpack', 'rspack', 'shared'] as const)
        type ValidBuilderType = typeof validBuilderTypes extends Set<infer Option> ? Option : never
        if (typeof val === 'string' && validBuilderTypes.has(val as ValidBuilderType)) {
          return val as ValidBuilderType
        }
        if (val === false) {
          return false
        }
        return null
      },
    },
    hoist: {
      $resolve: (val) => {
        const defaults = [
          // Nitro auto-imported/augmented dependencies
          'nitro/types',
          'nitro/runtime',
          // TODO: remove in v5
          'nitropack/types',
          'nitropack/runtime',
          'nitropack',
          'defu',
          'h3',
          'consola',
          'ofetch',
          'crossws',
          // Key nuxt dependencies
          '@unhead/vue',
          '@nuxt/devtools',
          'vue',
          '@vue/runtime-core',
          '@vue/compiler-sfc',
          'vue-router',
          'vue-router/auto-routes',
          'unplugin-vue-router/client',
          '@nuxt/schema',
          'nuxt',
        ]
        return val === false ? [] : (Array.isArray(val) ? val.concat(defaults) : defaults)
      },
    },
    includeWorkspace: false,
    typeCheck: false,
    tsConfig: {},
    shim: false,
  },
})
</file>

<file path="packages/schema/src/config/vite.ts">
import { defu } from 'defu'
import { resolve } from 'pathe'
import { isTest } from 'std-env'
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  vite: {
    root: {
      $resolve: async (val, get) => typeof val === 'string' ? val : (await get('srcDir')),
    },
    mode: {
      $resolve: async (val, get) => typeof val === 'string' ? val : (await get('dev') ? 'development' : 'production'),
    },
    define: {
      $resolve: async (_val, get) => {
        const [isDev, isDebug] = await Promise.all([get('dev'), get('debug')])
        return {
          '__VUE_PROD_HYDRATION_MISMATCH_DETAILS__': Boolean(isDebug && (isDebug === true || isDebug.hydration)),
          'process.dev': isDev,
          'import.meta.dev': isDev,
          'process.test': isTest,
          'import.meta.test': isTest,
          ..._val && typeof _val === 'object' ? _val : {},
        }
      },
    },
    resolve: {
      extensions: ['.mjs', '.js', '.ts', '.jsx', '.tsx', '.json', '.vue'],
    },
    publicDir: {
      $resolve: (val) => {
        if (val) {
          console.warn('Directly configuring the `vite.publicDir` option is not supported. Instead, set `dir.public`. You can read more in `https://nuxt.com/docs/4.x/api/nuxt-config#public`.')
        }
        // this is missing from our `vite` types deliberately, so users do not configure it
        return false as never
      },
    },
    vue: {
      isProduction: {
        $resolve: async (val, get) => typeof val === 'boolean' ? val : !(await get('dev')),
      },
      template: {
        compilerOptions: {
          $resolve: async (val, get) => val ?? (await get('vue')).compilerOptions,
        },
        transformAssetUrls: {
          $resolve: async (val, get) => val ?? (await get('vue')).transformAssetUrls,
        },
      },
      script: {
        hoistStatic: {
          $resolve: async (val, get) => typeof val === 'boolean' ? val : (await get('vue')).compilerOptions?.hoistStatic,
        },
      },
      features: {
        propsDestructure: {
          $resolve: async (val, get) => {
            if (typeof val === 'boolean') {
              return val
            }
            const vueOptions = await get('vue') || {}
            return Boolean(
              // @ts-expect-error TODO: remove in future: supporting a legacy schema
              vueOptions.script?.propsDestructure
              ?? vueOptions.propsDestructure,
            )
          },
        },
      },
    },
    vueJsx: {
      $resolve: async (val, get) => {
        return {
          // TODO: investigate type divergence between types for @vue/compiler-core and @vue/babel-plugin-jsx
          isCustomElement: (await get('vue')).compilerOptions?.isCustomElement as undefined | ((tag: string) => boolean),
          ...typeof val === 'object' ? val : {},
        }
      },
    },
    optimizeDeps: {
      esbuildOptions: {
        $resolve: async (val, get) => defu(val && typeof val === 'object' ? val : {}, await get('esbuild.options')),
      },
      exclude: {
        $resolve: val => [
          ...Array.isArray(val) ? val : [],
          'vue-demi',
        ],
      },
    },
    esbuild: {
      $resolve: async (val, get) => {
        return defu(val && typeof val === 'object' ? val : {}, await get('esbuild.options'))
      },
    },
    clearScreen: true,
    build: {
      assetsDir: {
        $resolve: async (val, get) => typeof val === 'string' ? val : (await get('app')).buildAssetsDir?.replace(/^\/+/, ''),
      },
      emptyOutDir: false,
    },
    server: {
      fs: {
        allow: {
          $resolve: async (val, get) => {
            const [buildDir, srcDir, rootDir, workspaceDir] = await Promise.all([get('buildDir'), get('srcDir'), get('rootDir'), get('workspaceDir')])
            return [...new Set([
              buildDir,
              srcDir,
              rootDir,
              workspaceDir,
              ...Array.isArray(val) ? val : [],
            ])]
          },
        },
      },
    },
    cacheDir: {
      $resolve: async (val, get) => typeof val === 'string' ? val : resolve(await get('rootDir'), 'node_modules/.cache/vite'),
    },
  },
})
</file>

<file path="packages/schema/src/config/webpack.ts">
import process from 'node:process'
import { defu } from 'defu'
import { defineResolvers } from '../utils/definition.ts'

export default defineResolvers({
  webpack: {
    analyze: {
      $resolve: async (val, get) => {
        const value = typeof val === 'boolean' ? { enabled: val } : (val && typeof val === 'object' ? val : {})
        return defu(value, await get('build.analyze') as { enabled?: boolean } | Record<string, unknown>)
      },
    },
    profile: process.argv.includes('--profile'),
    extractCSS: true,
    cssSourceMap: {
      $resolve: async (val, get) => typeof val === 'boolean' ? val : await get('dev'),
    },
    serverURLPolyfill: 'url',
    filenames: {
      app: ({ isDev }: { isDev: boolean }) => isDev ? '[name].js' : '[contenthash:7].js',
      chunk: ({ isDev }: { isDev: boolean }) => isDev ? '[name].js' : '[contenthash:7].js',
      css: ({ isDev }: { isDev: boolean }) => isDev ? '[name].css' : 'css/[contenthash:7].css',
      img: ({ isDev }: { isDev: boolean }) => isDev ? '[path][name].[ext]' : 'img/[name].[contenthash:7].[ext]',
      font: ({ isDev }: { isDev: boolean }) => isDev ? '[path][name].[ext]' : 'fonts/[name].[contenthash:7].[ext]',
      video: ({ isDev }: { isDev: boolean }) => isDev ? '[path][name].[ext]' : 'videos/[name].[contenthash:7].[ext]',
    },
    loaders: {
      $resolve: async (val, get) => {
        const loaders: Record<string, any> = val && typeof val === 'object' ? val : {}
        const styleLoaders = [
          'css', 'cssModules', 'less',
          'sass', 'scss', 'stylus', 'vueStyle',
        ]
        for (const name of styleLoaders) {
          const loader = loaders[name]
          if (loader && loader.sourceMap === undefined) {
            loader.sourceMap = Boolean(
              // @ts-expect-error TODO: remove legacay configuration
              await get('build.cssSourceMap'),
            )
          }
        }
        return loaders
      },
      esbuild: {
        $resolve: async (val, get) => {
          return defu(val && typeof val === 'object' ? val : {}, await get('esbuild.options'))
        },
      },
      file: { esModule: false, limit: 1000 },
      fontUrl: { esModule: false, limit: 1000 },
      imgUrl: { esModule: false, limit: 1000 },
      pugPlain: {},
      vue: {
        transformAssetUrls: {
          $resolve: async (val, get) => (val ?? (await get('vue.transformAssetUrls'))),
        },
        compilerOptions: {
          $resolve: async (val, get) => (val ?? (await get('vue.compilerOptions'))),
        },
        propsDestructure: {
          $resolve: async (val, get) => Boolean(val ?? await get('vue.propsDestructure')),
        },
      },
      css: {
        importLoaders: 0,
        url: {
          filter: (url: string, _resourcePath: string) => url[0] !== '/',
        },
        esModule: false,
      },
      cssModules: {
        importLoaders: 0,
        url: {
          filter: (url: string, _resourcePath: string) => url[0] !== '/',
        },
        esModule: false,
        modules: {
          localIdentName: '[local]_[hash:base64:5]',
        },
      },
      less: {},
      sass: {
        sassOptions: {
          indentedSyntax: true,
        },
      },
      scss: {},
      stylus: {},

      vueStyle: {},
    },
    plugins: [],
    aggressiveCodeRemoval: false,
    optimizeCSS: {
      $resolve: async (val, get) => {
        if (val === false || (val && typeof val === 'object')) {
          return val
        }
        // @ts-expect-error TODO: remove legacy configuration
        const extractCSS = await get('build.extractCSS')
        return extractCSS ? {} : false
      },
    },
    optimization: {
      runtimeChunk: 'single',
      minimize: {
        $resolve: async (val, get) => typeof val === 'boolean' ? val : !(await get('dev')),
      },
      minimizer: undefined,
      splitChunks: {
        chunks: 'all',
        automaticNameDelimiter: '/',
        cacheGroups: {},
      },
    },
    postcss: {
      postcssOptions: {
        plugins: {
          $resolve: async (val, get) => val && typeof val === 'object' ? val : (await get('postcss.plugins')),
        },
      },
    },
    devMiddleware: {
      stats: 'none',
    },
    hotMiddleware: {},
    friendlyErrors: true,
    warningIgnoreFilters: [],
    experiments: {},
  },
})
</file>

<file path="packages/schema/src/types/builder-env/index.ts">
import type { ViteImportMeta } from './vite.ts'
import type { WebpackImportMeta } from './webpack.ts'

export type BundlerImportMeta = ViteImportMeta & WebpackImportMeta

declare global {
  interface ImportMeta extends BundlerImportMeta {
    /** the `file:` url of the current file (similar to `__filename` but as file url) */
    url: string

    readonly env: Record<string, string | boolean | undefined>
  }
}
</file>

<file path="packages/schema/src/types/builder-env/vite.ts">
/**
 * Reference: https://github.com/vitejs/vite/blob/main/packages/vite/types/importMeta.d.ts
 */
export type ModuleNamespace = Record<string, any> & {
  [Symbol.toStringTag]: 'Module'
}

export interface ViteHot {
  readonly data: any

  accept (): void
  accept (cb: (mod: ModuleNamespace | undefined) => void): void
  accept (dep: string, cb: (mod: ModuleNamespace | undefined) => void): void
  accept (deps: readonly string[], cb: (mods: Array<ModuleNamespace | undefined>) => void): void
  acceptExports (exportNames: string | readonly string[], cb?: (mod: ModuleNamespace | undefined) => void): void

  dispose (cb: (data: any) => void): void
  prune (cb: (data: any) => void): void
  invalidate (message?: string): void

  on (event: any, cb: (payload: any) => void): void
  send (event: any, data?: any): void
}

export interface KnownAsTypeMap {
  raw: string
  url: string
  worker: Worker
}

export interface ImportGlobOptions<
  Eager extends boolean,
  AsType extends string,
> {
  /**
   * Import type for the import url.
   */
  as?: AsType
  /**
   * Import as static or dynamic
   */
  eager?: Eager
  /**
   * Import only the specific named export. Set to `default` to import the default export.
   */
  import?: string
  /**
   * Custom queries
   */
  query?: string | Record<string, string | number | boolean>
  /**
   * Search files also inside `node_modules/` and hidden directories (e.g. `.git/`). This might have impact on performance.
   */
  exhaustive?: boolean
}

export interface ImportGlobFunction {
  /**
   * Import a list of files with a glob pattern.
   *
   * Overload 1: No generic provided, infer the type from `eager` and `as`
   */
  <
    Eager extends boolean,
    As extends string,
    T = As extends keyof KnownAsTypeMap ? KnownAsTypeMap[As] : unknown,
  >(
    glob: string | string[],
    options?: ImportGlobOptions<Eager, As>
  ): (Eager extends true
    ? true
    : false) extends true
    ? Record<string, T>
    : Record<string, () => Promise<T>>
  /**
   * Import a list of files with a glob pattern.
   *
   * Overload 2: Module generic provided, infer the type from `eager: false`
   */
  <M>(
    glob: string | string[],
    options?: ImportGlobOptions<false, string>
  ): Record<string, () => Promise<M>>
  /**
   * Import a list of files with a glob pattern.
   *
   * Overload 3: Module generic provided, infer the type from `eager: true`
   */
  <M>(
    glob: string | string[],
    options: ImportGlobOptions<true, string>
  ): Record<string, M>
}

export interface ImportGlobEagerFunction {
  /**
   * Eagerly import a list of files with a glob pattern.
   *
   * Overload 1: No generic provided, infer the type from `as`
   */
  <
    As extends string,
    T = As extends keyof KnownAsTypeMap ? KnownAsTypeMap[As] : unknown,
  >(
    glob: string | string[],
    options?: Omit<ImportGlobOptions<boolean, As>, 'eager'>
  ): Record<string, T>
  /**
   * Eagerly import a list of files with a glob pattern.
   *
   * Overload 2: Module generic provided
   */
  <M>(
    glob: string | string[],
    options?: Omit<ImportGlobOptions<boolean, string>, 'eager'>
  ): Record<string, M>
}

export interface ViteImportMeta {
  /** Vite client HMR API - see https://vite.dev/guide/api-hmr */
  readonly hot?: ViteHot

  /** vite glob import utility - https://vite.dev/guide/features.html#glob-import */
  glob: ImportGlobFunction

  /**
   * @deprecated Use `import.meta.glob('*', { eager: true })` instead
   */
  globEager: ImportGlobEagerFunction
}
</file>

<file path="packages/schema/src/types/builder-env/webpack.ts">
/**
 * Reference: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/webpack-env/index.d.ts
 */

export type WebpackModuleId = string | number

export interface HotNotifierInfo {
  type:
  | 'self-declined'
  | 'declined'
  | 'unaccepted'
  | 'accepted'
  | 'disposed'
  | 'accept-errored'
  | 'self-accept-errored'
  | 'self-accept-error-handler-errored'
  /**
   * The module in question.
   */
  moduleId: number
  /**
   * For errors: the module id owning the accept handler.
   */
  dependencyId?: number | undefined
  /**
   * For declined/accepted/unaccepted: the chain from where the update was propagated.
   */
  chain?: number[] | undefined
  /**
   * For declined: the module id of the declining parent
   */
  parentId?: number | undefined
  /**
   * For accepted: the modules that are outdated and will be disposed
   */
  outdatedModules?: number[] | undefined
  /**
   * For accepted: The location of accept handlers that will handle the update
   */
  outdatedDependencies?: {
    [dependencyId: number]: number[]
  } | undefined
  /**
   * For errors: the thrown error
   */
  error?: Error | undefined
  /**
   * For self-accept-error-handler-errored: the error thrown by the module
   * before the error handler tried to handle it.
   */
  originalError?: Error | undefined
}

export interface AcceptOptions {
  /**
   * If true the update process continues even if some modules are not accepted (and would bubble to the entry point).
   */
  ignoreUnaccepted?: boolean | undefined
  /**
   * Ignore changes made to declined modules.
   */
  ignoreDeclined?: boolean | undefined
  /**
   *  Ignore errors throw in accept handlers, error handlers and while reevaluating module.
   */
  ignoreErrored?: boolean | undefined
  /**
   * Notifier for declined modules.
   */
  onDeclined?: ((info: HotNotifierInfo) => void) | undefined
  /**
   * Notifier for unaccepted modules.
   */
  onUnaccepted?: ((info: HotNotifierInfo) => void) | undefined
  /**
   * Notifier for accepted modules.
   */
  onAccepted?: ((info: HotNotifierInfo) => void) | undefined
  /**
   * Notifier for disposed modules.
   */
  onDisposed?: ((info: HotNotifierInfo) => void) | undefined
  /**
   * Notifier for errors.
   */
  onErrored?: ((info: HotNotifierInfo) => void) | undefined
  /**
   * Indicates that apply() is automatically called by check function
   */
  autoApply?: boolean | undefined
}

export interface WebpackHot {
  /**
   * Accept code updates for the specified dependencies. The callback is called when dependencies were replaced.
   * @param dependencies
   * @param callback
   * @param errorHandler
   */
  accept (dependencies: string[], callback?: (updatedDependencies: WebpackModuleId[]) => void, errorHandler?: (err: Error) => void): void
  /**
   * Accept code updates for the specified dependencies. The callback is called when dependencies were replaced.
   * @param dependency
   * @param callback
   * @param errorHandler
   */
  accept (dependency: string, callback?: () => void, errorHandler?: (err: Error) => void): void
  /**
   * Accept code updates for this module without notification of parents.
   * This should only be used if the module doesn’t export anything.
   * The errHandler can be used to handle errors that occur while loading the updated module.
   * @param errHandler
   */
  accept (errHandler?: (err: Error) => void): void
  /**
   * Do not accept updates for the specified dependencies. If any dependencies is updated, the code update fails with code "decline".
   */
  decline (dependencies: string[]): void
  /**
   * Do not accept updates for the specified dependencies. If any dependencies is updated, the code update fails with code "decline".
   */
  decline (dependency: string): void
  /**
   * Flag the current module as not update-able. If updated the update code would fail with code "decline".
   */
  decline (): void
  /**
   * Add a one time handler, which is executed when the current module code is replaced.
   * Here you should destroy/remove any persistent resource you have claimed/created.
   * If you want to transfer state to the new module, add it to data object.
   * The data will be available at module.hot.data on the new module.
   * @param callback
   */
  dispose (callback: (data: any) => void): void
  dispose (callback: <T>(data: T) => void): void
  /**
   * Add a one time handler, which is executed when the current module code is replaced.
   * Here you should destroy/remove any persistent resource you have claimed/created.
   * If you want to transfer state to the new module, add it to data object.
   * The data will be available at module.hot.data on the new module.
   * @param callback
   */
  addDisposeHandler (callback: (data: any) => void): void
  addDisposeHandler<T> (callback: (data: T) => void): void
  /**
   * Remove a handler.
   * This can useful to add a temporary dispose handler. You could i. e. replace code while in the middle of a multi-step async function.
   * @param callback
   */
  removeDisposeHandler (callback: (data: any) => void): void
  removeDisposeHandler<T> (callback: (data: T) => void): void
  /**
   * Throws an exceptions if status() is not idle.
   * Check all currently loaded modules for updates and apply updates if found.
   * If no update was found, the callback is called with null.
   * If autoApply is truthy the callback will be called with all modules that were disposed.
   * apply() is automatically called with autoApply as options parameter.
   * If autoApply is not set the callback will be called with all modules that will be disposed on apply().
   * @param autoApply
   * @param callback
   */
  check (autoApply: boolean, callback: (err: Error, outdatedModules: WebpackModuleId[]) => void): void
  /**
   * Throws an exceptions if status() is not idle.
   * Check all currently loaded modules for updates and apply updates if found.
   * If no update was found, the callback is called with null.
   * The callback will be called with all modules that will be disposed on apply().
   * @param callback
   */
  check (callback: (err: Error, outdatedModules: WebpackModuleId[]) => void): void
  /**
   * If status() != "ready" it throws an error.
   * Continue the update process.
   * @param options
   * @param callback
   */
  apply (options: AcceptOptions, callback: (err: Error, outdatedModules: WebpackModuleId[]) => void): void
  /**
   * If status() != "ready" it throws an error.
   * Continue the update process.
   * @param callback
   */
  apply (callback: (err: Error, outdatedModules: WebpackModuleId[]) => void): void
  /**
   * Return one of idle, check, watch, watch-delay, prepare, ready, dispose, apply, abort or fail.
   */
  status (): string
  /** Register a callback on status change. */
  status (callback: (status: string) => void): void
  /** Register a callback on status change. */
  addStatusHandler (callback: (status: string) => void): void
  /**
   * Remove a registered status change handler.
   * @param callback
   */
  removeStatusHandler (callback: (status: string) => void): void

  active: boolean
  data: any
}

export interface WebpackImportMeta {
  /** an alias for `module.hot` - see https://webpack.js.org/api/hot-module-replacement/ */
  webpackHot?: WebpackHot | undefined

  /** the webpack major version as number */
  webpack?: number
}
</file>

<file path="packages/schema/src/types/compatibility.ts">
export interface NuxtCompatibility {
  /**
   * Required nuxt version in semver format.
   * @example `^3.2.0` or `>=3.13.0`.
   */
  nuxt?: string

  /**
   * Mark a builder as incompatible, or require a particular version.
   *
   * @example
   * ```ts
   * export default defineNuxtModule({
   *   meta: {
   *     name: 'my-module',
   *     compatibility: {
   *       builder: {
   *         // marking as incompatible
   *         webpack: false,
   *         // you can require a (semver-compatible) version
   *         vite: '^5'
   *       }
   *     }
   *   }
   *   // ...
   * })
   * ```
   */
  builder?: Partial<Record<'vite' | 'webpack' | 'rspack' | (string & {}), false | string>>
}

export interface NuxtCompatibilityIssue {
  name: string
  message: string
}

export interface NuxtCompatibilityIssues extends Array<NuxtCompatibilityIssue> {
  /**
   * Return formatted error message.
   */
  toString(): string
}
</file>

<file path="packages/schema/src/types/compiler.ts">
export interface KeyedFunction {
  /**
   * The name of the function.
   *
   * Use 'default' to target a module's default export. In that case, the callable name
   * is derived from the filename (camel-cased) for matching during analysis.
   */
  name: string
  /**
   * The path to the file where the function is defined.
   * You can use Nuxt aliases (~ or @) to refer to directories inside the project or directly use an npm package path similar to require.
   */
  source: string
  /**
   * The maximum number of arguments the function can accept.
   * In the case that the function is called with fewer arguments than this number,
   * the compiler will inject an auto-generated key as an additional argument.
   *
   * The key is unique based on the location of the function being invoked within the file.
   *
   * @example `{ name: 'useKey', source: '~/composables/useKey', argumentLength: 2 }`
   *
   * ```ts
   * useKey()                  // will be transformed to: useKey('\$KzLSZ0O59L')
   * useKey('first')           // will be transformed to: useKey('first', '\$KzLSZ0O59L')
   * useKey('first', 'second') // will not be transformed
   * ```
   */
  argumentLength: number
}
</file>

<file path="packages/schema/src/types/components.ts">
export interface ComponentMeta {
  [key: string]: unknown
}

export interface Component {
  pascalName: string
  kebabName: string
  export: string
  filePath: string
  shortPath: string
  chunkName: string
  prefetch: boolean
  preload: boolean
  global?: boolean | 'sync'
  island?: boolean
  meta?: ComponentMeta
  mode?: 'client' | 'server' | 'all'
  /**
   * This number allows configuring the behavior of overriding Nuxt components.
   * If multiple components are provided with the same name, then higher priority
   * components will be used instead of lower priority components.
   */
  priority?: number
  /**
   * Path to component's declaration file
   * Used for type generation when different from filePath
   * @default filePath
   */
  declarationPath?: string
  /**
   * Allow bypassing client/server transforms for internal Nuxt components like
   * ServerPlaceholder and NuxtClientFallback.
   *
   * @internal
   */
  _raw?: boolean
}

export interface ScanDir {
  /**
   * Path (absolute or relative) to the directory containing your components.
   * You can use Nuxt aliases (~ or @) to refer to directories inside project or directly use an npm package path similar to require.
   */
  path: string
  /**
   * Accept Pattern that will be run against specified path.
   */
  pattern?: string | string[]
  /**
   * Ignore patterns that will be run against specified path.
   */
  ignore?: string[]
  /**
   * Prefix all matched components.
   */
  prefix?: string
  /**
   * Prefix component name by its path.
   */
  pathPrefix?: boolean
  /**
   * These properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments.
   * Learn more on webpack documentation: https://webpack.js.org/api/module-methods/#magic-comments
   */
  prefetch?: boolean
  /**
   * These properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments.
   * Learn more on webpack documentation: https://webpack.js.org/api/module-methods/#magic-comments
   */
  preload?: boolean
  /**
   * This flag indicates, component should be loaded async (with a separate chunk) regardless of using Lazy prefix or not.
   */
  isAsync?: boolean
  extendComponent?: (component: Component) => Promise<Component | void> | (Component | void)
  /**
   * If enabled, registers components to be globally available.
   *
   */
  global?: boolean
  /**
   * If enabled, registers components as islands
   */
  island?: boolean
}

export interface ComponentsDir extends ScanDir {
  /**
   * Watch specified path for changes, including file additions and file deletions.
   */
  watch?: boolean
  /**
   * Extensions supported by Nuxt builder.
   */
  extensions?: string[]
  /**
   * Transpile specified path using build.transpile.
   * By default ('auto') it will set transpile: true if node_modules/ is in path.
   */
  transpile?: 'auto' | boolean
  /**
   * This number allows configuring the behavior of overriding Nuxt components.
   * It will be inherited by any components within the directory.
   *
   * If multiple components are provided with the same name, then higher priority
   * components will be used instead of lower priority components.
   */
  priority?: number
}

export interface ComponentsOptions {
  dirs: (string | ComponentsDir)[]
  /**
   * The default value for whether to globally register components.
   *
   * When components are registered globally, they will still be directly imported where used,
   * but they can also be used dynamically, for example `<component :is="`icon-${myIcon}`">`.
   *
   * This can be overridden by an individual component directory entry.
   */
  global?: boolean
  /**
   * Whether to write metadata to the build directory with information about the components that
   * are auto-registered in your app.
   */
  generateMetadata?: boolean
  loader?: boolean

  transform?: {
    exclude?: RegExp[]
    include?: RegExp[]
  }
}
</file>

<file path="packages/schema/src/types/config.ts">
import type { KeepAliveProps, TransitionProps, AppConfig as VueAppConfig } from 'vue'
import type { ServerOptions as ViteServerOptions, UserConfig as ViteUserConfig } from 'vite'
import type { Options as VuePluginOptions } from '@vitejs/plugin-vue'
import type { Options as VueJsxPluginOptions } from '@vitejs/plugin-vue-jsx'
import type { SchemaDefinition } from 'untyped'
import type { NitroConfig, NitroRuntimeConfig, NitroRuntimeConfigApp } from 'nitropack/types'
import type { SnakeCase } from 'scule'
import type { ResolvedConfig } from 'c12'
import type { ConfigSchema } from './schema.ts'
import type { Nuxt } from './nuxt.ts'
import type { AppHeadMetaObject } from './head.ts'

export type { SchemaDefinition } from 'untyped'

// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
type DeepPartial<T> = T extends Function ? T : T extends Record<string, any> ? { [P in keyof T]?: DeepPartial<T[P]> } : T

export type UpperSnakeCase<S extends string> = Uppercase<SnakeCase<S>>

const message: symbol = Symbol('message')
export type RuntimeValue<T, B extends string> = T & { [message]?: B }
type Overrideable<T extends Record<string, any>, Path extends string = ''> = {
  [K in keyof T]?: K extends string
    ? unknown extends T[K]
      ? unknown
      : T[K] extends Record<string, unknown>
        ? RuntimeValue<Overrideable<T[K], `${Path}_${UpperSnakeCase<K>}`>, `You can override this value at runtime with NUXT${Path}_${UpperSnakeCase<K>}`>
        : RuntimeValue<T[K], `You can override this value at runtime with NUXT${Path}_${UpperSnakeCase<K>}`>
    : K extends number
      ? T[K]
      : never
}

// Runtime Config

type RuntimeConfigNamespace = Record<string, unknown>

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface PublicRuntimeConfig extends RuntimeConfigNamespace { }

export interface RuntimeConfig extends RuntimeConfigNamespace {
  app: NitroRuntimeConfigApp
  /** Only available on the server. */
  nitro?: NitroRuntimeConfig['nitro']
  public: PublicRuntimeConfig
}

// User configuration in `nuxt.config` file
export interface NuxtConfig extends DeepPartial<Omit<ConfigSchema, 'components' | 'vue' | 'vite' | 'runtimeConfig' | 'webpack' | 'nitro'>> {
  components?: ConfigSchema['components']
  vue?: Omit<DeepPartial<ConfigSchema['vue']>, 'config'> & { config?: Partial<Filter<VueAppConfig, string | boolean>> }
  // Avoid DeepPartial for vite config interface (#4772)
  vite?: ConfigSchema['vite']
  // Avoid DeepPartial for nitro config interface (#31908)
  nitro?: NitroConfig
  runtimeConfig?: Overrideable<RuntimeConfig>
  webpack?: DeepPartial<ConfigSchema['webpack']> & {
    $client?: DeepPartial<ConfigSchema['webpack']>
    $server?: DeepPartial<ConfigSchema['webpack']>
  }

  /**
   * Experimental custom config schema
   * @see [Nuxt Issue #15592](https://github.com/nuxt/nuxt/issues/15592)
   */
  $schema?: SchemaDefinition
}

export type NuxtConfigLayer = ResolvedConfig<NuxtConfig & {
  srcDir: ConfigSchema['srcDir']
  rootDir: ConfigSchema['rootDir']
}> & {
  cwd: string
  configFile: string
}

export interface NuxtBuilder {
  bundle: (nuxt: Nuxt) => Promise<void>
}

// Normalized Nuxt options available as `nuxt.options.*`
export interface NuxtOptions extends Omit<ConfigSchema, 'vue' | 'sourcemap' | 'debug' | 'builder' | 'postcss' | 'webpack'> {
  vue: Omit<ConfigSchema['vue'], 'config'> & { config?: Partial<Filter<VueAppConfig, string | boolean>> }
  sourcemap: Required<Exclude<ConfigSchema['sourcemap'], boolean>>
  debug: Required<Exclude<ConfigSchema['debug'], true>>
  builder: '@nuxt/vite-builder' | '@nuxt/webpack-builder' | '@nuxt/rspack-builder' | NuxtBuilder
  postcss: Omit<ConfigSchema['postcss'], 'order'> & { order: Exclude<ConfigSchema['postcss']['order'], string> }
  webpack: ConfigSchema['webpack'] & {
    $client: ConfigSchema['webpack']
    $server: ConfigSchema['webpack']
  }
  _layers: readonly NuxtConfigLayer[]
  $schema: SchemaDefinition
}

export interface ViteConfig extends Omit<ViteUserConfig, 'publicDir'> {
  /** The path to the entrypoint for the Vite build. */
  entry?: string
  /**
   * Options passed to @vitejs/plugin-vue.
   * @see [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue)
   */
  vue?: VuePluginOptions

  /**
   * Options passed to @vitejs/plugin-vue-jsx.
   * @see [@vitejs/plugin-vue-jsx.](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx)
   */
  vueJsx?: VueJsxPluginOptions

  /**
   * Warmup vite entrypoint caches on dev startup.
   */
  warmupEntry?: boolean

  /**
   * Use environment variables or top level `server` options to configure Nuxt server.
   */
  server?: Omit<ViteServerOptions, 'port' | 'host'>
  /**
   * Directly configuring the `vite.publicDir` option is not supported. Instead, set `dir.public`.
   *
   * You can read more in <https://nuxt.com/docs/4.x/api/nuxt-config#public>.
   * @deprecated
   */
  publicDir?: never
}

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface ViteOptions extends ViteConfig {}

// App Config
export interface CustomAppConfig {
  [key: string]: unknown
}

export interface AppConfigInput extends CustomAppConfig {
  /** @deprecated reserved */
  private?: never
  /** @deprecated reserved */
  nuxt?: never
  /** @deprecated reserved */
  nitro?: never
  /** @deprecated reserved */
  server?: never
}

// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
export type Serializable<T> = T extends Function ? never : T extends Promise<infer U> ? Serializable<U> : T extends string & {} ? T : T extends Record<string, any> ? { [K in keyof T]: Serializable<T[K]> } : T

type ValueOf<T> = T[keyof T]
type Filter<T extends Record<string, any>, V> = Pick<T, ValueOf<{ [K in keyof T]: NonNullable<T[K]> extends V ? K : never }>>

export interface NuxtAppConfig {
  head: Serializable<AppHeadMetaObject>
  layoutTransition: boolean | Serializable<TransitionProps>
  pageTransition: boolean | Serializable<TransitionProps>
  viewTransition?: boolean | 'always'
  keepalive: boolean | Serializable<KeepAliveProps>
}

export interface AppConfig {
  [key: string]: unknown
}
</file>

<file path="packages/schema/src/types/debug.ts">
import type { NitroOptions } from 'nitropack/types'
import type { NuxtModule } from './module.ts'

export interface NuxtDebugContext {
  /**
   * Module mutation records to the `nuxt` instance.
   */
  moduleMutationRecords?: NuxtDebugModuleMutationRecord[]
}

export interface NuxtDebugModuleMutationRecord {
  module: NuxtModule
  keys: (string | symbol)[]
  target: 'nuxt.options'
  value: any
  method?: string
  timestamp: number
}

export interface NuxtDebugOptions {
  /** Debug for Nuxt templates */
  templates?: boolean
  /** Debug for modules setup timings */
  modules?: boolean
  /** Debug for file watchers */
  watchers?: boolean
  /** Debug options for Nitro */
  nitro?: NitroOptions['debug']
  /** Debug for production hydration mismatch */
  hydration?: boolean
  /** Debug for Vue Router */
  router?: boolean
  /** Debug for hooks, can be set to `true` or an object with `server` and `client` keys */
  hooks?: boolean | {
    server?: boolean
    client?: boolean
  }
}
</file>

<file path="packages/schema/src/types/head.ts">
import type { AriaAttributes, DataKeys, GlobalAttributes, SerializableHead } from '@unhead/vue/types'

export type MetaObjectRaw = SerializableHead
export type MetaObject = MetaObjectRaw

export type AppHeadMetaObject = MetaObjectRaw & {
  /**
   * The character encoding in which the document is encoded => `<meta charset="<value>" />`
   */
  charset?: string
  /**
   * Configuration of the viewport (the area of the window in which web content can be seen),
   * mapped to => `<meta name="viewport" content="<value>" />`
   */
  viewport?: string
}

export type SerializableHtmlAttributes = GlobalAttributes & AriaAttributes & DataKeys
</file>

<file path="packages/schema/src/types/hooks.ts">
import type { Server as HttpServer } from 'node:http'
import type { Server as HttpsServer } from 'node:https'
import type { TSConfig } from 'pkg-types'
import type { ViteDevServer } from 'vite'
import type { Manifest } from 'vue-bundle-renderer'
import type { EventHandler } from 'h3'
import type { Import, InlinePreset, Unimport } from 'unimport'
import type { Compiler, Configuration, Stats } from 'webpack'
import type { Nitro, NitroConfig, NitroRouteConfig } from 'nitropack/types'
import type { Schema, SchemaDefinition } from 'untyped'
import type { RouteLocationRaw, RouteRecordRaw } from 'vue-router'
import type { RawVueCompilerOptions } from '@vue/language-core'
import type { ViteConfig } from './config.ts'
import type { NuxtCompatibility, NuxtCompatibilityIssues } from './compatibility.ts'
import type { Component, ComponentsOptions } from './components.ts'
import type { Nuxt, NuxtApp, ResolvedNuxtTemplate } from './nuxt.ts'

export type HookResult = Promise<void> | void

// https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html
export type TSReference = { types: string } | { path: string }

export type WatchEvent = 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir'

// If the user does not have `@vue/language-core` installed, RawVueCompilerOptions will be typed as `any`,
// thus making the whole `VueTSConfig` type `any`. We only augment TSConfig if RawVueCompilerOptions is available.
export type VueTSConfig = 0 extends 1 & RawVueCompilerOptions ? TSConfig : TSConfig & { vueCompilerOptions?: RawVueCompilerOptions }

export type NuxtPage = {
  name?: string
  path: string
  props?: RouteRecordRaw['props']
  file?: string
  meta?: Record<string, any>
  alias?: string[] | string
  redirect?: RouteLocationRaw
  children?: NuxtPage[]
  middleware?: string[] | string
  rules?: NitroRouteConfig
  /**
   * Set the render mode.
   *
   * `all` means the page will be rendered isomorphically - with JavaScript both on client and server.
   *
   * `server` means pages are automatically rendered with server components, so there will be no JavaScript to render the page in your client bundle.
   *
   * `client` means that page will render on the client-side only.
   */
  mode?: 'client' | 'server' | 'all'
  /** @internal */
  _sync?: boolean
}

export type NuxtMiddleware = {
  name: string
  path: string
  global?: boolean
}

export type NuxtLayout = {
  name: string
  file: string
}

/**
 * @deprecated Use {@link InlinePreset}
 */
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface ImportPresetWithDeprecation extends InlinePreset {
}

export interface GenerateAppOptions {
  filter?: (template: ResolvedNuxtTemplate<any>) => boolean
}

export interface NuxtAnalyzeMeta {
  name: string
  slug: string
  startTime: number
  endTime: number
  analyzeDir: string
  buildDir: string
  outDir: string
}

/**
 * The listeners to Nuxt build time events
 */
export interface NuxtHooks {
  // Kit
  /**
   * Allows extending compatibility checks.
   * @param compatibility Compatibility object
   * @param issues Issues to be mapped
   * @returns Promise
   */
  'kit:compatibility': (compatibility: NuxtCompatibility, issues: NuxtCompatibilityIssues) => HookResult

  // Nuxt
  /**
   * Called after Nuxt initialization, when the Nuxt instance is ready to work.
   * @param nuxt The configured Nuxt object
   * @returns Promise
   */
  'ready': (nuxt: Nuxt) => HookResult
  /**
   * Called when Nuxt instance is gracefully closing.
   * @param nuxt The configured Nuxt object
   * @returns Promise
   */
  'close': (nuxt: Nuxt) => HookResult
  /**
   * Called to restart the current Nuxt instance.
   * @returns Promise
   */
  'restart': (options?: {
    /**
     * Try to restart the whole process if supported
     */
    hard?: boolean
  }) => HookResult

  /**
   * Called during Nuxt initialization, before installing user modules.
   * @returns Promise
   */
  'modules:before': () => HookResult
  /**
   * Called during Nuxt initialization, after installing user modules.
   * @returns Promise
   */
  'modules:done': () => HookResult

  /**
   * Called after resolving the `app` instance.
   * @param app The resolved `NuxtApp` object
   * @returns Promise
   */
  'app:resolve': (app: NuxtApp) => HookResult
  /**
   * Called during `NuxtApp` generation, to allow customizing, modifying or adding new files to the build directory (either virtually or to written to `.nuxt`).
   * @param app The configured `NuxtApp` object
   * @returns Promise
   */
  'app:templates': (app: NuxtApp) => HookResult
  /**
   * Called after templates are compiled into the [virtual file system](https://nuxt.com/docs/4.x/directory-structure/nuxt) (vfs).
   * @param app The configured `NuxtApp` object
   * @returns Promise
   */
  'app:templatesGenerated': (app: NuxtApp, templates: ResolvedNuxtTemplate[], options?: GenerateAppOptions) => HookResult

  /**
   * Called before Nuxt bundle builder.
   * @returns Promise
   */
  'build:before': () => HookResult
  /**
   * Called after Nuxt bundle builder is complete.
   * @returns Promise
   */
  'build:done': () => HookResult
  /**
   * Called during the manifest build by Vite and Webpack. This allows customizing the manifest that Nitro will use to render `<script>` and `<link>` tags in the final HTML.
   * @param manifest The manifest object to build
   * @returns Promise
   */
  'build:manifest': (manifest: Manifest) => HookResult

  /**
   * Called when `nuxt analyze` is finished
   * @param meta the analyze meta object, mutations will be saved to `meta.json`
   * @returns Promise
   */
  'build:analyze:done': (meta: NuxtAnalyzeMeta) => HookResult

  /**
   * Called before generating the app.
   * @param options GenerateAppOptions object
   * @returns Promise
   */
  'builder:generateApp': (options?: GenerateAppOptions) => HookResult
  /**
   * Called at build time in development when the watcher spots a change to a file or directory in the project.
   * @param event "add" | "addDir" | "change" | "unlink" | "unlinkDir"
   * @param path the path to the watched file
   * @returns Promise
   */
  'builder:watch': (event: WatchEvent, path: string) => HookResult

  /**
   * Called after page routes are scanned from the file system.
   * @param pages Array containing scanned pages
   * @returns Promise
   */
  'pages:extend': (pages: NuxtPage[]) => HookResult

  /**
   * Called after page routes have been augmented with scanned metadata.
   * @param pages Array containing resolved pages
   * @returns Promise
   */
  'pages:resolved': (pages: NuxtPage[]) => HookResult

  /**
   * Called when resolving `app/router.options` files. It allows modifying the detected router options files
   * and adding new ones.
   *
   * Later items in the array override earlier ones.
   *
   * Adding a router options file will switch on page-based routing, unless `optional` is set, in which case
   * it will only apply when page-based routing is already enabled.
   * @param context An object with `files` containing an array of router options files.
   * @returns Promise
   */
  'pages:routerOptions': (context: { files: Array<{ path: string, optional?: boolean }> }) => HookResult

  /**
   * Called when the dev middleware is being registered on the Nitro dev server.
   * @param handler the Vite or Webpack event handler
   * @returns Promise
   */
  'server:devHandler': (handler: EventHandler) => HookResult

  /**
   * Called at setup allowing modules to extend sources.
   * @param presets Array containing presets objects
   * @returns Promise
   */
  'imports:sources': (presets: InlinePreset[]) => HookResult
  /**
   * Called at setup allowing modules to extend imports.
   * @param imports Array containing the imports to extend
   * @returns Promise
   */
  'imports:extend': (imports: Import[]) => HookResult
  /**
   * Called when the [unimport](https://github.com/unjs/unimport) context is created.
   * @param context The Unimport context
   * @returns Promise
   */
  'imports:context': (context: Unimport) => HookResult
  /**
   * Allows extending import directories.
   * @param dirs Array containing directories as string
   * @returns Promise
   */
  'imports:dirs': (dirs: string[]) => HookResult

  // Components
  /**
   * Called within `app:resolve` allowing to extend the directories that are scanned for auto-importable components.
   * @param dirs The `dirs` option to push new items
   * @returns Promise
   */
  'components:dirs': (dirs: ComponentsOptions['dirs']) => HookResult
  /**
   * Allows extending new components.
   * @param components The `components` array to push new items
   * @returns Promise
   */
  'components:extend': (components: Component[]) => HookResult

  // Nitropack
  /**
   * Called before Nitro writes `.nuxt/tsconfig.server.json`, allowing addition of custom references and declarations.
   * @param options Objects containing `references`, `declarations`
   * @returns Promise
   */
  'nitro:prepare:types': (options: { references: TSReference[], declarations: string[] }) => HookResult
  /**
   * Called before initializing Nitro, allowing customization of Nitro's configuration.
   * @param nitroConfig The nitro config to be extended
   * @returns Promise
   */
  'nitro:config': (nitroConfig: NitroConfig) => HookResult
  /**
   * Called after Nitro is initialized, which allows registering Nitro hooks and interacting directly with Nitro.
   * @param nitro The created nitro object
   * @returns Promise
   */
  'nitro:init': (nitro: Nitro) => HookResult
  /**
   * Called before building the Nitro instance.
   * @param nitro The created nitro object
   * @returns Promise
   */
  'nitro:build:before': (nitro: Nitro) => HookResult
  /**
   * Called after copying public assets. Allows modifying public assets before Nitro server is built.
   * @param nitro The created nitro object
   * @returns Promise
   */
  'nitro:build:public-assets': (nitro: Nitro) => HookResult
  /**
   * Allows extending the routes to be pre-rendered.
   * @param ctx Nuxt context
   * @returns Promise
   */
  'prerender:routes': (ctx: { routes: Set<string> }) => HookResult

  // @nuxt/cli
  /**
   * Called when an error occurs at build time.
   * @param error Error object
   * @returns Promise
   */
  'build:error': (error: Error) => HookResult
  /**
   * Called before @nuxt/cli writes `.nuxt/tsconfig.json` and `.nuxt/nuxt.d.ts`, allowing addition of custom references and declarations in `nuxt.d.ts`, or directly modifying the options in `tsconfig.json`
   * @param options Objects containing `references`, `declarations`, `tsConfig`
   * @returns Promise
   */
  'prepare:types': (options: { references: TSReference[], declarations: string[], tsConfig: VueTSConfig, nodeTsConfig: TSConfig, nodeReferences: TSReference[], sharedTsConfig: TSConfig, sharedReferences: TSReference[] }) => HookResult
  /**
   * Called when the dev server is loading.
   * @param listenerServer The HTTP/HTTPS server object
   * @param listener The server's listener object
   * @returns Promise
   */
  'listen': (listenerServer: HttpServer | HttpsServer, listener: any) => HookResult

  // Schema
  /**
   * Allows extending default schemas.
   * @param schemas Schemas to be extend
   * @returns void
   */
  'schema:extend': (schemas: SchemaDefinition[]) => void
  /**
   * Allows extending resolved schema.
   * @param schema Schema object
   * @returns void
   */
  'schema:resolved': (schema: Schema) => void
  /**
   * Called before writing the given schema.
   * @param schema Schema object
   * @returns void
   */
  'schema:beforeWrite': (schema: Schema) => void
  /**
   * Called after the schema is written.
   * @returns void
   */
  'schema:written': () => void

  // Vite
  /**
   * Allows to extend Vite default context.
   * @param viteBuildContext The vite build context object
   * @returns Promise
   */
  'vite:extend': (viteBuildContext: { nuxt: Nuxt, config: ViteConfig }) => HookResult
  /**
   * Allows to extend Vite default config.
   * @param viteInlineConfig The vite inline config object
   * @param env Server or client
   * @returns Promise
   * @deprecated
   */
  'vite:extendConfig': (viteInlineConfig: Readonly<ViteConfig>, env: { isClient: boolean, isServer: boolean }) => HookResult
  /**
   * Allows to read the resolved Vite config.
   * @param viteInlineConfig The vite inline config object
   * @param env Server or client
   * @returns Promise
   * @deprecated
   */
  'vite:configResolved': (viteInlineConfig: Readonly<ViteConfig>, env: { isClient: boolean, isServer: boolean }) => HookResult
  /**
   * Called when the Vite server is created.
   * @param viteServer Vite development server
   * @param env Server or client
   * @returns Promise
   */
  'vite:serverCreated': (viteServer: ViteDevServer, env: { isClient: boolean, isServer: boolean }) => HookResult
  /**
   * Called after Vite server is compiled.
   * @returns Promise
   */
  'vite:compiled': () => HookResult

  // webpack
  /**
   * Called before configuring the webpack compiler.
   * @param webpackConfigs Configs objects to be pushed to the compiler
   * @returns Promise
   */
  'webpack:config': (webpackConfigs: Configuration[]) => HookResult
  /**
   * Allows to read the resolved webpack config
   * @param webpackConfigs Configs objects to be pushed to the compiler
   * @returns Promise
   */
  'webpack:configResolved': (webpackConfigs: Readonly<Configuration>[]) => HookResult
  /**
   * Called right before compilation.
   * @param options The options to be added
   * @returns Promise
   */
  'webpack:compile': (options: { name: string, compiler: Compiler }) => HookResult
  /**
   * Called after resources are loaded.
   * @param options The compiler options
   * @returns Promise
   */
  'webpack:compiled': (options: { name: string, compiler: Compiler, stats: Stats }) => HookResult

  /**
   * Called on `change` on WebpackBar.
   * @param shortPath the short path
   * @returns void
   */
  'webpack:change': (shortPath: string) => void
  /**
   * Called on `done` if has errors on WebpackBar.
   * @returns void
   */
  'webpack:error': () => void
  /**
   * Called on `allDone` on WebpackBar.
   * @returns void
   */
  'webpack:done': () => void
  /**
   * Called on `progress` on WebpackBar.
   * @param statesArray The array containing the states on progress
   * @returns void
   */
  'webpack:progress': (statesArray: any[]) => void

  // rspack
  /**
   * Called before configuring the webpack compiler.
   * @param webpackConfigs Configs objects to be pushed to the compiler
   * @returns Promise
   */
  'rspack:config': (webpackConfigs: Configuration[]) => HookResult
  /**
   * Allows to read the resolved webpack config
   * @param webpackConfigs Configs objects to be pushed to the compiler
   * @returns Promise
   */
  'rspack:configResolved': (webpackConfigs: Readonly<Configuration>[]) => HookResult
  /**
   * Called right before compilation.
   * @param options The options to be added
   * @returns Promise
   */
  'rspack:compile': (options: { name: string, compiler: Compiler }) => HookResult
  /**
   * Called after resources are loaded.
   * @param options The compiler options
   * @returns Promise
   */
  'rspack:compiled': (options: { name: string, compiler: Compiler, stats: Stats }) => HookResult

  /**
   * Called on `change` on WebpackBar.
   * @param shortPath the short path
   * @returns void
   */
  'rspack:change': (shortPath: string) => void
  /**
   * Called on `done` if has errors on WebpackBar.
   * @returns void
   */
  'rspack:error': () => void
  /**
   * Called on `allDone` on WebpackBar.
   * @returns void
   */
  'rspack:done': () => void
  /**
   * Called on `progress` on WebpackBar.
   * @param statesArray The array containing the states on progress
   * @returns void
   */
  'rspack:progress': (statesArray: any[]) => void
}

export type NuxtHookName = keyof NuxtHooks
</file>

<file path="packages/schema/src/types/imports.ts">
import type { UnimportOptions } from 'unimport'

export interface ImportsOptions extends UnimportOptions {
  /**
   * Enable implicit auto import from Vue, Nuxt and module contributed utilities.
   * Generate global TypeScript definitions.
   */
  autoImport?: boolean

  /**
   * Directories to scan for auto imports.
   * @see https://nuxt.com/docs/4.x/directory-structure/app/composables#how-files-are-scanned
   */
  dirs?: string[]

  /**
   * Enabled scan for local directories for auto imports.
   * When this is disabled, `dirs` options will be ignored.
   */
  scan?: boolean

  /**
   * Assign auto imported utilities to `globalThis` instead of using built time transformation.
   */
  global?: boolean

  transform?: {
    exclude?: RegExp[]
    include?: RegExp[]
  }

  /**
   * Add polyfills for setInterval, requestIdleCallback, and others
   */
  polyfills?: boolean
}
</file>

<file path="packages/schema/src/types/module.ts">
import type { Defu } from 'defu'
import type { NuxtHooks } from './hooks.ts'
import type { Nuxt } from './nuxt.ts'
import type { NuxtCompatibility } from './compatibility.ts'

export interface ModuleMeta {
  /** Module name. */
  name?: string

  /** Module version. */
  version?: string

  /**
   * The configuration key used within `nuxt.config` for this module's options.
   * For example, `@nuxtjs/axios` uses `axios`.
   */
  configKey?: string

  /**
   * Constraints for the versions of Nuxt or features this module requires.
   */
  compatibility?: NuxtCompatibility

  /**
   * Fully resolved path used internally by Nuxt. Do not depend on this value.
   * @internal
   */
  rawPath?: string

  /**
   * Whether the module has been disabled in the Nuxt configuration.
   * @internal
   */
  disabled?: boolean

  [key: string]: unknown
}

/** The options received.  */
export type ModuleOptions = Record<string, any>

export type ModuleSetupInstallResult = {
  /**
   * Timing information for the initial setup
   */
  timings?: {
    /** Total time took for module setup in ms */
    setup?: number
    [key: string]: number | undefined
  }
}

type Awaitable<T> = T | Promise<T>

type Prettify<T> = {
  [K in keyof T]: T[K];
} & {}

export type ModuleSetupReturn = Awaitable<false | void | ModuleSetupInstallResult>

export type ResolvedModuleOptions<
  TOptions extends ModuleOptions,
  TOptionsDefaults extends Partial<TOptions>,
> =
  Prettify<
    Defu<
      Partial<TOptions>,
      [Partial<TOptions>, TOptionsDefaults]
    >
  >

export interface ModuleDependencyMeta<T = Record<string, unknown>> {
  version?: string
  overrides?: Partial<T>
  defaults?: Partial<T>
  optional?: boolean
}

export interface ModuleDependencies {
  [key: string]: ModuleDependencyMeta<Record<string, unknown>>
}

/** Module definition passed to 'defineNuxtModule(...)' or 'defineNuxtModule().with(...)'. */
export interface ModuleDefinition<
  TOptions extends ModuleOptions,
  TOptionsDefaults extends Partial<TOptions>,
  TWith extends boolean,
> {
  meta?: ModuleMeta
  defaults?: TOptionsDefaults | ((nuxt: Nuxt) => Awaitable<TOptionsDefaults>)
  schema?: TOptions
  hooks?: Partial<NuxtHooks>
  moduleDependencies?: ModuleDependencies | ((nuxt: Nuxt) => Awaitable<ModuleDependencies>)
  onInstall?: (nuxt: Nuxt) => Awaitable<void>
  onUpgrade?: (nuxt: Nuxt, options: TOptions, previousVersion: string) => Awaitable<void>
  setup?: (
    this: void,
    resolvedOptions: TWith extends true
      ? ResolvedModuleOptions<TOptions, TOptionsDefaults>
      : TOptions,
    nuxt: Nuxt,
  ) => ModuleSetupReturn
}

export interface NuxtModule<
  TOptions extends ModuleOptions = ModuleOptions,
  TOptionsDefaults extends Partial<TOptions> = Partial<TOptions>,
  TWith extends boolean = false,
> {
  (
    this: void,
    resolvedOptions: TWith extends true
      ? ResolvedModuleOptions<TOptions, TOptionsDefaults>
      : TOptions,
    nuxt: Nuxt
  ): ModuleSetupReturn
  getOptions?: (
    inlineOptions?: Partial<TOptions>,
    nuxt?: Nuxt,
  ) => Promise<
    TWith extends true
      ? ResolvedModuleOptions<TOptions, TOptionsDefaults>
      : TOptions
  >
  getModuleDependencies?: (nuxt: Nuxt) => Awaitable<ModuleDependencies> | undefined
  getMeta?: () => Promise<ModuleMeta>
  onInstall?: (nuxt: Nuxt) => Awaitable<void>
  onUpgrade?: (
    nuxt: Nuxt,
    options: TWith extends true
      ? ResolvedModuleOptions<TOptions, TOptionsDefaults>
      : TOptions,
    previousVersion: string,
  ) => Awaitable<void>
}
</file>

<file path="packages/schema/src/types/nuxt.ts">
import type { AsyncLocalStorage } from 'node:async_hooks'
import type { Hookable } from 'hookable'
import type { Ignore } from 'ignore'
import type { NuxtModule } from './module.ts'
import type { NuxtHooks, NuxtLayout, NuxtMiddleware, NuxtPage } from './hooks.ts'
import type { Component } from './components.ts'
import type { NuxtOptions } from './config.ts'
import type { NuxtDebugContext } from './debug.ts'

export interface NuxtPlugin {
  /** @deprecated use mode */
  ssr?: boolean
  src: string
  mode?: 'all' | 'server' | 'client'
  /**
   * This allows more granular control over plugin order and should only be used by advanced users.
   * Lower numbers run first, and user plugins default to `0`.
   *
   * Default Nuxt priorities can be seen at [here](https://github.com/nuxt/nuxt/blob/9904849bc87c53dfbd3ea3528140a5684c63c8d8/packages/nuxt/src/core/plugins/plugin-metadata.ts#L15-L34).
   */
  order?: number
  /**
   * @internal
   */
  name?: string
}

// Internal type for simpler NuxtTemplate interface extension

type TemplateDefaultOptions = Record<string, any>

export interface NuxtTemplate<Options = TemplateDefaultOptions> {
  /** resolved output file path (generated) */
  dst?: string
  /** The target filename once the template is copied into the Nuxt buildDir */
  filename?: string
  /** An options object that will be accessible within the template via `<% options %>` */
  options?: Options
  /** The resolved path to the source file to be template */
  src?: string
  /** Provided compile option instead of src */

  getContents?: (data: { nuxt: Nuxt, app: NuxtApp, options: Options }) => string | Promise<string>
  /** Write to filesystem */
  write?: boolean
  /**
   * The source path of the template (to try resolving dependencies from).
   * @internal
   */
  _path?: string
}

export interface NuxtServerTemplate {
  /** The target filename once the template is copied into the Nuxt buildDir */
  filename: string
  getContents: () => string | Promise<string>
}

export interface ResolvedNuxtTemplate<Options = TemplateDefaultOptions> extends NuxtTemplate<Options> {
  filename: string
  dst: string
  modified?: boolean
}

export interface NuxtTypeTemplate<Options = TemplateDefaultOptions> extends Omit<NuxtTemplate<Options>, 'write' | 'filename'> {
  filename: `${string}.d.ts`
  write?: true
}

type _TemplatePlugin<Options> = Omit<NuxtPlugin, 'src'> & NuxtTemplate<Options>
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface NuxtPluginTemplate<Options = TemplateDefaultOptions> extends _TemplatePlugin<Options> { }

export interface NuxtApp {
  mainComponent?: string | null
  rootComponent?: string | null
  errorComponent?: string | null
  dir: string
  extensions: string[]
  plugins: NuxtPlugin[]
  components: Component[]
  layouts: Record<string, NuxtLayout>
  middleware: NuxtMiddleware[]
  templates: NuxtTemplate[]
  configs: string[]
  pages?: NuxtPage[]
}

export interface Nuxt {
  // Private fields.
  __name: string
  _version: string
  _ignore?: Ignore
  _dependencies?: Set<string>
  _debug?: NuxtDebugContext
  /** Async local storage for current running Nuxt module instance. */
  _asyncLocalStorageModule?: AsyncLocalStorage<NuxtModule>
  /**
   * Module options functions collected from moduleDependencies.
   * @internal
   */
  _moduleOptionsFunctions?: Map<string | NuxtModule, Array<() => { defaults?: Record<string, unknown>, overrides?: Record<string, unknown> }>>

  /** The resolved Nuxt configuration. */
  options: NuxtOptions
  hooks: Hookable<NuxtHooks>
  hook: Nuxt['hooks']['hook']
  callHook: Nuxt['hooks']['callHook']
  addHooks: Nuxt['hooks']['addHooks']
  runWithContext: <T extends (...args: any[]) => any>(fn: T) => ReturnType<T>

  ready: () => Promise<void>
  close: () => Promise<void>

  /** The production or development server. */
  server?: any

  vfs: Record<string, string>

  apps: Record<string, NuxtApp>
}
</file>

<file path="packages/schema/src/types/router.ts">
import type { RouterHistory, RouterOptions as _RouterOptions } from 'vue-router'

export type RouterOptions = Partial<Omit<_RouterOptions, 'history' | 'routes'>> & {
  history?: (baseURL?: string) => RouterHistory | null | undefined
  routes?: (_routes: _RouterOptions['routes']) => _RouterOptions['routes'] | Promise<_RouterOptions['routes']>
  hashMode?: boolean
  scrollBehaviorType?: 'smooth' | 'auto'
}

export type RouterConfig = RouterOptions

/**
 * Only JSON serializable router options are configurable from nuxt config
 */
export type RouterConfigSerializable = Pick<RouterConfig, 'linkActiveClass' | 'linkExactActiveClass' | 'end' | 'sensitive' | 'strict' | 'hashMode' | 'scrollBehaviorType'>
</file>

<file path="packages/schema/src/types/schema.ts">
import type { IncomingMessage, ServerResponse } from 'node:http'
import type { AssetURLTagConfig } from '@vue/compiler-sfc'
import type { CompilerOptions } from '@vue/compiler-core'
import type { RenderSSRHeadOptions } from '@unhead/vue/types'
import type { BundleAnalyzerPlugin } from 'webpack-bundle-analyzer'
import type { PluginVisualizerOptions } from 'rollup-plugin-visualizer'
import type { TransformerOptions } from 'unctx/transform'
import type { DotenvOptions, SourceOptions } from 'c12'
import type { CompatibilityDateSpec } from 'compatx'
import type { Options } from 'ignore'
import type { ChokidarOptions } from 'chokidar'
import type { H3CorsOptions } from 'h3'
import type { NuxtLinkOptions } from 'nuxt/app'
import type { FetchOptions } from 'ofetch'
import type { NitroConfig, NitroDevEventHandler, NitroEventHandler } from 'nitropack/types'
import type { Options as AutoprefixerOptions } from 'autoprefixer'
import type { Options as CssnanoOptions } from 'cssnano'
import type { TSConfig } from 'pkg-types'
import type { RawVueCompilerOptions } from '@vue/language-core'
import type { PluginOptions } from 'mini-css-extract-plugin'
import type { LoaderOptions } from 'esbuild-loader'
import type { Options as PugOptions } from 'pug'
import type { VueLoaderOptions } from 'vue-loader'
import type { BasePluginOptions, DefinedDefaultMinimizerAndOptions } from 'css-minimizer-webpack-plugin'
import type { Configuration, WebpackError } from 'webpack'
import type { ProcessOptions } from 'postcss'
import type { Options as WebpackDevMiddlewareOptions } from 'webpack-dev-middleware'
import type { ClientOptions, MiddlewareOptions } from 'webpack-hot-middleware'
import type { AppConfig as VueAppConfig } from 'vue'
import type { TransformOptions as OxcTransformOptions } from 'oxc-transform'
import type { TransformOptions as EsbuildTransformOptions } from 'esbuild'

import type { RouterConfigSerializable } from './router.ts'
import type { NuxtHooks } from './hooks.ts'
import type { ModuleMeta, NuxtModule } from './module.ts'
import type { NuxtDebugOptions } from './debug.ts'
import type { Nuxt, NuxtPlugin, NuxtTemplate } from './nuxt.ts'
import type { SerializableHtmlAttributes } from './head.ts'
import type { AppConfig, NuxtAppConfig, NuxtOptions, RuntimeConfig, Serializable, ViteOptions } from './config.ts'
import type { ImportsOptions } from './imports.ts'
import type { ComponentsOptions } from './components.ts'
import type { KeyedFunction } from './compiler.ts'

export interface ConfigSchema {
  /**
   * Configure Nuxt component auto-registration.
   *
   * Any components in the directories configured here can be used throughout your pages, layouts (and other components) without needing to explicitly import them.
   *
   * @see [`components/` directory documentation](https://nuxt.com/docs/4.x/directory-structure/app/components)
   */
  components: boolean | ComponentsOptions | ComponentsOptions['dirs']

  /**
   * Configure how Nuxt auto-imports composables into your application.
   *
   * @see [Nuxt documentation](https://nuxt.com/docs/4.x/directory-structure/app/composables)
   */
  imports: ImportsOptions

  /**
   * Whether to use the vue-router integration in Nuxt 3. If you do not provide a value it will be enabled if you have a `pages/` directory in your source folder.
   *
   * Additionally, you can provide a glob pattern or an array of patterns to scan only certain files for pages.
   *
   * @example
   * ```js
   * pages: {
   *   pattern: ['**\/*\/*.vue', '!**\/*.spec.*'],
   * }
   * ```
   */
  pages: boolean | { enabled?: boolean, pattern?: string | string[] }

  /**
   * Manually disable nuxt telemetry.
   *
   * @see [Nuxt Telemetry](https://github.com/nuxt/telemetry) for more information.
   */
  telemetry: boolean | Record<string, any>

  /**
   * Enable Nuxt DevTools for development.
   *
   * Breaking changes for devtools might not reflect on the version of Nuxt.
   *
   * @see  [Nuxt DevTools](https://devtools.nuxt.com/) for more information.
   */
  devtools: boolean | { enabled: boolean, [key: string]: any }

  /**
   * Vue.js config
   */
  vue: {
    transformAssetUrls: AssetURLTagConfig

    /**
     * Options for the Vue compiler that will be passed at build time.
     *
     * @see [Vue documentation](https://vuejs.org/api/application#app-config-compileroptions)
     */
    compilerOptions: CompilerOptions

    /**
     * Include Vue compiler in runtime bundle.
     */
    runtimeCompiler: boolean

    /**
     * Enable reactive destructure for `defineProps`
     */
    propsDestructure: boolean

    /**
     * It is possible to pass configure the Vue app globally. Only serializable options may be set in your `nuxt.config`. All other options should be set at runtime in a Nuxt plugin.
     *
     * @see [Vue app config documentation](https://vuejs.org/api/application#app-config)
     */
    config: Serializable<VueAppConfig>
  }

  /**
   * Nuxt App configuration.
   */
  app: {
  /**
   * The base path of your Nuxt application.
   *
   * For example:
   *
   *
   * @example
   * ```ts
   * export default defineNuxtConfig({
   *   app: {
   *     baseURL: '/prefix/'
   *   }
   * })
   * ```
   *
   * This can also be set at runtime by setting the NUXT_APP_BASE_URL environment variable.
   *
   * @example
   * ```bash
   * NUXT_APP_BASE_URL=/prefix/ node .output/server/index.mjs
   * ```
   */
    baseURL: string

    /**
     * The folder name for the built site assets, relative to `baseURL` (or `cdnURL` if set). This is set at build time and should not be customized at runtime.
     */
    buildAssetsDir: string

    /**
     * An absolute URL to serve the public folder from (production-only).
     *
     * For example:
     *
     * @example
     * ```ts
     * export default defineNuxtConfig({
     *   app: {
     *     cdnURL: 'https://mycdn.org/'
     *   }
     * })
     * ```
     *
     * This can be set to a different value at runtime by setting the `NUXT_APP_CDN_URL` environment variable.
     *
     * @example
     * ```bash
     * NUXT_APP_CDN_URL=https://mycdn.org/ node .output/server/index.mjs
     * ```
     */
    cdnURL: string

    /**
     * Set default configuration for `<head>` on every page.
     *
     * @example
     * ```js
     * app: {
     *   head: {
     *     meta: [
     *       // <meta name="viewport" content="width=device-width, initial-scale=1">
     *       { name: 'viewport', content: 'width=device-width, initial-scale=1' }
     *     ],
     *     script: [
     *       // <script src="https://myawesome-lib.js"></script>
     *       { src: 'https://awesome-lib.js' }
     *     ],
     *     link: [
     *       // <link rel="stylesheet" href="https://myawesome-lib.css">
     *       { rel: 'stylesheet', href: 'https://awesome-lib.css' }
     *     ],
     *     // please note that this is an area that is likely to change
     *     style: [
     *       // <style>:root { color: red }</style>
     *       { textContent: ':root { color: red }' }
     *     ],
     *     noscript: [
     *       // <noscript>JavaScript is required</noscript>
     *       { textContent: 'JavaScript is required' }
     *     ]
     *   }
     * }
     * ```
     */
    head: NuxtAppConfig['head']

    /**
     * Default values for layout transitions.
     *
     * This can be overridden with `definePageMeta` on an individual page. Only JSON-serializable values are allowed.
     *
     * @see [Vue Transition docs](https://vuejs.org/api/built-in-components#transition)
     */
    layoutTransition: NuxtAppConfig['layoutTransition']

    /**
     * Default values for page transitions.
     *
     * This can be overridden with `definePageMeta` on an individual page. Only JSON-serializable values are allowed.
     *
     * @see [Vue Transition docs](https://vuejs.org/api/built-in-components#transition)
     */
    pageTransition: NuxtAppConfig['pageTransition']

    /**
     * Default values for view transitions.
     *
     * This only has an effect when **experimental** support for View Transitions is [enabled in your nuxt.config file](https://nuxt.com/docs/4.x/getting-started/transitions#view-transitions-api-experimental).
     * This can be overridden with `definePageMeta` on an individual page.
     *
     * @see [Nuxt View Transition API docs](https://nuxt.com/docs/4.x/getting-started/transitions#view-transitions-api-experimental)
     */
    viewTransition: NuxtAppConfig['viewTransition']

    /**
     * Default values for KeepAlive configuration between pages.
     *
     * This can be overridden with `definePageMeta` on an individual page. Only JSON-serializable values are allowed.
     *
     * @see [Vue KeepAlive](https://vuejs.org/api/built-in-components#keepalive)
     */
    keepalive: NuxtAppConfig['keepalive']

    /**
     * Customize Nuxt root element id.
     *
     * @deprecated Prefer `rootAttrs.id` instead
     */
    rootId: string | false

    /**
     * Customize Nuxt root element tag.
     */
    rootTag: string

    /**
     * Customize Nuxt root element id.
     */
    rootAttrs: SerializableHtmlAttributes

    /**
     * Customize Nuxt Teleport element tag.
     */
    teleportTag: string

    /**
     * Customize Nuxt Teleport element id.
     *
     * @deprecated Prefer `teleportAttrs.id` instead
     */
    teleportId: string | false

    /**
     * Customize Nuxt Teleport element attributes.
     */
    teleportAttrs: SerializableHtmlAttributes

    /**
     * Customize Nuxt SpaLoader element tag.
     */
    spaLoaderTag: string

    /**
     * Customize Nuxt SPA loading template element attributes.
     */
    spaLoaderAttrs: SerializableHtmlAttributes
  }

  /**
   * Boolean or a path to an HTML file with the contents of which will be inserted into any HTML page rendered with `ssr: false`.
   *
   * - If it is unset, it will use `~/spa-loading-template.html` file in one of your layers, if it exists. - If it is false, no SPA loading indicator will be loaded. - If true, Nuxt will look for `~/spa-loading-template.html` file in one of your layers, or a
   *   default Nuxt image will be used.
   * Some good sources for spinners are [SpinKit](https://github.com/tobiasahlin/SpinKit) or [SVG Spinners](https://icones.js.org/collection/svg-spinners).
   *
   * @example ~/spa-loading-template.html
   * ```html
   * <!-- https://github.com/barelyhuman/snips/blob/dev/pages/css-loader.md -->
   * <div class="loader"></div>
   * <style>
   * .loader {
   *   display: block;
   *   position: fixed;
   *   z-index: 1031;
   *   top: 50%;
   *   left: 50%;
   *   transform: translate(-50%, -50%);
   *   width: 18px;
   *   height: 18px;
   *   box-sizing: border-box;
   *   border: solid 2px transparent;
   *   border-top-color: #000;
   *   border-left-color: #000;
   *   border-bottom-color: #efefef;
   *   border-right-color: #efefef;
   *   border-radius: 50%;
   *   -webkit-animation: loader 400ms linear infinite;
   *   animation: loader 400ms linear infinite;
   * }
   *
   * @-webkit-keyframes loader {
   *   0% {
   *     -webkit-transform: translate(-50%, -50%) rotate(0deg);
   *   }
   *   100% {
   *     -webkit-transform: translate(-50%, -50%) rotate(360deg);
   *   }
   * }
   * @keyframes loader {
   *   0% {
   *     transform: translate(-50%, -50%) rotate(0deg);
   *   }
   *   100% {
   *     transform: translate(-50%, -50%) rotate(360deg);
   *   }
   * }
   * </style>
   * ```
   */
  spaLoadingTemplate: string | boolean | undefined | null

  /**
   * An array of nuxt app plugins.
   *
   * Each plugin can be a string (which can be an absolute or relative path to a file). If it ends with `.client` or `.server` then it will be automatically loaded only in the appropriate context.
   * It can also be an object with `src` and `mode` keys.
   *
   * @note Plugins are also auto-registered from the `~/plugins` directory
   * and these plugins do not need to be listed in `nuxt.config` unless you
   * need to customize their order. All plugins are deduplicated by their src path.
   *
   * @see [`plugins/` directory documentation](https://nuxt.com/docs/4.x/directory-structure/app/plugins)
   *
   * @example
   * ```js
   * plugins: [
   *   '~/plugins/foo.client.js', // only in client side
   *   '~/plugins/bar.server.js', // only in server side
   *   '~/plugins/baz.js', // both client & server
   *   { src: '~/plugins/both-sides.js' },
   *   { src: '~/plugins/client-only.js', mode: 'client' }, // only on client side
   *   { src: '~/plugins/server-only.js', mode: 'server' } // only on server side
   * ]
   * ```
   */
  plugins: (NuxtPlugin | string)[]

  /**
   * You can define the CSS files/modules/libraries you want to set globally (included in every page).
   *
   * Nuxt will automatically guess the file type by its extension and use the appropriate pre-processor. You will still need to install the required loader if you need to use them.
   *
   * @example
   * ```js
   * css: [
   *   // Load a Node.js module directly (here it's a Sass file).
   *   'bulma',
   *   // CSS file in the project
   *   '~/assets/css/main.css',
   *   // SCSS file in the project
   *   '~/assets/css/main.scss'
   * ]
   * ```
   */
  css: string[]

  /**
   * An object that allows us to configure the `unhead` nuxt module.
   */
  unhead: {
  /**
   * Enable the legacy compatibility mode for `unhead` module. This applies the following changes: - Disables Capo.js sorting - Adds the `DeprecationsPlugin`: supports `hid`, `vmid`, `children`, `body` - Adds the `PromisesPlugin`: supports promises as input
   *
   *
   * @see [`unhead` migration documentation](https://unhead.unjs.io/docs/typescript/head/guides/get-started/migration)
   *
   * @example
   * ```ts
   * export default defineNuxtConfig({
   *  unhead: {
   *   legacy: true
   * })
   * ```
   */
    legacy: boolean

    /**
     * An object that will be passed to `renderSSRHead` to customize the output.
     *
     * @example
     * ```ts
     * export default defineNuxtConfig({
     *  unhead: {
     *   renderSSRHeadOptions: {
     *    omitLineBreaks: true
     *   }
     * })
     * ```
     */
    renderSSRHeadOptions: RenderSSRHeadOptions
  }

  /**
   * The builder to use for bundling the Vue part of your application.
   *
   */
  builder: 'vite' | 'webpack' | 'rspack' | { bundle: (nuxt: Nuxt) => Promise<void> }

  /**
   * Configures whether and how sourcemaps are generated for server and/or client bundles.
   *
   * If set to a single boolean, that value applies to both server and client. Additionally, the `'hidden'` option is also available for both server and client.
   * Available options for both client and server: - `true`: Generates sourcemaps and includes source references in the final bundle. - `false`: Does not generate any sourcemaps. - `'hidden'`: Generates sourcemaps but does not include references in the final bundle.
   */
  sourcemap: boolean | { server?: boolean | 'hidden', client?: boolean | 'hidden' }

  /**
   * Log level when building logs.
   *
   * Defaults to 'silent' when running in CI or when a TTY is not available. This option is then used as 'silent' in Vite and 'none' in Webpack
   *
   */
  logLevel: 'silent' | 'info' | 'verbose'

  /**
   * Shared build configuration.
   */
  build: {
  /**
   * If you want to transpile specific dependencies with Babel, you can add them here. Each item in transpile can be a package name, a function, a string or regex object matching the dependency's file name.
   *
   * You can also use a function to conditionally transpile. The function will receive an object ({ isDev, isServer, isClient, isModern, isLegacy }).
   *
   * @example
   * ```js
   * transpile: [({ isLegacy }) => isLegacy && 'ky']
   * ```
   */
    transpile: Array<string | RegExp | ((ctx: { isClient?: boolean, isServer?: boolean, isDev: boolean }) => string | RegExp | false)>

    /**
     * It is recommended to use `addTemplate` from `@nuxt/kit` instead of this option.
     *
     * @example
     * ```js
     * templates: [
     *   {
     *     src: '~/modules/support/plugin.js', // `src` can be absolute or relative
     *     dst: 'support.js', // `dst` is relative to project `.nuxt` dir
     *   }
     * ]
     * ```
     */
    templates: NuxtTemplate<any>[]

    /**
     * Nuxt allows visualizing your bundles and how to optimize them.
     *
     * Set to `true` to enable bundle analysis, or pass an object with options: [for webpack](https://github.com/webpack/webpack-bundle-analyzer#options-for-plugin) or [for vite](https://github.com/btd/rollup-plugin-visualizer#options).
     *
     * @example
     * ```js
     * analyze: {
     *   analyzerMode: 'static'
     * }
     * ```
     */
    analyze: boolean | { enabled?: boolean } & ((0 extends 1 & BundleAnalyzerPlugin.Options ? Record<string, unknown> : BundleAnalyzerPlugin.Options) | PluginVisualizerOptions)
  }

  /**
   * Build time optimization configuration.
   */
  optimization: {
    /**
     * Functions to inject a key for.
     *
     * As long as the number of arguments passed to the function is lower than `argumentLength`, an additional magic string will be injected that can be used to deduplicate requests between server and client. You will need to take steps to handle this additional key.
     * The key will be unique based on the location of the function being invoked within the file.
     *
     */
    keyedComposables: KeyedFunction[]

    /**
     * Tree shake code from specific builds.
     */
    treeShake: {
      /**
       * Tree shake composables from the server or client builds.
       *
       *
       * @example
       * ```js
       * treeShake: { client: { myPackage: ['useServerOnlyComposable'] } }
       * ```
       */
      composables: {
        server: Record<string, string[]>
        client: Record<string, string[]>
      }
    }

    /**
     * Options passed directly to the transformer from `unctx` that preserves async context after `await`.
     */
    asyncTransforms: TransformerOptions
  }

  /**
   * Extend project from multiple local or remote sources.
   *
   * Value should be either a string or array of strings pointing to source directories or config path relative to current config.
   * You can use `github:`, `gh:` `gitlab:` or `bitbucket:`
   *
   * @see [`c12` docs on extending config layers](https://github.com/unjs/c12#extending-config-layer-from-remote-sources)
   *
   * @see [`giget` documentation](https://github.com/unjs/giget)
   */
  extends: string | [string, SourceOptions?] | (string | [string, SourceOptions?])[]

  /**
   * Specify a compatibility date for your app.
   *
   * This is used to control the behavior of presets in Nitro, Nuxt Image and other modules that may change behavior without a major version bump.
   * We plan to improve the tooling around this feature in the future.
   */
  compatibilityDate: CompatibilityDateSpec

  /**
   * Extend project from a local or remote source.
   *
   * Value should be a string pointing to source directory or config path relative to current config.
   * You can use `github:`, `gitlab:`, `bitbucket:` or `https://` to extend from a remote git repository.
   */
  theme: string

  /**
   * Define the root directory of your application.
   *
   * This property can be overwritten (for example, running `nuxt ./my-app/` will set the `rootDir` to the absolute path of `./my-app/` from the current/working directory.
   * It is normally not needed to configure this option.
   *
   */
  rootDir: string

  /**
   * Define the workspace directory of your application.
   *
   * Often this is used when in a monorepo setup. Nuxt will attempt to detect your workspace directory automatically, but you can override it here.
   * It is normally not needed to configure this option.
   *
   */
  workspaceDir: string

  /**
   * Define the source directory of your Nuxt application.
   *
   * If a relative path is specified, it will be relative to the `rootDir`.
   *
   *
   * @example
   * ```js
   * export default {
   *   srcDir: 'app/'
   * }
   * ```
   * This expects the following folder structure:
   * ```bash
   * -| app/
   * ---| assets/
   * ---| components/
   * ---| layouts/
   * ---| middleware/
   * ---| pages/
   * ---| plugins/
   * ---| app.config.ts
   * ---| app.vue
   * ---| error.vue
   * -| server/
   * -| public/
   * -| modules/
   * -| nuxt.config.js
   * -| package.json
   * ```
   */
  srcDir: string

  /**
   * Define the server directory of your Nuxt application, where Nitro routes, middleware and plugins are kept.
   *
   * If a relative path is specified, it will be relative to your `rootDir`.
   *
   */
  serverDir: string

  /**
   * Define the directory where your built Nuxt files will be placed.
   *
   * Many tools assume that `.nuxt` is a hidden directory (because it starts with a `.`). If that is a problem, you can use this option to prevent that.
   *
   *
   * @example
   * ```js
   * export default {
   *   buildDir: 'nuxt-build'
   * }
   * ```
   */
  buildDir: string

  /**
   * For multi-app projects, the unique id of the Nuxt application.
   *
   * Defaults to `nuxt-app`.
   *
   */
  appId: string

  /**
   * A unique identifier matching the build. This may contain the hash of the current state of the project.
   *
   */
  buildId: string

  /**
   * Used to set the modules directories for path resolving (for example, webpack's `resolveLoading`, `nodeExternals` and `postcss`).
   *
   * The configuration path is relative to `options.rootDir` (default is current working directory).
   * Setting this field may be necessary if your project is organized as a yarn workspace-styled mono-repository.
   *
   *
   * @example
   * ```js
   * export default {
   *   modulesDir: ['../../node_modules']
   * }
   * ```
   */
  modulesDir: Array<string>

  /**
   * The directory where Nuxt will store the generated files when running `nuxt analyze`.
   *
   * If a relative path is specified, it will be relative to your `rootDir`.
   *
   */
  analyzeDir: string

  /**
   * Whether Nuxt is running in development mode.
   *
   * Normally, you should not need to set this.
   *
   */
  dev: boolean

  /**
   * Whether your app is being unit tested.
   *
   */
  test: boolean

  /**
   * Set to `true` to enable debug mode.
   *
   * At the moment, it prints out hook names and timings on the server, and logs hook arguments as well in the browser.
   * You can also set this to an object to enable specific debug options.
   *
   */
  debug: boolean | (NuxtDebugOptions) | undefined

  /**
   * Whether to enable rendering of HTML - either dynamically (in server mode) or at generate time. If set to `false` generated pages will have no content.
   *
   */
  ssr: boolean

  /**
   * Modules are Nuxt extensions which can extend its core functionality and add endless integrations.
   *
   * Each module is either a string (which can refer to a package, or be a path to a file), a tuple with the module as first string and the options as a second object, or an inline module function.
   * Nuxt tries to resolve each item in the modules array using node require path (in `node_modules`) and then will be resolved from project `srcDir` if `~` alias is used.
   *
   * @note Modules are executed sequentially so the order is important. First, the modules defined in `nuxt.config.ts` are loaded. Then, modules found in the `modules/`
   * directory are executed, and they load in alphabetical order.
   *
   * @example
   * ```js
   * modules: [
   *   // Using package name
   *   '@nuxtjs/axios',
   *   // Relative to your project srcDir
   *   '~/modules/awesome.js',
   *   // Providing options
   *   ['@nuxtjs/google-analytics', { ua: 'X1234567' }],
   *   // Inline definition
   *   function () {}
   * ]
   * ```
   */
  modules: (NuxtModule<any> | string | [NuxtModule | string, Record<string, any>] | undefined | null | false)[]

  /**
   * Customize default directory structure used by Nuxt.
   *
   * It is better to stick with defaults unless needed.
   */
  dir: {
    app: string

    /**
     * The assets directory (aliased as `~assets` in your build).
     */
    assets: string

    /**
     * The layouts directory, each file of which will be auto-registered as a Nuxt layout.
     */
    layouts: string

    /**
     * The middleware directory, each file of which will be auto-registered as a Nuxt middleware.
     */
    middleware: string

    /**
     * The modules directory, each file in which will be auto-registered as a Nuxt module.
     */
    modules: string

    /**
     * The directory which will be processed to auto-generate your application page routes.
     */
    pages: string

    /**
     * The plugins directory, each file of which will be auto-registered as a Nuxt plugin.
     */
    plugins: string

    /**
     * The shared directory. This directory is shared between the app and the server.
     */
    shared: string

    /**
     * The directory containing your static files, which will be directly accessible via the Nuxt server and copied across into your `dist` folder when your app is generated.
     */
    public: string
  }

  /**
   * The extensions that should be resolved by the Nuxt resolver.
   *
   */
  extensions: Array<string>

  /**
   * You can improve your DX by defining additional aliases to access custom directories within your JavaScript and CSS.
   *
   * @note Within a webpack context (image sources, CSS - but not JavaScript) you _must_ access
   * your alias by prefixing it with `~`.
   *
   * @note These aliases will be automatically added to the generated `.nuxt/tsconfig.json` so you can get full
   * type support and path auto-complete. In case you need to extend options provided by `./.nuxt/tsconfig.json`
   * further, make sure to add them here or within the `typescript.tsConfig` property in `nuxt.config`.
   *
   * @example
   * ```js
   * export default {
   *   alias: {
   *     'images': fileURLToPath(new URL('./assets/images', import.meta.url)),
   *     'style': fileURLToPath(new URL('./assets/style', import.meta.url)),
   *     'data': fileURLToPath(new URL('./assets/other/data', import.meta.url))
   *   }
   * }
   * ```
   *
   * ```html
   * <template>
   *   <img src="~images/main-bg.jpg">
   * </template>
   *
   * <script>
   * import data from 'data/test.json'
   * </script>
   *
   * <style>
   * // Uncomment the below
   * //@import '~style/variables.scss';
   * //@import '~style/utils.scss';
   * //@import '~style/base.scss';
   * body {
   *   background-image: url('~images/main-bg.jpg');
   * }
   * </style>
   * ```
   */
  alias: Record<string, string>

  /**
   * Pass options directly to `node-ignore` (which is used by Nuxt to ignore files).
   *
   * @see [node-ignore](https://github.com/kaelzhang/node-ignore)
   *
   * @example
   * ```js
   * ignoreOptions: {
   *   ignorecase: false
   * }
   * ```
   */
  ignoreOptions: Options

  /**
   * Any file in `pages/`, `layouts/`, `middleware/`, and `public/` directories will be ignored during the build process if its filename starts with the prefix specified by `ignorePrefix`. This is intended to prevent certain files from being processed or served in the built application. By default, the `ignorePrefix` is set to '-', ignoring any files starting with '-'.
   *
   */
  ignorePrefix: string

  /**
   * More customizable than `ignorePrefix`: all files matching glob patterns specified inside the `ignore` array will be ignored in building.
   *
   */
  ignore: Array<string>

  /**
   * The watch property lets you define patterns that will restart the Nuxt dev server when changed.
   *
   * It is an array of strings or regular expressions. Strings should be either absolute paths or relative to the `srcDir` (and the `srcDir` of any layers). Regular expressions will be matched against the path relative to the project `srcDir` (and the `srcDir` of any layers).
   */
  watch: Array<string | RegExp>

  /**
   * The watchers property lets you overwrite watchers configuration in your `nuxt.config`.
   */
  watchers: {
    /**
     * An array of event types, which, when received, will cause the watcher to restart.
     */
    rewatchOnRawEvents: string[]

    /**
     * `watchOptions` to pass directly to webpack.
     *
     * @see [webpack@4 watch options](https://v4.webpack.js.org/configuration/watch/#watchoptions).
     */
    webpack: {
      aggregateTimeout: number
    }

    /**
     * Options to pass directly to `chokidar`.
     *
     * @see [chokidar](https://github.com/paulmillr/chokidar)
     */
    chokidar: ChokidarOptions
  }

  /**
   * Hooks are listeners to Nuxt events that are typically used in modules, but are also available in `nuxt.config`.
   *
   * Internally, hooks follow a naming pattern using colons (e.g., build:done).
   * For ease of configuration, you can also structure them as an hierarchical object in `nuxt.config` (as below).
   *
   * @example
   * ```js
   * import fs from 'node:fs'
   * import path from 'node:path'
   * export default {
   *   hooks: {
   *     build: {
   *       done(builder) {
   *         const extraFilePath = path.join(
   *           builder.nuxt.options.buildDir,
   *           'extra-file'
   *         )
   *         fs.writeFileSync(extraFilePath, 'Something extra')
   *       }
   *     }
   *   }
   * }
   * ```
   */
  hooks: NuxtHooks

  /**
   * Runtime config allows passing dynamic config and environment variables to the Nuxt app context.
   *
   * The value of this object is accessible from server only using `useRuntimeConfig`.
   * It mainly should hold _private_ configuration which is not exposed on the frontend. This could include a reference to your API secret tokens.
   * Anything under `public` and `app` will be exposed to the frontend as well.
   * Values are automatically replaced by matching env variables at runtime, e.g. setting an environment variable `NUXT_API_KEY=my-api-key NUXT_PUBLIC_BASE_URL=/foo/` would overwrite the two values in the example below.
   *
   * @example
   * ```js
   * export default {
   *  runtimeConfig: {
   *     apiKey: '', // Default to an empty string, automatically set at runtime using process.env.NUXT_API_KEY
   *     public: {
   *        baseURL: '' // Exposed to the frontend as well.
   *     }
   *   }
   * }
   * ```
   */
  runtimeConfig: RuntimeConfig

  /**
   * Additional app configuration
   *
   * For programmatic usage and type support, you can directly provide app config with this option. It will be merged with `app.config` file as default value.
   */
  appConfig: AppConfig

  devServer: {
  /**
   * Whether to enable HTTPS.
   *
   *
   * @example
   * ```ts
   * export default defineNuxtConfig({
   *   devServer: {
   *     https: {
   *       key: './server.key',
   *       cert: './server.crt'
   *     }
   *   }
   * })
   * ```
   */
    https: boolean | { key: string, cert: string } | { pfx: string, passphrase: string }

    /**
     * Dev server listening port
     */
    port: number

    /**
     * Dev server listening host
     */
    host: string | undefined

    /**
     * Listening dev server URL.
     *
     * This should not be set directly as it will always be overridden by the dev server with the full URL (for module and internal use).
     */
    url: string

    /**
     * Template to show a loading screen
     */
    loadingTemplate: (data: { loading?: string }) => string

    /**
     * Set CORS options for the dev server
     */
    cors: H3CorsOptions
  }

  /**
   * `future` is for early opting-in to new features that will become default in a future (possibly major) version of the framework.
   */
  future: {
  /**
   * Enable early access to future features or flags.
   *
   */
    compatibilityVersion: 4 | 5

    /**
     * This enables early access to the experimental multi-app support.
     *
     * @see [Nuxt Issue #21635](https://github.com/nuxt/nuxt/issues/21635)
     */
    multiApp: boolean

    /**
     * This enables 'Bundler' module resolution mode for TypeScript, which is the recommended setting for frameworks like Nuxt and Vite.
     *
     * It improves type support when using modern libraries with `exports`.
     * You can set it to false to use the legacy 'Node' mode, which is the default for TypeScript.
     *
     * @see [TypeScript PR implementing `bundler` module resolution](https://github.com/microsoft/TypeScript/pull/51669)
     */
    typescriptBundlerResolution: boolean
  }

  /**
   * Some features of Nuxt are available on an opt-in basis, or can be disabled based on your needs.
   */
  features: {
  /**
   * Inline styles when rendering HTML (currently vite only).
   *
   * You can also pass a function that receives the path of a Vue component and returns a boolean indicating whether to inline the styles for that component.
   */
    inlineStyles: boolean | ((id?: string) => boolean)

    /**
     * Stream server logs to the client as you are developing. These logs can be handled in the `dev:ssr-logs` hook.
     *
     * If set to `silent`, the logs will not be printed to the browser console.
     */
    devLogs: boolean | 'silent'

    /**
     * Turn off rendering of Nuxt scripts and JS resource hints. You can also disable scripts more granularly within `routeRules`.
     *
     * If set to 'production' or `true`, JS will be disabled in production mode only.
     */
    noScripts: 'production' | 'all' | boolean
  }

  experimental: {
  /**
   * Enable to use experimental decorators in Nuxt and Nitro.
   *
   *
   * @see https://github.com/tc39/proposal-decorators
   */
    decorators: boolean

    /**
     * Set to true to generate an async entry point for the Vue bundle (for module federation support).
     */
    asyncEntry: boolean

    /**
     * Externalize `vue`, `@vue/*` and `vue-router` when building.
     *
     * @see [Nuxt Issue #13632](https://github.com/nuxt/nuxt/issues/13632)
     */
    externalVue: boolean

    /**
     * Enable accessing `appConfig` from server routes.
     *
     * @deprecated This option is not recommended.
     */
    serverAppConfig: boolean

    /**
     * Emit `app:chunkError` hook when there is an error loading vite/webpack chunks.
     *
     * By default, Nuxt will also perform a reload of the new route when a chunk fails to load when navigating to a new route (`automatic`).
     * Setting `automatic-immediate` will lead Nuxt to perform a reload of the current route right when a chunk fails to load (instead of waiting for navigation).
     * You can disable automatic handling by setting this to `false`, or handle chunk errors manually by setting it to `manual`.
     *
     * @see [Nuxt PR #19038](https://github.com/nuxt/nuxt/pull/19038)
     */
    emitRouteChunkError: false | 'manual' | 'automatic' | 'automatic-immediate'

    /**
     * By default the route object returned by the auto-imported `useRoute()` composable is kept in sync with the current page in view in `<NuxtPage>`. This is not true for `vue-router`'s exported `useRoute` or for the default `$route` object available in your Vue templates.
     *
     * By enabling this option a mixin will be injected to keep the `$route` template object in sync with Nuxt's managed `useRoute()`.
     */
    templateRouteInjection: boolean

    /**
     * Whether to restore Nuxt app state from `sessionStorage` when reloading the page after a chunk error or manual `reloadNuxtApp()` call.
     *
     * To avoid hydration errors, it will be applied only after the Vue app has been mounted, meaning there may be a flicker on initial load.
     * Consider carefully before enabling this as it can cause unexpected behavior, and consider providing explicit keys to `useState` as auto-generated keys may not match across builds.
     */
    restoreState: boolean

    /**
     * Render JSON payloads with support for revivifying complex types.
     */
    renderJsonPayloads: boolean

    /**
     * Disable vue server renderer endpoint within nitro.
     */
    noVueServer: boolean

    /**
     * When this option is enabled (by default) payload of pages that are prerendered are extracted
     */
    payloadExtraction: boolean | undefined

    /**
     * Whether to enable the experimental `<NuxtClientFallback>` component for rendering content on the client if there's an error in SSR.
     */
    clientFallback: boolean

    /**
     * Enable cross-origin prefetch using the Speculation Rules API.
     */
    crossOriginPrefetch: boolean

    /**
     * Enable View Transition API integration with client-side router.
     *
     * @see [View Transitions API](https://developer.chrome.com/docs/web-platform/view-transitions)
     */
    viewTransition: boolean | 'always'

    /**
     * Write early hints when using node server.
     *
     * @note nginx does not support 103 Early hints in the current version.
     */
    writeEarlyHints: boolean

    /**
     * Experimental component islands support with `<NuxtIsland>` and `.island.vue` files.
     *
     * By default it is set to 'auto', which means it will be enabled only when there are islands, server components or server pages in your app.
     */
    componentIslands: true | 'auto' | 'local' | 'local+remote' | Partial<{ remoteIsland: boolean, selectiveClient: boolean | 'deep' }> | false

    /**
     * Resolve `~`, `~~`, `@` and `@@` aliases located within layers with respect to their layer source and root directories.
     */
    localLayerAliases: boolean

    /**
     * Enable the new experimental typed router using [unplugin-vue-router](https://github.com/posva/unplugin-vue-router).
     */
    typedPages: boolean

    /**
     * Use app manifests to respect route rules on client-side.
     */
    appManifest: boolean

    /**
     * Set the time interval (in ms) to check for new builds. Disabled when `experimental.appManifest` is `false`.
     *
     * Set to `false` to disable.
     */
    checkOutdatedBuildInterval: number | false

    /**
     * Set an alternative watcher that will be used as the watching service for Nuxt.
     *
     * Nuxt uses 'chokidar-granular' if your source directory is the same as your root directory . This will ignore top-level directories (like `node_modules` and `.git`) that are excluded from watching.
     * You can set this instead to `parcel` to use `@parcel/watcher`, which may improve performance in large projects or on Windows platforms.
     * You can also set this to `chokidar` to watch all files in your source directory.
     *
     * @see [chokidar](https://github.com/paulmillr/chokidar)
     *
     * @see [@parcel/watcher](https://github.com/parcel-bundler/watcher)
     */
    watcher: 'chokidar' | 'parcel' | 'chokidar-granular'

    /**
     * Enable native async context to be accessible for nested composables
     *
     * @see [Nuxt PR #20918](https://github.com/nuxt/nuxt/pull/20918)
     */
    asyncContext: boolean

    /**
     * Use new experimental head optimisations:
     *
     * - Add the capo.js head plugin in order to render tags in of the head in a more performant way. - Uses the hash hydration plugin to reduce initial hydration
     *
     * @see [Nuxt Discussion #22632](https://github.com/nuxt/nuxt/discussions/22632)
     */
    headNext: boolean

    /**
     * Allow defining `routeRules` directly within your `~/pages` directory using `defineRouteRules`.
     *
     * Rules are converted (based on the path) and applied for server requests. For example, a rule defined in `~/pages/foo/bar.vue` will be applied to `/foo/bar` requests. A rule in `~/pages/foo/[id].vue` will be applied to `/foo/**` requests.
     * For more control, such as if you are using a custom `path` or `alias` set in the page's `definePageMeta`, you should set `routeRules` directly within your `nuxt.config`.
     */
    inlineRouteRules: boolean

    /**
     * Allow exposing some route metadata defined in `definePageMeta` at build-time to modules (alias, name, path, redirect, props, middleware).
     *
     * This only works with static or strings/arrays rather than variables or conditional assignment.
     *
     * @see [Nuxt Issues #24770](https://github.com/nuxt/nuxt/issues/24770)
     */
    scanPageMeta: boolean | 'after-resolve'

    /**
     * Configure additional keys to extract from the page metadata when using `scanPageMeta`.
     *
     * This allows modules to access additional metadata from the page metadata. It's recommended to augment the NuxtPage types with your keys.
     */
    extraPageMetaExtractionKeys: string[]

    /**
     * Automatically share payload _data_ between pages that are prerendered. This can result in a significant performance improvement when prerendering sites that use `useAsyncData` or `useFetch` and fetch the same data in different pages.
     *
     * It is particularly important when enabling this feature to make sure that any unique key of your data is always resolvable to the same data. For example, if you are using `useAsyncData` to fetch data related to a particular page, you should provide a key that uniquely matches that data. (`useFetch` should do this automatically for you.)
     *
     * @example
     * ```ts
     * // This would be unsafe in a dynamic page (e.g. `[slug].vue`) because the route slug makes a difference
     * // to the data fetched, but Nuxt can't know that because it's not reflected in the key.
     * const route = useRoute()
     * const { data } = await useAsyncData(async () => {
     *   return await $fetch(`/api/my-page/${route.params.slug}`)
     * })
     * // Instead, you should use a key that uniquely identifies the data fetched.
     * const { data } = await useAsyncData(route.params.slug, async () => {
     *   return await $fetch(`/api/my-page/${route.params.slug}`)
     * })
     * ```
     */
    sharedPrerenderData: boolean

    /**
     * Enables CookieStore support to listen for cookie updates (if supported by the browser) and refresh `useCookie` ref values.
     *
     * @see [CookieStore](https://developer.mozilla.org/en-US/docs/Web/API/CookieStore)
     */
    cookieStore: boolean

    /**
     * Enable experimental Vite Environment API
     */
    viteEnvironmentApi: boolean

    /**
     * This allows specifying the default options for core Nuxt components and composables.
     *
     * These options will likely be moved elsewhere in the future, such as into `app.config` or into the `app/` directory.
     */
    defaults: {
      nuxtLink: NuxtLinkOptions

      /**
       * Options that apply to `useAsyncData` (and also therefore `useFetch`)
       */
      useAsyncData: {
        deep: boolean
      }

      useFetch: Pick<FetchOptions, 'timeout' | 'retry' | 'retryDelay' | 'retryStatusCodes'>
    }

    /**
     * Automatically polyfill Node.js imports in the client build using `unenv`.
     *
     * @see [unenv](https://github.com/unjs/unenv)
     *
     * **Note:** To make globals like `Buffer` work in the browser, you need to manually inject them.
     *
     * ```ts
     * import { Buffer } from 'node:buffer'
     *
     * globalThis.Buffer = globalThis.Buffer || Buffer
     * ```
     */
    clientNodeCompat: boolean

    /**
     * Wait for a single animation frame before navigation, which gives an opportunity for the browser to repaint, acknowledging user interaction.
     *
     * It can reduce INP when navigating on prerendered routes.
     */
    navigationRepaint: boolean

    /**
     * Cache Nuxt/Nitro build artifacts based on a hash of the configuration and source files.
     *
     * This only works for source files within `srcDir` and `serverDir` for the Vue/Nitro parts of your app.
     */
    buildCache: boolean

    /**
     * Ensure that auto-generated Vue component names match the full component name you would use to auto-import the component.
     */
    normalizeComponentNames: boolean

    /**
     * Keep showing the spa-loading-template until suspense:resolve
     *
     * @see [Nuxt Issues #21721](https://github.com/nuxt/nuxt/issues/21721)
     */
    spaLoadingTemplateLocation: 'body' | 'within'

    /**
     * Enable timings for Nuxt application hooks in the performance panel of Chromium-based browsers.
     *
     * This feature adds performance markers for Nuxt hooks, allowing you to track their execution time in the browser's Performance tab. This is particularly useful for debugging performance issues.
     *
     * @example
     * ```ts
     * // nuxt.config.ts
     * export default defineNuxtConfig({
     *   experimental: {
     *     // Enable performance markers for Nuxt hooks in browser devtools
     *     browserDevtoolsTiming: true
     *   }
     * })
     * ```
     *
     * @see [PR #29922](https://github.com/nuxt/nuxt/pull/29922)
     *
     * @see [Chrome DevTools Performance API](https://developer.chrome.com/docs/devtools/performance/extension#tracks)
     */
    browserDevtoolsTiming: boolean

    /**
     * Enable integration with Chrome DevTools Workspaces
     * for Nuxt projects.
     *
     * @default true
     * @see [Chrome DevTools Project Settings](https://docs.google.com/document/d/1rfKPnxsNuXhnF7AiQZhu9kIwdiMS5hnAI05HBwFuBSM/edit)
     */
    chromeDevtoolsProjectSettings: boolean

    /**
     * Record mutations to `nuxt.options` in module context, helping to debug configuration changes made by modules during the Nuxt initialization phase.
     *
     * When enabled, Nuxt will track which modules modify configuration options, making it easier to trace unexpected configuration changes.
     *
     * @example
     * ```ts
     * // nuxt.config.ts
     * export default defineNuxtConfig({
     *   experimental: {
     *     // Enable tracking of config mutations by modules
     *     debugModuleMutation: true
     *   }
     * })
     * ```
     *
     * @see [PR #30555](https://github.com/nuxt/nuxt/pull/30555)
     */
    debugModuleMutation: boolean

    /**
     * Enable automatic configuration of hydration strategies for `<Lazy>` components.
     *
     * This feature intelligently determines when to hydrate lazy components based on visibility, idle time, or other triggers, improving performance by deferring hydration of components until they're needed.
     *
     * @example
     * ```ts
     * // nuxt.config.ts
     * export default defineNuxtConfig({
     *   experimental: {
     *     lazyHydration: true // Enable smart hydration strategies for Lazy components
     *   }
     * })
     *
     * // In your Vue components
     * <template>
     *   <Lazy>
     *     <ExpensiveComponent />
     *   </Lazy>
     * </template>
     * ```
     *
     * @see [PR #26468](https://github.com/nuxt/nuxt/pull/26468)
     */
    lazyHydration: boolean

    /**
     * Disable resolving imports into Nuxt templates from the path of the module that added the template.
     *
     * By default, Nuxt attempts to resolve imports in templates relative to the module that added them. Setting this to `false` disables this behavior, which may be useful if you're experiencing resolution conflicts in certain environments.
     *
     * @example
     * ```ts
     * // nuxt.config.ts
     * export default defineNuxtConfig({
     *   experimental: {
     *     // Disable template import resolution from module path
     *     templateImportResolution: false
     *   }
     * })
     * ```
     *
     * @see [PR #31175](https://github.com/nuxt/nuxt/pull/31175)
     */
    templateImportResolution: boolean

    /**
     * Whether to clean up Nuxt static and asyncData caches on route navigation.
     *
     * Nuxt will automatically purge cached data from `useAsyncData` and `nuxtApp.static.data`. This helps prevent memory leaks and ensures fresh data is loaded when needed, but it is possible to disable it.
     *
     * @example
     * ```ts
     * // nuxt.config.ts
     * export default defineNuxtConfig({
     *   experimental: {
     *     // Disable automatic cache cleanup (default is true)
     *     purgeCachedData: false
     *   }
     * })
     * ```
     *
     * @see [PR #31379](https://github.com/nuxt/nuxt/pull/31379)
     */
    purgeCachedData: boolean

    /**
     * Whether to call and use the result from `getCachedData` on manual refresh for `useAsyncData` and `useFetch`.
     */
    granularCachedData: boolean

    /**
     * Whether to run `useFetch` when the key changes, even if it is set to `immediate: false` and it has not been triggered yet.
     *
     * `useFetch` and `useAsyncData` will always run when the key changes if `immediate: true` or if it has been already triggered.
     */
    alwaysRunFetchOnKeyChange: boolean

    /**
     * Whether to parse `error.data` when rendering a server error page.
     */
    parseErrorData: boolean

    /**
     * Whether Nuxt should stop if a Nuxt module is incompatible.
     */
    enforceModuleCompatibility: boolean

    /**
     * For `useAsyncData` and `useFetch`, whether `pending` should be `true` when data has not yet started to be fetched.
     */
    pendingWhenIdle: boolean

    /**
     * Whether to improve chunk stability by using an import map to resolve the entry chunk of the bundle.
     */
    entryImportMap: boolean

    /**
     * Extract async data handler functions into separate chunks for better performance and caching.
     *
     * When enabled, handler functions passed to `useAsyncData` and `useLazyAsyncData` will be extracted
     * into separate chunks and dynamically imported, allowing for better code splitting and caching.
     *
     * @experimental This is an experimental feature and API may change in the future.
     */
    extractAsyncDataHandlers: boolean

    /**
     * Whether to enable `@dxup/nuxt` module for better TypeScript DX.
     *
     * @see https://github.com/KazariEX/dxup
     */
    typescriptPlugin: boolean
  }

  /**
   *
   * @private
   */
  _majorVersion: number

  /**
   *
   * @private
   */
  _prepare: boolean

  /**
   *
   * @private
   */
  _requiredModules: Record<string, boolean>

  /**
   *
   * @private
   */
  _loadOptions: { dotenv?: boolean | DotenvOptions }

  /**
   *
   * @private
   */
  _nuxtConfigFile: string

  /**
   *
   * @private
   */
  _nuxtConfigFiles: Array<string>

  /**
   *
   * @private
   */
  appDir: string

  /**
   *
   * @private
   */
  _installedModules: Array<{ meta: ModuleMeta, module: NuxtModule, timings?: Record<string, number | undefined>, entryPath?: string }>

  /**
   *
   * @private
   */
  _modules: Array<any>

  /**
   * Configuration for Nuxt's server builder.
   */
  server: {
    builder?: '@nuxt/nitro-server' | (string & {}) | { bundle: (nuxt: Nuxt) => Promise<void> }
  }

  /**
   * Configuration for Nitro.
   *
   * @see [Nitro configuration docs](https://nitro.build/config)
   */
  nitro: NitroConfig

  /**
   * Global route options applied to matching server routes.
   *
   * @experimental This is an experimental feature and API may change in the future.
   *
   * @see [Nitro route rules documentation](https://nitro.build/config#routerules)
   */
  routeRules: NitroConfig['routeRules']

  /**
   * Nitro server handlers.
   *
   * Each handler accepts the following options:
   * - handler: The path to the file defining the handler. - route: The route under which the handler is available. This follows the conventions of [rou3](https://github.com/h3js/rou3). - method: The HTTP method of requests that should be handled. - middleware: Specifies whether it is a middleware handler. - lazy: Specifies whether to use lazy loading to import the handler.
   *
   * @see [`server/` directory documentation](https://nuxt.com/docs/4.x/directory-structure/server)
   *
   * @note Files from `server/api`, `server/middleware` and `server/routes` will be automatically registered by Nuxt.
   *
   * @example
   * ```js
   * serverHandlers: [
   *   { route: '/path/foo/**:name', handler: '~/server/foohandler.ts' }
   * ]
   * ```
   */
  serverHandlers: NitroEventHandler[]

  /**
   * Nitro development-only server handlers.
   *
   * @see [Nitro server routes documentation](https://nitro.build/guide/routing)
   */
  devServerHandlers: NitroDevEventHandler[]

  postcss: {
  /**
   * A strategy for ordering PostCSS plugins.
   */
    order: 'cssnanoLast' | 'autoprefixerLast' | 'autoprefixerAndCssnanoLast' | string[] | ((names: string[]) => string[])

    /**
     * Options for configuring PostCSS plugins.
     *
     * @see [PostCSS docs](https://postcss.org/)
     */
    plugins: Record<string, unknown> & { autoprefixer?: false | AutoprefixerOptions, cssnano?: false | CssnanoOptions }
  }

  router: {
  /**
   * Additional router options passed to `vue-router`. On top of the options for `vue-router`, Nuxt offers additional options to customize the router (see below).
   *
   * @note Only JSON serializable options should be passed by Nuxt config.
   * For more control, you can use `app/router.options.ts` file.
   *
   * @see [Vue Router documentation](https://router.vuejs.org/api/interfaces/routeroptions)
   */
    options: RouterConfigSerializable
  }

  /**
   * Configuration for Nuxt's TypeScript integration.
   */
  typescript: {
  /**
   * TypeScript comes with certain checks to give you more safety and analysis of your program. Once you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety. [Read More](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#getting-stricter-checks)
   *
   */
    strict: boolean

    /**
     * Which builder types to include for your project.
     *
     * By default Nuxt infers this based on your `builder` option (defaulting to 'vite') but you can either turn off builder environment types (with `false`) to handle this fully yourself, or opt for a 'shared' option.
     * The 'shared' option is advised for module authors, who will want to support multiple possible builders.
     */
    builder: 'vite' | 'webpack' | 'rspack' | 'shared' | false | undefined | null

    /**
     * Modules to generate deep aliases for within `compilerOptions.paths`. This does not yet support subpaths. It may be necessary when using Nuxt within a pnpm monorepo with `shamefully-hoist=false`.
     */
    hoist: Array<string>

    /**
     * Include parent workspace in the Nuxt project. Mostly useful for themes and module authors.
     */
    includeWorkspace: boolean

    /**
     * Enable build-time type checking.
     *
     * If set to true, this will type check in development. You can restrict this to build-time type checking by setting it to `build`. Requires to install `typescript` and `vue-tsc` as dev dependencies.
     *
     * @see [Nuxt TypeScript docs](https://nuxt.com/docs/4.x/guide/concepts/typescript)
     */
    typeCheck: boolean | 'build'

    /**
     * You can extend the generated `.nuxt/tsconfig.app.json` (and legacy `.nuxt/tsconfig.json`) using this option.
     */
    tsConfig: 0 extends 1 & RawVueCompilerOptions ? TSConfig : TSConfig & { vueCompilerOptions?: RawVueCompilerOptions }

    /**
     * You can extend the generated `.nuxt/tsconfig.node.json` using this option.
     */
    nodeTsConfig: TSConfig

    /**
     * You can extend the generated `.nuxt/tsconfig.shared.json` using this option.
     */
    sharedTsConfig: TSConfig

    /**
     * Generate a `*.vue` shim.
     *
     * We recommend instead letting the [official Vue extension](https://marketplace.visualstudio.com/items?itemName=Vue.volar) generate accurate types for your components.
     * Note that you may wish to set this to `true` if you are using other libraries, such as ESLint, that are unable to understand the type of `.vue` files.
     */
    shim: boolean
  }

  esbuild: {
  /**
   * Configure shared esbuild options used within Nuxt and passed to other builders, such as Vite or Webpack.
   */
    options: EsbuildTransformOptions
  }

  oxc: {
    transform: {
      options: OxcTransformOptions
    }
  }

  /**
   * Configuration that will be passed directly to Vite.
   *
   * @see [Vite configuration docs](https://vite.dev/config/) for more information.
   * Please note that not all vite options are supported in Nuxt.
   */
  vite: ViteOptions

  webpack: {
  /**
   * Nuxt uses `webpack-bundle-analyzer` to visualize your bundles and how to optimize them.
   *
   * Set to `true` to enable bundle analysis, or pass an object with options: [for webpack](https://github.com/webpack/webpack-bundle-analyzer#options-for-plugin) or [for vite](https://github.com/btd/rollup-plugin-visualizer#options).
   *
   * @example
   * ```js
   * analyze: {
   *   analyzerMode: 'static'
   * }
   * ```
   */
    analyze: boolean | { enabled?: boolean } & BundleAnalyzerPlugin.Options

    /**
     * Enable the profiler in webpackbar.
     *
     * It is normally enabled by CLI argument `--profile`.
     *
     * @see [webpackbar](https://github.com/unjs/webpackbar#profile).
     */
    profile: boolean

    /**
     * Enables Common CSS Extraction.
     *
     * Using [mini-css-extract-plugin](https://github.com/webpack/mini-css-extract-plugin) under the hood, your CSS will be extracted into separate files, usually one per component. This allows caching your CSS and JavaScript separately.
     *
     * @example
     * ```js
     * export default {
     *   webpack: {
     *     extractCSS: true,
     *     // or
     *     extractCSS: {
     *       ignoreOrder: true
     *     }
     *   }
     * }
     * ```
     *
     * If you want to extract all your CSS to a single file, there is a workaround for this.
     * However, note that it is not recommended to extract everything into a single file.
     * Extracting into multiple CSS files is better for caching and preload isolation. It
     * can also improve page performance by downloading and resolving only those resources
     * that are needed.
     *
     * @example
     * ```js
     * export default {
     *   webpack: {
     *     extractCSS: true,
     *     optimization: {
     *       splitChunks: {
     *         cacheGroups: {
     *           styles: {
     *             name: 'styles',
     *             test: /\.(css|vue)$/,
     *             chunks: 'all',
     *             enforce: true
     *           }
     *         }
     *       }
     *     }
     *   }
     * }
     * ```
     */
    extractCSS: boolean | PluginOptions

    /**
     * Enables CSS source map support (defaults to `true` in development).
     */
    cssSourceMap: boolean

    /**
     * The polyfill library to load to provide URL and URLSearchParams.
     *
     * Defaults to `'url'` ([see package](https://www.npmjs.com/package/url)).
     */
    serverURLPolyfill: string

    /**
     * Customize bundle filenames.
     *
     * To understand a bit more about the use of manifests, take a look at [webpack documentation](https://webpack.js.org/guides/code-splitting/).
     *
     * @note Be careful when using non-hashed based filenames in production
     * as most browsers will cache the asset and not detect the changes on first load.
     *
     * This example changes fancy chunk names to numerical ids:
     *
     * @example
     * ```js
     * filenames: {
     *   chunk: ({ isDev }) => (isDev ? '[name].js' : '[id].[contenthash].js')
     * }
     * ```
     */
    filenames:
    Record<string, string | ((
      ctx: {
        nuxt: Nuxt
        options: NuxtOptions
        name: string
        isDev: boolean
        isServer: boolean
        isClient: boolean
        alias: { [index: string]: string | false | string[] }
        transpile: RegExp[]
      }) => string)
    >

    /**
     * Customize the options of Nuxt's integrated webpack loaders.
     */
    loaders: {
      /**
       * @see [esbuild loader](https://github.com/privatenumber/esbuild-loader)
       */
      esbuild: Omit<LoaderOptions, 'loader'>

      /**
       * @see [`file-loader` Options](https://github.com/webpack/file-loader#options)
       */
      file: {
        esModule: boolean

        limit: number
      }

      /**
       * @see [`file-loader` Options](https://github.com/webpack/file-loader#options)
       */
      fontUrl: {
        esModule: boolean

        limit: number
      }

      /**
       * @see [`file-loader` Options](https://github.com/webpack/file-loader#options)
       */
      imgUrl: {
        esModule: boolean

        limit: number
      }

      /**
       * @see [`pug` options](https://pugjs.org/api/reference.html#options)
       */
      pugPlain: PugOptions

      /**
       * See [vue-loader](https://github.com/vuejs/vue-loader) for available options.
       */
      vue: Partial<VueLoaderOptions>

      /**
       * See [css-loader](https://github.com/webpack/css-loader) for available options.
       */
      css: {
        importLoaders: number

        url: boolean | { filter: (url: string, resourcePath: string) => boolean }

        esModule: boolean
      }

      /**
       * See [css-loader](https://github.com/webpack/css-loader) for available options.
       */
      cssModules: {
        importLoaders: number

        url: boolean | { filter: (url: string, resourcePath: string) => boolean }

        esModule: boolean

        modules: {
          localIdentName: string
        }
      }

      /**
       * @see [`less-loader` Options](https://github.com/webpack/less-loader#options)
       */
      less: any

      /**
       * @see [`sass-loader` Options](https://github.com/webpack/sass-loader#options)
       */
      sass: {
        sassOptions: {
          indentedSyntax: boolean
        }
      }

      /**
       * @see [`sass-loader` Options](https://github.com/webpack/sass-loader#options)
       */
      scss: any

      /**
       * @see [`stylus-loader` Options](https://github.com/webpack/stylus-loader#options)
       */
      stylus: any

      vueStyle: any
    }

    /**
     * Add webpack plugins.
     *
     * @example
     * ```js
     * import webpack from 'webpack'
     * import { version } from './package.json.ts'
     * // ...
     * plugins: [
     *   new webpack.DefinePlugin({
     *     'process.VERSION': version
     *   })
     * ]
     * ```
     */
    plugins: Array<any>

    /**
     * Hard-replaces `typeof process`, `typeof window` and `typeof document` to tree-shake bundle.
     */
    aggressiveCodeRemoval: boolean

    /**
     * OptimizeCSSAssets plugin options.
     *
     * Defaults to true when `extractCSS` is enabled.
     *
     * @see [css-minimizer-webpack-plugin documentation](https://github.com/webpack/css-minimizer-webpack-plugin).
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-object-type
    optimizeCSS: false | BasePluginOptions & DefinedDefaultMinimizerAndOptions<{}>

    /**
     * Configure [webpack optimization](https://webpack.js.org/configuration/optimization/).
     */
    optimization: false | Configuration['optimization']

    /**
     * Customize PostCSS Loader. same options as [`postcss-loader` options](https://github.com/webpack/postcss-loader#options)
     */
    postcss: { execute?: boolean, postcssOptions: ProcessOptions & { plugins: Record<string, unknown> & { autoprefixer?: AutoprefixerOptions, cssnano?: CssnanoOptions } }, sourceMap?: boolean, implementation?: any }

    /**
     * See [webpack-dev-middleware](https://github.com/webpack/webpack-dev-middleware) for available options.
     */
    devMiddleware: WebpackDevMiddlewareOptions<IncomingMessage, ServerResponse>

    /**
     * See [webpack-hot-middleware](https://github.com/webpack/webpack-hot-middleware) for available options.
     */
    hotMiddleware: MiddlewareOptions & { client?: ClientOptions }

    /**
     * Set to `false` to disable the overlay provided by [FriendlyErrorsWebpackPlugin](https://github.com/nuxt/friendly-errors-webpack-plugin).
     */
    friendlyErrors: boolean

    /**
     * Filters to hide build warnings.
     */
    warningIgnoreFilters: Array<(warn: WebpackError | Error) => boolean>

    /**
     * Configure [webpack experiments](https://webpack.js.org/configuration/experiments/)
     */
    experiments: false | Configuration['experiments']
  }
}
</file>

<file path="packages/schema/src/utils/definition.ts">
import type { InputObject } from 'untyped'

import type { ConfigSchema } from '../types/schema.ts'

type KeysOf<T, Prefix extends string | unknown = unknown> = keyof T extends string
  ?
    {
      [K in keyof T]: K extends string
        ? string extends K
          ? never // exclude generic 'string' type
          : unknown extends Prefix
            ? `${K | KeysOf<T[K], K>}`
            : Prefix extends string
              ? `${Prefix}.${K | KeysOf<T[K], `hey.${Prefix}.${K}`>}`
              : never
        : never
    }[keyof T]
  : never

type ReturnFromKey<T, K extends string> = keyof T extends string
  ? K extends keyof T
    ? T[K]
    : K extends `${keyof T}.${string}`
      ? K extends `${infer Prefix}.${string}`
        ? Prefix extends keyof T
          ? K extends `${Prefix}.${infer Suffix}`
            ? ReturnFromKey<T[Prefix], Suffix>
            : never
          : never
        : never
      : never
  : never

type Awaitable<T> = T | Promise<T>

interface Resolvers<ReturnValue> {
  $resolve: (val: unknown, get: <K extends KeysOf<ConfigSchema>>(key: K) => Promise<ReturnFromKey<ConfigSchema, K>>) => Awaitable<ReturnValue>
  $schema?: InputObject['$schema']
  $default?: ReturnValue
}

type Resolvable<Namespace> = keyof Exclude<NonNullable<Namespace>, boolean | string | (() => any)> extends string
  ? {
    [K in keyof Namespace]: Partial<Resolvable<Namespace[K]>> | Resolvers<Namespace[K]>
  } | Namespace
  : Namespace | Resolvers<Namespace>

export function defineResolvers<C extends Partial<Resolvable<ConfigSchema>>> (config: C) {
  return config as any
}
</file>

<file path="packages/schema/src/builder-env.ts">
import './types/builder-env/index.ts'

export const builders = ['vite', 'webpack'] as const
</file>

<file path="packages/schema/src/index.ts">
// Types
export type { NuxtCompatibility, NuxtCompatibilityIssue, NuxtCompatibilityIssues } from './types/compatibility.ts'
export type { Component, ComponentMeta, ComponentsDir, ComponentsOptions, ScanDir } from './types/components.ts'
export type { KeyedFunction } from './types/compiler.ts'
export type { AppConfig, AppConfigInput, CustomAppConfig, NuxtAppConfig, NuxtBuilder, NuxtConfig, NuxtConfigLayer, NuxtOptions, PublicRuntimeConfig, RuntimeConfig, RuntimeValue, SchemaDefinition, UpperSnakeCase, ViteConfig, ViteOptions } from './types/config.ts'
// eslint-disable-next-line @typescript-eslint/no-deprecated
export type { ImportPresetWithDeprecation } from './types/hooks.ts'
export type { GenerateAppOptions, HookResult, NuxtAnalyzeMeta, NuxtHookName, NuxtHooks, NuxtLayout, NuxtMiddleware, NuxtPage, TSReference, VueTSConfig, WatchEvent } from './types/hooks.ts'
export type { ImportsOptions } from './types/imports.ts'
export type { AppHeadMetaObject, MetaObject, MetaObjectRaw } from './types/head.ts'
export type { ModuleDefinition, ModuleDependencies, ModuleDependencyMeta, ModuleMeta, ModuleOptions, ModuleSetupInstallResult, ModuleSetupReturn, NuxtModule, ResolvedModuleOptions } from './types/module.ts'
export type { Nuxt, NuxtApp, NuxtPlugin, NuxtPluginTemplate, NuxtTemplate, NuxtTypeTemplate, NuxtServerTemplate, ResolvedNuxtTemplate } from './types/nuxt.ts'
export type { RouterConfig, RouterConfigSerializable, RouterOptions } from './types/router.ts'
export type { NuxtDebugContext, NuxtDebugModuleMutationRecord } from './types/debug.ts'

// Schema
export { default as NuxtConfigSchema } from './config/index.ts'
</file>

<file path="packages/schema/test/folder-structure.spec.ts">
import { describe, expect, it, vi } from 'vitest'
import { applyDefaults } from 'untyped'
import process from 'node:process'

import { normalize } from 'pathe'
import { NuxtConfigSchema } from '../src/index.ts'
import type { NuxtOptions } from '../src/index.ts'

vi.mock('node:fs', () => ({
  existsSync: (id: string) => id.endsWith('app'),
}))

describe('nuxt folder structure', () => {
  it('should resolve directories for v3 setup correctly', async () => {
    const result = await applyDefaults(NuxtConfigSchema, {})
    expect(getDirs(result as unknown as NuxtOptions)).toMatchInlineSnapshot(`
      {
        "dir": {
          "app": "<cwd>/app",
          "modules": "<cwd>/modules",
          "public": "<cwd>/public",
        },
        "rootDir": "<cwd>",
        "serverDir": "<cwd>/server",
        "srcDir": "<cwd>/app",
        "workspaceDir": "<cwd>",
      }
    `)
  })

  it('should resolve directories with a custom `srcDir` and `rootDir`', async () => {
    const result = await applyDefaults(NuxtConfigSchema, { srcDir: 'src/', rootDir: '/test' })
    expect(getDirs(result as unknown as NuxtOptions)).toMatchInlineSnapshot(`
      {
        "dir": {
          "app": "/test/src",
          "modules": "/test/modules",
          "public": "/test/public",
        },
        "rootDir": "/test",
        "serverDir": "/test/server",
        "srcDir": "/test/src",
        "workspaceDir": "/test",
      }
    `)
  })

  it('should resolve directories', async () => {
    const result = await applyDefaults(NuxtConfigSchema, {})
    expect(getDirs(result as unknown as NuxtOptions)).toMatchInlineSnapshot(`
      {
        "dir": {
          "app": "<cwd>/app",
          "modules": "<cwd>/modules",
          "public": "<cwd>/public",
        },
        "rootDir": "<cwd>",
        "serverDir": "<cwd>/server",
        "srcDir": "<cwd>/app",
        "workspaceDir": "<cwd>",
      }
    `)
  })

  it('should resolve directories when opting-in to v4 schema with a custom `srcDir` and `rootDir`', async () => {
    const result = await applyDefaults(NuxtConfigSchema, { srcDir: 'customApp/', rootDir: '/test' })
    expect(getDirs(result as unknown as NuxtOptions)).toMatchInlineSnapshot(`
      {
        "dir": {
          "app": "/test/customApp",
          "modules": "/test/modules",
          "public": "/test/public",
        },
        "rootDir": "/test",
        "serverDir": "/test/server",
        "srcDir": "/test/customApp",
        "workspaceDir": "/test",
      }
    `)
  })

  it('should not override value from user for serverDir', async () => {
    const result = await applyDefaults(NuxtConfigSchema, { serverDir: '/myServer' })
    expect(getDirs(result as unknown as NuxtOptions)).toMatchInlineSnapshot(`
      {
        "dir": {
          "app": "<cwd>/app",
          "modules": "<cwd>/modules",
          "public": "<cwd>/public",
        },
        "rootDir": "<cwd>",
        "serverDir": "/myServer",
        "srcDir": "<cwd>/app",
        "workspaceDir": "<cwd>",
      }
    `)
  })
})

function getDirs (options: NuxtOptions) {
  const stripRoot = (dir: string) => {
    return normalize(dir).replace(normalize(process.cwd()), '<cwd>')
  }
  return {
    rootDir: stripRoot(options.rootDir),
    serverDir: stripRoot(options.serverDir),
    srcDir: stripRoot(options.srcDir),
    dir: {
      app: stripRoot(options.dir.app),
      modules: stripRoot(options.dir.modules),
      public: stripRoot(options.dir.public),
    },
    workspaceDir: stripRoot(options.workspaceDir!),
  }
}
</file>

<file path="packages/schema/.attw.json">
{
  "ignoreRules": [
    "cjs-resolves-to-esm"
  ]
}
</file>

<file path="packages/schema/.gitignore">
/schema
</file>

<file path="packages/schema/build.config.ts">
import { defineBuildConfig } from 'unbuild'

export default defineBuildConfig({
  declaration: true,
  entries: [
    'src/index',
    'src/builder-env',
  ],
  rollup: {
    dts: { respectExternal: false },
    inlineDependencies: ['untyped', 'knitwork'],
  },
  externals: [
    // Type imports
    '@unhead/vue',
    '@vitejs/plugin-vue',
    'chokidar',
    '@vitejs/plugin-vue-jsx',
    '@vue/language-core',
    'autoprefixer',
    'c12',
    'compatx',
    'css-minimizer-webpack-plugin',
    'cssnano',
    'esbuild',
    'esbuild-loader',
    'file-loader',
    'h3',
    'hookable',
    'ignore',
    'mini-css-extract-plugin',
    'nitro',
    'nitropack',
    'nuxt/app',
    'ofetch',
    'oxc-transform',
    'postcss',
    'pug',
    'rollup-plugin-visualizer',
    'sass-loader',
    'scule',
    'unctx',
    'unimport',
    'vite',
    'vue',
    'vue-bundle-renderer',
    'vue-loader',
    'vue-router',
    'webpack',
    'webpack-bundle-analyzer',
    'webpack-dev-middleware',
    'webpack-hot-middleware',
    // Implicit
    '@vue/compiler-core',
    '@vue/compiler-sfc',
  ],
})
</file>

<file path="packages/schema/builder-env.d.ts">
export * from './dist/builder-env.ts'
</file>

<file path="packages/schema/package.json">
{
  "name": "@nuxt/schema",
  "version": "4.2.2",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nuxt/nuxt.git",
    "directory": "packages/schema"
  },
  "description": "Nuxt types and default configuration",
  "homepage": "https://nuxt.com",
  "license": "MIT",
  "type": "module",
  "types": "./dist/index.d.ts",
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs",
      "require": "./dist/index.mjs"
    },
    "./builder-env": {
      "types": "./dist/builder-env.d.ts",
      "import": "./dist/builder-env.mjs"
    },
    "./package.json": "./package.json"
  },
  "files": [
    "dist",
    "schema",
    "builder-env.d.ts",
    "env.d.ts"
  ],
  "scripts": {
    "prepack": "unbuild",
    "build:stub": "unbuild --stub",
    "test:attw": "attw --pack"
  },
  "devDependencies": {
    "@types/pug": "2.0.10",
    "@types/webpack-bundle-analyzer": "4.7.0",
    "@types/webpack-hot-middleware": "2.25.12",
    "@unhead/vue": "2.1.1",
    "@vitejs/plugin-vue": "6.0.3",
    "@vitejs/plugin-vue-jsx": "5.1.3",
    "@vue/compiler-core": "3.5.26",
    "@vue/compiler-sfc": "3.5.26",
    "@vue/language-core": "3.2.1",
    "c12": "3.3.3",
    "chokidar": "5.0.0",
    "compatx": "0.2.0",
    "css-minimizer-webpack-plugin": "7.0.4",
    "esbuild": "0.27.2",
    "esbuild-loader": "4.4.2",
    "file-loader": "6.2.0",
    "h3": "1.15.4",
    "hookable": "5.5.3",
    "ignore": "7.0.5",
    "mini-css-extract-plugin": "2.9.4",
    "nitropack": "2.12.9",
    "ofetch": "1.5.1",
    "oxc-transform": "0.106.0",
    "postcss": "8.5.6",
    "rollup-plugin-visualizer": "6.0.5",
    "sass-loader": "16.0.6",
    "scule": "1.3.0",
    "unbuild": "3.6.1",
    "unctx": "2.5.0",
    "unimport": "5.6.0",
    "untyped": "2.0.0",
    "vite": "7.3.0",
    "vue": "3.5.26",
    "vue-bundle-renderer": "2.2.0",
    "vue-loader": "17.4.2",
    "vue-router": "4.6.4",
    "webpack": "5.104.1",
    "webpack-dev-middleware": "7.4.5"
  },
  "dependencies": {
    "@vue/shared": "^3.5.26",
    "defu": "^6.1.4",
    "pathe": "^2.0.3",
    "pkg-types": "^2.3.0",
    "std-env": "^3.10.0"
  },
  "engines": {
    "node": "^14.18.0 || >=16.10.0"
  }
}
</file>

<file path="packages/ui-templates/lib/dev.ts">
import { runInNewContext } from 'node:vm'
import { join, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { promises as fsp } from 'node:fs'
import type { Plugin } from 'vite'
import genericMessages from '../templates/messages.json' with { type: 'json' }
import pkg from '../../nuxt/package.json' with { type: 'json' }

const templatesRoot = fileURLToPath(new URL('..', import.meta.url))

const r = (...path: string[]) => resolve(join(templatesRoot, ...path))

export const DevRenderingPlugin = () => {
  return <Plugin>{
    name: 'dev-rendering',
    async transformIndexHtml (html: string, context) {
      const page = context.originalUrl || '/'

      if (page.endsWith('.png')) { return }

      if (page === '/') {
        const templateNames = await fsp.readdir(r('templates'))
        const serializedData = JSON.stringify({ templateNames })
        return html.replace('{{ data }}', serializedData)
      }

      const contents = await fsp.readFile(r(page, 'index.html'), 'utf-8')

      const messages = JSON.parse(await fsp.readFile(r(page, 'messages.json'), 'utf-8'))

      const chunks = contents.split(/\{{2,3}[^{}]+\}{2,3}/)
      let templateString = chunks.shift()
      for (const expression of contents.matchAll(/\{{2,3}([^{}]+)\}{2,3}/g)) {
        const value = runInNewContext(expression[1]!.trim(), {
          version: pkg.version,
          messages: { ...genericMessages, ...messages },
        })
        templateString += `${value}${chunks.shift()}`
      }
      if (chunks.length > 0) {
        templateString += chunks.join('')
      }

      return templateString
    },
  }
}
</file>

<file path="packages/ui-templates/lib/prerender.ts">
import { fileURLToPath } from 'node:url'
import { promises as fsp } from 'node:fs'
import { glob } from 'tinyglobby'

const templatesRoot = fileURLToPath(new URL('..', import.meta.url))

async function main () {
  const templates = await glob(['dist/templates/*.js'], { cwd: templatesRoot })
  for (const file of templates) {
    const { template } = await import(file)
    const updated = template({
      // messages: {},
      name: '{{ name }}', // TODO
    })
    await fsp.mkdir(file.replace('.js', ''))
    await fsp.writeFile(file.replace('.js', '/index.html'), updated)
  }
}

main().catch(console.error)
</file>

<file path="packages/ui-templates/lib/render.ts">
import { fileURLToPath } from 'node:url'
import { readFileSync, rmdirSync, unlinkSync, writeFileSync } from 'node:fs'
import { copyFile, mkdir } from 'node:fs/promises'
import { basename, dirname, join } from 'pathe'
import type { Plugin } from 'vite'
import Beasties from 'beasties'
import { genObjectFromRawEntries } from 'knitwork'
import htmlnano from 'htmlnano'
import { glob } from 'tinyglobby'
import { camelCase } from 'scule'

import pkg from '../../nuxt/package.json' with { type: 'json' }
import genericMessages from '../templates/messages.json' with { type: 'json' }

const r = (path: string) => fileURLToPath(new URL(join('..', path), import.meta.url))
const replaceAll = (input: string, search: string | RegExp, replace: string) => input.split(search).join(replace)

export const RenderPlugin = () => {
  let outputDir: string
  return <Plugin> {
    name: 'render',
    configResolved (config) {
      outputDir = r(config.build.outDir)
    },
    enforce: 'post',
    async writeBundle () {
      const critters = new Beasties({ path: outputDir })
      const htmlFiles = await glob(['templates/**/*.html'], {
        cwd: outputDir,
        absolute: true,
      })

      const templateExports: Array<{
        exportName: string
        templateName: string
        types: string
      }> = []

      for (const fileName of htmlFiles) {
        // Infer template name
        const templateName = basename(dirname(fileName))

        // eslint-disable-next-line no-console
        console.log('Processing', templateName)

        // Read source template
        let html = readFileSync(fileName, 'utf-8')
        const isCompleteHTML = html.includes('<!DOCTYPE html>')

        if (html.includes('<html')) {
          // Apply critters to inline styles
          html = await critters.process(html)
        }
        html = html.replace(/<html[^>]*>/, '<html lang="en">')
        // We no longer need references to external CSS
        html = html.replace(/<link[^>]*>/g, '')

        // Inline SVGs
        const svgSources: string[] = []

        for (const [_, src] of html.matchAll(/src="([^"]+)"|url\([^)]+\)/g)) {
          if (src?.match(/\.svg$/)) {
            svgSources.push(src)
          }
        }

        for (const src of svgSources) {
          const svg = readFileSync(join(outputDir, src), 'utf-8')
          const base64Source = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`
          html = replaceAll(html, src, base64Source)
        }

        // Inline our scripts
        const scriptSources: [string, string][] = []

        for (const [block, src] of html.matchAll(/<script[^>]*src="([^"]*)"[^>]*>[\s\S]*?<\/script>/g)) {
          if (src?.match(/^\/.*\.js$/)) {
            scriptSources.push([block, src])
          }
        }

        for (const [scriptBlock, src] of scriptSources) {
          let contents = readFileSync(join(outputDir, src), 'utf-8')
          contents = replaceAll(contents, '/* empty css               */', '').trim()
          html = html.replace(scriptBlock, contents.length ? `<script>${contents}</script>` : '')
        }

        // Minify HTML
        html = await htmlnano.process(html, { collapseWhitespace: 'aggressive' }).then(r => r.html)

        if (!isCompleteHTML) {
          html = html.replace('<html><head></head><body>', '')
          html = html.replace('</body></html>', '')
        }

        html = html.replace(/\{\{ version \}\}/g, pkg.version)

        // Load messages
        const messages = JSON.parse(readFileSync(r(`templates/${templateName}/messages.json`), 'utf-8'))

        // Serialize into a js function
        const chunks = html.split(/\{{2,3}[^{}]+\}{2,3}/).map(chunk => JSON.stringify(chunk))
        const hasMessages = chunks.length > 1
        let hasExpression = false
        let templateString = chunks.shift()
        for (const [_, expression] of html.matchAll(/\{{2,3}([^{}]+)\}{2,3}/g)) {
          if (expression) {
            hasExpression = true
            templateString += ` + escapeHtml(${expression.trim()}) + ${chunks.shift()}`
          }
        }
        if (chunks.length > 0) {
          templateString += ' + ' + chunks.join(' + ')
        }
        const functionalCode = [
          hasExpression ? 'import { escapeHtml } from \'@vue/shared\'\n' : '',
          hasMessages ? `export type DefaultMessages = Record<${Object.keys({ ...genericMessages, ...messages }).map(a => `"${a}"`).join(' | ') || 'string'}, string | boolean | number >` : '',
          hasMessages ? `const _messages = ${JSON.stringify({ ...genericMessages, ...messages })}` : '',
          `export const template = (${hasMessages ? 'messages: Partial<DefaultMessages>' : ''}): string => {`,
          hasMessages ? '  messages = { ..._messages, ...messages }' : '',
          `  return ${templateString}`,
          '}',
        ].join('\n')

        const templateContent = html
          .match(/<body[^>]*>[\s\S]*<\/body>/)?.[0]
          .replace(/(?<=<\/|<)body/g, 'div')
          .replace(/messages\./g, '')
          .replace(/<script[^>]*>[\s\S]*?<\/script>/g, '')
          .replace(/<a href="(\/[^"]*)"([^>]*)>([\s\S]*)<\/a>/g, '<NuxtLink to="$1"$2>\n$3\n</NuxtLink>')

          .replace(/<([^>]+) ([a-z]+)="([^"]*)\{\{\s*(\w+)\s*\}\}([^"]*)"([^>]*)>/g, '<$1 :$2="`$3${$4}$5`"$6>')
          .replace(/>\{\{\s*(\w+)\s*\}\}<\/[\w-]*>/g, ' v-text="$1" />')
          .replace(/>\{\{\{\s*(\w+)\s*\}\}\}<\/[\w-]*>/g, ' v-html="$1" />')
        // We are not matching <link> <script> and <meta> tags as these aren't used yet in nuxt/ui
        // and should be taken care of wherever this SFC is used
        const title = html.match(/<title[^>]*>([\s\S]*)<\/title>/)?.[1]?.replace(/\{\{[\s\S]+?\}\}/g, (r) => {
          return `\${${r.slice(2, -2)}}`.replace(/messages\./g, 'props.')
        })
        const styleContent = Array.from(html.matchAll(/<style[^>]*>([\s\S]*?)<\/style>/g)).map(block => block[1]).join('\n')
        const globalStyles = styleContent.replace(/(?:\.[^{\d][^{]*\{[^}]*\})+.?/g, (r) => {
          const lastChar = r[r.length - 1]
          if (lastChar && !['}', '.', '@', '*', ':'].includes(lastChar)) {
            return ';' + lastChar
          }
          return lastChar || ''
        }).replace(/@media[^{]*\{\}/g, '')

        const inlineScripts: string[] = []
        for (const [_, i] of html.matchAll(/<script>([\s\S]*?)<\/script>/g)) {
          if (i && !i.includes('const t=document.createElement("link")')) {
            inlineScripts.push(i)
          }
        }

        const props = genObjectFromRawEntries(Object.entries({ ...genericMessages, ...messages }).map(([key, value]) => [key, {
          type: typeof value === 'string' ? 'String' : typeof value === 'number' ? 'Number' : typeof value === 'boolean' ? 'Boolean' : 'undefined',
          default: JSON.stringify(value),
        }]))
        const vueCode = [
          '<script setup>',
          title && 'import { useHead } from \'#imports\'',
          `const props = defineProps(${props})`,
          title && 'useHead(' + genObjectFromRawEntries([
            ['title', `\`${title}\``],
            ['script', inlineScripts.map(s => ({ innerHTML: `\`${s.replace(/[`$]/g, '\\$&')}\`` }))],
            ['style', [{ innerHTML: `\`${globalStyles.replace(/[`$]/g, '\\$&')}\`` }]],
          ]) + ')',
          '</script>',
          '<template>',
          templateContent,
          '</template>',
          '<style scoped>',
          styleContent.replace(globalStyles, ''),
          '</style>',
        ].filter(Boolean).join('\n').trim()

        // Generate types
        const types = [
          `export type DefaultMessages = Record<${Object.keys(messages).map(a => `"${a}"`).join(' | ') || 'string'}, string | boolean | number >`,
          'declare const template: (data: Partial<DefaultMessages>) => string',
          'export { template }',
        ].join('\n')

        // Register exports
        templateExports.push({
          exportName: camelCase(templateName),
          templateName,
          types,
        })

        // Write new template
        writeFileSync(fileName.replace('/index.html', '.ts'), functionalCode)
        writeFileSync(fileName.replace('/index.html', '.vue'), vueCode)

        // Remove original html file
        unlinkSync(fileName)
        rmdirSync(dirname(fileName))
      }

      // we manually copy files across rather than using symbolic links for better windows support
      const nuxtRoot = r('../nuxt')
      const nitroRoot = r('../nitro-server')
      for (const file of ['error-404.vue', 'error-500.vue', 'welcome.vue']) {
        await copyFile(r(`dist/templates/${file}`), join(nuxtRoot, 'src/app/components', file))
      }
      await mkdir(join(nitroRoot, 'src/runtime/templates'), { recursive: true })
      await copyFile(r(`dist/templates/error-500.ts`), join(nitroRoot, 'src/runtime/templates/error-500.ts'))
    },
  }
}
</file>

<file path="packages/ui-templates/public/icons/book-open-solid 1.svg">
<svg width="150" height="150" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M163.796 9.64c-16.555.935-49.457 4.34-69.77 16.72-1.401.855-2.196 2.374-2.196 3.962v109.445c0 3.474 3.816 5.67 7.033 4.058 20.898-10.474 51.121-13.331 66.065-14.113 5.103-.268 9.069-4.34 9.069-9.222V18.874c.003-5.327-4.637-9.547-10.201-9.234zM79.971 26.36C59.66 13.98 26.758 10.58 10.204 9.64 4.64 9.327 0 13.547 0 18.874v101.619c0 4.885 3.966 8.957 9.069 9.222 14.95.782 45.188 3.642 66.086 14.122 3.208 1.609 7.012-.584 7.012-4.049V30.268c0-1.591-.792-3.05-2.197-3.908z" fill="#D1E2E2"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h150v150H0z"/></clipPath></defs></svg>
</file>

<file path="packages/ui-templates/public/icons/discord-brands 1.svg">
<svg width="80" height="80" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M63.69 51.775c0 3.325-2.47 6.05-5.596 6.05-3.072 0-5.596-2.726-5.596-6.05 0-3.325 2.469-6.05 5.596-6.05 3.127 0 5.595 2.725 5.595 6.05zm-25.62-6.05c-3.126 0-5.595 2.725-5.595 6.05 0 3.325 2.524 6.05 5.596 6.05 3.127 0 5.595-2.726 5.595-6.05.055-3.325-2.468-6.05-5.595-6.05zM96 11.227V109c-13.82-12.133-9.4-8.117-25.454-22.945l2.908 10.083H11.246C5.046 96.138 0 91.124 0 84.911V11.227C0 5.014 5.047 0 11.246 0h73.508C90.954 0 96 5.014 96 11.227zM80.366 62.893c0-17.549-7.9-31.774-7.9-31.774-7.9-5.886-15.415-5.722-15.415-5.722l-.768.872c9.326 2.834 13.66 6.922 13.66 6.922-13.031-7.096-28.338-7.097-40.978-1.581-2.03.926-3.237 1.58-3.237 1.58s4.553-4.305 14.427-7.139l-.548-.654s-7.516-.163-15.415 5.723c0 0-7.9 14.224-7.9 31.773 0 0 4.609 7.903 16.732 8.284 0 0 2.03-2.453 3.675-4.524-6.966-2.07-9.6-6.43-9.6-6.43.807.56 2.138 1.288 2.25 1.362 9.259 5.152 22.411 6.84 34.23 1.907 1.92-.708 4.06-1.743 6.309-3.215 0 0-2.743 4.469-9.93 6.486 1.647 2.07 3.621 4.414 3.621 4.414 12.124-.382 16.787-8.284 16.787-8.284z" fill="#D1E2E2"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h80v80H0z"/></clipPath></defs></svg>
</file>

<file path="packages/ui-templates/public/icons/documentation-color-light.svg">
<svg width="342" height="165" viewBox="0 0 342 165" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_2687_3947)">
<path d="M0.152832 131.851H154.28" stroke="#E4E4E7"/>
<path d="M215.399 107.359H349.153" stroke="#E4E4E7"/>
<path d="M0.152832 77.2178L116.191 77.2178" stroke="#E4E4E7"/>
<path d="M36.1528 106.921L152.191 106.921" stroke="#E4E4E7"/>
<path d="M202.153 42.9209L317.305 42.9209" stroke="#E4E4E7"/>
<path d="M218.153 76.9209L345.305 76.9209" stroke="#E4E4E7"/>
<path d="M285.947 8.45605V166.979" stroke="#E4E4E7"/>
<path d="M252.602 16.8311V107.36" stroke="#E4E4E7"/>
<path d="M171.153 16.9209V107.45" stroke="#E4E4E7"/>
<path d="M218.153 16.9209V43.4501" stroke="#E4E4E7"/>
<path d="M122.153 16.9211L327.45 16.9209" stroke="#E4E4E7"/>
<path d="M1.92432 43.3086H148.163" stroke="#E4E4E7"/>
<path d="M122.392 16.4209V55.3659" stroke="#E4E4E7"/>
<path d="M36.084 0.920898L36.084 176.921" stroke="#E4E4E7"/>
<path d="M75.4448 43.249V175.152" stroke="#E4E4E7"/>
<circle opacity="0.7" cx="75.4448" cy="77.2178" r="3.5" fill="#00DC82"/>
<circle opacity="0.7" cx="36.1528" cy="131.85" r="3.5" fill="#00DC82"/>
<circle opacity="0.7" cx="285.947" cy="42.9209" r="3.5" fill="#00DC82"/>
<circle opacity="0.7" cx="252.602" cy="107.359" r="3.5" fill="#00DC82"/>
<g filter="url(#filter0_d_2687_3947)">
<path d="M122.846 50.7109L163.067 26.0929C166.656 23.9507 171.117 23.8611 174.77 25.8579L217.894 49.0819C221.524 51.0665 223.807 54.8133 223.892 58.9246L224.15 104.352C224.235 108.448 222.13 112.287 218.609 114.46L177.783 139.658C174.174 141.886 169.638 142.011 165.931 139.984L123.774 116.935C120.045 114.896 117.125 111.001 117.153 106.776L117.153 60.5974C117.18 56.5529 119.338 52.8048 122.846 50.7109Z" fill="white"/>
<path d="M222.151 104.393C222.22 107.764 220.487 110.944 217.571 112.75C217.567 112.753 217.563 112.755 217.559 112.758L176.733 137.956C173.748 139.798 169.96 139.907 166.89 138.229L124.733 115.18C121.469 113.395 119.131 110.069 119.153 106.79L119.153 106.776L119.153 60.6107C119.153 60.6086 119.153 60.6065 119.153 60.6044C119.178 57.2703 120.958 54.1669 123.871 52.4282L123.881 52.4225L123.89 52.4167L164.101 27.8047C164.101 27.8047 164.101 27.8047 164.101 27.8047C164.106 27.8022 164.11 27.7997 164.114 27.7972C167.078 26.0385 170.793 25.9632 173.81 27.6128L173.81 27.6128L173.821 27.6188L216.934 50.8367C216.936 50.8377 216.938 50.8387 216.94 50.8397C219.935 52.4801 221.817 55.5878 221.892 58.9515L222.15 104.363L222.15 104.378L222.151 104.393Z" stroke="url(#paint0_linear_2687_3947)" stroke-width="4"/>
</g>
<path d="M192.349 96.9158L190.63 90.5186L183.778 64.9088C183.55 64.0605 182.994 63.3375 182.233 62.8988C181.472 62.4601 180.568 62.3416 179.72 62.5693L173.323 64.2877L173.116 64.3498C172.807 63.945 172.409 63.6168 171.953 63.3906C171.497 63.1644 170.995 63.0463 170.486 63.0455H163.861C163.279 63.0471 162.707 63.2043 162.205 63.501C161.703 63.2043 161.132 63.0471 160.549 63.0455H153.924C153.045 63.0455 152.203 63.3945 151.582 64.0157C150.96 64.6369 150.611 65.4795 150.611 66.358V99.483C150.611 100.362 150.96 101.204 151.582 101.825C152.203 102.447 153.045 102.796 153.924 102.796H160.549C161.132 102.794 161.703 102.637 162.205 102.34C162.707 102.637 163.279 102.794 163.861 102.796H170.486C171.365 102.796 172.207 102.447 172.829 101.825C173.45 101.204 173.799 100.362 173.799 99.483V78.8627L177.836 93.9346L179.554 100.332C179.742 101.039 180.158 101.665 180.739 102.11C181.32 102.556 182.031 102.797 182.763 102.796C183.049 102.791 183.334 102.756 183.612 102.692L190.009 100.974C190.43 100.861 190.824 100.665 191.169 100.399C191.514 100.132 191.802 99.7997 192.018 99.4209C192.238 99.047 192.381 98.6325 192.438 98.2021C192.495 97.7717 192.465 97.3342 192.349 96.9158V96.9158ZM176.325 75.4881L182.722 73.7697L187.007 89.7732L180.61 91.4916L176.325 75.4881ZM180.569 65.7783L181.873 70.5607L175.476 72.2791L174.171 67.4967L180.569 65.7783ZM170.486 66.358V91.2018H163.861V66.358H170.486ZM160.549 66.358V71.3268H153.924V66.358H160.549ZM153.924 99.483V74.6393H160.549V99.483H153.924ZM170.486 99.483H163.861V94.5143H170.486V99.483ZM189.161 97.7646L182.763 99.483L181.459 94.6799L187.877 92.9615L189.161 97.7646V97.7646Z" fill="url(#paint1_linear_2687_3947)"/>
<rect x="2.15283" y="-3.0791" width="327" height="23" fill="url(#paint2_linear_2687_3947)"/>
<rect width="327" height="25" transform="matrix(1 0 0 -1 2.15283 166.921)" fill="url(#paint3_linear_2687_3947)"/>
<rect width="327" height="25" transform="matrix(0 1 1 0 0.152832 -17.0791)" fill="url(#paint4_linear_2687_3947)"/>
<rect x="342.153" y="-17.0791" width="327" height="25" transform="rotate(90 342.153 -17.0791)" fill="url(#paint5_linear_2687_3947)"/>
</g>
<defs>
<filter id="filter0_d_2687_3947" x="86.1528" y="-6.5791" width="169" height="179" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="15.5"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.07 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_2687_3947"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_2687_3947" result="shape"/>
</filter>
<linearGradient id="paint0_linear_2687_3947" x1="118.202" y1="60.3042" x2="223.159" y2="113.509" gradientUnits="userSpaceOnUse">
<stop stop-color="#00DC82"/>
<stop offset="1" stop-color="#003F25"/>
</linearGradient>
<linearGradient id="paint1_linear_2687_3947" x1="150.495" y1="71.0767" x2="191.769" y2="94.1139" gradientUnits="userSpaceOnUse">
<stop stop-color="#00DC82"/>
<stop offset="1" stop-color="#003F25"/>
</linearGradient>
<linearGradient id="paint2_linear_2687_3947" x1="165.653" y1="-3.0791" x2="166.153" y2="19.9209" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="white" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint3_linear_2687_3947" x1="163.5" y1="-2.30278e-07" x2="164.091" y2="24.9979" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="white" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint4_linear_2687_3947" x1="163.5" y1="-2.30278e-07" x2="164.091" y2="24.9979" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="white" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint5_linear_2687_3947" x1="505.653" y1="-17.0791" x2="506.244" y2="7.91876" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="white" stop-opacity="0"/>
</linearGradient>
<clipPath id="clip0_2687_3947">
<rect width="341" height="164" fill="white" transform="translate(0.152832 0.920898)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/documentation-color.svg">
<svg width="342" height="165" viewBox="0 0 342 165" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_2595_7273)">
<path d="M0.152832 131.851H154.28" stroke="#27272A"/>
<path d="M215.399 107.359H349.153" stroke="#27272A"/>
<path d="M0.152832 77.2178L116.191 77.2178" stroke="#27272A"/>
<path d="M36.1528 106.921L152.191 106.921" stroke="#27272A"/>
<path d="M202.153 42.9209L317.305 42.9209" stroke="#27272A"/>
<path d="M218.153 76.9209L345.305 76.9209" stroke="#27272A"/>
<path d="M285.947 8.45605V166.979" stroke="#27272A"/>
<path d="M252.602 16.8311V107.36" stroke="#27272A"/>
<path d="M171.153 16.9209V107.45" stroke="#27272A"/>
<path d="M218.153 16.9209V43.4501" stroke="#27272A"/>
<path d="M122.153 16.9211L327.45 16.9209" stroke="#27272A"/>
<path d="M1.92432 43.3086H148.163" stroke="#27272A"/>
<path d="M122.392 16.4209V55.3659" stroke="#27272A"/>
<path d="M36.084 0.920898L36.084 176.921" stroke="#27272A"/>
<path d="M75.4448 43.249V175.152" stroke="#27272A"/>
<circle opacity="0.14" cx="75.4448" cy="77.2178" r="3.5" fill="#00DC82"/>
<circle opacity="0.14" cx="36.1528" cy="131.85" r="3.5" fill="#00DC82"/>
<circle opacity="0.14" cx="285.947" cy="42.9209" r="3.5" fill="#00DC82"/>
<circle opacity="0.14" cx="252.602" cy="107.359" r="3.5" fill="#00DC82"/>
<g filter="url(#filter0_d_2595_7273)">
<path d="M122.846 50.7109L163.067 26.0929C166.656 23.9507 171.117 23.8611 174.77 25.8579L217.894 49.0819C221.524 51.0665 223.807 54.8133 223.892 58.9246L224.15 104.352C224.235 108.448 222.13 112.287 218.609 114.46L177.783 139.658C174.174 141.886 169.638 142.011 165.931 139.984L123.774 116.935C120.045 114.896 117.125 111.001 117.153 106.776L117.153 60.5974C117.18 56.5529 119.338 52.8048 122.846 50.7109Z" fill="#18181B"/>
<path d="M123.871 52.4282L123.881 52.4225L123.89 52.4167L164.101 27.8047C167.083 26.0291 170.786 25.9592 173.81 27.6128L173.81 27.6128L173.821 27.6188L216.934 50.8367C216.936 50.8376 216.938 50.8386 216.939 50.8395C219.938 52.4814 221.817 55.5694 221.892 58.9515L222.15 104.363L222.15 104.378L222.151 104.393C222.221 107.772 220.485 110.952 217.559 112.758L176.733 137.956C173.732 139.808 169.963 139.909 166.89 138.229L124.733 115.18C121.465 113.393 119.131 110.089 119.153 106.79L119.153 106.776L119.153 60.6107C119.153 60.6086 119.153 60.6065 119.153 60.6044C119.178 57.2703 120.958 54.1669 123.871 52.4282Z" stroke="url(#paint0_linear_2595_7273)" stroke-width="4"/>
</g>
<path d="M192.349 96.9158L190.63 90.5186L183.778 64.9088C183.55 64.0605 182.994 63.3375 182.233 62.8988C181.472 62.4601 180.568 62.3416 179.72 62.5693L173.323 64.2877L173.116 64.3498C172.807 63.945 172.409 63.6168 171.953 63.3906C171.497 63.1644 170.995 63.0463 170.486 63.0455H163.861C163.279 63.0471 162.707 63.2043 162.205 63.501C161.703 63.2043 161.132 63.0471 160.549 63.0455H153.924C153.045 63.0455 152.203 63.3945 151.582 64.0157C150.96 64.6369 150.611 65.4795 150.611 66.358V99.483C150.611 100.362 150.96 101.204 151.582 101.825C152.203 102.447 153.045 102.796 153.924 102.796H160.549C161.132 102.794 161.703 102.637 162.205 102.34C162.707 102.637 163.279 102.794 163.861 102.796H170.486C171.365 102.796 172.207 102.447 172.829 101.825C173.45 101.204 173.799 100.362 173.799 99.483V78.8627L177.836 93.9346L179.554 100.332C179.742 101.039 180.158 101.665 180.739 102.11C181.32 102.556 182.031 102.797 182.763 102.796C183.049 102.791 183.334 102.756 183.612 102.692L190.009 100.974C190.43 100.861 190.824 100.665 191.169 100.399C191.514 100.132 191.802 99.7998 192.018 99.4209C192.238 99.047 192.381 98.6325 192.438 98.2021C192.495 97.7717 192.465 97.3342 192.349 96.9158ZM176.325 75.4881L182.722 73.7697L187.007 89.7732L180.61 91.4916L176.325 75.4881ZM180.569 65.7783L181.873 70.5607L175.476 72.2791L174.171 67.4967L180.569 65.7783ZM170.486 66.358V91.2018H163.861V66.358H170.486ZM160.549 66.358V71.3268H153.924V66.358H160.549ZM153.924 99.483V74.6393H160.549V99.483H153.924ZM170.486 99.483H163.861V94.5143H170.486V99.483ZM189.161 97.7646L182.763 99.483L181.459 94.6799L187.877 92.9615L189.161 97.7646Z" fill="url(#paint1_linear_2595_7273)"/>
<rect x="2.15283" y="-3.0791" width="327" height="23" fill="url(#paint2_linear_2595_7273)"/>
<rect width="327" height="25" transform="matrix(1 0 0 -1 2.15283 166.921)" fill="url(#paint3_linear_2595_7273)"/>
<rect width="327" height="25" transform="matrix(0 1 1 0 0.152832 -17.0791)" fill="url(#paint4_linear_2595_7273)"/>
<rect x="342.153" y="-17.0791" width="327" height="25" transform="rotate(90 342.153 -17.0791)" fill="url(#paint5_linear_2595_7273)"/>
</g>
<defs>
<filter id="filter0_d_2595_7273" x="86.1528" y="-6.5791" width="169" height="179" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="15.5"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.07 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_2595_7273"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_2595_7273" result="shape"/>
</filter>
<linearGradient id="paint0_linear_2595_7273" x1="118.202" y1="60.3042" x2="223.159" y2="113.509" gradientUnits="userSpaceOnUse">
<stop stop-color="#00DC82"/>
<stop offset="1" stop-color="#003F25"/>
</linearGradient>
<linearGradient id="paint1_linear_2595_7273" x1="150.495" y1="71.0767" x2="191.769" y2="94.1139" gradientUnits="userSpaceOnUse">
<stop stop-color="#00DC82"/>
<stop offset="1" stop-color="#003F25"/>
</linearGradient>
<linearGradient id="paint2_linear_2595_7273" x1="165.653" y1="-3.0791" x2="166.153" y2="19.9209" gradientUnits="userSpaceOnUse">
<stop stop-color="#18181B"/>
<stop offset="1" stop-color="#18181B" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint3_linear_2595_7273" x1="163.5" y1="-2.30278e-07" x2="164.091" y2="24.9979" gradientUnits="userSpaceOnUse">
<stop stop-color="#18181B"/>
<stop offset="1" stop-color="#18181B" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint4_linear_2595_7273" x1="163.5" y1="-2.30278e-07" x2="164.091" y2="24.9979" gradientUnits="userSpaceOnUse">
<stop stop-color="#18181B"/>
<stop offset="1" stop-color="#18181B" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint5_linear_2595_7273" x1="505.653" y1="-17.0791" x2="506.244" y2="7.91876" gradientUnits="userSpaceOnUse">
<stop stop-color="#18181B"/>
<stop offset="1" stop-color="#18181B" stop-opacity="0"/>
</linearGradient>
<clipPath id="clip0_2595_7273">
<rect width="341" height="164" fill="white" transform="translate(0.152832 0.920898)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/documentation-light.svg">
<svg width="342" height="165" viewBox="0 0 342 165" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_2687_3977)">
<path d="M0.152832 131.851H154.28" stroke="#E4E4E7"/>
<path d="M215.399 107.359H349.153" stroke="#E4E4E7"/>
<path d="M0.152832 77.2178L116.191 77.2178" stroke="#E4E4E7"/>
<path d="M36.1528 106.921L152.191 106.921" stroke="#E4E4E7"/>
<path d="M202.153 42.9209L317.305 42.9209" stroke="#E4E4E7"/>
<path d="M218.153 76.9209L345.305 76.9209" stroke="#E4E4E7"/>
<path d="M285.947 8.45605V166.979" stroke="#E4E4E7"/>
<path d="M252.602 16.8311V107.36" stroke="#E4E4E7"/>
<path d="M171.153 16.9209V107.45" stroke="#E4E4E7"/>
<path d="M218.153 16.9209V43.4501" stroke="#E4E4E7"/>
<path d="M122.153 16.9211L327.45 16.9209" stroke="#E4E4E7"/>
<path d="M1.92432 43.3086H148.163" stroke="#E4E4E7"/>
<path d="M122.392 16.4209V55.3659" stroke="#E4E4E7"/>
<path d="M36.084 0.920898L36.084 176.921" stroke="#E4E4E7"/>
<path d="M75.4448 43.249V175.152" stroke="#E4E4E7"/>
<circle opacity="0.7" cx="75.4448" cy="77.2178" r="3.5" fill="#A1A1AA"/>
<circle opacity="0.7" cx="36.1528" cy="131.85" r="3.5" fill="#A1A1AA"/>
<circle opacity="0.7" cx="285.947" cy="42.9209" r="3.5" fill="#A1A1AA"/>
<circle opacity="0.7" cx="252.602" cy="107.359" r="3.5" fill="#A1A1AA"/>
<g filter="url(#filter0_d_2687_3977)">
<path d="M122.846 50.7109L163.067 26.0929C166.656 23.9507 171.117 23.8611 174.77 25.8579L217.894 49.0819C221.524 51.0665 223.807 54.8133 223.892 58.9246L224.15 104.352C224.235 108.448 222.13 112.287 218.609 114.46L177.783 139.658C174.174 141.886 169.638 142.011 165.931 139.984L123.774 116.935C120.045 114.896 117.125 111.001 117.153 106.776L117.153 60.5974C117.18 56.5529 119.338 52.8048 122.846 50.7109Z" fill="white"/>
<path d="M222.151 104.393C222.22 107.764 220.487 110.944 217.571 112.75C217.567 112.753 217.563 112.755 217.559 112.758L176.733 137.956C173.748 139.798 169.96 139.907 166.89 138.229L124.733 115.18C121.469 113.395 119.131 110.069 119.153 106.79L119.153 106.776L119.153 60.6107C119.153 60.6086 119.153 60.6065 119.153 60.6044C119.178 57.2703 120.958 54.1669 123.871 52.4282L123.881 52.4225L123.89 52.4167L164.101 27.8047C164.101 27.8047 164.101 27.8047 164.101 27.8047C164.106 27.8022 164.11 27.7997 164.114 27.7972C167.078 26.0385 170.793 25.9632 173.81 27.6128L173.81 27.6128L173.821 27.6188L216.934 50.8367C216.936 50.8377 216.938 50.8387 216.94 50.8397C219.935 52.4801 221.817 55.5878 221.892 58.9515L222.15 104.363L222.15 104.378L222.151 104.393Z" stroke="url(#paint0_linear_2687_3977)" stroke-width="4"/>
</g>
<path d="M192.349 96.9158L190.63 90.5186L183.778 64.9088C183.55 64.0605 182.994 63.3375 182.233 62.8988C181.472 62.4601 180.568 62.3416 179.72 62.5693L173.323 64.2877L173.116 64.3498C172.807 63.945 172.409 63.6168 171.953 63.3906C171.497 63.1644 170.995 63.0463 170.486 63.0455H163.861C163.279 63.0471 162.707 63.2043 162.205 63.501C161.703 63.2043 161.132 63.0471 160.549 63.0455H153.924C153.045 63.0455 152.203 63.3945 151.582 64.0157C150.96 64.6369 150.611 65.4795 150.611 66.358V99.483C150.611 100.362 150.96 101.204 151.582 101.825C152.203 102.447 153.045 102.796 153.924 102.796H160.549C161.132 102.794 161.703 102.637 162.205 102.34C162.707 102.637 163.279 102.794 163.861 102.796H170.486C171.365 102.796 172.207 102.447 172.829 101.825C173.45 101.204 173.799 100.362 173.799 99.483V78.8627L177.836 93.9346L179.554 100.332C179.742 101.039 180.158 101.665 180.739 102.11C181.32 102.556 182.031 102.797 182.763 102.796C183.049 102.791 183.334 102.756 183.612 102.692L190.009 100.974C190.43 100.861 190.824 100.665 191.169 100.399C191.514 100.132 191.802 99.7997 192.018 99.4209C192.238 99.047 192.381 98.6325 192.438 98.2021C192.495 97.7717 192.465 97.3342 192.349 96.9158V96.9158ZM176.325 75.4881L182.722 73.7697L187.007 89.7732L180.61 91.4916L176.325 75.4881ZM180.569 65.7783L181.873 70.5607L175.476 72.2791L174.171 67.4967L180.569 65.7783ZM170.486 66.358V91.2018H163.861V66.358H170.486ZM160.549 66.358V71.3268H153.924V66.358H160.549ZM153.924 99.483V74.6393H160.549V99.483H153.924ZM170.486 99.483H163.861V94.5143H170.486V99.483ZM189.161 97.7646L182.763 99.483L181.459 94.6799L187.877 92.9615L189.161 97.7646V97.7646Z" fill="url(#paint1_linear_2687_3977)"/>
<rect x="2.15283" y="-3.0791" width="327" height="23" fill="url(#paint2_linear_2687_3977)"/>
<rect width="327" height="25" transform="matrix(1 0 0 -1 2.15283 166.921)" fill="url(#paint3_linear_2687_3977)"/>
<rect width="327" height="25" transform="matrix(0 1 1 0 0.152832 -17.0791)" fill="url(#paint4_linear_2687_3977)"/>
<rect x="342.153" y="-17.0791" width="327" height="25" transform="rotate(90 342.153 -17.0791)" fill="url(#paint5_linear_2687_3977)"/>
</g>
<defs>
<filter id="filter0_d_2687_3977" x="86.1528" y="-6.5791" width="169" height="179" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="15.5"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.831373 0 0 0 0 0.831373 0 0 0 0 0.847059 0 0 0 0.07 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_2687_3977"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_2687_3977" result="shape"/>
</filter>
<linearGradient id="paint0_linear_2687_3977" x1="118.202" y1="60.3042" x2="223.159" y2="113.509" gradientUnits="userSpaceOnUse">
<stop stop-color="#D4D4D8"/>
<stop offset="1" stop-color="#3F3F46"/>
</linearGradient>
<linearGradient id="paint1_linear_2687_3977" x1="150.495" y1="71.0767" x2="191.769" y2="94.1139" gradientUnits="userSpaceOnUse">
<stop stop-color="#D4D4D8"/>
<stop offset="1" stop-color="#3F3F46"/>
</linearGradient>
<linearGradient id="paint2_linear_2687_3977" x1="165.653" y1="-3.0791" x2="166.153" y2="19.9209" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="white" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint3_linear_2687_3977" x1="163.5" y1="-2.30278e-07" x2="164.091" y2="24.9979" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="white" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint4_linear_2687_3977" x1="163.5" y1="-2.30278e-07" x2="164.091" y2="24.9979" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="white" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint5_linear_2687_3977" x1="505.653" y1="-17.0791" x2="506.244" y2="7.91876" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="white" stop-opacity="0"/>
</linearGradient>
<clipPath id="clip0_2687_3977">
<rect width="341" height="164" fill="white" transform="translate(0.152832 0.920898)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/documentation.svg">
<svg width="342" height="165" viewBox="0 0 342 165" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_2595_7193)">
<path d="M0.152832 131.851H154.28" stroke="#27272A"/>
<path d="M215.399 107.359H349.153" stroke="#27272A"/>
<path d="M0.152832 77.2178L116.191 77.2178" stroke="#27272A"/>
<path d="M36.1528 106.921L152.191 106.921" stroke="#27272A"/>
<path d="M202.153 42.9209L317.305 42.9209" stroke="#27272A"/>
<path d="M218.153 76.9209L345.305 76.9209" stroke="#27272A"/>
<path d="M285.947 8.45605V166.979" stroke="#27272A"/>
<path d="M252.602 16.8311V107.36" stroke="#27272A"/>
<path d="M171.153 16.9209V107.45" stroke="#27272A"/>
<path d="M218.153 16.9209V43.4501" stroke="#27272A"/>
<path d="M122.153 16.9211L327.45 16.9209" stroke="#27272A"/>
<path d="M1.92432 43.3086H148.163" stroke="#27272A"/>
<path d="M122.392 16.4209V55.3659" stroke="#27272A"/>
<path d="M36.084 0.920898L36.084 176.921" stroke="#27272A"/>
<path d="M75.4448 43.249V175.152" stroke="#27272A"/>
<circle opacity="0.14" cx="75.4448" cy="77.2178" r="3.5" fill="white"/>
<circle opacity="0.14" cx="36.1528" cy="131.85" r="3.5" fill="white"/>
<circle opacity="0.14" cx="285.947" cy="42.9209" r="3.5" fill="white"/>
<circle opacity="0.14" cx="252.602" cy="107.359" r="3.5" fill="white"/>
<g filter="url(#filter0_d_2595_7193)">
<path d="M122.846 50.7109L163.067 26.0929C166.656 23.9507 171.117 23.8611 174.77 25.8579L217.894 49.0819C221.524 51.0665 223.807 54.8133 223.892 58.9246L224.15 104.352C224.235 108.448 222.13 112.287 218.609 114.46L177.783 139.658C174.174 141.886 169.638 142.011 165.931 139.984L123.774 116.935C120.045 114.896 117.125 111.001 117.153 106.776L117.153 60.5974C117.18 56.5529 119.338 52.8048 122.846 50.7109Z" fill="#18181B"/>
<path d="M123.871 52.4282L123.881 52.4225L123.89 52.4167L164.101 27.8047C167.083 26.0291 170.786 25.9592 173.81 27.6128L173.81 27.6128L173.821 27.6188L216.934 50.8367C216.936 50.8376 216.938 50.8386 216.939 50.8395C219.938 52.4814 221.817 55.5694 221.892 58.9515L222.15 104.363L222.15 104.378L222.151 104.393C222.221 107.772 220.485 110.952 217.559 112.758L176.733 137.956C173.732 139.808 169.963 139.909 166.89 138.229L124.733 115.18C121.465 113.393 119.131 110.089 119.153 106.79L119.153 106.776L119.153 60.6107C119.153 60.6086 119.153 60.6065 119.153 60.6044C119.178 57.2703 120.958 54.1669 123.871 52.4282Z" stroke="url(#paint0_linear_2595_7193)" stroke-width="4"/>
</g>
<path d="M192.349 96.9158L190.63 90.5186L183.778 64.9088C183.55 64.0605 182.994 63.3375 182.233 62.8988C181.472 62.4601 180.568 62.3416 179.72 62.5693L173.323 64.2877L173.116 64.3498C172.807 63.945 172.409 63.6168 171.953 63.3906C171.497 63.1644 170.995 63.0463 170.486 63.0455H163.861C163.279 63.0471 162.707 63.2043 162.205 63.501C161.703 63.2043 161.132 63.0471 160.549 63.0455H153.924C153.045 63.0455 152.203 63.3945 151.582 64.0157C150.96 64.6369 150.611 65.4795 150.611 66.358V99.483C150.611 100.362 150.96 101.204 151.582 101.825C152.203 102.447 153.045 102.796 153.924 102.796H160.549C161.132 102.794 161.703 102.637 162.205 102.34C162.707 102.637 163.279 102.794 163.861 102.796H170.486C171.365 102.796 172.207 102.447 172.829 101.825C173.45 101.204 173.799 100.362 173.799 99.483V78.8627L177.836 93.9346L179.554 100.332C179.742 101.039 180.158 101.665 180.739 102.11C181.32 102.556 182.031 102.797 182.763 102.796C183.049 102.791 183.334 102.756 183.612 102.692L190.009 100.974C190.43 100.861 190.824 100.665 191.169 100.399C191.514 100.132 191.802 99.7998 192.018 99.4209C192.238 99.047 192.381 98.6325 192.438 98.2021C192.495 97.7717 192.465 97.3342 192.349 96.9158ZM176.325 75.4881L182.722 73.7697L187.007 89.7732L180.61 91.4916L176.325 75.4881ZM180.569 65.7783L181.873 70.5607L175.476 72.2791L174.171 67.4967L180.569 65.7783ZM170.486 66.358V91.2018H163.861V66.358H170.486ZM160.549 66.358V71.3268H153.924V66.358H160.549ZM153.924 99.483V74.6393H160.549V99.483H153.924ZM170.486 99.483H163.861V94.5143H170.486V99.483ZM189.161 97.7646L182.763 99.483L181.459 94.6799L187.877 92.9615L189.161 97.7646Z" fill="url(#paint1_linear_2595_7193)"/>
<rect x="2.15283" y="-3.0791" width="327" height="23" fill="url(#paint2_linear_2595_7193)"/>
<rect width="327" height="25" transform="matrix(1 0 0 -1 2.15283 166.921)" fill="url(#paint3_linear_2595_7193)"/>
<rect width="327" height="25" transform="matrix(0 1 1 0 0.152832 -17.0791)" fill="url(#paint4_linear_2595_7193)"/>
<rect x="342.153" y="-17.0791" width="327" height="25" transform="rotate(90 342.153 -17.0791)" fill="url(#paint5_linear_2595_7193)"/>
</g>
<defs>
<filter id="filter0_d_2595_7193" x="86.1528" y="-6.5791" width="169" height="179" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset/>
<feGaussianBlur stdDeviation="15.5"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.07 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_2595_7193"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_2595_7193" result="shape"/>
</filter>
<linearGradient id="paint0_linear_2595_7193" x1="118.202" y1="60.3042" x2="223.159" y2="113.509" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="#71717A"/>
</linearGradient>
<linearGradient id="paint1_linear_2595_7193" x1="150.495" y1="71.0767" x2="191.769" y2="94.1139" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="#71717A"/>
</linearGradient>
<linearGradient id="paint2_linear_2595_7193" x1="165.653" y1="-3.0791" x2="166.153" y2="19.9209" gradientUnits="userSpaceOnUse">
<stop stop-color="#18181B"/>
<stop offset="1" stop-color="#18181B" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint3_linear_2595_7193" x1="163.5" y1="-2.30278e-07" x2="164.091" y2="24.9979" gradientUnits="userSpaceOnUse">
<stop stop-color="#18181B"/>
<stop offset="1" stop-color="#18181B" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint4_linear_2595_7193" x1="163.5" y1="-2.30278e-07" x2="164.091" y2="24.9979" gradientUnits="userSpaceOnUse">
<stop stop-color="#18181B"/>
<stop offset="1" stop-color="#18181B" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint5_linear_2595_7193" x1="505.653" y1="-17.0791" x2="506.244" y2="7.91876" gradientUnits="userSpaceOnUse">
<stop stop-color="#18181B"/>
<stop offset="1" stop-color="#18181B" stop-opacity="0"/>
</linearGradient>
<clipPath id="clip0_2595_7193">
<rect width="341" height="164" fill="white" transform="translate(0.152832 0.920898)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/examples-color-light.svg">
<svg width="53" height="58" viewBox="0 0 53 58" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M49.1971 43.7595C49.1113 43.8209 49.0231 43.8796 48.9325 43.9357L29.0918 56.2117C27.6504 57.1035 25.8212 57.1564 24.3387 56.3439L3.85107 45.1148C2.27157 44.2491 1.14238 42.6366 1.15291 41.0494L1.15293 41.0427L1.153 18.552C1.15301 18.5509 1.15302 18.5499 1.15302 18.5488C1.16485 16.9324 2.02611 15.4289 3.43319 14.5869L3.43322 14.587L3.44269 14.5812L22.9844 2.59084C24.4169 1.73583 26.2139 1.69824 27.6729 2.49791L27.6729 2.49792L27.6784 2.50094L48.6303 13.8121C48.6313 13.8126 48.6322 13.8131 48.6331 13.8136C50.0797 14.6078 50.9898 16.1132 51.026 17.7438L51.1517 39.8672L51.1517 39.8746L51.1519 39.8821C51.1834 41.4138 50.4491 42.8635 49.1971 43.7595Z" fill="white" stroke="url(#paint0_linear_2613_3941)" stroke-width="2"/>
<path d="M37.1528 17.9209H15.1528C14.6224 17.9209 14.1137 18.1316 13.7386 18.5067C13.3635 18.8818 13.1528 19.3905 13.1528 19.9209V37.9209C13.1528 38.4513 13.3635 38.96 13.7386 39.3351C14.1137 39.7102 14.6224 39.9209 15.1528 39.9209H37.1528C37.6833 39.9209 38.192 39.7102 38.567 39.3351C38.9421 38.96 39.1528 38.4513 39.1528 37.9209V19.9209C39.1528 19.3905 38.9421 18.8818 38.567 18.5067C38.192 18.1316 37.6833 17.9209 37.1528 17.9209V17.9209ZM15.1528 19.9209H37.1528V24.9209H15.1528V19.9209ZM15.1528 26.9209H22.1528V37.9209H15.1528V26.9209ZM37.1528 37.9209H24.1528V26.9209H37.1528V37.9209Z" fill="url(#paint1_linear_2613_3941)"/>
<defs>
<linearGradient id="paint0_linear_2613_3941" x1="0.662695" y1="18.4025" x2="51.7209" y2="44.2212" gradientUnits="userSpaceOnUse">
<stop stop-color="#8DEAFF"/>
<stop offset="1" stop-color="#008AA9"/>
</linearGradient>
<linearGradient id="paint1_linear_2613_3941" x1="13.0804" y1="22.6224" x2="37.028" y2="37.847" gradientUnits="userSpaceOnUse">
<stop stop-color="#8DEAFF"/>
<stop offset="1" stop-color="#008AA9"/>
</linearGradient>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/examples-color.svg">
<svg width="53" height="58" viewBox="0 0 53 58" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.43319 14.5869L3.43322 14.587L3.44269 14.5812L22.9844 2.59084C24.4246 1.73116 26.2124 1.69742 27.6729 2.49791L27.6729 2.49792L27.6784 2.50094L48.6303 13.8121C48.6313 13.8126 48.6322 13.8131 48.6331 13.8137C50.0812 14.6086 50.9896 16.1043 51.026 17.7437L51.1517 39.8672L51.1517 39.8746L51.1519 39.8821C51.1856 41.5203 50.346 43.0611 48.9325 43.9357L29.0918 56.2117C27.6424 57.1085 25.8227 57.1572 24.3387 56.3439L3.85107 45.1148C2.26984 44.2481 1.14232 42.646 1.15293 41.0494V41.0427L1.153 18.552C1.15301 18.5509 1.15302 18.5499 1.15302 18.5488C1.16485 16.9324 2.02611 15.4289 3.43319 14.5869Z" fill="#18181B" stroke="url(#paint0_linear_2595_7426)" stroke-width="2"/>
<path d="M37.1528 17.9209H15.1528C14.6224 17.9209 14.1137 18.1316 13.7386 18.5067C13.3635 18.8818 13.1528 19.3905 13.1528 19.9209V37.9209C13.1528 38.4513 13.3635 38.96 13.7386 39.3351C14.1137 39.7102 14.6224 39.9209 15.1528 39.9209H37.1528C37.6833 39.9209 38.192 39.7102 38.567 39.3351C38.9421 38.96 39.1528 38.4513 39.1528 37.9209V19.9209C39.1528 19.3905 38.9421 18.8818 38.567 18.5067C38.192 18.1316 37.6833 17.9209 37.1528 17.9209ZM15.1528 19.9209H37.1528V24.9209H15.1528V19.9209ZM15.1528 26.9209H22.1528V37.9209H15.1528V26.9209ZM37.1528 37.9209H24.1528V26.9209H37.1528V37.9209Z" fill="url(#paint1_linear_2595_7426)"/>
<defs>
<linearGradient id="paint0_linear_2595_7426" x1="0.662695" y1="18.4025" x2="51.7209" y2="44.2212" gradientUnits="userSpaceOnUse">
<stop stop-color="#8DEAFF"/>
<stop offset="1" stop-color="#008AA9"/>
</linearGradient>
<linearGradient id="paint1_linear_2595_7426" x1="13.0804" y1="22.6224" x2="37.028" y2="37.847" gradientUnits="userSpaceOnUse">
<stop stop-color="#8DEAFF"/>
<stop offset="1" stop-color="#008AA9"/>
</linearGradient>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/examples-light.svg">
<svg width="53" height="58" viewBox="0 0 53 58" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M49.1971 43.7595C49.1113 43.8209 49.0231 43.8796 48.9325 43.9357L29.0918 56.2117C27.6504 57.1035 25.8212 57.1564 24.3387 56.3439L3.85107 45.1148C2.27157 44.2491 1.14238 42.6366 1.15291 41.0494L1.15293 41.0427L1.153 18.552C1.15301 18.5509 1.15302 18.5499 1.15302 18.5488C1.16485 16.9324 2.02611 15.4289 3.43319 14.5869L3.43322 14.587L3.44269 14.5812L22.9844 2.59084C24.4169 1.73583 26.2139 1.69824 27.6729 2.49791L27.6729 2.49792L27.6784 2.50094L48.6303 13.8121C48.6313 13.8126 48.6322 13.8131 48.6331 13.8136C50.0797 14.6078 50.9898 16.1132 51.026 17.7438L51.1517 39.8672L51.1517 39.8746L51.1519 39.8821C51.1834 41.4138 50.4491 42.8635 49.1971 43.7595Z" fill="white" stroke="url(#paint0_linear_2691_4397)" stroke-width="2"/>
<path d="M37.1528 17.9209H15.1528C14.6224 17.9209 14.1137 18.1316 13.7386 18.5067C13.3635 18.8818 13.1528 19.3905 13.1528 19.9209V37.9209C13.1528 38.4513 13.3635 38.96 13.7386 39.3351C14.1137 39.7102 14.6224 39.9209 15.1528 39.9209H37.1528C37.6833 39.9209 38.192 39.7102 38.567 39.3351C38.9421 38.96 39.1528 38.4513 39.1528 37.9209V19.9209C39.1528 19.3905 38.9421 18.8818 38.567 18.5067C38.192 18.1316 37.6833 17.9209 37.1528 17.9209V17.9209ZM15.1528 19.9209H37.1528V24.9209H15.1528V19.9209ZM15.1528 26.9209H22.1528V37.9209H15.1528V26.9209ZM37.1528 37.9209H24.1528V26.9209H37.1528V37.9209Z" fill="url(#paint1_linear_2691_4397)"/>
<defs>
<linearGradient id="paint0_linear_2691_4397" x1="0.662695" y1="18.4025" x2="51.7209" y2="44.2212" gradientUnits="userSpaceOnUse">
<stop stop-color="#D4D4D8"/>
<stop offset="1" stop-color="#71717A"/>
</linearGradient>
<linearGradient id="paint1_linear_2691_4397" x1="13.0804" y1="22.6224" x2="37.028" y2="37.847" gradientUnits="userSpaceOnUse">
<stop stop-color="#D4D4D8"/>
<stop offset="1" stop-color="#71717A"/>
</linearGradient>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/examples.svg">
<svg width="53" height="58" viewBox="0 0 53 58" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.43319 14.5869L3.43322 14.587L3.44269 14.5812L22.9844 2.59084C24.4246 1.73116 26.2124 1.69742 27.6729 2.49791L27.6729 2.49792L27.6784 2.50094L48.6303 13.8121C48.6313 13.8126 48.6322 13.8131 48.6331 13.8137C50.0812 14.6086 50.9896 16.1043 51.026 17.7437L51.1517 39.8672L51.1517 39.8746L51.1519 39.8821C51.1856 41.5203 50.346 43.0611 48.9325 43.9357L29.0918 56.2117C27.6424 57.1085 25.8227 57.1572 24.3387 56.3439L3.85107 45.1148C2.26984 44.2481 1.14232 42.646 1.15293 41.0494V41.0427L1.153 18.552C1.15301 18.5509 1.15302 18.5499 1.15302 18.5488C1.16485 16.9324 2.02611 15.4289 3.43319 14.5869Z" fill="#18181B" stroke="url(#paint0_linear_2595_7182)" stroke-width="2"/>
<path d="M37.1528 17.9209H15.1528C14.6224 17.9209 14.1137 18.1316 13.7386 18.5067C13.3635 18.8818 13.1528 19.3905 13.1528 19.9209V37.9209C13.1528 38.4513 13.3635 38.96 13.7386 39.3351C14.1137 39.7102 14.6224 39.9209 15.1528 39.9209H37.1528C37.6833 39.9209 38.192 39.7102 38.567 39.3351C38.9421 38.96 39.1528 38.4513 39.1528 37.9209V19.9209C39.1528 19.3905 38.9421 18.8818 38.567 18.5067C38.192 18.1316 37.6833 17.9209 37.1528 17.9209ZM15.1528 19.9209H37.1528V24.9209H15.1528V19.9209ZM15.1528 26.9209H22.1528V37.9209H15.1528V26.9209ZM37.1528 37.9209H24.1528V26.9209H37.1528V37.9209Z" fill="url(#paint1_linear_2595_7182)"/>
<defs>
<linearGradient id="paint0_linear_2595_7182" x1="0.662695" y1="18.4025" x2="51.7209" y2="44.2212" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="#71717A"/>
</linearGradient>
<linearGradient id="paint1_linear_2595_7182" x1="13.0804" y1="22.6224" x2="37.028" y2="37.847" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="#71717A"/>
</linearGradient>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/get-started-light.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="105" height="116" fill="none"><g filter="url(#a)"><path fill="#fff" d="M17.203 33.223 46.9 14.286a8.416 8.416 0 0 1 8.64-.18L87.38 31.97c2.68 1.527 4.365 4.409 4.428 7.571l.191 34.944c.063 3.151-1.491 6.104-4.091 7.776l-30.143 19.383a8.417 8.417 0 0 1-8.75.251l-31.126-17.73C15.135 82.595 12.98 79.6 13 76.35V40.828c.02-3.111 1.614-5.994 4.203-7.605Z"/><path stroke="url(#b)" stroke-width="2" d="M46.9 14.286 17.202 33.223c-2.59 1.61-4.183 4.494-4.203 7.605V76.35m33.9-62.064a8.416 8.416 0 0 1 8.64-.18m-8.64.18a8.435 8.435 0 0 1 8.64-.18M13 76.35c-.02 3.25 2.135 6.246 4.888 7.814M13 76.35c-.02 3.233 2.136 6.247 4.888 7.814m0 0 31.126 17.731m0 0a8.417 8.417 0 0 0 8.75-.251m-8.75.251a8.438 8.438 0 0 0 8.75-.251m0 0 30.143-19.383m0 0c2.598-1.67 4.154-4.627 4.091-7.776m-4.091 7.776c2.6-1.672 4.154-4.625 4.091-7.776m0 0-.19-34.944m0 0c-.064-3.162-1.75-6.044-4.43-7.571m4.43 7.571c-.063-3.147-1.75-6.045-4.43-7.571m0 0L55.54 14.105"/></g><path fill="#fff" d="M32 37h42v42H32z"/><path fill="url(#c)" d="M48.669 67.697c-.886 2.69-3.02 4.659-6.153 5.709-1.41.465-2.88.72-4.364.755a1.313 1.313 0 0 1-1.312-1.313c.035-1.484.29-2.954.754-4.364 1.05-3.134 3.02-5.266 5.71-6.152a1.314 1.314 0 1 1 .836 2.477c-3.232 1.083-4.232 4.577-4.544 6.595 2.018-.311 5.512-1.312 6.595-4.544a1.313 1.313 0 0 1 2.477.837Zm16.39-12.486-1.46 1.477v10.057a2.657 2.657 0 0 1-.772 1.854l-5.316 5.3a2.559 2.559 0 0 1-1.853.77 2.413 2.413 0 0 1-.755-.115 2.626 2.626 0 0 1-1.821-2.001l-1.296-6.48-6.858-6.858-6.48-1.297a2.625 2.625 0 0 1-2.002-1.82 2.609 2.609 0 0 1 .656-2.61l5.3-5.315a2.658 2.658 0 0 1 1.853-.771h10.057l1.477-1.46c4.692-4.692 9.499-4.561 11.353-4.282a2.576 2.576 0 0 1 2.198 2.198c.28 1.854.41 6.661-4.282 11.353Zm-26.103.132 6.185 1.23 6.546-6.546h-7.432l-5.299 5.316ZM47.438 58 53 63.562l10.205-10.204c1.28-1.28 4.2-4.725 3.543-9.106-4.38-.656-7.826 2.264-9.105 3.544L47.438 58Zm13.535 1.313-6.546 6.546 1.23 6.185 5.316-5.299v-7.432Z"/><defs><linearGradient id="b" x1="57.994" x2="92" y1="58" y2="58" gradientUnits="userSpaceOnUse"><stop stop-color="#00DC82"/><stop offset=".5" stop-color="#1DE0B1"/><stop offset="1" stop-color="#36E4DA"/></linearGradient><linearGradient id="c" x1="55.197" x2="69.453" y1="58.108" y2="58.108" gradientUnits="userSpaceOnUse"><stop stop-color="#00DC82"/><stop offset=".5" stop-color="#1DE0B1"/><stop offset="1" stop-color="#36E4DA"/></linearGradient><filter id="a" width="104.897" height="115.897" x=".052" y=".052" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/><feOffset/><feGaussianBlur stdDeviation="5.974"/><feComposite in2="hardAlpha" operator="out"/><feColorMatrix values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.07 0"/><feBlend in2="BackgroundImageFix" result="effect1_dropShadow_2726_4054"/><feBlend in="SourceGraphic" in2="effect1_dropShadow_2726_4054" result="shape"/></filter></defs></svg>
</file>

<file path="packages/ui-templates/public/icons/get-started.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="105" height="116" fill="none"><g filter="url(#a)" shape-rendering="geometricPrecision"><path fill="#18181B" d="M17.203 33.223 46.9 14.286a8.416 8.416 0 0 1 8.64-.18L87.38 31.97c2.68 1.527 4.365 4.409 4.428 7.571l.191 34.944c.063 3.151-1.491 6.104-4.091 7.776l-30.143 19.383a8.417 8.417 0 0 1-8.75.251l-31.126-17.73C15.135 82.595 12.98 79.6 13 76.35V40.828c.02-3.111 1.614-5.994 4.203-7.605Z"/><path stroke="url(#b)" stroke-width="2" d="M46.9 14.286 17.202 33.223c-2.59 1.61-4.183 4.494-4.203 7.605V76.35m33.9-62.064a8.416 8.416 0 0 1 8.64-.18m-8.64.18a8.435 8.435 0 0 1 8.64-.18M13 76.35c-.02 3.25 2.135 6.246 4.888 7.814M13 76.35c-.02 3.233 2.136 6.247 4.888 7.814m0 0 31.126 17.731m0 0a8.417 8.417 0 0 0 8.75-.251m-8.75.251a8.438 8.438 0 0 0 8.75-.251m0 0 30.143-19.383m0 0c2.598-1.67 4.154-4.627 4.091-7.776m-4.091 7.776c2.6-1.672 4.154-4.625 4.091-7.776m0 0-.19-34.944m0 0c-.064-3.162-1.75-6.044-4.43-7.571m4.43 7.571c-.063-3.147-1.75-6.045-4.43-7.571m0 0L55.54 14.105"/></g><path fill="url(#c)" d="M48.669 67.696c-.886 2.69-3.02 4.659-6.153 5.709-1.41.465-2.88.72-4.364.755a1.313 1.313 0 0 1-1.312-1.313c.035-1.484.29-2.954.754-4.364 1.05-3.133 3.02-5.266 5.71-6.152a1.312 1.312 0 1 1 .836 2.477c-3.232 1.083-4.232 4.577-4.544 6.595 2.018-.311 5.512-1.312 6.595-4.544a1.313 1.313 0 0 1 2.477.837Zm16.39-12.486-1.46 1.477v10.057a2.657 2.657 0 0 1-.772 1.854l-5.316 5.3a2.559 2.559 0 0 1-1.853.77 2.413 2.413 0 0 1-.755-.115 2.624 2.624 0 0 1-1.821-2.001l-1.296-6.48-6.858-6.858-6.48-1.297a2.625 2.625 0 0 1-2.002-1.82 2.609 2.609 0 0 1 .656-2.61l5.3-5.315a2.658 2.658 0 0 1 1.853-.771h10.057l1.477-1.46c4.692-4.692 9.499-4.561 11.353-4.282a2.576 2.576 0 0 1 2.198 2.198c.28 1.854.41 6.661-4.282 11.353Zm-26.103.132 6.185 1.23 6.546-6.546h-7.432l-5.299 5.316Zm8.482 2.657L53 63.561l10.205-10.205c1.28-1.28 4.2-4.724 3.543-9.105-4.38-.656-7.826 2.264-9.105 3.544L47.438 57.999Zm13.535 1.313-6.546 6.546 1.23 6.185 5.316-5.299v-7.432Z" shape-rendering="geometricPrecision"/><defs><linearGradient id="b" x1="57.994" x2="92" y1="58" y2="58" gradientUnits="userSpaceOnUse"><stop stop-color="#00DC82"/><stop offset=".5" stop-color="#1DE0B1"/><stop offset="1" stop-color="#36E4DA"/></linearGradient><linearGradient id="c" x1="55.197" x2="69.453" y1="58.107" y2="58.107" gradientUnits="userSpaceOnUse"><stop stop-color="#00DC82"/><stop offset=".5" stop-color="#1DE0B1"/><stop offset="1" stop-color="#36E4DA"/></linearGradient><filter id="a" width="104.897" height="115.897" x=".052" y=".052" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feColorMatrix in="SourceAlpha" result="hardAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/><feOffset/><feGaussianBlur stdDeviation="5.974"/><feComposite in2="hardAlpha" operator="out"/><feColorMatrix values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.07 0"/><feBlend in2="BackgroundImageFix" result="effect1_dropShadow_2724_4091"/><feBlend in="SourceGraphic" in2="effect1_dropShadow_2724_4091" result="shape"/></filter></defs></svg>
</file>

<file path="packages/ui-templates/public/icons/github-brands 1.svg">
<svg width="80" height="87" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M31.44 75.289c0 .379-.435.682-.985.682-.625.056-1.061-.247-1.061-.682 0-.38.436-.682.985-.682.569-.057 1.062.246 1.062.682zm-5.893-.853c-.133.379.246.815.815.928.492.19 1.061 0 1.175-.379.113-.378-.247-.814-.815-.985-.493-.132-1.043.057-1.175.436zm8.376-.322c-.55.133-.928.493-.871.928.056.38.55.626 1.118.493.55-.133.928-.493.871-.871-.056-.36-.568-.607-1.118-.55zm12.47-72.598C20.109 1.516 0 21.465 0 47.742c0 21.01 13.228 38.99 32.123 45.317 2.426.436 3.279-1.06 3.279-2.292 0-1.175-.057-7.654-.057-11.632 0 0-13.266 2.841-16.052-5.646 0 0-2.16-5.513-5.269-6.934 0 0-4.34-2.975.303-2.918 0 0 4.72.38 7.316 4.888 4.15 7.313 11.105 5.21 13.816 3.96.435-3.031 1.667-5.134 3.032-6.385-10.594-1.174-21.283-2.709-21.283-20.934 0-5.21 1.44-7.825 4.473-11.16-.493-1.23-2.104-6.308.492-12.863 3.961-1.232 13.077 5.115 13.077 5.115 3.79-1.06 7.865-1.61 11.902-1.61 4.036 0 8.11.55 11.901 1.61 0 0 9.116-6.365 13.077-5.115 2.596 6.574.985 11.632.493 12.864 3.032 3.353 4.89 5.968 4.89 11.159 0 18.282-11.163 19.74-21.757 20.934 1.743 1.497 3.221 4.339 3.221 8.79 0 6.385-.056 14.286-.056 15.84 0 1.23.871 2.727 3.278 2.291C81.151 86.731 94 68.752 94 47.742 94 21.465 72.68 1.516 46.394 1.516zM18.422 66.858c-.246.19-.19.625.133.985.303.303.739.436.985.19.246-.19.19-.626-.133-.986-.303-.303-.739-.435-.985-.189zm-2.047-1.535c-.133.247.057.55.436.74.303.189.682.132.815-.133.133-.247-.057-.55-.436-.74-.379-.113-.682-.056-.815.133zm6.14 6.745c-.303.246-.189.815.247 1.175.436.435.985.492 1.232.189.246-.246.132-.815-.247-1.175-.417-.435-.985-.492-1.231-.189zm-2.16-2.785c-.303.19-.303.682 0 1.118.303.436.815.625 1.061.436.303-.247.303-.74 0-1.175-.265-.436-.758-.625-1.061-.379z" fill="#D1E2E2"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h80v86.761H0z"/></clipPath></defs></svg>
</file>

<file path="packages/ui-templates/public/icons/logo.svg">
<svg width="61" height="42" viewBox="0 0 61 42" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M33.9869 41.2211H56.412C57.1243 41.2212 57.824 41.0336 58.4408 40.6772C59.0576 40.3209 59.5698 39.8083 59.9258 39.191C60.2818 38.5737 60.469 37.8736 60.4687 37.1609C60.4684 36.4482 60.2805 35.7482 59.924 35.1313L44.864 9.03129C44.508 8.41416 43.996 7.90168 43.3793 7.54537C42.7626 7.18906 42.063 7.00147 41.3509 7.00147C40.6387 7.00147 39.9391 7.18906 39.3225 7.54537C38.7058 7.90168 38.1937 8.41416 37.8377 9.03129L33.9869 15.7093L26.458 2.65061C26.1018 2.03354 25.5895 1.52113 24.9726 1.16489C24.3557 0.808639 23.656 0.621094 22.9438 0.621094C22.2316 0.621094 21.5318 0.808639 20.915 1.16489C20.2981 1.52113 19.7858 2.03354 19.4296 2.65061L0.689224 35.1313C0.332704 35.7482 0.144842 36.4482 0.144532 37.1609C0.144222 37.8736 0.331476 38.5737 0.687459 39.191C1.04344 39.8083 1.5556 40.3209 2.17243 40.6772C2.78925 41.0336 3.48899 41.2212 4.20126 41.2211H18.2778C23.8551 41.2211 27.9682 38.7699 30.7984 33.9876L37.6694 22.0813L41.3498 15.7093L52.3951 34.8492H37.6694L33.9869 41.2211ZM18.0484 34.8426L8.2247 34.8404L22.9504 9.32211L30.2979 22.0813L25.3784 30.6092C23.4989 33.7121 21.3637 34.8426 18.0484 34.8426Z" fill="#00DC82"/>
</svg>
</file>

<file path="packages/ui-templates/public/icons/MiniGem.svg">
<svg width="14" height="14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="m6.667 0 4.041 7H2.625l4.042-7zm0 14L2.625 7h8.083l-4.041 7z" opacity=".9" fill="#00DC82"/></svg>
</file>

<file path="packages/ui-templates/public/icons/modules-color-light.svg">
<svg width="53" height="58" viewBox="0 0 53 58" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_2613_3853)">
<path d="M51.1519 39.8821C51.154 39.9844 51.1527 40.0863 51.148 40.1877C51.0782 41.7091 50.2566 43.1165 48.9325 43.9357L29.0918 56.2117C27.6504 57.1035 25.8212 57.1564 24.3387 56.3439L3.85107 45.1148C2.27157 44.2491 1.14238 42.6366 1.15291 41.0494L1.15293 41.0427L1.153 18.552C1.15301 18.5509 1.15302 18.5499 1.15302 18.5488C1.16485 16.9324 2.02611 15.4289 3.43319 14.5869L3.43322 14.587L3.44269 14.5812L22.9844 2.59084C24.4169 1.73583 26.2139 1.69824 27.6729 2.49791L27.6729 2.49792L27.6784 2.50094L48.6303 13.8121C48.6313 13.8126 48.6322 13.8131 48.6331 13.8136C50.0797 14.6078 50.9898 16.1132 51.026 17.7438L51.1517 39.8672L51.1517 39.8746L51.1519 39.8821Z" fill="white" stroke="url(#paint0_linear_2613_3853)" stroke-width="2"/>
<path d="M33.8193 42.2552H17.8193C16.7585 42.2552 15.7411 41.8337 14.9909 41.0836C14.2408 40.3334 13.8193 39.316 13.8193 38.2552V24.9218C13.8193 23.861 14.2408 22.8435 14.9909 22.0934C15.7411 21.3433 16.7585 20.9218 17.8193 20.9218H19.1527C19.1751 19.792 19.5558 18.6985 20.2399 17.7991C20.924 16.8996 21.8761 16.2407 22.9589 15.9173C24.0416 15.594 25.1992 15.6229 26.2644 16C27.3297 16.377 28.2477 17.0827 28.886 18.0152C29.4839 18.8674 29.8094 19.8808 29.8193 20.9218H33.8193C34.173 20.9218 34.5121 21.0623 34.7621 21.3124C35.0122 21.5624 35.1527 21.9015 35.1527 22.2552V26.2552C36.2825 26.2776 37.376 26.6583 38.2754 27.3424C39.1749 28.0265 39.8338 28.9786 40.1572 30.0613C40.4805 31.1441 40.4516 32.3016 40.0745 33.3669C39.6975 34.4322 38.9918 35.3502 38.0593 35.9885C37.2071 36.5864 36.1937 36.9118 35.1527 36.9218V36.9218V40.9218C35.1527 41.2755 35.0122 41.6146 34.7621 41.8646C34.5121 42.1147 34.173 42.2552 33.8193 42.2552ZM17.8193 23.5885C17.4657 23.5885 17.1266 23.729 16.8765 23.979C16.6265 24.2291 16.486 24.5682 16.486 24.9218V38.2552C16.486 38.6088 16.6265 38.9479 16.8765 39.198C17.1266 39.448 17.4657 39.5885 17.8193 39.5885H32.486V35.3485C32.4849 35.1347 32.5351 34.9238 32.6326 34.7335C32.7301 34.5432 32.8718 34.3792 33.046 34.2552C33.2196 34.1313 33.4204 34.051 33.6316 34.0208C33.8427 33.9907 34.058 34.0116 34.2593 34.0818C34.6393 34.2368 35.0532 34.2901 35.46 34.2363C35.8669 34.1825 36.2527 34.0236 36.5793 33.7752C36.9045 33.5769 37.1834 33.3113 37.3973 32.9962C37.6111 32.6811 37.7551 32.3239 37.8193 31.9485C37.8708 31.5699 37.8402 31.1847 37.7298 30.8189C37.6194 30.4532 37.4317 30.1154 37.1793 29.8285C36.8381 29.414 36.3734 29.1193 35.8529 28.9874C35.3325 28.8555 34.7835 28.8932 34.286 29.0952C34.0846 29.1654 33.8694 29.1863 33.6582 29.1562C33.4471 29.126 33.2463 29.0457 33.0727 28.9218C32.8985 28.7978 32.7567 28.6338 32.6593 28.4435C32.5618 28.2532 32.5115 28.0423 32.5127 27.8285V23.5885H28.246C28.0269 23.6009 27.8081 23.559 27.609 23.4666C27.4099 23.3742 27.2368 23.234 27.1049 23.0586C26.973 22.8832 26.8864 22.6779 26.8529 22.461C26.8194 22.2441 26.8399 22.0222 26.9127 21.8152C27.0677 21.4352 27.1209 21.0213 27.0671 20.6145C27.0134 20.2076 26.8544 19.8218 26.606 19.4952C26.4091 19.1607 26.1395 18.8749 25.8172 18.6588C25.4948 18.4427 25.128 18.3019 24.7438 18.2468C24.3597 18.1917 23.9681 18.2238 23.598 18.3407C23.2279 18.4575 22.8889 18.6561 22.606 18.9218C22.3433 19.1824 22.1377 19.4948 22.0023 19.8391C21.8668 20.1834 21.8045 20.5521 21.8193 20.9218C21.8224 21.2277 21.8812 21.5304 21.9927 21.8152C22.0632 22.0168 22.0842 22.2324 22.054 22.4438C22.0237 22.6553 21.9432 22.8564 21.819 23.0302C21.6949 23.204 21.5308 23.3454 21.3406 23.4426C21.1504 23.5397 20.9396 23.5898 20.726 23.5885H17.8193Z" fill="url(#paint1_linear_2613_3853)"/>
</g>
<defs>
<linearGradient id="paint0_linear_2613_3853" x1="0.662695" y1="18.4025" x2="51.7209" y2="44.2212" gradientUnits="userSpaceOnUse">
<stop stop-color="#F7D14C"/>
<stop offset="1" stop-color="#A38108"/>
</linearGradient>
<linearGradient id="paint1_linear_2613_3853" x1="13.7453" y1="21.3705" x2="40.3876" y2="35.7024" gradientUnits="userSpaceOnUse">
<stop stop-color="#F7D14C"/>
<stop offset="1" stop-color="#A38108"/>
</linearGradient>
<clipPath id="clip0_2613_3853">
<rect width="52" height="57" fill="white" transform="translate(0.152832 0.920898)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/modules-color.svg">
<svg width="53" height="58" viewBox="0 0 53 58" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.43319 14.5869L3.43322 14.587L3.44269 14.5812L22.9844 2.59084C24.4246 1.73116 26.2124 1.69742 27.6729 2.49791L27.6729 2.49792L27.6784 2.50094L48.6303 13.8121C48.6313 13.8126 48.6322 13.8131 48.6331 13.8137C50.0812 14.6086 50.9896 16.1043 51.026 17.7437L51.1517 39.8672L51.1517 39.8746L51.1519 39.8821C51.1856 41.5204 50.346 43.0611 48.9325 43.9357L29.0918 56.2117C27.6424 57.1085 25.8227 57.1572 24.3387 56.3439L3.85107 45.1148C2.26984 44.2481 1.14232 42.646 1.15293 41.0494V41.0427L1.153 18.552C1.15301 18.5509 1.15302 18.5499 1.15302 18.5488C1.16485 16.9324 2.02611 15.4289 3.43319 14.5869Z" fill="#18181B" stroke="url(#paint0_linear_2595_7337)" stroke-width="2"/>
<path d="M33.8193 42.2542H17.8193C16.7585 42.2542 15.7411 41.8328 14.9909 41.0826C14.2408 40.3325 13.8193 39.3151 13.8193 38.2542V24.9209C13.8193 23.86 14.2408 22.8426 14.9909 22.0924C15.7411 21.3423 16.7585 20.9209 17.8193 20.9209H19.1527C19.1751 19.791 19.5558 18.6975 20.2399 17.7981C20.924 16.8986 21.8761 16.2397 22.9589 15.9164C24.0416 15.593 25.1992 15.6219 26.2644 15.999C27.3297 16.376 28.2477 17.0817 28.886 18.0142C29.4839 18.8664 29.8094 19.8799 29.8193 20.9209H33.8193C34.173 20.9209 34.5121 21.0613 34.7621 21.3114C35.0122 21.5614 35.1527 21.9006 35.1527 22.2542V26.2542C36.2825 26.2766 37.376 26.6573 38.2754 27.3414C39.1749 28.0255 39.8338 28.9776 40.1572 30.0604C40.4805 31.1432 40.4516 32.3007 40.0745 33.366C39.6975 34.4312 38.9918 35.3492 38.0593 35.9875C37.2071 36.5854 36.1937 36.9109 35.1527 36.9209V40.9209C35.1527 41.2745 35.0122 41.6136 34.7621 41.8637C34.5121 42.1137 34.173 42.2542 33.8193 42.2542ZM17.8193 23.5875C17.4657 23.5875 17.1266 23.728 16.8765 23.978C16.6265 24.2281 16.486 24.5672 16.486 24.9209V38.2542C16.486 38.6078 16.6265 38.9469 16.8765 39.197C17.1266 39.447 17.4657 39.5875 17.8193 39.5875H32.486V35.3475C32.4849 35.1337 32.5351 34.9228 32.6326 34.7325C32.7301 34.5422 32.8718 34.3782 33.046 34.2542C33.2196 34.1304 33.4205 34.05 33.6316 34.0198C33.8427 33.9897 34.058 34.0106 34.2593 34.0809C34.6393 34.2359 35.0532 34.2891 35.46 34.2353C35.8669 34.1816 36.2527 34.0226 36.5793 33.7742C36.9045 33.5759 37.1834 33.3103 37.3973 32.9952C37.6111 32.6801 37.7551 32.3229 37.8193 31.9475C37.8708 31.5689 37.8402 31.1837 37.7298 30.8179C37.6194 30.4522 37.4317 30.1144 37.1793 29.8275C36.8381 29.413 36.3734 29.1183 35.8529 28.9864C35.3325 28.8545 34.7835 28.8923 34.286 29.0942C34.0846 29.1644 33.8694 29.1854 33.6582 29.1552C33.4471 29.125 33.2463 29.0447 33.0727 28.9209C32.8985 28.7969 32.7567 28.6328 32.6593 28.4425C32.5618 28.2522 32.5115 28.0413 32.5127 27.8275V23.5875H28.246C28.0269 23.5999 27.8081 23.5581 27.609 23.4656C27.4099 23.3732 27.2368 23.233 27.1049 23.0576C26.973 22.8822 26.8864 22.6769 26.8529 22.46C26.8194 22.2431 26.8399 22.0213 26.9127 21.8142C27.0677 21.4342 27.1209 21.0204 27.0671 20.6135C27.0134 20.2066 26.8544 19.8208 26.606 19.4942C26.4091 19.1597 26.1395 18.8739 25.8172 18.6578C25.4948 18.4417 25.128 18.3009 24.7438 18.2458C24.3597 18.1908 23.9681 18.2228 23.598 18.3397C23.2279 18.4565 22.8889 18.6552 22.606 18.9209C22.3433 19.1814 22.1377 19.4938 22.0023 19.8381C21.8668 20.1824 21.8045 20.5512 21.8193 20.9209C21.8224 21.2267 21.8812 21.5294 21.9927 21.8142C22.0632 22.0158 22.0842 22.2314 22.054 22.4429C22.0237 22.6543 21.9432 22.8554 21.819 23.0292C21.6949 23.203 21.5308 23.3444 21.3406 23.4416C21.1504 23.5388 20.9396 23.5888 20.726 23.5875H17.8193Z" fill="url(#paint1_linear_2595_7337)"/>
<defs>
<linearGradient id="paint0_linear_2595_7337" x1="0.662695" y1="18.4025" x2="51.7209" y2="44.2212" gradientUnits="userSpaceOnUse">
<stop stop-color="#F7D14C"/>
<stop offset="1" stop-color="#A38108"/>
</linearGradient>
<linearGradient id="paint1_linear_2595_7337" x1="13.7453" y1="21.3695" x2="40.3876" y2="35.7015" gradientUnits="userSpaceOnUse">
<stop stop-color="#F7D14C"/>
<stop offset="1" stop-color="#A38108"/>
</linearGradient>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/modules-light.svg">
<svg width="53" height="58" viewBox="0 0 53 58" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_2691_4389)">
<path d="M51.1519 39.8821C51.154 39.9844 51.1527 40.0863 51.148 40.1877C51.0782 41.7091 50.2566 43.1165 48.9325 43.9357L29.0918 56.2117C27.6504 57.1035 25.8212 57.1564 24.3387 56.3439L3.85107 45.1148C2.27157 44.2491 1.14238 42.6366 1.15291 41.0494L1.15293 41.0427L1.153 18.552C1.15301 18.5509 1.15302 18.5499 1.15302 18.5488C1.16485 16.9324 2.02611 15.4289 3.43319 14.5869L3.43322 14.587L3.44269 14.5812L22.9844 2.59084C24.4169 1.73583 26.2139 1.69824 27.6729 2.49791L27.6729 2.49792L27.6784 2.50094L48.6303 13.8121C48.6313 13.8126 48.6322 13.8131 48.6331 13.8136C50.0797 14.6078 50.9898 16.1132 51.026 17.7438L51.1517 39.8672L51.1517 39.8746L51.1519 39.8821Z" fill="white" stroke="url(#paint0_linear_2691_4389)" stroke-width="2"/>
<path d="M33.8193 42.2542H17.8193C16.7585 42.2542 15.7411 41.8328 14.9909 41.0826C14.2408 40.3325 13.8193 39.3151 13.8193 38.2542V24.9209C13.8193 23.86 14.2408 22.8426 14.9909 22.0924C15.7411 21.3423 16.7585 20.9209 17.8193 20.9209H19.1527C19.1751 19.791 19.5558 18.6975 20.2399 17.7981C20.924 16.8986 21.8761 16.2397 22.9589 15.9164C24.0416 15.593 25.1992 15.6219 26.2644 15.999C27.3297 16.376 28.2477 17.0817 28.886 18.0142C29.4839 18.8664 29.8094 19.8799 29.8193 20.9209H33.8193C34.173 20.9209 34.5121 21.0613 34.7621 21.3114C35.0122 21.5614 35.1527 21.9006 35.1527 22.2542V26.2542C36.2825 26.2766 37.376 26.6573 38.2754 27.3414C39.1749 28.0255 39.8338 28.9776 40.1572 30.0604C40.4805 31.1432 40.4516 32.3007 40.0745 33.366C39.6975 34.4312 38.9918 35.3492 38.0593 35.9875C37.2071 36.5854 36.1937 36.9109 35.1527 36.9209V36.9209V40.9209C35.1527 41.2745 35.0122 41.6136 34.7621 41.8637C34.5121 42.1137 34.173 42.2542 33.8193 42.2542ZM17.8193 23.5875C17.4657 23.5875 17.1266 23.728 16.8765 23.978C16.6265 24.2281 16.486 24.5672 16.486 24.9209V38.2542C16.486 38.6078 16.6265 38.9469 16.8765 39.197C17.1266 39.447 17.4657 39.5875 17.8193 39.5875H32.486V35.3475C32.4849 35.1337 32.5351 34.9228 32.6326 34.7325C32.7301 34.5422 32.8718 34.3782 33.046 34.2542C33.2196 34.1304 33.4204 34.05 33.6316 34.0198C33.8427 33.9897 34.058 34.0106 34.2593 34.0809C34.6393 34.2359 35.0532 34.2891 35.46 34.2353C35.8669 34.1816 36.2527 34.0226 36.5793 33.7742C36.9045 33.5759 37.1834 33.3103 37.3973 32.9952C37.6111 32.6801 37.7551 32.3229 37.8193 31.9475C37.8708 31.5689 37.8402 31.1837 37.7298 30.8179C37.6194 30.4522 37.4317 30.1144 37.1793 29.8275C36.8381 29.413 36.3734 29.1183 35.8529 28.9864C35.3325 28.8545 34.7835 28.8923 34.286 29.0942C34.0846 29.1644 33.8694 29.1854 33.6582 29.1552C33.4471 29.125 33.2463 29.0447 33.0727 28.9209C32.8985 28.7969 32.7567 28.6328 32.6593 28.4425C32.5618 28.2522 32.5115 28.0413 32.5127 27.8275V23.5875H28.246C28.0269 23.5999 27.8081 23.5581 27.609 23.4656C27.4099 23.3732 27.2368 23.233 27.1049 23.0576C26.973 22.8822 26.8864 22.6769 26.8529 22.46C26.8194 22.2431 26.8399 22.0213 26.9127 21.8142C27.0677 21.4342 27.1209 21.0204 27.0671 20.6135C27.0134 20.2066 26.8544 19.8208 26.606 19.4942C26.4091 19.1597 26.1395 18.8739 25.8172 18.6578C25.4948 18.4417 25.128 18.3009 24.7438 18.2458C24.3597 18.1908 23.9681 18.2228 23.598 18.3397C23.2279 18.4565 22.8889 18.6552 22.606 18.9209C22.3433 19.1814 22.1377 19.4938 22.0023 19.8381C21.8668 20.1824 21.8045 20.5512 21.8193 20.9209C21.8224 21.2267 21.8812 21.5294 21.9927 21.8142C22.0632 22.0158 22.0842 22.2314 22.054 22.4429C22.0237 22.6543 21.9432 22.8554 21.819 23.0292C21.6949 23.203 21.5308 23.3444 21.3406 23.4416C21.1504 23.5388 20.9396 23.5888 20.726 23.5875H17.8193Z" fill="url(#paint1_linear_2691_4389)"/>
</g>
<defs>
<linearGradient id="paint0_linear_2691_4389" x1="0.662695" y1="18.4025" x2="51.7209" y2="44.2212" gradientUnits="userSpaceOnUse">
<stop stop-color="#D4D4D8"/>
<stop offset="1" stop-color="#71717A"/>
</linearGradient>
<linearGradient id="paint1_linear_2691_4389" x1="13.7453" y1="21.3695" x2="40.3876" y2="35.7015" gradientUnits="userSpaceOnUse">
<stop stop-color="#D4D4D8"/>
<stop offset="1" stop-color="#71717A"/>
</linearGradient>
<clipPath id="clip0_2691_4389">
<rect width="52" height="57" fill="white" transform="translate(0.152832 0.920898)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/modules.svg">
<svg width="53" height="58" viewBox="0 0 53 58" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.43319 14.5869L3.43322 14.587L3.44269 14.5812L22.9844 2.59084C24.4246 1.73116 26.2124 1.69742 27.6729 2.49791L27.6729 2.49792L27.6784 2.50094L48.6303 13.8121C48.6313 13.8126 48.6322 13.8131 48.6331 13.8137C50.0812 14.6086 50.9896 16.1043 51.026 17.7437L51.1517 39.8672L51.1517 39.8746L51.1519 39.8821C51.1856 41.5203 50.346 43.0611 48.9325 43.9357L29.0918 56.2117C27.6424 57.1085 25.8227 57.1572 24.3387 56.3439L3.85107 45.1148C2.26984 44.2481 1.14232 42.646 1.15293 41.0494V41.0427L1.153 18.552C1.15301 18.5509 1.15302 18.5499 1.15302 18.5488C1.16485 16.9324 2.02611 15.4289 3.43319 14.5869Z" fill="#18181B" stroke="url(#paint0_linear_2595_7175)" stroke-width="2"/>
<path d="M33.8193 42.2542H17.8193C16.7585 42.2542 15.7411 41.8328 14.9909 41.0826C14.2408 40.3325 13.8193 39.3151 13.8193 38.2542V24.9209C13.8193 23.86 14.2408 22.8426 14.9909 22.0924C15.7411 21.3423 16.7585 20.9209 17.8193 20.9209H19.1527C19.1751 19.791 19.5558 18.6975 20.2399 17.7981C20.924 16.8986 21.8761 16.2397 22.9589 15.9164C24.0416 15.593 25.1992 15.6219 26.2644 15.999C27.3297 16.376 28.2477 17.0817 28.886 18.0142C29.4839 18.8664 29.8094 19.8799 29.8193 20.9209H33.8193C34.173 20.9209 34.5121 21.0613 34.7621 21.3114C35.0122 21.5614 35.1527 21.9006 35.1527 22.2542V26.2542C36.2825 26.2766 37.376 26.6573 38.2754 27.3414C39.1749 28.0255 39.8338 28.9776 40.1572 30.0604C40.4805 31.1432 40.4516 32.3007 40.0745 33.366C39.6975 34.4312 38.9918 35.3492 38.0593 35.9875C37.2071 36.5854 36.1937 36.9109 35.1527 36.9209V40.9209C35.1527 41.2745 35.0122 41.6136 34.7621 41.8637C34.5121 42.1137 34.173 42.2542 33.8193 42.2542ZM17.8193 23.5875C17.4657 23.5875 17.1266 23.728 16.8765 23.978C16.6265 24.2281 16.486 24.5672 16.486 24.9209V38.2542C16.486 38.6078 16.6265 38.9469 16.8765 39.197C17.1266 39.447 17.4657 39.5875 17.8193 39.5875H32.486V35.3475C32.4849 35.1337 32.5351 34.9228 32.6326 34.7325C32.7301 34.5422 32.8718 34.3782 33.046 34.2542C33.2196 34.1304 33.4205 34.05 33.6316 34.0198C33.8427 33.9897 34.058 34.0106 34.2593 34.0809C34.6393 34.2359 35.0532 34.2891 35.46 34.2353C35.8669 34.1816 36.2527 34.0226 36.5793 33.7742C36.9045 33.5759 37.1834 33.3103 37.3973 32.9952C37.6111 32.6801 37.7551 32.3229 37.8193 31.9475C37.8708 31.5689 37.8402 31.1837 37.7298 30.8179C37.6194 30.4522 37.4317 30.1144 37.1793 29.8275C36.8381 29.413 36.3734 29.1183 35.8529 28.9864C35.3325 28.8545 34.7835 28.8923 34.286 29.0942C34.0846 29.1644 33.8694 29.1854 33.6582 29.1552C33.4471 29.125 33.2463 29.0447 33.0727 28.9209C32.8985 28.7969 32.7567 28.6328 32.6593 28.4425C32.5618 28.2522 32.5115 28.0413 32.5127 27.8275V23.5875H28.246C28.0269 23.5999 27.8081 23.5581 27.609 23.4656C27.4099 23.3732 27.2368 23.233 27.1049 23.0576C26.973 22.8822 26.8864 22.6769 26.8529 22.46C26.8194 22.2431 26.8399 22.0213 26.9127 21.8142C27.0677 21.4342 27.1209 21.0204 27.0671 20.6135C27.0134 20.2066 26.8544 19.8208 26.606 19.4942C26.4091 19.1597 26.1395 18.8739 25.8172 18.6578C25.4948 18.4417 25.128 18.3009 24.7438 18.2458C24.3597 18.1908 23.9681 18.2228 23.598 18.3397C23.2279 18.4565 22.8889 18.6552 22.606 18.9209C22.3433 19.1814 22.1377 19.4938 22.0023 19.8381C21.8668 20.1824 21.8045 20.5512 21.8193 20.9209C21.8224 21.2267 21.8812 21.5294 21.9927 21.8142C22.0632 22.0158 22.0842 22.2314 22.054 22.4429C22.0237 22.6543 21.9432 22.8554 21.819 23.0292C21.6949 23.203 21.5308 23.3444 21.3406 23.4416C21.1504 23.5388 20.9396 23.5888 20.726 23.5875H17.8193Z" fill="url(#paint1_linear_2595_7175)"/>
<defs>
<linearGradient id="paint0_linear_2595_7175" x1="0.662695" y1="18.4025" x2="51.7209" y2="44.2212" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="#71717A"/>
</linearGradient>
<linearGradient id="paint1_linear_2595_7175" x1="13.7453" y1="21.3695" x2="40.3876" y2="35.7015" gradientUnits="userSpaceOnUse">
<stop stop-color="white"/>
<stop offset="1" stop-color="#71717A"/>
</linearGradient>
</defs>
</svg>
</file>

<file path="packages/ui-templates/public/icons/twitter-brands 1.svg">
<svg width="80" height="80" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M87.926 29.04c.063.87.063 1.74.063 2.611 0 26.552-20.21 57.146-57.146 57.146-11.38 0-21.95-3.296-30.843-9.016 1.617.186 3.171.248 4.85.248 9.39 0 18.033-3.171 24.935-8.58-8.83-.188-16.23-5.97-18.779-13.93 1.244.187 2.488.31 3.793.31a21.24 21.24 0 0 0 5.286-.683C10.882 55.28 3.98 47.196 3.98 37.434v-.249a20.227 20.227 0 0 0 9.078 2.55c-5.41-3.607-8.954-9.763-8.954-16.727 0-3.731.995-7.151 2.736-10.136C16.727 25.06 31.589 33.019 48.253 33.89a22.677 22.677 0 0 1-.497-4.602c0-11.068 8.954-20.085 20.085-20.085a20.037 20.037 0 0 1 14.675 6.343c4.54-.87 8.892-2.55 12.748-4.85-1.493 4.663-4.664 8.58-8.83 11.068 4.042-.435 7.96-1.555 11.566-3.109a43.177 43.177 0 0 1-10.074 10.384z" fill="#D1E2E2"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h80v80H0z"/></clipPath></defs></svg>
</file>

<file path="packages/ui-templates/templates/error-404/index.html">
<!DOCTYPE html>
<html>

<head>
  <title>{{ messages.status }} - {{ messages.statusText }} | {{ messages.appName }}</title>
  <meta charset="utf-8" />
  <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport" />
  <script type="module" src="/styles.ts"></script>
</head>

<body
  class="font-sans antialiased bg-white dark:bg-[#020420] text-[#020420] tracking-wide dark:text-white grid min-h-screen place-content-center overflow-hidden ">
  <div class="max-w-520px text-center">
    <h1 class="text-[80px] sm:text-[110px] font-semibold mb-4 tabular-nums leading-none">{{ messages.status }}</h1>
    <h2 class="text-2xl font-semibold sm:text-3xl mb-2">{{ messages.statusText }}</h2>
    <p class="text-[#64748B] text-md mb-4 px-2">{{ messages.description }}</p>
    <div class="w-full flex items-center justify-center">
      <a href="/" class="underline underline-offset-3 text-sm font-medium hover:text-[#00DC82]">
        {{ messages.backHome }}
      </a>
    </div>
  </div>
</body>

</html>
</file>

<file path="packages/ui-templates/templates/error-404/messages.json">
{
  "status": 404,
  "statusText": "Page not found",
  "description": "Sorry, the page you are looking for could not be found.",
  "backHome": "Go back home"
}
</file>

<file path="packages/ui-templates/templates/error-500/index.html">
<!DOCTYPE html>
<html>

<head>
  <title>{{ messages.status }} - {{ messages.statusText }} | {{ messages.appName }}</title>
  <meta charset="utf-8" />
  <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport" />
  <script type="module" src="/styles.ts"></script>
</head>

<body
  class="font-sans antialiased bg-white dark:bg-[#020420] text-[#020420] tracking-wide dark:text-white grid min-h-screen place-content-center overflow-hidden ">
  <div class="max-w-520px text-center">
    <h1 class="text-[80px] sm:text-[110px] font-semibold mb-4 tabular-nums leading-none">{{ messages.status }}</h1>
    <h2 class="text-2xl font-semibold sm:text-3xl mb-2">{{ messages.statusText }}</h2>
    <p class="text-[#64748B] text-md mb-4 px-2">{{ messages.description }}</p>
  </div>
</body>

</html>
</file>

<file path="packages/ui-templates/templates/error-500/messages.json">
{
  "status": 500,
  "statusText": "Internal server error",
  "description": "This page is temporarily unavailable.",
  "refresh": "Refresh this page"
}
</file>

<file path="packages/ui-templates/templates/loading/index.html">
<!DOCTYPE html>
<html>
  <head>
    <title>{{ messages.loading }} | {{ messages.appName }}</title>
    <meta charset="utf-8" />
    <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport" />
    <script type="module" src="/styles.ts"></script>
    <style>
      .nuxt-loader-bar {
        background: #00DC82;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 3px;
      }
      .triangle-loading {
        position: absolute;
      }
      .triangle-loading>path {
        fill: none;
        stroke-width: 4px;
        stroke-linecap: round;
        stroke-linejoin: round;
        /* Stroke-dasharray property */
        stroke-dasharray: 128;
        stroke-dashoffset: 128;
        animation: nuxt-loading-move 3s linear infinite;
      }
      .nuxt-logo:hover .triangle-loading>path {
        animation-play-state: paused;
      }
      @keyframes nuxt-loading-move {
        100% {
          stroke-dashoffset: -128;
        }
      }
      @media (prefers-color-scheme: dark) {
        html, body {
          color: white;
          color-scheme: dark;
        }
      }
      @media (prefers-reduced-motion: reduce) {
        #snow-canvas {
          display: none !important;
        }
      }
    </style>
  </head>
  <body class="font-sans antialiased relative overflow-hidden min-h-screen bg-white dark:bg-[#020420] text-[#020420] dark:text-white flex flex-col justify-center items-center text-center">
    <a href="https://nuxt.com/?utm_source=nuxt-loading-screen" target="_blank" rel="noopener" class="nuxt-logo group flex items-end gap-4" id="nuxtImg">
      <div class="relative">
        <svg class="triangle-loading text-[#00DC82]/80 group-hover:text-[#00DC82]" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 37 25" fill="none" width="80">
          <path stroke="currentColor" d="M24.236 22.006h10.742L25.563 5.822l-8.979 14.31a4 4 0 0 1-3.388 1.874H2.978l11.631-20 5.897 10.567" />
        </svg>
        <svg class="dark:text-gray-200 dark:group-hover:text-white text-[#020420]/80 group-hover:text-[#020420]" xmlns="http://www.w3.org/2000/svg" width="214" height="53" fill="none" viewBox="0 0 800 200">
          <path fill="currentColor" d="M377 200a4 4 0 0 0 4-4v-93s5.244 8.286 15 25l38.707 66.961c1.789 3.119 5.084 5.039 8.649 5.039H470V50h-27a4 4 0 0 0-4 4v94l-17-30-36.588-62.98c-1.792-3.108-5.081-5.02-8.639-5.02H350v150h27ZM676.203 143.857 710.551 92h-25.73a9.972 9.972 0 0 0-8.333 4.522L660.757 120.5l-15.731-23.978A9.972 9.972 0 0 0 636.693 92h-25.527l34.348 51.643L608.524 200h24.966a9.969 9.969 0 0 0 8.29-4.458l19.18-28.756 18.981 28.72a9.968 9.968 0 0 0 8.313 4.494h24.736l-36.787-56.143ZM724.598 92h19.714V60.071h28.251V92H800v24.857h-27.437V159.5c0 10.5 5.284 15.429 14.43 15.429H800V200h-16.869c-23.576 0-38.819-14.143-38.819-39.214v-43.929h-19.714V92ZM590 92h-15c-3.489 0-6.218.145-8.5 2.523-2.282 2.246-2.5 3.63-2.5 7.066v52.486c0 8.058-.376 12.962-4 16.925-3.624 3.831-8.619 5-16 5-7.247 0-12.376-1.169-16-5-3.624-3.963-4-8.867-4-16.925v-52.486c0-3.435-.218-4.82-2.5-7.066C519.218 92.145 516.489 92 513 92h-15v62.422c0 14.004 3.892 25.101 11.676 33.292C517.594 195.905 529.103 200 544 200c14.897 0 26.204-4.095 34.123-12.286 7.918-8.191 11.877-19.288 11.877-33.292V92Z" />
        </svg>
      </div>
      <span class="inline-block font-mono leading-none text-[#00DC82] group-hover:border-[#00DC42] text-[16px] font-semibold border-[#00DC42]/50 bg-[#00DC42]/10 group-hover:bg-[#00DC42]/15 px-2.5 py-1.5 border rounded">{{ version }}</span>
    </a>
    <div class="nuxt-loader-bar"></div>
    <script>
      if (typeof window.fetch === 'undefined') {
        setTimeout(() => window.location.reload(), 200)
      } else {
        const check = async () => {
          try {
            const body = await window
              .fetch(window.location.href)
              .then(r => r.text())
            if (!body.includes('__NUXT_LOADING__')) {
              return window
                .location
                .reload()
            }
          } catch {}
          setTimeout(check, 200)
        }
        check()
      }
    </script>
    <script>
      // Snow effect with localStorage toggle
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches
      function whatHemisphere() {
        let y = new Date()
        if (y.getTimezoneOffset == undefined) return null
        y = y.getFullYear()
        let jan = -(new Date(y, 0, 1, 0, 0, 0, 0).getTimezoneOffset())
        let jul = -(new Date(y, 6, 1, 0, 0, 0, 0).getTimezoneOffset())
        let diff = jan - jul
        return diff < 0 ? 'N' : diff > 0 ? 'S' : null
      }
      // Only run in November, December, and January (N hemisphere) or May, June, and July (S hemisphere)
      const months = { N: [10, 11, 0], S: [4, 5, 6] }
      const hemisphere = whatHemisphere()
      if (hemisphere && months[hemisphere].includes(new Date().getMonth()) && !prefersReducedMotion) {
        let snowEnabled = localStorage.getItem('nuxt-snow') !== 'false'
        let animationId = null, particles = [], lastCall = Date.now()
        const density = 0.00025, gravity = 1.25
        const wind = { current: 0, maxCurrent: 4, force: 0.1, target: 0.1, min: 0.1, max: 0.4, easing: 0.01 }
        const mod = (a, b) => ((a % b) + b) % b

        // Create toggle button and canvas
        const $btn = document.createElement('button')
        $btn.id = 'snow-toggle'
        $btn.style = 'position:fixed;bottom:16px;right:16px;z-index:100;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;padding:8px 12px;cursor:pointer;font-size:20px;'
        document.body.appendChild($btn)

        const $canvas = document.createElement('canvas')
        $canvas.id = 'snow-canvas'
        $canvas.style = 'position:fixed;inset:0;z-index:-10;pointer-events:none;opacity:0;transition:opacity 0.5s;filter:blur(4px);'
        document.body.appendChild($canvas)
        const ctx = $canvas.getContext('2d')

        // Resize and initialize particles
        function resize() {
          $canvas.width = window.innerWidth
          $canvas.height = window.innerHeight
          particles = Array.from({ length: Math.floor($canvas.width * $canvas.height * density) }, () => ({
            x: Math.random() * $canvas.width, y: Math.random() * $canvas.height,
            vx: 1 + Math.random(), vy: 1 + Math.random(), vsin: Math.random() * 10,
            rangle: Math.random() * 2 * Math.PI, rsin: Math.random() * 10,
            color: `rgba(255,255,255,${0.1 + Math.random() * 0.15})`,
            size: 5 * Math.random() * 4 * ($canvas.height / 1000)
          }))
        }

        // Draw particles
        function draw() {
          ctx.clearRect(0, 0, $canvas.width, $canvas.height)
          const now = Date.now(), delta = now - lastCall
          lastCall = now
          wind.force += (wind.target - wind.force) * wind.easing
          wind.current = Math.max(-wind.maxCurrent, Math.min(wind.current + wind.force * delta * 0.05, wind.maxCurrent))
          if (Math.random() > 0.995) wind.target = (wind.min + Math.random() * (wind.max - wind.min)) * (Math.random() > 0.5 ? -1 : 1)
          const uTime = delta * 0.2
          particles.forEach(p => {
            p.x = mod(p.x + uTime + wind.current * p.vx, $canvas.width)
            p.y = mod(p.y + uTime * p.vy * gravity, $canvas.height)
            p.x += Math.sin(uTime * p.vsin) * p.rsin * 0.5
            p.rangle += uTime * 0.01
            ctx.fillStyle = p.color
            ctx.beginPath()
            ctx.ellipse(p.x, p.y, p.size, p.size * 0.66, p.rangle, 0, Math.PI * 2)
            ctx.fill()
          })
          animationId = requestAnimationFrame(draw)
        }

        // Update snow effect and handle toggle (resize)
        function update() {
          $btn.innerHTML = snowEnabled ? '☀️' : '❄️'
          $btn.title = snowEnabled ? 'Disable snow' : 'Enable snow'
          if (snowEnabled) { resize(); window.addEventListener('resize', resize); $canvas.style.opacity = 1; lastCall = Date.now(); draw() }
          else { if (animationId) cancelAnimationFrame(animationId); animationId = null; window.removeEventListener('resize', resize); $canvas.style.opacity = 0 }
        }

        $btn.onclick = () => { snowEnabled = !snowEnabled; localStorage.setItem('nuxt-snow', snowEnabled); update() }
        update()
      }
    </script>
  </body>
</html>
</file>

<file path="packages/ui-templates/templates/loading/messages.json">
{
  "loading": "Loading",
  "version": "4.0"
}
</file>

<file path="packages/ui-templates/templates/spa-loading-icon/index.html">
<svg class="nuxt-spa-loading" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 37 25" fill="none" width="80">
  <path d="M24.236 22.006h10.742L25.563 5.822l-8.979 14.31a4 4 0 0 1-3.388 1.874H2.978l11.631-20 5.897 10.567" />
</svg>
<style>
  .nuxt-spa-loading {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

  .nuxt-spa-loading>path {
    fill: none;
    stroke: #00DC82;
    stroke-width: 4px;
    stroke-linecap: round;
    stroke-linejoin: round;
    /* Stroke-dasharray property */
    stroke-dasharray: 128;
    stroke-dashoffset: 128;
    animation: nuxt-spa-loading-move 3s linear infinite;
  }

  @keyframes nuxt-spa-loading-move {
    100% {
      stroke-dashoffset: -128;
    }
  }
</style>
</file>

<file path="packages/ui-templates/templates/spa-loading-icon/messages.json">
{}
</file>

<file path="packages/ui-templates/templates/welcome/index.html">
<!DOCTYPE html>
<html>
  <head>
    <title>{{ messages.title }}</title>
    <meta charset="utf-8" />
    <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport" />
    <link rel="icon" type="image/png" href="/icon.png" />
    <script type="module" src="/styles.ts"></script>
  </head>
  <body class="antialiased bg-white dark:bg-[#020420] text-[#020420] dark:text-white min-h-screen place-content-center flex flex-col items-center justify-center text-sm sm:text-base">
    <div class="flex flex-col mt-6 sm:mt-0">
      <h1 class="flex flex-col gap-y-4 items-center justify-center">
        <a href="https://nuxt.com?utm_source=nuxt-welcome" target="_blank" class="inline-flex items-end gap-4">
          <svg role="img" aria-label="Nuxt" class="h-8 sm:h-12" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 800 200">
            <path fill="#00DC82" d="M168.303 200h111.522c3.543 0 7.022-.924 10.09-2.679A20.086 20.086 0 0 0 297.3 190a19.855 19.855 0 0 0 2.7-10.001 19.858 19.858 0 0 0-2.709-9.998L222.396 41.429a20.09 20.09 0 0 0-7.384-7.32 20.313 20.313 0 0 0-10.088-2.679c-3.541 0-7.02.925-10.087 2.68a20.082 20.082 0 0 0-7.384 7.32l-19.15 32.896L130.86 9.998a20.086 20.086 0 0 0-7.387-7.32A20.322 20.322 0 0 0 113.384 0c-3.542 0-7.022.924-10.09 2.679a20.091 20.091 0 0 0-7.387 7.319L2.709 170A19.853 19.853 0 0 0 0 179.999c-.002 3.511.93 6.96 2.7 10.001a20.091 20.091 0 0 0 7.385 7.321A20.322 20.322 0 0 0 20.175 200h70.004c27.737 0 48.192-12.075 62.266-35.633l34.171-58.652 18.303-31.389 54.93 94.285h-73.233L168.303 200Zm-79.265-31.421-48.854-.011 73.232-125.706 36.541 62.853-24.466 42.01c-9.347 15.285-19.965 20.854-36.453 20.854Z" />
            <path fill="currentColor" d="M377 200a4 4 0 0 0 4-4v-93s5.244 8.286 15 25l38.707 66.961c1.789 3.119 5.084 5.039 8.649 5.039H470V50h-27a4 4 0 0 0-4 4v94l-17-30-36.588-62.98c-1.792-3.108-5.081-5.02-8.639-5.02H350v150h27ZM676.203 143.857 710.551 92h-25.73a9.972 9.972 0 0 0-8.333 4.522L660.757 120.5l-15.731-23.978A9.972 9.972 0 0 0 636.693 92h-25.527l34.348 51.643L608.524 200h24.966a9.969 9.969 0 0 0 8.29-4.458l19.18-28.756 18.981 28.72a9.968 9.968 0 0 0 8.313 4.494h24.736l-36.787-56.143ZM724.598 92h19.714V60.071h28.251V92H800v24.857h-27.437V159.5c0 10.5 5.284 15.429 14.43 15.429H800V200h-16.869c-23.576 0-38.819-14.143-38.819-39.214v-43.929h-19.714V92ZM590 92h-15c-3.489 0-6.218.145-8.5 2.523-2.282 2.246-2.5 3.63-2.5 7.066v52.486c0 8.058-.376 12.962-4 16.925-3.624 3.831-8.619 5-16 5-7.247 0-12.376-1.169-16-5-3.624-3.963-4-8.867-4-16.925v-52.486c0-3.435-.218-4.82-2.5-7.066C519.218 92.145 516.489 92 513 92h-15v62.422c0 14.004 3.892 25.101 11.676 33.292C517.594 195.905 529.103 200 544 200c14.897 0 26.204-4.095 34.123-12.286 7.918-8.191 11.877-19.288 11.877-33.292V92Z" />
          </svg>
          <span class="inline-block font-mono leading-none text-[#00DC82] group-hover:border-[#00DC42] text-[12px] sm:text-[14px] font-semibold border-[#00DC42]/50 bg-[#00DC42]/10 group-hover:bg-[#00DC42]/15 px-2 sm:px-2.5 py-1 sm:py-1.5 border rounded">{{ version }}</span>
        </a>
      </h1>
      <div class="max-w-[980px] w-full grid grid-cols-1 sm:grid-cols-3 mt-6 sm:mt-10 gap-4 sm:gap-6 px-4">
        <div class="sm:col-span-2 flex flex-col gap-1 border p-6 rounded-lg border-[#00DC42]/50 dark:bg-white/5 bg-gray-50/10">
          <div class="w-[32px] h-[32px] bg-[#00DC82]/5 flex items-center justify-center border rounded border-[#00DC82] dark:border-[#00DC82]/80 dark:bg-[#020420] text-[#00DC82] dark:text-[#00DC82]">
            <svg class="size-[18px]" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path fill="currentColor" d="m228.1 121.2l-143.9-88A8 8 0 0 0 72 40v176a8 8 0 0 0 12.2 6.8l143.9-88a7.9 7.9 0 0 0 0-13.6Z" opacity=".2"/><path fill="currentColor" d="M80 232a15.5 15.5 0 0 1-7.8-2.1A15.8 15.8 0 0 1 64 216V40a15.8 15.8 0 0 1 8.2-13.9a15.5 15.5 0 0 1 16.1.3l144 87.9a16 16 0 0 1 0 27.4l-144 87.9A15.4 15.4 0 0 1 80 232Zm0-192v176l144-88Z"/></svg>
          </div>
          <h2 class="font-semibold text-base mt-1">Get started</h2>
          <p class="text-sm text-gray-700 dark:text-gray-200">Remove this welcome page by replacing <a class="bg-green-50 text-green-700 dark:text-[#00DC82] dark:bg-[#020420] rounded font-mono p-1 font-bold border dark:border-white/10 border-green-600/10">&lt;NuxtWelcome/&gt;</a> in <a href="https://nuxt.com/docs/4.x/directory-structure/app" target="_blank" rel="noopener" class="bg-green-50 text-green-700 dark:text-[#00DC82] dark:bg-[#020420] dark:border-white/20 rounded font-mono p-1 font-bold border border-green-600/20 hover:border-[#00DC82]">app.vue</a> with your own code.</p>
        </div>
        <a href="https://nuxt.com/docs?utm_source=nuxt-welcome" target="_blank" class="relative flex flex-col gap-1 border p-6 rounded-lg border-gray-200 dark:border-white/10 dark:bg-white/5 bg-gray-50/10 group hover:dark:border-[#00DC82] hover:border-[#00DC82] transition-all">
          <div class="w-[32px] h-[32px] bg-[#00DC82]/5 flex items-center justify-center border rounded border-[#00DC82] transition-all dark:border-[#00DC82]/50 group-hover:dark:border-[#00DC82]/80 dark:bg-[#020420] text-[#00DC82] dark:text-[#00DC82]">
            <svg class="size-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path fill="currentColor" d="M136 48v128H88V80H40V48a8 8 0 0 1 8-8h32a8 8 0 0 1 8 8a8 8 0 0 1 8-8h32a8 8 0 0 1 8 8Zm89.9 149.6l-8.3-30.9l-46.4 12.5l8.3 30.9a8 8 0 0 0 9.8 5.6l30.9-8.3a8 8 0 0 0 5.7-9.8ZM184.5 43.1a8.1 8.1 0 0 0-9.8-5.7l-30.9 8.3a8.1 8.1 0 0 0-5.7 9.8l8.3 30.9L192.8 74Z" opacity=".2"/><path fill="currentColor" d="M233.6 195.6L192.2 41a16 16 0 0 0-19.6-11.3L141.7 38l-1 .3A16 16 0 0 0 128 32H96a15.8 15.8 0 0 0-8 2.2a15.8 15.8 0 0 0-8-2.2H48a16 16 0 0 0-16 16v160a16 16 0 0 0 16 16h32a15.8 15.8 0 0 0 8-2.2a15.8 15.8 0 0 0 8 2.2h32a16 16 0 0 0 16-16v-99.6l27.8 103.7a16 16 0 0 0 15.5 11.9a19.9 19.9 0 0 0 4.1-.5l30.9-8.3a16 16 0 0 0 11.3-19.6ZM156.2 92.1l30.9-8.3l20.7 77.3l-30.9 8.3Zm20.5-46.9l6.3 23.1l-30.9 8.3l-6.3-23.1ZM128 48v120H96V48Zm-48 0v24H48V48ZM48 208V88h32v120Zm80 0H96v-24h32v24Zm90.2-8.3l-30.9 8.3l-6.3-23.2l31-8.3l6.2 23.2Z"/></svg>
          </div>
          <svg class="absolute right-4 top-4 dark:text-white/40 text-[#020420]/20 group-hover:text-[#00DC82] size-4 group-hover:size-5 transition-all" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 256 256"><path fill="currentColor" d="M200 64v104a8 8 0 0 1-16 0V83.3L69.7 197.7a8.2 8.2 0 0 1-11.4 0a8.1 8.1 0 0 1 0-11.4L172.7 72H88a8 8 0 0 1 0-16h104a8 8 0 0 1 8 8Z"/></svg>
          <h2 class="font-semibold text-base mt-1">Documentation</h2>
          <p class="text-sm text-gray-700 dark:text-gray-200 group-hover:dark:text-gray-100">We highly recommend you take a look at the Nuxt documentation to level up.</p>
        </a>
      </div>
      <div class="max-w-[980px] w-full grid grid-cols-1 sm:grid-cols-3 gap-4 sm:gap-6 mt-4 sm:mt-6 px-4">
        <a href="https://nuxt.com/modules?utm_source=nuxt-welcome" target="_blank" class="relative flex flex-col gap-1 border p-6 rounded-lg border-gray-200 dark:border-white/10 dark:bg-white/5 bg-gray-50/10 group hover:dark:border-[#00DC82] hover:border-[#00DC82] transition-all">
          <div class="w-[32px] h-[32px] bg-[#00DC82]/5 flex items-center justify-center border rounded border-[#00DC82] transition-all dark:border-[#00DC82]/50 group-hover:dark:border-[#00DC82]/80 dark:bg-[#020420] text-[#00DC82] dark:text-[#00DC82]">
            <svg class="size-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path fill="currentColor" d="M64 216a8 8 0 0 1-8-8v-42.7a27.6 27.6 0 0 1-14.1 2.6A28 28 0 1 1 56 114.7V72a8 8 0 0 1 8-8h46.7a27.6 27.6 0 0 1-2.6-14.1A28 28 0 1 1 161.3 64H208a8 8 0 0 1 8 8v42.7a27.6 27.6 0 0 0-14.1-2.6a28 28 0 1 0 14.1 53.2V208a8 8 0 0 1-8 8Z" opacity=".2"/><path fill="currentColor" d="M220.3 158.5a8.1 8.1 0 0 0-7.7-.4a20.2 20.2 0 0 1-23.2-4.4a20 20 0 0 1 13.1-33.6a19.6 19.6 0 0 1 10.1 1.8a8.1 8.1 0 0 0 7.7-.4a8.2 8.2 0 0 0 3.7-6.8V72a16 16 0 0 0-16-16h-36.2c.1-1.3.2-2.7.2-4a36.1 36.1 0 0 0-38.3-35.9a36 36 0 0 0-33.6 33.3a36.4 36.4 0 0 0 .1 6.6H64a16 16 0 0 0-16 16v32.2l-4-.2a35.6 35.6 0 0 0-26.2 11.4a35.3 35.3 0 0 0-9.7 26.9a36 36 0 0 0 33.3 33.6a36.4 36.4 0 0 0 6.6-.1V208a16 16 0 0 0 16 16h144a16 16 0 0 0 16-16v-42.7a8.2 8.2 0 0 0-3.7-6.8ZM208 208H64v-42.7a8.2 8.2 0 0 0-3.7-6.8a8.1 8.1 0 0 0-7.7-.4a19.6 19.6 0 0 1-10.1 1.8a20 20 0 0 1-13.1-33.6a20.2 20.2 0 0 1 23.2-4.4a8.1 8.1 0 0 0 7.7-.4a8.2 8.2 0 0 0 3.7-6.8V72h46.7a8.2 8.2 0 0 0 6.8-3.7a8.1 8.1 0 0 0 .4-7.7a19.6 19.6 0 0 1-1.8-10.1a20 20 0 0 1 33.6-13.1a20.2 20.2 0 0 1 4.4 23.2a8.1 8.1 0 0 0 .4 7.7a8.2 8.2 0 0 0 6.8 3.7H208v32.2a36.4 36.4 0 0 0-6.6-.1a36 36 0 0 0-33.3 33.6A36.1 36.1 0 0 0 204 176l4-.2Z"/></svg>
          </div>
          <svg class="absolute right-4 top-4 dark:text-white/40 text-[#020420]/20 group-hover:text-[#00DC82] size-4 group-hover:size-5 transition-all" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 256 256"><path fill="currentColor" d="M200 64v104a8 8 0 0 1-16 0V83.3L69.7 197.7a8.2 8.2 0 0 1-11.4 0a8.1 8.1 0 0 1 0-11.4L172.7 72H88a8 8 0 0 1 0-16h104a8 8 0 0 1 8 8Z"/></svg>
          <h2 class="font-semibold text-base mt-1">Modules</h2>
          <p class="text-sm text-gray-700 dark:text-gray-200 group-hover:dark:text-gray-100">Discover our list of modules to supercharge your Nuxt project.</p>
        </a>
        <a href="https://nuxt.com/docs/4.x/examples?utm_source=nuxt-welcome" target="_blank" class="relative flex flex-col gap-1 border p-6 rounded-lg border-gray-200 dark:border-white/10 dark:bg-white/5 bg-gray-50/10 group hover:dark:border-[#00DC82] hover:border-[#00DC82] transition-all">
          <div class="w-[32px] h-[32px] bg-[#00DC82]/5 flex items-center justify-center border rounded border-[#00DC82] transition-all dark:border-[#00DC82]/50 group-hover:dark:border-[#00DC82]/80 dark:bg-[#020420] text-[#00DC82] dark:text-[#00DC82]">
            <svg class="size-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"><path fill="currentColor" d="M224 56v144a8 8 0 0 1-8 8H40a8 8 0 0 1-8-8V56a8 8 0 0 1 8-8h176a8 8 0 0 1 8 8Z" opacity=".2"/><path fill="currentColor" d="M216 40H40a16 16 0 0 0-16 16v144a16 16 0 0 0 16 16h176a16 16 0 0 0 16-16V56a16 16 0 0 0-16-16Zm0 160H40V56h176v144ZM80 84a12 12 0 1 1-12-12a12 12 0 0 1 12 12Zm40 0a12 12 0 1 1-12-12a12 12 0 0 1 12 12Z"/></svg>
          </div>
          <svg class="absolute right-4 top-4 dark:text-white/40 text-[#020420]/20 group-hover:text-[#00DC82] size-4 group-hover:size-5 transition-all" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 256 256"><path fill="currentColor" d="M200 64v104a8 8 0 0 1-16 0V83.3L69.7 197.7a8.2 8.2 0 0 1-11.4 0a8.1 8.1 0 0 1 0-11.4L172.7 72H88a8 8 0 0 1 0-16h104a8 8 0 0 1 8 8Z"/></svg>
          <h2 class="font-semibold text-base mt-1">Examples</h2>
          <p class="text-sm text-gray-700 dark:text-gray-200 group-hover:dark:text-gray-100">Explore different way of using Nuxt features and get inspired.</p>
        </a>
        <a href="https://nuxt.com/deploy?utm_source=nuxt-welcome" target="_blank" class="relative flex flex-col gap-1 border p-6 rounded-lg border-gray-200 dark:border-white/10 dark:bg-white/5 bg-gray-50/10 group hover:dark:border-[#00DC82] hover:border-[#00DC82] transition-all">
          <div class="w-[32px] h-[32px] bg-[#00DC82]/5 flex items-center justify-center border rounded border-[#00DC82] transition-all dark:border-[#00DC82]/50 group-hover:dark:border-[#00DC82]/80 dark:bg-[#020420] text-[#00DC82] dark:text-[#00DC82]">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 256 256"><path fill="currentColor" d="M94.1 184.6c-11.4 33.9-56.6 33.9-56.6 33.9s0-45.2 33.9-56.6Zm90.5-67.9v64.6a8 8 0 0 1-2.4 5.6l-32.3 32.4a8 8 0 0 1-13.5-4.1l-8.4-41.9Zm-45.3-45.3H74.7a8 8 0 0 0-5.6 2.4l-32.4 32.3a8 8 0 0 0 4.1 13.5l41.9 8.4Z" opacity=".2"/><path fill="currentColor" d="M96.6 177a7.9 7.9 0 0 0-10.1 5c-6.6 19.7-27.9 25.8-40.2 27.7c1.9-12.3 8-33.6 27.7-40.2a8 8 0 1 0-5.1-15.1c-16.4 5.4-28.4 18.4-34.8 37.5a91.8 91.8 0 0 0-4.6 26.6a8 8 0 0 0 8 8a91.8 91.8 0 0 0 26.6-4.6c19.1-6.4 32.1-18.4 37.5-34.8a7.9 7.9 0 0 0-5-10.1Z"/><path fill="currentColor" d="M227.6 41.8a15.7 15.7 0 0 0-13.4-13.4c-11.3-1.7-40.6-2.5-69.2 26.1l-9 8.9H74.7a16.2 16.2 0 0 0-11.3 4.7l-32.3 32.4a15.9 15.9 0 0 0-4 15.9a16 16 0 0 0 12.2 11.1l39.5 7.9l41.8 41.8l7.9 39.5a16 16 0 0 0 11.1 12.2a14.7 14.7 0 0 0 4.6.7a15.6 15.6 0 0 0 11.3-4.7l32.4-32.3a16.2 16.2 0 0 0 4.7-11.3V120l8.9-9c28.6-28.6 27.8-57.9 26.1-69.2ZM74.7 79.4H120l-39.9 39.9l-37.7-7.5Zm81.6-13.6c7.8-7.8 28.8-25.6 55.5-21.6c4 26.7-13.8 47.7-21.6 55.5L128 161.9L94.1 128Zm20.3 115.5l-32.4 32.3l-7.5-37.7l39.9-39.9Z"/></svg>
          </div>
          <svg class="absolute right-4 top-4 dark:text-white/40 text-[#020420]/20 group-hover:text-[#00DC82] size-4 group-hover:size-5 transition-all" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 256 256"><path fill="currentColor" d="M200 64v104a8 8 0 0 1-16 0V83.3L69.7 197.7a8.2 8.2 0 0 1-11.4 0a8.1 8.1 0 0 1 0-11.4L172.7 72H88a8 8 0 0 1 0-16h104a8 8 0 0 1 8 8Z"/></svg>
          <h2 class="font-semibold text-base mt-1">Deploy</h2>
          <p class="text-sm text-gray-700 dark:text-gray-200 group-hover:dark:text-gray-100">Learn how to deploy your Nuxt project on different providers.</p>
        </a>
      </div>
      <footer class="mx-auto sm:px-6 lg:px-8 px-4 w-full mb-6 mt-6 sm:mt-10 sm:mb-0">
        <ul class="flex items-center justify-center gap-4">
          <li>
            <a
              href="https://go.nuxt.com/github"
              target="_blank"
              class="focus-visible:ring-2 text-gray-500 hover:text-[#020420] dark:text-gray-400 dark:hover:text-white"
            >
              <span class="sr-only">Nuxt GitHub Repository</span>
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12 .297c-6.63 0-12 5.373-12 12c0 5.303 3.438 9.8 8.205 11.385c.6.113.82-.258.82-.577c0-.285-.01-1.04-.015-2.04c-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729c1.205.084 1.838 1.236 1.838 1.236c1.07 1.835 2.809 1.305 3.495.998c.108-.776.417-1.305.76-1.605c-2.665-.3-5.466-1.332-5.466-5.93c0-1.31.465-2.38 1.235-3.22c-.135-.303-.54-1.523.105-3.176c0 0 1.005-.322 3.3 1.23c.96-.267 1.98-.399 3-.405c1.02.006 2.04.138 3 .405c2.28-1.552 3.285-1.23 3.285-1.23c.645 1.653.24 2.873.12 3.176c.765.84 1.23 1.91 1.23 3.22c0 4.61-2.805 5.625-5.475 5.92c.42.36.81 1.096.81 2.22c0 1.606-.015 2.896-.015 3.286c0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
            </a>
          </li>
          <li>
            <a
              href="https://go.nuxt.com/discord"
              target="_blank"
              class="focus-visible:ring-2 text-gray-500 hover:text-[#020420] dark:text-gray-400 dark:hover:text-white"
            >
              <span class="sr-only">Nuxt Discord Server</span>
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M20.317 4.37a19.8 19.8 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.3 18.3 0 0 0-5.487 0a13 13 0 0 0-.617-1.25a.08.08 0 0 0-.079-.037A19.7 19.7 0 0 0 3.677 4.37a.1.1 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.08.08 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.08.08 0 0 0 .084-.028a14 14 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13 13 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10 10 0 0 0 .372-.292a.07.07 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.07.07 0 0 1 .078.01q.181.149.373.292a.077.077 0 0 1-.006.127a12.3 12.3 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.08.08 0 0 0 .084.028a19.8 19.8 0 0 0 6.002-3.03a.08.08 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.06.06 0 0 0-.031-.03M8.02 15.33c-1.182 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418m7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418"/></svg>
            </a>
          </li>
          <li>
            <a
              href="https://go.nuxt.com/x"
              target="_blank"
              class="focus-visible:ring-2 text-gray-500 hover:text-[#020420] dark:text-gray-400 dark:hover:text-white"
            >
              <span class="sr-only">Nuxt on X</span>
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584l-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/></svg>
            </a>
          </li>
          <li>
            <a
              href="https://go.nuxt.com/bluesky"
              target="_blank"
              class="focus-visible:ring-2 text-gray-500 hover:text-[#020420] dark:text-gray-400 dark:hover:text-white"
            >
              <span class="sr-only">Nuxt Bluesky</span>
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12 10.8c-1.087-2.114-4.046-6.053-6.798-7.995C2.566.944 1.561 1.266.902 1.565C.139 1.908 0 3.08 0 3.768c0 .69.378 5.65.624 6.479c.815 2.736 3.713 3.66 6.383 3.364q.204-.03.415-.056q-.207.033-.415.056c-3.912.58-7.387 2.005-2.83 7.078c5.013 5.19 6.87-1.113 7.823-4.308c.953 3.195 2.05 9.271 7.733 4.308c4.267-4.308 1.172-6.498-2.74-7.078a9 9 0 0 1-.415-.056q.21.026.415.056c2.67.297 5.568-.628 6.383-3.364c.246-.828.624-5.79.624-6.478c0-.69-.139-1.861-.902-2.206c-.659-.298-1.664-.62-4.3 1.24C16.046 4.748 13.087 8.687 12 10.8"/></svg>
            </a>
          </li>
          <li>
            <a
              href="https://go.nuxt.com/linkedin"
              target="_blank"
              class="focus-visible:ring-2 text-gray-500 hover:text-[#020420] dark:text-gray-400 dark:hover:text-white"
            >
              <span class="sr-only">Nuxt Linkedin</span>
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037c-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85c3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.06 2.06 0 0 1-2.063-2.065a2.064 2.064 0 1 1 2.063 2.065m1.782 13.019H3.555V9h3.564zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0z"/></svg>
            </a>
          </li>
        </ul>
      </footer>
    </div>
  </body>
</html>
</file>

<file path="packages/ui-templates/templates/welcome/messages.json">
{
  "title": "Welcome to Nuxt!"
}
</file>

<file path="packages/ui-templates/templates/messages.json">
{
  "appName": "Nuxt"
}
</file>

<file path="packages/ui-templates/test/templates.spec.ts">
import { fileURLToPath } from 'node:url'
import { readFileSync } from 'node:fs'
import { rm } from 'node:fs/promises'
import { afterAll, beforeAll, describe, expect, it } from 'vitest'
import { exec } from 'tinyexec'
import { format } from 'prettier'
import { createJiti } from 'jiti'
import { HtmlValidate } from 'html-validate'

const distDir = fileURLToPath(new URL('../node_modules/.temp/dist/templates', import.meta.url))

describe('template', () => {
  beforeAll(async () => {
    await exec('pnpm', ['build'], {
      nodeOptions: {
        cwd: fileURLToPath(new URL('..', import.meta.url)),
        env: {
          OUTPUT_DIR: './node_modules/.temp/dist',
        },
      },
    })
  })
  afterAll(() => rm(distDir, { force: true, recursive: true }))

  function formatCss (css: string) {
    return format(css, {
      parser: 'css',
    })
  }

  const jiti = createJiti(import.meta.url)

  const validator = new HtmlValidate({
    extends: [
      'html-validate:document',
      'html-validate:recommended',
      'html-validate:standard',
    ],
    rules: {
    //
      'svg-focusable': 'off',
      'no-unknown-elements': 'error',
      // Conflicts or not needed as we use prettier formatting
      'void-style': 'off',
      'no-trailing-whitespace': 'off',
      // Conflict with Nuxt defaults
      'require-sri': 'off',
      'attribute-boolean-style': 'off',
      'doctype-style': 'off',
      // Unreasonable rule
      'no-inline-style': 'off',
    },
  })

  it.each(['error-404', 'error-500', 'loading', 'welcome'])('produces correct output for %s template', async (file) => {
    const contents = readFileSync(`${distDir}/${file}.vue`, 'utf-8')

    const scopedStyle = contents.match(/<style scoped>([\s\S]*)<\/style>/)
    const globalStyle = contents.match(/style: \[[\s\S]*innerHTML: `([\s\S]*)`/)

    expect(await formatCss(scopedStyle?.[1] || '')).toMatchSnapshot()
    expect(await formatCss(globalStyle?.[1] || '')).toMatchSnapshot()

    const { template } = await jiti.import(`file://${distDir}/${file}.ts`) as { template: () => string }
    const html = template()
    const { valid, results } = await (validator as any).validateString(html)
    expect.soft(valid).toBe(true)
    expect.soft(results).toEqual([])
  })
})
</file>

<file path="packages/ui-templates/index.html">
<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/petite-vue" defer init></script>
    <script type="module" src="/styles.ts"></script>
  </head>
  <body v-scope='{{ data }}'>
    <div class="container mx-auto pt-10">
      <h1 class="text-4xl mb-8">Nuxt Templates</h1>
      <ul>
        <li v-for="name in templateNames.filter(name => !name.includes('.json'))">
          <a :href="`/templates/${name}`" class="block border p-4 mb-2 hover:border-black">{{ name }}</a>
        </li>
      </ul>
    </div>
  </body>
</html>
</file>

<file path="packages/ui-templates/package.json">
{
  "name": "@nuxt/ui-templates",
  "version": "1.3.3",
  "private": true,
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nuxt/nuxt.git",
    "directory": "packages/ui-templates"
  },
  "license": "MIT",
  "type": "module",
  "scripts": {
    "build": "vite build",
    "dev": "vite",
    "optimize-assets": "npx svgo public/assets/**/*.svg",
    "postinstall": "pnpm build",
    "prerender": "pnpm build && jiti ./lib/prerender"
  },
  "devDependencies": {
    "@unocss/reset": "66.5.12",
    "@vue/shared": "3.5.26",
    "beasties": "0.3.5",
    "html-validate": "10.5.0",
    "htmlnano": "3.0.0",
    "jiti": "2.6.1",
    "knitwork": "1.3.0",
    "pathe": "2.0.3",
    "prettier": "3.7.4",
    "scule": "1.3.0",
    "svgo": "4.0.0",
    "tinyexec": "1.0.2",
    "tinyglobby": "0.2.15",
    "unocss": "66.5.12",
    "vite": "7.3.0"
  }
}
</file>

<file path="packages/ui-templates/styles.ts">
// @ts-expect-error untyped css file
import '@unocss/reset/tailwind.css'
// @ts-expect-error untyped css file
import 'uno.css'
</file>

<file path="packages/ui-templates/uno.config.ts">
import { defineConfig, presetWind3 } from 'unocss'
import type { UserConfig } from 'unocss'

export default defineConfig({
  presets: [
    presetWind3({
      dark: 'media',
    }),
  ],
  content: {
    filesystem: [
      './templates/**/*.html',
    ],
  },
  theme: {
    colors: {
      'primary': {
        50: '#F2FDF9',
        100: '#E6FCF3',
        200: '#BFF6E0',
        300: '#99F1CD',
        400: '#4DE7A8',
        DEFAULT: '#00DC82',
        600: '#00C675',
        700: '#00844E',
        800: '#00633B',
        900: '#004227',
      },
      'secondary-surface': '#E5F9FF',
      'secondary-lightest': '#B7E1ED',
      'secondary-lighter': '#95CDDE',
      'secondary-light': '#71A2B0',
      'secondary': '#497A87',
      'secondary-dark': '#255461',
      'secondary-darker': '#003543',
      'secondary-darkest': '#012A35',
      'secondary-black': '#001E26',
      'tertiary': '#B2CCCC', // cloud
      'cloud-surface': '#E6F0F0',
      'cloud-lightest': '#D1E2E2',
      'cloud-lighter': '#B2CCCC',
      'cloud-light': '#92ADAD',
      'cloud': '#688282',
      'cloud-dark': '#566B6B',
      'cloud-darker': '#334040',
      'cloud-darkest': '#273131',
      'cloud-black': '#1A2121',
      'green': {
        // 50: "#eefdf2",
        50: '#d0fcde',
        100: '#b0fccb',
        200: '#8cfab7',
        300: '#64f4a3',
        400: '#37e990',
        500: '#00d77d',
        600: '#00bb6a',
        700: '#009956',
        800: '#047342',
        900: '#134d2e',
        // 950: "#132a1c",
      },
      'gray': {
        50: '#f5f5f5',
        100: '#eeeeee',
        200: '#e0e0e0',
        300: '#bdbdbd',
        400: '#9e9e9e',
        500: '#757575',
        600: '#616161',
        700: '#424242',
        800: '#212121',
        900: '#18181B',
      },
      'sky': {
        surface: '#E5F9FF',
        lightest: '#B7E1ED',
        lighter: '#95CDDE',
        light: '#71A2B0',
        DEFAULT: '#497A87',
        dark: '#255461',
        darker: '#003543',
        darkest: '#012A35',
        black: '#001E26',
      },
    },
  },
}) satisfies UserConfig as UserConfig
</file>

<file path="packages/ui-templates/vite.config.ts">
import process from 'node:process'
import { fileURLToPath } from 'node:url'
import { resolve } from 'node:path'
import { readdirSync } from 'node:fs'

import type { UserConfig } from 'vite'
import { defineConfig } from 'vite'
import UnoCSS from 'unocss/vite'

import { DevRenderingPlugin } from './lib/dev.ts'
import { RenderPlugin } from './lib/render.ts'

const rootDir = fileURLToPath(new URL('.', import.meta.url))
const r = (...path: string[]) => resolve(rootDir, ...path)

export default defineConfig({
  build: {
    outDir: process.env.OUTPUT_DIR || 'dist',
    rollupOptions: {
      input: {
        ...Object.fromEntries(
          readdirSync(r('templates')).filter(dir => dir !== 'messages.json').map(dir => [
            dir,
            r('templates', dir, 'index.html'),
          ]),
        ),
        index: r('index.html'),
      },
    },
  },
  plugins: [
    UnoCSS(),
    DevRenderingPlugin(),
    RenderPlugin(),
  ],
  server: {
    fs: {
      allow: ['./templates', rootDir],
    },
  },
}) satisfies UserConfig as UserConfig
</file>

<file path="packages/vite/src/plugins/analyze.ts">
import type { Plugin } from 'vite'
import { transform } from 'esbuild'
import { defu } from 'defu'
import type { Nuxt, NuxtOptions } from '@nuxt/schema'
import type { RenderedModule } from 'rollup'

export async function AnalyzePlugin (nuxt: Nuxt): Promise<Plugin | undefined> {
  if (nuxt.options.test) {
    return
  }

  const analyzeOptions = defu({}, nuxt.options.build.analyze) as Exclude<NuxtOptions['build']['analyze'], boolean>
  if (!analyzeOptions.enabled) {
    return
  }

  const { visualizer } = await import('rollup-plugin-visualizer')

  return {
    name: 'nuxt:analyze',
    applyToEnvironment (environment) {
      if (environment.name !== 'client') {
        return false
      }
      return [
        {
          name: 'nuxt:analyze-minify',
          async generateBundle (_opts, outputBundle) {
            for (const _bundleId in outputBundle) {
              const bundle = outputBundle[_bundleId]
              if (!bundle || bundle.type !== 'chunk') { continue }
              const minifiedModuleEntryPromises: Array<Promise<[string, RenderedModule]>> = []
              for (const [moduleId, module] of Object.entries(bundle.modules)) {
                minifiedModuleEntryPromises.push(
                  transform(module.code || '', { minify: true })
                    .then(result => [moduleId, { ...module, code: result.code }]),
                )
              }
              bundle.modules = Object.fromEntries(await Promise.all(minifiedModuleEntryPromises))
            }
          },
        },
        visualizer({
          ...analyzeOptions,
          filename: 'filename' in analyzeOptions && analyzeOptions.filename ? analyzeOptions.filename.replace('{name}', 'client') : undefined,
          title: 'Client bundle stats',
          gzipSize: true,
          brotliSize: true,
        }),
      ]
    },
  }
}
</file>

<file path="packages/vite/src/plugins/client-manifest.ts">
import { readFileSync } from 'node:fs'
import { mkdir, rm, writeFile } from 'node:fs/promises'

import { relative, resolve } from 'pathe'
import { withTrailingSlash, withoutLeadingSlash } from 'ufo'
import escapeRE from 'escape-string-regexp'
import { normalizeViteManifest, precomputeDependencies } from 'vue-bundle-renderer'
import { serialize } from 'seroval'
import type { Manifest as RendererManifest } from 'vue-bundle-renderer'
import type { Plugin, Manifest as ViteClientManifest } from 'vite'
import type { Nuxt } from '@nuxt/schema'
import { resolveClientEntry } from '../utils/config.ts'

export function ClientManifestPlugin (nuxt: Nuxt): Plugin {
  let clientEntry: string
  let key: string
  let disableCssCodeSplit: boolean

  return {
    name: 'nuxt:client-manifest',
    // needs to run after server build (or after client build if there is no server build)
    applyToEnvironment: environment => environment.name === 'ssr',
    configResolved (config) {
      clientEntry = resolveClientEntry(config)
      key = relative(config.root, clientEntry)
      disableCssCodeSplit = config.build?.cssCodeSplit === false
    },
    async closeBundle () {
      // This is only used for ssr: false - when ssr is enabled we use vite-node runtime manifest
      const devClientManifest: RendererManifest = {
        '@vite/client': {
          isEntry: true,
          file: '@vite/client',
          css: [],
          module: true,
          resourceType: 'script',
        },
        ...nuxt.options.features.noScripts === 'all'
          ? {}
          : {
              [clientEntry]: {
                isEntry: true,
                file: clientEntry,
                module: true,
                resourceType: 'script',
              },
            },
      }

      // Write client manifest for use in vue-bundle-renderer
      const clientDist = resolve(nuxt.options.buildDir, 'dist/client')
      const serverDist = resolve(nuxt.options.buildDir, 'dist/server')

      const manifestFile = resolve(clientDist, 'manifest.json')
      const clientManifest = nuxt.options.dev ? devClientManifest : JSON.parse(readFileSync(manifestFile, 'utf-8')) as ViteClientManifest
      const manifestEntries = Object.values(clientManifest)

      const buildAssetsDir = withTrailingSlash(withoutLeadingSlash(nuxt.options.app.buildAssetsDir))
      const BASE_RE = new RegExp(`^${escapeRE(buildAssetsDir)}`)

      for (const entry of manifestEntries) {
        entry.file &&= entry.file.replace(BASE_RE, '')
        for (const item of ['css', 'assets'] as const) {
          entry[item] &&= entry[item].map((i: string) => i.replace(BASE_RE, ''))
        }
      }

      await mkdir(serverDist, { recursive: true })

      if (disableCssCodeSplit) {
        for (const entry of manifestEntries) {
          if (entry.file?.endsWith('.css')) {
            clientManifest[key]!.css ||= []
            ;(clientManifest[key]!.css as string[]).push(entry.file)
            break
          }
        }
      }

      const manifest = normalizeViteManifest(clientManifest)
      await nuxt.callHook('build:manifest', manifest)
      const precomputed = precomputeDependencies(manifest)
      await writeFile(resolve(serverDist, 'client.manifest.mjs'), 'export default ' + serialize(manifest), 'utf8')
      await writeFile(resolve(serverDist, 'client.precomputed.mjs'), 'export default ' + serialize(precomputed), 'utf8')

      if (!nuxt.options.dev) {
        await rm(manifestFile, { force: true })
      }
    },
  }
}
</file>

<file path="packages/vite/src/plugins/dev-server.ts">
import type { Connect, Plugin, ServerOptions } from 'vite'
import type { Nuxt, ViteConfig } from '@nuxt/schema'
import { getPort } from 'get-port-please'
import { defu } from 'defu'
import { createError, defineEventHandler, defineLazyEventHandler, handleCors, setHeader } from 'h3'
import { useNitro } from '@nuxt/kit'
import { joinURL } from 'ufo'
import type { IncomingMessage, ServerResponse } from 'node:http'

export function DevServerPlugin (nuxt: Nuxt): Plugin {
  let useViteCors = false
  const nitro = useNitro()
  return {
    name: 'nuxt:dev-server',
    async config (config) {
      // Prioritize `optimizeDeps.exclude`. If same dep is in `include` and `exclude`, remove it from `include`
      for (const item of [config.optimizeDeps, config.environments?.client?.optimizeDeps, config.environments?.ssr?.optimizeDeps]) {
        if (!item) {
          continue
        }
        const exclude = new Set(item.exclude ?? [])
        item.include = item.include?.filter(dep => !exclude.has(dep))
      }

      // In build mode we explicitly override any vite options that vite is relying on
      // to detect whether to inject production or development code (such as HMR code)
      if (!nuxt.options.dev && config.server) {
        config.server.hmr = false
      }

      // Inject an h3-based CORS handler in preference to vite's
      useViteCors = config.server?.cors !== undefined
      if (!useViteCors) {
        config.server ??= {}
        config.server.cors = false
      }

      if (config.server && config.server.hmr !== false) {
        const serverDefaults: Omit<ServerOptions, 'hmr'> & { hmr: Exclude<ServerOptions['hmr'], boolean> } = {
          hmr: {
            protocol: nuxt.options.devServer.https ? 'wss' : undefined,
          },
        }
        if (typeof config.server.hmr !== 'object' || !config.server.hmr.server) {
          serverDefaults.hmr ??= {}
          const hmrPortDefault = 24678 // Vite's default HMR port
          serverDefaults.hmr.port = await getPort({
            port: hmrPortDefault,
            ports: Array.from({ length: 20 }, (_, i) => hmrPortDefault + 1 + i),
          })
        }
        if (nuxt.options.devServer.https) {
          serverDefaults.https = nuxt.options.devServer.https === true ? {} : nuxt.options.devServer.https
        }
        config.server = defu(config.server, serverDefaults as ViteConfig['server'])
      }
    },
    async configureServer (viteServer) {
      // Invalidate virtual modules when templates are re-generated
      nuxt.hook('app:templatesGenerated', async (_app, changedTemplates) => {
        await Promise.all(changedTemplates.map(async (template) => {
          for (const mod of viteServer.moduleGraph.getModulesByFile(`virtual:nuxt:${encodeURIComponent(template.dst)}`) || []) {
            viteServer.moduleGraph.invalidateModule(mod)
            await viteServer.reloadModule(mod)
          }
        }))
      })

      if (nuxt.options.experimental.viteEnvironmentApi) {
        await nuxt.callHook('vite:serverCreated', viteServer, { isClient: true, isServer: true })
      }

      const mw: Connect.ServerStackItem = {
        route: '',
        handle: (req: IncomingMessage & { _skip_transform?: boolean }, res: ServerResponse, next: (err?: any) => void) => {
          // 'Skip' the transform middleware
          if (req._skip_transform && req.url) {
            req.url = joinURL('/__skip_vite', req.url.replace(/\?.*/, ''))
          }
          next()
        },
      }
      const transformHandler = viteServer.middlewares.stack.findIndex(m => m.handle instanceof Function && m.handle.name === 'viteTransformMiddleware')
      if (transformHandler === -1) {
        viteServer.middlewares.stack.push(mw)
      } else {
        viteServer.middlewares.stack.splice(transformHandler, 0, mw)
      }

      const staticBases: string[] = []
      for (const folder of nitro.options.publicAssets) {
        if (folder.baseURL && folder.baseURL !== '/' && folder.baseURL.startsWith(nuxt.options.app.buildAssetsDir)) {
          staticBases.push(folder.baseURL.replace(/\/?$/, '/'))
        }
      }

      const devHandlerRegexes: RegExp[] = []
      for (const handler of nuxt.options.devServerHandlers) {
        if (handler.route && handler.route !== '/' && handler.route.startsWith(nuxt.options.app.buildAssetsDir)) {
          devHandlerRegexes.push(new RegExp(
            `^${handler.route
              .replace(/[.+?^${}()|[\]\\]/g, '\\$&') // escape regex syntax characters
              .replace(/:[^/]+/g, '[^/]+') // dynamic segments (:param)
              .replace(/\*\*/g, '.*') // double wildcard (**) to match any path
              .replace(/\*/g, '[^/]*')}$`, // single wildcard (*) to match any segment
          ))
        }
      }

      const viteMiddleware = defineLazyEventHandler(() => {
        // Pre-process proxy configuration once
        const proxyConfig = viteServer.config.server.proxy
        const proxyPatterns: Array<{ type: 'string' | 'regex', value: string | RegExp }> = []

        if (proxyConfig) {
          for (const key in proxyConfig) {
            if (key.startsWith('^')) {
              try {
                proxyPatterns.push({ type: 'regex', value: new RegExp(key) })
              } catch {
                // Invalid regex, skip this key
              }
            } else {
              proxyPatterns.push({ type: 'string', value: key })
            }
          }
        }

        function isProxyPath (path: string) {
          for (const pattern of proxyPatterns) {
            if (pattern.type === 'regex' && (pattern.value as RegExp).test(path)) {
              return true
            } else if (pattern.type === 'string' && path.startsWith(pattern.value as string)) {
              return true
            }
          }
          return false
        }

        return defineEventHandler(async (event) => {
          const isBasePath = event.path.startsWith(viteServer.config.base!)

          // Check if this is a vite-handled route or proxy path
          let isViteRoute = isBasePath
          if (!isViteRoute) {
            // Check vite middleware routes (must be done per-request as middleware stack can change)
            for (const viteRoute of viteServer.middlewares.stack) {
              if (viteRoute.route.length > 1 && event.path.startsWith(viteRoute.route)) {
                isViteRoute = true
                break
              }
            }
            // Check proxy paths
            isViteRoute ||= isProxyPath(event.path)
          }

          if (!isViteRoute) {
            // @ts-expect-error _skip_transform is a private property
            event.node.req._skip_transform = true
          } else if (!useViteCors) {
            const isPreflight = handleCors(event, nuxt.options.devServer.cors)
            if (isPreflight) {
              return null
            }
            setHeader(event, 'Vary', 'Origin')
          }

          // Workaround: vite devmiddleware modifies req.url
          const _originalPath = event.node.req.url
          await new Promise((resolve, reject) => {
            viteServer.middlewares.handle(event.node.req, event.node.res, (err: Error) => {
              event.node.req.url = _originalPath
              return err ? reject(err) : resolve(null)
            })
          })

          // if vite has not handled the request, we want to send a 404 for paths which are not in any static base or dev server handlers
          const ended = event.node.res.writableEnded || event.handled
          if (!ended && event.path.startsWith(nuxt.options.app.buildAssetsDir) && !staticBases.some(baseURL => event.path.startsWith(baseURL)) && !devHandlerRegexes.some(regex => regex.test(event.path))) {
            throw createError({ status: 404 })
          }
        })
      })
      await nuxt.callHook('server:devHandler', viteMiddleware)
    },
  }
}
</file>

<file path="packages/vite/src/plugins/dev-style-ssr.ts">
import { joinURL } from 'ufo'
import type { Plugin } from 'vite'
import { isCSS } from '../utils/index.ts'

interface DevStyleSSRPluginOptions {
  srcDir: string
  buildAssetsURL: string
}

export function DevStyleSSRPlugin (options: DevStyleSSRPluginOptions): Plugin {
  return {
    name: 'nuxt:dev-style-ssr',
    apply: 'serve',
    enforce: 'post',
    applyToEnvironment: environment => environment.name === 'client',
    transform (code, id) {
      if (!isCSS(id) || !code.includes('import.meta.hot')) {
        return
      }

      let moduleId = id
      if (moduleId.startsWith(options.srcDir)) {
        moduleId = moduleId.slice(options.srcDir.length)
      }

      // When dev `<style>` is injected, remove the `<link>` styles from manifest
      const selectors = [joinURL(options.buildAssetsURL, moduleId), joinURL(options.buildAssetsURL, '@fs', moduleId)]
      return code + selectors.map(selector => `\ndocument.querySelectorAll(\`link[href="${selector}"]\`).forEach(i=>i.remove())`).join('')
    },
  }
}
</file>

<file path="packages/vite/src/plugins/environments.ts">
import type { Plugin } from 'vite'
import type { Nuxt } from '@nuxt/schema'
import { withoutLeadingSlash } from 'ufo'
import * as vite from 'vite'
import { dirname, isAbsolute, join, relative, resolve } from 'pathe'
import { useNitro } from '@nuxt/kit'
import { resolveModulePath } from 'exsolve'
import { defineEnv } from 'unenv'
import escapeStringRegexp from 'escape-string-regexp'

export function EnvironmentsPlugin (nuxt: Nuxt): Plugin {
  const fileNames = withoutLeadingSlash(join(nuxt.options.app.buildAssetsDir, '[hash].js'))
  const clientOutputDir = join(useNitro().options.output.publicDir, nuxt.options.app.buildAssetsDir)

  const clientAliases: Record<string, string> = {
    'nitro/runtime': join(nuxt.options.buildDir, 'nitro.client.mjs'),
    // TODO: remove in v5
    '#internal/nitro': join(nuxt.options.buildDir, 'nitro.client.mjs'),
    'nitropack/runtime': join(nuxt.options.buildDir, 'nitro.client.mjs'),
    // work around vite optimizer bug
    '#app-manifest': resolveModulePath('mocked-exports/empty', { from: import.meta.url }),
  }

  let viteConfig: vite.InlineConfig

  return {
    name: 'nuxt:environments',
    enforce: 'pre', // run before other plugins
    config (config) {
      viteConfig = config
      if (!nuxt.options.dev) {
        return {
          base: './',
        }
      }
    },
    configEnvironment (name, config) {
      if (!nuxt.options.experimental.viteEnvironmentApi && viteConfig.ssr) {
        config.optimizeDeps ||= {}
        config.optimizeDeps.include = undefined
      }
      if (name === 'client') {
        const outputConfig = config.build?.rollupOptions?.output as vite.Rollup.OutputOptions
        return {
          build: {
            rollupOptions: {
              output: {
                chunkFileNames: outputConfig?.chunkFileNames ?? (nuxt.options.dev ? undefined : fileNames),
                entryFileNames: outputConfig?.entryFileNames ?? (nuxt.options.dev ? 'entry.js' : fileNames),
                sourcemapPathTransform: outputConfig?.sourcemapPathTransform ?? ((relativeSourcePath, sourcemapPath) => {
                  // client build is running in a temporary build directory, like `.nuxt/dist/client`
                  // so we need to transform the sourcemap path to be relative to the final build directory
                  if (!isAbsolute(relativeSourcePath)) {
                    const absoluteSourcePath = resolve(dirname(sourcemapPath), relativeSourcePath)
                    return relative(clientOutputDir, absoluteSourcePath)
                  }
                  return relativeSourcePath
                }),
              },
            },
          },
        }
      }

      if (name === 'ssr') {
        // Disable manual chunks for SSR environment to avoid splitting issues
        if (config.build?.rollupOptions?.output && !Array.isArray(config.build.rollupOptions.output)) {
          config.build.rollupOptions.output.manualChunks = undefined

          // Also disable advancedChunks when using Rolldown
          if ((vite as any).rolldownVersion) {
            (config.build.rollupOptions.output as any).advancedChunks = undefined
          }
        }
      }
    },
    applyToEnvironment (environment) {
      if (environment.name === 'client') {
        return [
          ...nuxt.options.experimental.clientNodeCompat ? [NodeCompatAliasPlugin()] : [],
          {
            name: 'nuxt:client:aliases',
            enforce: 'post',
            resolveId: {
              filter: {
                id: Object.keys(clientAliases).map(id => new RegExp('^' + escapeStringRegexp(id) + '$')),
              },
              handler: source => clientAliases[source],
            },
          },
        ]
      } else if (environment.name === 'ssr') {
        //
      }
      return false
    },
  }
}

function NodeCompatAliasPlugin (): Plugin {
  const nodeCompatAlias = defineEnv({ nodeCompat: true, resolve: true }).env.alias
  return {
    name: 'nuxt:client:node-compat-aliases',
    resolveId: {
      order: 'pre',
      handler (source) {
        if (source in nodeCompatAlias) {
          return nodeCompatAlias[source]
        }
      },
    },
  }
}
</file>

<file path="packages/vite/src/plugins/layer-dep-optimize.ts">
import type { Plugin } from 'vite'
import type { Nuxt } from '@nuxt/schema'
import { join, normalize } from 'pathe'
import { getLayerDirectories } from '@nuxt/kit'

export function LayerDepOptimizePlugin (nuxt: Nuxt): Plugin | undefined {
  if (!nuxt.options.dev) {
    return
  }

  // TODO: this may no longer be needed with most recent vite version
  // Identify which layers will need to have an extra resolve step.
  const layerDirs: string[] = []
  const delimitedRootDir = nuxt.options.rootDir + '/'
  for (const dirs of getLayerDirectories(nuxt)) {
    if (dirs.app !== nuxt.options.srcDir && !dirs.app.startsWith(delimitedRootDir)) {
      layerDirs.push(dirs.app)
    }
  }

  if (layerDirs.length > 0) {
    // Reverse so longest/most specific directories are searched first
    layerDirs.sort().reverse()
    const dirs = [...layerDirs]
    return {
      name: 'nuxt:optimize-layer-deps',
      enforce: 'pre',
      resolveId: {
        async handler (source, _importer) {
          if (!_importer) { return }
          const importer = normalize(_importer)
          const layerIndex = dirs.findIndex(dir => importer.startsWith(dir))
          // Trigger vite to optimize dependencies imported within a layer, just as if they were imported in final project
          if (layerIndex !== -1) {
            dirs.splice(layerIndex, 1)
            await this.resolve(source, join(nuxt.options.srcDir, 'index.html'), { skipSelf: true }).catch(() => null)
          }
        },
      },
    }
  }
}
</file>

<file path="packages/vite/src/plugins/module-preload-polyfill.ts">
import MagicString from 'magic-string'
import type { Plugin } from 'vite'
import { resolveClientEntry } from '../utils/config.ts'

const QUERY_RE = /\?.+$/

export function ModulePreloadPolyfillPlugin (): Plugin {
  let isDisabled = false
  let entry: string
  let sourcemap: boolean
  return {
    name: 'nuxt:module-preload-polyfill',
    applyToEnvironment: environment => environment.name === 'client',
    configResolved (config) {
      try {
        isDisabled = config.build.modulePreload === false || config.build.modulePreload.polyfill === false
        sourcemap = !!config.build.sourcemap
        entry = resolveClientEntry(config)
      } catch {
        console.debug('[nuxt:module-preload-polyfill] Could not resolve client entry, module preload polyfill will not be injected.')
      }
    },
    transform (code, id) {
      if (isDisabled || id.replace(QUERY_RE, '') !== entry) { return }

      const s = new MagicString(code)

      s.prepend('import "vite/modulepreload-polyfill";\n')

      return {
        code: s.toString(),
        map: sourcemap ? s.generateMap({ hires: true }) : undefined,
      }
    },
  }
}
</file>

<file path="packages/vite/src/plugins/public-dirs.ts">
import { existsSync } from 'node:fs'
import { useNitro } from '@nuxt/kit'
import { withLeadingSlash, withTrailingSlash } from 'ufo'
import { dirname, relative } from 'pathe'
import MagicString from 'magic-string'
import { isCSSRequest } from 'vite'
import type { Plugin } from 'vite'

const PREFIX = 'virtual:public?'
const PREFIX_RE = /^virtual:public\?/
const CSS_URL_RE = /url\((\/[^)]+)\)/g
const CSS_URL_SINGLE_RE = /url\(\/[^)]+\)/
const RENDER_CHUNK_RE = /(?<= = )['"`]/

interface VitePublicDirsPluginOptions {
  dev?: boolean
  baseURL?: string
}

export const PublicDirsPlugin = (options: VitePublicDirsPluginOptions): Plugin[] => {
  const { resolveFromPublicAssets } = useResolveFromPublicAssets()
  let sourcemap: boolean

  return [
    {
      name: 'nuxt:vite-public-dir-resolution-dev',
      apply () {
        return !!options.dev && !!options.baseURL && options.baseURL !== '/'
      },
      transform (code, id) {
        if (!isCSSRequest(id) || !CSS_URL_SINGLE_RE.test(code)) { return }

        const s = new MagicString(code)
        for (const [full, url] of code.matchAll(CSS_URL_RE)) {
          if (url && resolveFromPublicAssets(url)) {
            s.replace(full, `url(${options.baseURL}${url})`)
          }
        }

        if (s.hasChanged()) {
          return {
            code: s.toString(),
            map: sourcemap ? s.generateMap({ hires: true }) : undefined,
          }
        }
      },
    },
    {
      name: 'nuxt:vite-public-dir-resolution',
      configResolved (config) {
        sourcemap = !!config.build.sourcemap
      },
      load: {
        order: 'pre',
        filter: {
          id: PREFIX_RE,
        },
        handler (id) {
          return `import { publicAssetsURL } from '#internal/nuxt/paths';export default publicAssetsURL(${JSON.stringify(decodeURIComponent(id.slice(PREFIX.length)))})`
        },
      },
      resolveId: {
        order: 'post',
        filter: {
          id: {
            exclude: [/^\/__skip_vite$/, /^[^/]/, /^\/@fs/],
          },
        },
        handler (id) {
          if (resolveFromPublicAssets(id)) {
            return PREFIX + encodeURIComponent(id)
          }
        },
      },
      renderChunk (code, chunk) {
        if (!chunk.facadeModuleId?.includes('?inline&used')) { return }

        const s = new MagicString(code)
        const q = code.match(RENDER_CHUNK_RE)?.[0] || '"'
        for (const [full, url] of code.matchAll(CSS_URL_RE)) {
          if (url && resolveFromPublicAssets(url)) {
            s.replace(full, `url(${q} + publicAssetsURL(${q}${url}${q}) + ${q})`)
          }
        }

        if (s.hasChanged()) {
          s.prepend(`import { publicAssetsURL } from '#internal/nuxt/paths';`)
          return {
            code: s.toString(),
            map: sourcemap ? s.generateMap({ hires: true }) : undefined,
          }
        }
      },
      generateBundle (_outputOptions, bundle) {
        for (const [file, chunk] of Object.entries(bundle)) {
          if (!file.endsWith('.css') || chunk.type !== 'asset') { continue }

          let css = chunk.source.toString()
          let wasReplaced = false
          for (const [full, url] of css.matchAll(CSS_URL_RE)) {
            if (url && resolveFromPublicAssets(url)) {
              const relativeURL = relative(withLeadingSlash(dirname(file)), url)
              css = css.replace(full, `url(${relativeURL})`)
              wasReplaced = true
            }
          }
          if (wasReplaced) {
            chunk.source = css
          }
        }
      },
    },
  ]
}

const PUBLIC_ASSETS_RE = /[?#].*$/
export function useResolveFromPublicAssets () {
  const nitro = useNitro()

  function resolveFromPublicAssets (id: string) {
    for (const dir of nitro.options.publicAssets) {
      if (!id.startsWith(withTrailingSlash(dir.baseURL || '/'))) { continue }
      const path = id.replace(PUBLIC_ASSETS_RE, '').replace(withTrailingSlash(dir.baseURL || '/'), withTrailingSlash(dir.dir))
      if (existsSync(path)) {
        return id
      }
    }
  }

  return { resolveFromPublicAssets }
}
</file>

<file path="packages/vite/src/plugins/replace.ts">
import type { Plugin } from 'vite'
import replacePlugin from '@rollup/plugin-replace'
import * as vite from 'vite'

export function ReplacePlugin (): Plugin {
  return {
    name: 'nuxt:replace',
    enforce: 'post',
    async applyToEnvironment (environment) {
      const config = environment.getTopLevelConfig()

      const replaceOptions: Record<string, string> = Object.create(null)

      for (const define of [config.define || {}, environment.config.define || {}]) {
        for (const key in define) {
          if (key.startsWith('import.meta.')) {
            replaceOptions[key] = define[key]
          }
        }
      }

      if (config.isProduction && (vite as any).rolldownVersion) {
        const { replacePlugin } = await import('rolldown/plugins')
        return replacePlugin(replaceOptions, { preventAssignment: true })
      } else {
        return replacePlugin({ ...replaceOptions, preventAssignment: true })
      }
    },
  }
}
</file>

<file path="packages/vite/src/plugins/resolve-deep-imports.ts">
import { parseNodeModulePath } from 'mlly'
import { resolveModulePath } from 'exsolve'
import { isAbsolute, normalize, resolve } from 'pathe'
import type { Environment, Plugin } from 'vite'
import { directoryToURL, logger, resolveAlias } from '@nuxt/kit'
import escapeRE from 'escape-string-regexp'
import type { Nuxt } from '@nuxt/schema'

const VIRTUAL_RE = /^\0?virtual:(?:nuxt:)?/

export function ResolveDeepImportsPlugin (nuxt: Nuxt): Plugin {
  const exclude: string[] = ['virtual:', '\0virtual:', '/__skip_vite', '@vitest/']

  const conditions: Record<string, undefined | string[]> = {}

  function resolveConditions (environment: Environment) {
    const resolvedConditions = new Set([nuxt.options.dev ? 'development' : 'production', ...environment.config.resolve.conditions])
    if (resolvedConditions.has('browser')) {
      resolvedConditions.add('web')
      resolvedConditions.add('import')
      resolvedConditions.add('module')
      resolvedConditions.add('default')
    }
    if (environment.config.mode === 'test') {
      resolvedConditions.add('import')
      resolvedConditions.add('require')
    }
    return [...resolvedConditions]
  }

  return {
    name: 'nuxt:resolve-bare-imports',
    enforce: 'post',
    resolveId: {
      filter: {
        id: {
          exclude: [
            // absolute path
            /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Z]:[/\\]/i,
            ...exclude.map(e => new RegExp('^' + escapeRE(e))),
          ],
        },
      },
      async handler (id, importer) {
        if (!importer || (!isAbsolute(importer) && !VIRTUAL_RE.test(importer))) {
          return
        }

        const normalisedId = resolveAlias(normalize(id), nuxt.options.alias)
        const isNuxtTemplate = importer.startsWith('virtual:nuxt')
        const normalisedImporter = (isNuxtTemplate ? decodeURIComponent(importer) : importer).replace(VIRTUAL_RE, '')

        if (nuxt.options.experimental.templateImportResolution !== false && isNuxtTemplate) {
          const template = nuxt.options.build.templates.find(t => resolve(nuxt.options.buildDir, t.filename!) === normalisedImporter)
          if (template?._path) {
            const res = await this.resolve?.(normalisedId, template._path, { skipSelf: true })
            if (res !== undefined && res !== null) {
              return res
            }
          }
        }

        const dir = parseNodeModulePath(normalisedImporter).dir || nuxt.options.appDir

        const res = await this.resolve?.(normalisedId, dir, { skipSelf: true })
        if (res !== undefined && res !== null) {
          return res
        }

        const environmentConditions = conditions[this.environment.name] ||= resolveConditions(this.environment)

        const path = resolveModulePath(id, {
          from: [dir, ...nuxt.options.modulesDir].map(d => directoryToURL(d)),
          suffixes: ['', 'index'],
          conditions: environmentConditions,
          try: true,
        })

        if (!path) {
          logger.debug('Could not resolve id', id, importer)
          return null
        }

        return normalize(path)
      },
    },
  }
}
</file>

<file path="packages/vite/src/plugins/resolved-externals.ts">
import type { Plugin } from 'vite'
import { tryImportModule, useNitro } from '@nuxt/kit'
import type { Nuxt } from '@nuxt/schema'
import { resolveModulePath } from 'exsolve'
import escapeStringRegexp from 'escape-string-regexp'
import { runtimeDependencies as runtimeNuxtDependencies } from 'nuxt/meta'

export function ResolveExternalsPlugin (nuxt: Nuxt): Plugin {
  let external: Set<string> = new Set()
  const nitro = useNitro()

  return {
    name: 'nuxt:resolve-externals',
    enforce: 'pre',
    async config () {
      const { runtimeDependencies: runtimeNitroDependencies = [] } = await tryImportModule<typeof import('nitropack/runtime/meta')>('nitropack/runtime/meta', {
        url: new URL(import.meta.url),
      }) || {}

      external = new Set([
        // explicit dependencies we use in our ssr renderer - these can be inlined (if necessary) in the nitro build
        'unhead', '@unhead/vue', '@nuxt/devalue', 'unstorage',
        // ensure we only have one version of vue if nitro is going to inline anyway
        ...nitro.options.inlineDynamicImports ? ['vue', '@vue/server-renderer'] : [],
        ...runtimeNuxtDependencies,
        // dependencies we might share with nitro - these can be inlined (if necessary) in the nitro build
        ...runtimeNitroDependencies,
      ])

      return {
        optimizeDeps: {
          exclude: Array.from(external),
        },
      }
    },
    applyToEnvironment (environment) {
      if (nuxt.options.dev || environment.name !== 'ssr') {
        return false
      }
      return {
        name: 'nuxt:resolve-externals:external',
        resolveId: {
          filter: {
            id: [...external].map(dep => new RegExp('^' + escapeStringRegexp(dep) + '$')),
          },
          async handler (id, importer) {
            const res = await this.resolve?.(id, importer, { skipSelf: true })
            if (res !== undefined && res !== null) {
              if (res.id === id) {
                res.id = resolveModulePath(res.id, {
                  try: true,
                  from: importer,
                  extensions: nuxt.options.extensions,
                }) || res.id
              }
              return {
                ...res,
                external: 'absolute',
              }
            }
          },
        },
      }
    },
  }
}
</file>

<file path="packages/vite/src/plugins/runtime-paths.ts">
import { pathToFileURL } from 'node:url'
import MagicString from 'magic-string'
import { parseQuery, parseURL } from 'ufo'
import type { Plugin } from 'vite'
import { isCSS } from '../utils/index.ts'

const VITE_ASSET_RE = /__VITE_ASSET__|__VITE_PUBLIC_ASSET__/

export function RuntimePathsPlugin (): Plugin {
  let sourcemap: boolean
  return {
    name: 'nuxt:runtime-paths-dep',
    enforce: 'post',
    applyToEnvironment: environment => environment.name === 'client',
    configResolved (config) {
      sourcemap = !!config.build.sourcemap
    },
    transform (code, id) {
      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href))

      // skip import into css files
      if (isCSS(pathname)) { return }

      // skip import into <style> vue files
      if (pathname.endsWith('.vue')) {
        if (search && parseQuery(search).type === 'style') { return }
      }

      if (VITE_ASSET_RE.test(code)) {
        const s = new MagicString(code)
        // Register dependency on #build/paths.mjs or #internal/nuxt/paths.mjs, which sets globalThis.__publicAssetsURL
        s.prepend('import "#internal/nuxt/paths";')

        return {
          code: s.toString(),
          map: sourcemap
            ? s.generateMap({ hires: true })
            : undefined,
        }
      }
    },
  }
}
</file>

<file path="packages/vite/src/plugins/sourcemap-preserver.ts">
import { mkdir, readFile, writeFile } from 'node:fs/promises'
import { defu } from 'defu'
import type { Nuxt } from '@nuxt/schema'
import { dirname, resolve } from 'pathe'
import escapeStringRegexp from 'escape-string-regexp'

import type { Plugin as RollupPlugin } from 'rollup'
import type { Plugin as VitePlugin } from 'vite'

export const SourcemapPreserverPlugin = (nuxt: Nuxt): VitePlugin | VitePlugin[] => {
  let outputDir: string
  const ids = new Set<string>()

  if (!nuxt.options.sourcemap.server || nuxt.options.dev) {
    return []
  }

  const nitroPlugin = () => ({
    name: 'nuxt:sourcemap-import',
    load: {
      filter: {
        id: new RegExp('^(\\w:)?' + escapeStringRegexp(outputDir.replace(/\/?$/, '/')).replace(/\//g, '[\\\\/]')),
      },
      async handler (id) {
        id = resolve(id)
        if (!ids.has(id)) { return }

        const [code, map] = await Promise.all([
          readFile(id, 'utf-8').catch(() => undefined),
          readFile(id + '.map.json', 'utf-8').catch(() => undefined),
        ])

        if (!code) {
          this.warn('Failed loading file')
          return null
        }

        return {
          code,
          map,
        }
      },
    },
  }) satisfies RollupPlugin

  nuxt.hook('nitro:build:before', (nitro) => {
    nitro.options.rollupConfig = defu(nitro.options.rollupConfig, {
      plugins: [nitroPlugin],
    })
  })

  return {
    name: 'nuxt:sourcemap-export',
    applyToEnvironment: (environment) => {
      return environment.name === 'ssr' && environment.config.isProduction
    },
    apply (config) {
      return !!config.build?.sourcemap
    },
    configResolved (config) {
      outputDir = config.build.outDir
    },
    async writeBundle (_options, bundle) {
      for (const chunk of Object.values(bundle)) {
        if (chunk.type !== 'chunk' || !chunk.map) { continue }

        const id = resolve(outputDir, chunk.fileName)
        ids.add(id)
        const dest = id + '.map.json'
        await mkdir(dirname(dest), { recursive: true })
        await writeFile(dest, JSON.stringify({
          file: chunk.map.file,
          mappings: chunk.map.mappings,
          names: chunk.map.names,
          sources: chunk.map.sources,
          sourcesContent: chunk.map.sourcesContent,
          version: chunk.map.version,
        }))
      }
    },
  }
}
</file>

<file path="packages/vite/src/plugins/ssr-styles.ts">
import { pathToFileURL } from 'node:url'
import type { Plugin } from 'vite'
import { dirname, relative } from 'pathe'
import { genArrayFromRaw, genImport, genObjectFromRawEntries } from 'knitwork'
import { filename as _filename } from 'pathe/utils'
import { parseQuery, parseURL } from 'ufo'
import type { Nuxt } from '@nuxt/schema'
import MagicString from 'magic-string'
import { findStaticImports } from 'mlly'

import { IS_CSS_RE, isCSS, isVue } from '../utils/index.ts'
import { resolveClientEntry } from '../utils/config.ts'
import { useNitro } from '@nuxt/kit'
import escapeStringRegexp from 'escape-string-regexp'

const SUPPORTED_FILES_RE = /\.(?:vue|(?:[cm]?j|t)sx?)$/
const QUERY_RE = /\?.+$/

export function SSRStylesPlugin (nuxt: Nuxt): Plugin | undefined {
  if (nuxt.options.dev) { return }

  const chunksWithInlinedCSS = new Set<string>()
  const clientCSSMap: Record<string, Set<string>> = {}

  // Remove CSS entries for files that will have inlined styles
  const nitro = useNitro()
  nuxt.hook('build:manifest', (manifest) => {
    const entryIds = new Set<string>()
    for (const id of chunksWithInlinedCSS) {
      const chunk = manifest[id]
      if (!chunk) {
        continue
      }
      if (chunk.isEntry && chunk.src) {
        entryIds.add(chunk.src)
      } else {
        chunk.css &&= []
      }
    }

    nitro.options.virtual['#internal/nuxt/entry-ids.mjs'] = () => `export default ${JSON.stringify(Array.from(entryIds))}`
    nitro.options._config.virtual ||= {}
    nitro.options._config.virtual['#internal/nuxt/entry-ids.mjs'] = nitro.options.virtual['#internal/nuxt/entry-ids.mjs']
  })

  const cssMap: Record<string, { files: string[], inBundle?: boolean }> = {}
  const idRefMap: Record<string, string> = {}

  const options = {
    shouldInline: nuxt.options.features.inlineStyles,
    globalCSS: nuxt.options.css,
  }

  // relative file lookup has duplicate checks
  const relativeCache = new Map<string, string>()
  const relativeToSrcDir = (path: string) => {
    let cached = relativeCache.get(path)
    if (cached === undefined) {
      cached = relative(nuxt.options.srcDir, path)
      relativeCache.set(path, cached)
    }
    return cached
  }

  const warnCache = new Set<string>()
  const components = nuxt.apps.default!.components || []
  const islands = components.filter(component =>
    component.island ||
    // .server components without a corresponding .client component will need to be rendered as an island
    (component.mode === 'server' && !components.some(c => c.pascalName === component.pascalName && c.mode === 'client')),
  )
  const islandPaths = new Set(islands.map(c => c.filePath))

  let entry: string

  return {
    name: 'ssr-styles',
    configResolved (config) {
      // TODO: remove when adopting vite environment api
      if (!config.build.ssr || nuxt.options.experimental.viteEnvironmentApi) {
        entry = resolveClientEntry(config)
      }
    },
    applyToEnvironment (environment) {
      return {
        name: `nuxt:ssr-styles:${environment.name}`,
        enforce: 'pre',
        resolveId: {
          order: 'pre',
          filter: {
            id: {
              include: [/^#build\/css$/, /\.vue$/, IS_CSS_RE],
            },
          },
          async handler (id, importer, _options) {
            // We want to remove side effects (namely, emitting CSS) from `.vue` files and explicitly imported `.css` files
            // but only as long as we are going to inline that CSS.
            if ((options.shouldInline === false || (typeof options.shouldInline === 'function' && !options.shouldInline(importer)))) {
              return
            }

            const res = await this.resolve(id, importer, { ..._options, skipSelf: true })
            if (res) {
              return {
                ...res,
                moduleSideEffects: false,
              }
            }
          },
        },
        generateBundle (outputOptions) {
          if (environment.name === 'client') { return }

          const emitted: Record<string, string> = {}
          for (const [file, { files, inBundle }] of Object.entries(cssMap)) {
            // File has been tree-shaken out of build (or there are no styles to inline)
            if (!files.length || !inBundle) { continue }
            const fileName = filename(file)
            const base = typeof outputOptions.assetFileNames === 'string'
              ? outputOptions.assetFileNames
              : outputOptions.assetFileNames({
                  type: 'asset',
                  name: `${fileName}-styles.mjs`,
                  names: [`${fileName}-styles.mjs`],
                  originalFileName: `${fileName}-styles.mjs`,
                  originalFileNames: [`${fileName}-styles.mjs`],
                  source: '',
                })

            const baseDir = dirname(base)

            const cssImports = new Set<string>()
            const exportNames = new Set<string>()
            const importStatements = new Set<string>()
            let i = 0
            for (const css of files) {
              const file = this.getFileName(css)
              if (cssImports.has(file)) {
                continue
              }
              cssImports.add(file)
              const name = `style_${i++}`
              importStatements.add(genImport(`./${relative(baseDir, file)}`, name))
              exportNames.add(name)
            }
            emitted[file] = this.emitFile({
              type: 'asset',
              name: `${fileName}-styles.mjs`,
              source: [
                ...importStatements,
                `export default ${genArrayFromRaw([...exportNames])}`,
              ].join('\n'),
            })
          }

          for (const key in emitted) {
            // Track the chunks we are inlining CSS for so we can omit including links to the .css files
            chunksWithInlinedCSS.add(key)
          }

          // TODO: remove css from vite preload arrays

          this.emitFile({
            type: 'asset',
            fileName: 'styles.mjs',
            originalFileName: 'styles.mjs',
            source:
          [
            'const interopDefault = r => r.default || r || []',
            `export default ${genObjectFromRawEntries(
              Object.entries(emitted).map(([key, value]) => [key, `() => import('./${this.getFileName(value)}').then(interopDefault)`]) as [string, string][],
            )}`,
          ].join('\n'),
          })
        },
        renderChunk (_code, chunk) {
          const isEntry = chunk.facadeModuleId === entry
          if (isEntry) {
            clientCSSMap[chunk.facadeModuleId!] ||= new Set()
          }
          for (const moduleId of [chunk.facadeModuleId, ...chunk.moduleIds].filter(Boolean) as string[]) {
            // 'Teleport' CSS chunks that made it into the bundle on the client side
            // to be inlined on server rendering
            if (environment.name === 'client') {
              const moduleMap = clientCSSMap[moduleId] ||= new Set()
              if (isCSS(moduleId)) {
                // Vue files can (also) be their own entrypoints as they are tracked separately
                if (isVue(moduleId)) {
                  moduleMap.add(moduleId)
                  const parent = moduleId.replace(/\?.+$/, '')
                  const parentMap = clientCSSMap[parent] ||= new Set()
                  parentMap.add(moduleId)
                }
                // This is required to track CSS in entry chunk
                if (isEntry && chunk.facadeModuleId) {
                  const facadeMap = clientCSSMap[chunk.facadeModuleId] ||= new Set()
                  facadeMap.add(moduleId)
                }
              }
              continue
            }

            const relativePath = relativeToSrcDir(moduleId)
            if (relativePath in cssMap) {
              cssMap[relativePath]!.inBundle = cssMap[relativePath]!.inBundle ?? ((isVue(moduleId) && !!relativePath) || isEntry)
            }
          }

          return null
        },
        transform: {
          filter: {
            id: {
              include: environment.name === 'client'
                ? new RegExp('^' + escapeStringRegexp(entry) + '$')
                : undefined,
              exclude: environment.name === 'client' ? [] : [/\?.*macro=/, /\?.*nuxt_component=/],
            },
          },
          async handler (code, id) {
            if (environment.name === 'client') {
              // We will either teleport global CSS to the 'entry' chunk on the server side
              // or include it here in the client build so it is emitted in the CSS.
              if (id === entry && (options.shouldInline === true || (typeof options.shouldInline === 'function' && options.shouldInline(id)))) {
                const idClientCSSMap = clientCSSMap[id] ||= new Set()
                if (!options.globalCSS.length) { return }

                const s = new MagicString(code)
                for (const file of options.globalCSS) {
                  const resolved = await this.resolve(file) ?? await this.resolve(file, id)
                  const res = await this.resolve(file + '?inline&used') ?? await this.resolve(file + '?inline&used', id)
                  if (!resolved || !res) {
                    if (!warnCache.has(file)) {
                      warnCache.add(file)
                      this.warn(`[nuxt] Cannot extract styles for \`${file}\`. Its styles will not be inlined when server-rendering.`)
                    }
                    s.prepend(`${genImport(file)}\n`)
                    continue
                  }
                  idClientCSSMap.add(resolved.id)
                }
                if (s.hasChanged()) {
                  return {
                    code: s.toString(),
                    map: s.generateMap({ hires: true }),
                  }
                }
              }
              return
            }

            const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href))

            if (!(id in clientCSSMap) && !islandPaths.has(pathname)) { return }

            const query = parseQuery(search)
            if (query.macro || query.nuxt_component) { return }

            if (!islandPaths.has(pathname)) {
              if (options.shouldInline === false || (typeof options.shouldInline === 'function' && !options.shouldInline(id))) { return }
            }

            const relativeId = relativeToSrcDir(id)
            const idMap = cssMap[relativeId] ||= { files: [] }

            const emittedIds = new Set<string>()
            const idFilename = filename(id)

            let styleCtr = 0
            const ids = clientCSSMap[id] || []
            for (const file of ids) {
              if (emittedIds.has(file)) { continue }
              const fileInline = file + '?inline&used'
              const resolved = await this.resolve(file) ?? await this.resolve(file, id)
              const res = await this.resolve(fileInline) ?? await this.resolve(fileInline, id)
              if (!resolved || !res) {
                if (!warnCache.has(file)) {
                  warnCache.add(file)
                  this.warn(`[nuxt] Cannot extract styles for \`${file}\`. Its styles will not be inlined when server-rendering.`)
                }
                continue
              }
              emittedIds.add(file)
              const ref = this.emitFile({
                type: 'chunk',
                name: `${idFilename}-styles-${++styleCtr}.mjs`,
                id: fileInline,
              })

              idRefMap[relativeToSrcDir(file)] = ref
              idMap.files.push(ref)
            }

            if (!SUPPORTED_FILES_RE.test(pathname)) { return }

            for (const i of findStaticImports(code)) {
              if (!i.specifier.endsWith('.css') && parseQuery(i.specifier).type !== 'style') { continue }

              const resolved = await this.resolve(i.specifier, id)
              if (!resolved) { continue }
              const resolvedIdInline = resolved.id + '?inline&used'
              if (!(await this.resolve(resolvedIdInline))) {
                if (!warnCache.has(resolved.id)) {
                  warnCache.add(resolved.id)
                  this.warn(`[nuxt] Cannot extract styles for \`${i.specifier}\`. Its styles will not be inlined when server-rendering.`)
                }
                continue
              }

              if (emittedIds.has(resolved.id)) { continue }
              const ref = this.emitFile({
                type: 'chunk',
                name: `${idFilename}-styles-${++styleCtr}.mjs`,
                id: resolvedIdInline,
              })

              idRefMap[relativeToSrcDir(resolved.id)] = ref
              idMap.files.push(ref)
            }
          },
        },
      }
    },
  }
}

function filename (name: string) {
  return _filename(name.replace(QUERY_RE, ''))
}
</file>

<file path="packages/vite/src/plugins/stable-entry.ts">
import { useNitro } from '@nuxt/kit'
import type { Nuxt } from '@nuxt/schema'
import escapeStringRegexp from 'escape-string-regexp'
import MagicString from 'magic-string'
import { basename } from 'pathe'
import { withoutLeadingSlash } from 'ufo'
import type { Plugin } from 'vite'
import { toArray } from '../utils/index.ts'

export function StableEntryPlugin (nuxt: Nuxt): Plugin {
  let sourcemap: boolean
  let entryFileName: string | undefined

  const nitro = useNitro()

  nitro.options.virtual ||= {}
  nitro.options._config.virtual ||= {}

  nitro.options._config.virtual['#internal/entry-chunk.mjs'] = nitro.options.virtual['#internal/entry-chunk.mjs'] = () => `export const entryFileName = ${JSON.stringify(entryFileName)}`

  return {
    name: 'nuxt:stable-entry',
    configResolved (config) {
      sourcemap = !!config.build.sourcemap
    },
    apply: () => !nuxt.options.dev && nuxt.options.experimental.entryImportMap,
    applyToEnvironment (environment) {
      if (environment.name !== 'client') {
        return false
      }
      if (environment.config.build.target) {
        const targets = toArray(environment.config.build.target)
        if (!targets.every(isSupported)) {
          return false
        }
      }
      // only apply plugin if the entry file name is hashed
      return toArray(environment.config.build.rollupOptions?.output)
        .some(output => typeof output?.entryFileNames === 'string' && output?.entryFileNames.includes('[hash]'))
    },
    renderChunk (code, chunk, _options, meta) {
      const entry = Object.values(meta.chunks).find(chunk => chunk.isEntry && chunk.name === 'entry')?.fileName
      if (!entry || !chunk.imports.includes(entry)) {
        return
      }

      const filename = new RegExp(`(?<=['"])[\\./]*${escapeStringRegexp(basename(entry))}`, 'g')
      const s = new MagicString(code)
      s.replaceAll(filename, '#entry')

      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: sourcemap ? s.generateMap({ hires: true }) : undefined,
        }
      }
    },
    writeBundle (_options, bundle) {
      let entry = Object.values(bundle).find(chunk => chunk.type === 'chunk' && chunk.isEntry && chunk.name === 'entry')?.fileName
      const prefix = withoutLeadingSlash(nuxt.options.app.buildAssetsDir)
      if (entry?.startsWith(prefix)) {
        entry = entry.slice(prefix.length)
      }
      entryFileName = entry
    },
  }
}

// https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/script/type/importmap#browser_compatibility
const supportedEnvironments = {
  chrome: 89,
  edge: 89,
  firefox: 108,
  ie: Infinity,
  ios: 16.4,
  opera: 75,
  safari: 16.4,
}

function isSupported (target: string) {
  const [engine, _version] = target.split(/(?<=[a-z])(?=\d)/)
  const constraint = supportedEnvironments[engine as keyof typeof supportedEnvironments]
  if (!constraint) {
    return true
  }
  const version = Number(_version)
  return Number.isNaN(version) || Number(version) >= constraint
}
</file>

<file path="packages/vite/src/plugins/type-check.ts">
import MagicString from 'magic-string'
import type { Nuxt } from '@nuxt/schema'
import type { Plugin } from 'vite'
import { resolveClientEntry } from '../utils/config.ts'

const QUERY_RE = /\?.+$/

export function TypeCheckPlugin (nuxt: Nuxt): Plugin {
  let entry: string
  let sourcemap: boolean
  return {
    name: 'nuxt:type-check',
    applyToEnvironment: environment => environment.name === 'client' && !environment.config.isProduction,
    apply: () => {
      return !nuxt.options.test && nuxt.options.typescript.typeCheck === true
    },
    configResolved (config) {
      try {
        entry = resolveClientEntry(config)
        sourcemap = !!config.build.sourcemap
      } catch {
        console.debug('[nuxt:type-check] Could not resolve client entry, type checking will not be applied.')
      }
    },
    transform (code, id) {
      if (id.replace(QUERY_RE, '') !== entry) { return }

      const s = new MagicString(code)

      s.prepend('import "/@vite-plugin-checker-runtime-entry";\n')

      return {
        code: s.toString(),
        map: sourcemap ? s.generateMap({ hires: true }) : undefined,
      }
    },
  }
}
</file>

<file path="packages/vite/src/plugins/vite-node.ts">
import process from 'node:process'
import { mkdir, unlink, writeFile } from 'node:fs/promises'
import type { Socket } from 'node:net'
import net from 'node:net'
import os from 'node:os'
import fs from 'node:fs' // For sync operations like unlinkSync if needed during setup
import { pathToFileURL } from 'node:url'
import { Buffer } from 'node:buffer'
import { createError } from 'h3'
import { join, normalize } from 'pathe'
import { tryUseNuxt } from '@nuxt/kit'
import type { EnvironmentModuleNode, ModuleNode, PluginContainer, ViteDevServer, Plugin as VitePlugin } from 'vite'
import { getQuery } from 'ufo'
import type { FetchResult } from 'vite-node'
import { ViteNodeServer } from 'vite-node/server'
import { normalizeViteManifest } from 'vue-bundle-renderer'
import type { Manifest } from 'vue-bundle-renderer'
import type { Nuxt } from '@nuxt/schema'
import { provider } from 'std-env'
import { resolveModulePath } from 'exsolve'

import { isCSS } from '../utils/index.ts'
import { resolveClientEntry, resolveServerEntry } from '../utils/config.ts'

type ResolveIdResponse = Awaited<ReturnType<PluginContainer['resolveId']>>

export interface ViteNodeRequestMap {
  manifest: {
    request: undefined
    response: Manifest
  }
  invalidates: {
    request: undefined
    response: string[]
  }
  resolve: {
    request: { id: string, importer?: string }
    response: ResolveIdResponse | null
  }
  module: {
    request: { moduleId: string }
    response: FetchResult
  }
}

type RequestOf = {
  [K in keyof ViteNodeRequestMap]: {
    id: number
    type: K
    payload: ViteNodeRequestMap[K]['request']
  }
}

type ViteNodeRequest = RequestOf[keyof RequestOf]

export interface ViteNodeFetch {
  /**  Gets the client manifest. */
  getManifest(): Promise<Manifest>
  /** Gets the list of invalidated files. */
  getInvalidates(): Promise<string[]>
  /** Resolves a module ID. */
  resolveId(id: string, importer?: string): Promise<ResolveIdResponse | null>
  /** Fetches a module. */
  fetchModule(moduleId: string): Promise<FetchResult>
  /** Ensures the IPC socket is connected. */
  ensureConnected(): Promise<Socket>
}

function getManifest (nuxt: Nuxt, viteServer: ViteDevServer, clientEntry: string) {
  const css = new Set<string>()
  const ssrServer = nuxt.options.experimental.viteEnvironmentApi ? viteServer.environments.ssr : viteServer
  for (const key of ssrServer.moduleGraph.urlToModuleMap.keys()) {
    if (isCSS(key)) {
      const query = getQuery(key)
      if ('raw' in query) { continue }
      const importers = ssrServer.moduleGraph.urlToModuleMap.get(key)?.importers
      if (importers && [...importers].every(i => i.id && 'raw' in getQuery(i.id))) {
        continue
      }
      css.add(key)
    }
  }

  const manifest = normalizeViteManifest({
    '@vite/client': {
      file: '@vite/client',
      css: [...css],
      module: true,
      isEntry: true,
    },
    ...nuxt.options.features.noScripts === 'all'
      ? {}
      : {
          [clientEntry]: {
            file: clientEntry,
            isEntry: true,
            module: true,
            resourceType: 'script',
          },
        },
  })

  return manifest
}

function generateSocketPath () {
  const uniqueSuffix = `${process.pid}-${Date.now()}`
  const socketName = `nuxt-vite-node-${uniqueSuffix}`

  // Windows: pipe
  if (process.platform === 'win32') {
    return join(String.raw`\\.\pipe`, socketName)
  }
  // Linux: abstract namespace
  if (process.platform === 'linux') {
    const nodeMajor = Number.parseInt(process.versions.node.split('.')[0]!, 10)
    if (nodeMajor >= 20 && provider !== 'stackblitz') {
      // We avoid abstract sockets in Docker due to performance issues
      let isDocker = false

      try {
        isDocker = fs.existsSync('/.dockerenv') || (fs.existsSync('/proc/1/cgroup') && fs.readFileSync('/proc/1/cgroup', 'utf8').includes('docker'))
      } catch {
        // Ignore errors checking Docker status
      }

      if (!isDocker) {
        return `\0${socketName}.sock`
      }
    }
  }
  // Unix socket
  return join(os.tmpdir(), `${socketName}.sock`)
}

function useInvalidates () {
  // Store the invalidates for the next rendering
  const invalidates = new Set<string>()

  function markInvalidate (mod: ModuleNode | EnvironmentModuleNode) {
    if (!mod.id) { return }
    if (invalidates.has(mod.id)) { return }
    invalidates.add(mod.id)
    markInvalidates(mod.importers)
  }

  function markInvalidates (mods?: (ModuleNode | EnvironmentModuleNode)[] | Set<ModuleNode | EnvironmentModuleNode>) {
    if (!mods) { return }
    for (const mod of mods) {
      markInvalidate(mod)
    }
  }

  return {
    invalidates,
    markInvalidate,
    markInvalidates,
  }
}

export function ViteNodePlugin (nuxt: Nuxt): VitePlugin {
  let socketServer: net.Server | undefined
  const socketPath = generateSocketPath()
  const { invalidates, markInvalidate, markInvalidates } = useInvalidates()

  async function cleanupSocket () {
    if (socketServer && socketServer.listening) {
      await new Promise<void>(resolveClose => socketServer!.close(() => resolveClose()))
    }
    if (socketPath && !socketPath.startsWith('\\\\.\\pipe\\')) {
      try {
        await unlink(socketPath)
      } catch {
        // Error is ignored if the file doesn't exist or cannot be unlinked
      }
    }
  }

  return {
    name: 'nuxt:vite-node-server',
    enforce: 'post',
    configureServer (clientServer) {
      // early return if plugins are 'borrowed' for testing/storybook
      if (!tryUseNuxt()) {
        return
      }

      function resolveServer (ssrServer: ViteDevServer) {
        const viteNodeServerOptions = {
          socketPath,
          root: nuxt.options.srcDir,
          entryPath: resolveServerEntry(ssrServer.config),
          base: ssrServer.config.base || '/_nuxt/',
          maxRetryAttempts: nuxt.options.vite.viteNode?.maxRetryAttempts,
          baseRetryDelay: nuxt.options.vite.viteNode?.baseRetryDelay,
          maxRetryDelay: nuxt.options.vite.viteNode?.maxRetryDelay,
          requestTimeout: nuxt.options.vite.viteNode?.requestTimeout,
          // TODO: remove baseURL in future
          baseURL: nuxt.options.devServer.url,
        }

        process.env.NUXT_VITE_NODE_OPTIONS = JSON.stringify(viteNodeServerOptions)

        socketServer = createViteNodeSocketServer(nuxt, ssrServer, clientServer, invalidates, viteNodeServerOptions)
      }

      if (nuxt.options.experimental.viteEnvironmentApi) {
        resolveServer(clientServer)
      } else {
        nuxt.hook('vite:serverCreated', (ssrServer, ctx) => ctx.isServer ? resolveServer(ssrServer) : undefined)
      }

      nuxt.hook('close', cleanupSocket)

      const client = nuxt.options.experimental.viteEnvironmentApi ? clientServer.environments.client : clientServer
      nuxt.hook('app:templatesGenerated', (_app, changedTemplates) => {
        for (const template of changedTemplates) {
          const mods = client.moduleGraph.getModulesByFile(`virtual:nuxt:${encodeURIComponent(template.dst)}`)
          for (const mod of mods || []) {
            markInvalidate(mod)
          }
        }
      })

      clientServer.watcher.on('all', (_event, file) => {
        invalidates.add(file)
        markInvalidates(clientServer.moduleGraph.getModulesByFile(normalize(file)))
      })
    },
    async buildEnd () {
      await cleanupSocket()
    },
  }
}

let _node: ViteNodeServer | undefined

function getNode (server: ViteDevServer) {
  return _node ||= new ViteNodeServer(server, {
    transformMode: {
      ssr: [/.*/],
      web: [],
    },
  })
}

function createViteNodeSocketServer (nuxt: Nuxt, ssrServer: ViteDevServer, clientServer: ViteDevServer, invalidates: Set<string>, config: ViteNodeServerOptions) {
  const server = net.createServer((socket) => {
    const INITIAL_BUFFER_SIZE = 64 * 1024 // 64kB
    const MAX_BUFFER_SIZE = 1024 * 1024 * 1024 // 1GB

    let buffer = Buffer.alloc(INITIAL_BUFFER_SIZE)
    let writeOffset = 0
    let readOffset = 0

    // Optimize socket settings for performance
    socket.setNoDelay(true)
    socket.setKeepAlive(true, 0)

    async function processMessage (request: ViteNodeRequest) {
      try {
        switch (request.type) {
          case 'manifest': {
            const manifestData = getManifest(nuxt, ssrServer, resolveClientEntry(clientServer.config))
            sendResponse<typeof request.type>(socket, request.id, manifestData)
            return
          }
          case 'invalidates': {
            const responsePayload = Array.from(invalidates)
            invalidates.clear()
            sendResponse<typeof request.type>(socket, request.id, responsePayload)
            return
          }
          case 'resolve': {
            const { id: resolveId, importer } = request.payload
            if (!resolveId) {
              throw createError({ status: 400, message: 'Missing id for resolve' })
            }
            const ssrNode = nuxt.options.experimental.viteEnvironmentApi
              ? ssrServer.environments.ssr.pluginContainer
              : getNode(ssrServer)
            const resolvedResult = await ssrNode.resolveId(resolveId, importer).catch(() => null)
            sendResponse<typeof request.type>(socket, request.id, resolvedResult)
            return
          }
          case 'module': {
            if (request.payload.moduleId === '/') {
              throw createError({ status: 400, message: 'Invalid moduleId' })
            }
            const ssrNode = nuxt.options.experimental.viteEnvironmentApi
              ? ssrServer.environments.ssr
              : getNode(ssrServer)
            const response = await ssrNode.fetchModule(request.payload.moduleId)
              .catch(async (err) => {
                const errorData: Record<string, any> = {
                  code: 'VITE_ERROR',
                  id: request.payload.moduleId,
                  stack: err.stack || '',
                  message: err.message || '',
                }
                if (err.frame) { errorData.frame = err.frame }

                if (!errorData.frame && err.code === 'PARSE_ERROR') {
                  try {
                    const clientNode = nuxt.options.experimental.viteEnvironmentApi
                      ? ssrServer.environments.client
                      : getNode(ssrServer)
                    errorData.frame = await clientNode.transformRequest(request.payload.moduleId)
                      .then(res => `${err.message || ''}\n${res?.code}`).catch(() => undefined)
                  } catch {
                  // Ignore transform errors
                  }
                }
                throw createError({ data: errorData, message: err.message || 'Error fetching module' })
              }) as Exclude<FetchResult, { cache: true }>
            sendResponse<typeof request.type>(socket, request.id, response)
            return
          }
          default:
            // @ts-expect-error this should never happen
            throw createError({ status: 400, message: `Unknown request type: ${request.type}` })
        }
      } catch (error: any) {
        sendError(socket, request.id, error)
      }
    }

    const resetBuffer = () => {
      writeOffset = 0
      readOffset = 0
    }

    const compactBuffer = () => {
      if (readOffset > 0) {
        const remainingData = writeOffset - readOffset
        if (remainingData > 0) {
          buffer.copy(buffer, 0, readOffset, writeOffset)
        }
        writeOffset = remainingData
        readOffset = 0
      }
    }

    const ensureBufferCapacity = (additionalBytes: number) => {
      const requiredSize = writeOffset + additionalBytes

      if (requiredSize > MAX_BUFFER_SIZE) {
        throw new Error(`Buffer size limit exceeded: ${requiredSize} > ${MAX_BUFFER_SIZE}`)
      }

      if (requiredSize > buffer.length) {
        // try compacting first
        compactBuffer()

        // ... then if we still need more space, grow the buffer
        if (writeOffset + additionalBytes > buffer.length) {
          const newSize = Math.min(
            Math.max(buffer.length * 2, requiredSize),
            MAX_BUFFER_SIZE,
          )
          const newBuffer = Buffer.alloc(newSize)
          buffer.copy(newBuffer, 0, 0, writeOffset)
          buffer = newBuffer
        }
      }
    }

    socket.on('data', (data) => {
      try {
        ensureBufferCapacity(data.length)
        data.copy(buffer, writeOffset)
        writeOffset += data.length

        // Process all complete messages in the buffer
        while (writeOffset - readOffset >= 4) {
          const messageLength = buffer.readUInt32BE(readOffset)
          const totalLength = 4 + messageLength

          if (writeOffset - readOffset < totalLength) {
            break // Wait for more data
          }

          const messageJSON = buffer.subarray(readOffset + 4, readOffset + totalLength).toString('utf-8')
          readOffset += totalLength

          try {
            const request = JSON.parse(messageJSON)
            processMessage(request).catch((error) => {
              sendError(socket, request?.id || 'unknown', error)
            })
          } catch (parseError) {
            // invalid JSON
            const errorMessage = parseError instanceof Error ? parseError.message : 'Unknown parse error'
            socket.destroy(new Error(`Invalid JSON in message: ${errorMessage}`))
            return
          }
        }

        // compact buffer periodically to prevent memory waste
        if (readOffset > buffer.length / 2) {
          compactBuffer()
        }
      } catch (error) {
        // buffer management error - close connection
        socket.destroy(error instanceof Error ? error : new Error('Buffer management error'))
      }
    })

    socket.on('error', () => {
      resetBuffer()
    })

    socket.on('close', () => {
      resetBuffer()
    })
  })

  const currentSocketPath = config.socketPath
  if (!currentSocketPath) {
    throw new Error('Socket path not configured for ViteNodeSocketServer.')
  }

  // Clean up existing socket file (Unix only)
  if (!currentSocketPath.startsWith('\\\\.\\pipe\\')) {
    try {
      fs.unlinkSync(currentSocketPath)
    } catch (unlinkError: any) {
      if (unlinkError.code !== 'ENOENT') {
        // Socket cleanup failed, but continue anyway
      }
    }
  }

  server.listen(currentSocketPath)

  server.on('error', () => {
    // Server error - will be handled by calling code
  })

  return server
}

function sendResponse<T extends keyof ViteNodeRequestMap> (
  socket: net.Socket,
  id: number,
  data: ViteNodeRequestMap[T]['response'],
): undefined {
  try {
    const response = { id, type: 'response', data }
    const responseJSON = JSON.stringify(response)
    const messageBuffer = Buffer.from(responseJSON, 'utf-8')
    const messageLength = messageBuffer.length

    // pre-allocate single buffer for length + message to avoid Buffer.concat()
    const fullMessage = Buffer.alloc(4 + messageLength)
    fullMessage.writeUInt32BE(messageLength, 0)
    messageBuffer.copy(fullMessage, 4)

    socket.write(fullMessage, (err) => {
      if (err) {
        // Failed to send response - connection likely closed
      }
    })
  } catch (error) {
    // Send error response instead
    sendError(socket, id, error)
  }
}

function sendError (socket: net.Socket, id: number, error: any) {
  const errorResponse = {
    id,
    type: 'error',
    error: {
      message: error.message,
      stack: error.stack,
      status: error.status,
      statusText: error.statusText,
      data: error.data,
    },
  }
  const responseJSON = JSON.stringify(errorResponse)
  const messageBuffer = Buffer.from(responseJSON, 'utf-8')
  const messageLength = messageBuffer.length

  // Pre-allocate single buffer for length + message to avoid Buffer.concat()
  const fullMessage = Buffer.alloc(4 + messageLength)
  fullMessage.writeUInt32BE(messageLength, 0)
  messageBuffer.copy(fullMessage, 4)

  socket.write(fullMessage, (err) => {
    if (err) {
      // Failed to send error response - connection likely closed
    }
  })
}

export type ViteNodeServerOptions = {
  baseURL: string
  socketPath: string
  root: string
  entryPath: string
  base: string
  maxRetryAttempts?: number
  baseRetryDelay?: number
  maxRetryDelay?: number
  requestTimeout?: number
}

export async function writeDevServer (nuxt: Nuxt): Promise<void> {
  const serverResolvedPath = resolveModulePath('#vite-node-entry', { from: import.meta.url })
  const fetchResolvedPath = resolveModulePath('#vite-node', { from: import.meta.url })

  const serverDist = join(nuxt.options.buildDir, 'dist/server')

  await mkdir(serverDist, { recursive: true })

  await Promise.all([
    writeFile(join(serverDist, 'server.mjs'), `export { default } from ${JSON.stringify(pathToFileURL(serverResolvedPath).href)}`),
    writeFile(join(serverDist, 'client.precomputed.mjs'), `export default undefined`),
    writeFile(join(serverDist, 'client.manifest.mjs'), `
import { viteNodeFetch } from ${JSON.stringify(pathToFileURL(fetchResolvedPath))}
export default () => viteNodeFetch.getManifest()
    `),
  ])
}
</file>

<file path="packages/vite/src/plugins/vite-plugin-checker.ts">
import type { Plugin } from 'vite'
import type { Nuxt } from '@nuxt/schema'
import { readTSConfig, resolveTSConfig } from 'pkg-types'

export async function VitePluginCheckerPlugin (nuxt: Nuxt, environment?: string): Promise<Array<Plugin | undefined> | undefined> {
  if (!nuxt.options.test && (nuxt.options.typescript.typeCheck === true || (nuxt.options.typescript.typeCheck === 'build' && !nuxt.options.dev))) {
    const [checker, tsconfigPath] = await Promise.all([
      import('vite-plugin-checker').then(r => r.default),
      resolveTSConfig(nuxt.options.rootDir),
    ])
    const supportsProjects = await readTSConfig(tsconfigPath).then(r => !!(r.references?.length))
    const environments = (['client', nuxt.options.ssr ? 'ssr' : undefined] as const).filter(name => environment ? name === environment : !!name)
    return environments.map(envName => ({
      applyToEnvironment: environment => environment.name === envName,
      ...checker({
        vueTsc: {
          tsconfigPath,
          buildMode: supportsProjects,
        },
      }),
    }))
  }
}
</file>

<file path="packages/vite/src/plugins/vue-feature-flags.ts">
import type { Nitro } from 'nitropack/types'
import type { Nuxt } from '@nuxt/schema'
import type { Plugin } from 'vite'

export function VueFeatureFlagsPlugin (nuxt: Nuxt): Plugin {
  return {
    name: 'nuxt:nitro:vue-feature-flags',
    applyToEnvironment: environment => environment.name === 'ssr' && environment.config.isProduction,
    configResolved (config) {
      for (const key in config.define) {
        if (key.startsWith('__VUE')) {
          // tree-shake vue feature flags for non-node targets
          ((nuxt as any)._nitro as Nitro).options.replace[key] = config.define[key]
        }
      }
    },
  }
}
</file>

<file path="packages/vite/src/shared/client.ts">
import type { Nuxt } from 'nuxt/schema'
import { resolve } from 'pathe'

import { getTranspileStrings } from '../utils/transpile.ts'

export const clientEnvironment = (nuxt: Nuxt, entry: string) => {
  return {
    optimizeDeps: {
      entries: [entry],
      include: [],
      // We exclude Vue and Nuxt common dependencies from optimization
      // as they already ship ESM.
      //
      // This will help to reduce the chance for users to encounter
      // common chunk conflicts that causing browser reloads.
      // We should also encourage module authors to add their deps to
      // `exclude` if they ships bundled ESM.
      //
      // Also since `exclude` is inert, it's safe to always include
      // all possible deps even if they are not used yet.
      //
      // @see https://github.com/antfu/nuxt-better-optimize-deps#how-it-works
      exclude: [
        // Vue
        'vue',
        '@vue/runtime-core',
        '@vue/runtime-dom',
        '@vue/reactivity',
        '@vue/shared',
        '@vue/devtools-api',
        '@vue/test-utils',
        'vue-router',
        'vue-demi',

        // Nuxt
        'nuxt',
        'nuxt/app',
        '@nuxt/test-utils',

        // Nuxt Deps
        '@unhead/vue',
        'consola',
        'defu',
        'devalue',
        'get-port-please',
        'h3',
        'hookable',
        'klona',
        'ofetch',
        'pathe',
        'ufo',
        'unctx',
        'unenv',

        // this will never be imported on the client
        '#app-manifest',
        // these should all be valid ESM
        '#imports',
        '#app',
        '#build',
        '#build/*',
        '#components',
        '#head',
        'virtual:nuxt:',
        'virtual:nuxt:*',
        ...getTranspileStrings({ isDev: nuxt.options.dev, isClient: true }),
      ],
    },
    define: {
      'process.env.NODE_ENV': JSON.stringify(nuxt.options.vite.mode),
      'process.server': false,
      'process.client': true,
      'process.browser': true,
      'process.nitro': false,
      'process.prerender': false,
      'import.meta.server': false,
      'import.meta.client': true,
      'import.meta.browser': true,
      'import.meta.nitro': false,
      'import.meta.prerender': false,
      'module.hot': false,
      ...nuxt.options.experimental.clientNodeCompat ? { global: 'globalThis' } : {},
    },
    build: {
      sourcemap: nuxt.options.sourcemap.client ? nuxt.options.vite.build?.sourcemap ?? nuxt.options.sourcemap.client : false,
      manifest: 'manifest.json',
      outDir: resolve(nuxt.options.buildDir, 'dist/client'),
      rollupOptions: {
        input: { entry },
      },
    },
  }
}
</file>

<file path="packages/vite/src/shared/server.ts">
import * as vite from 'vite'
import type { Nuxt } from 'nuxt/schema'
import { resolve } from 'pathe'
import type { EnvironmentOptions } from 'vite'
import { useNitro } from '@nuxt/kit'
import escapeStringRegexp from 'escape-string-regexp'
import { withTrailingSlash } from 'ufo'

import { getTranspilePatterns, getTranspileStrings } from '../utils/transpile.ts'

export function ssr (nuxt: Nuxt) {
  return {
    external: [
      'nitro/runtime',
      // TODO: remove in v5
      '#internal/nitro',
      '#internal/nitro/utils',
    ],
    noExternal: [
      ...getTranspilePatterns({ isServer: true, isDev: nuxt.options.dev }),
      '/__vue-jsx',
      '#app',
      /^nuxt(\/|$)/,
      /(nuxt|nuxt3|nuxt-nightly)\/(dist|src|app)/,
    ],
  }
}

export function ssrEnvironment (nuxt: Nuxt, serverEntry: string) {
  return {
    build: {
      // we'll display this in nitro build output
      reportCompressedSize: false,
      sourcemap: nuxt.options.sourcemap.server ? nuxt.options.vite.build?.sourcemap ?? nuxt.options.sourcemap.server : false,
      outDir: resolve(nuxt.options.buildDir, 'dist/server'),
      ssr: true,
      rollupOptions: {
        input: { server: serverEntry },
        external: [
          'nitro/runtime',
          // TODO: remove in v5
          '#internal/nitro',
          'nitropack/runtime',
          '#internal/nuxt/paths',
          '#internal/nuxt/app-config',
          '#app-manifest',
          '#shared',
          new RegExp('^' + escapeStringRegexp(withTrailingSlash(resolve(nuxt.options.rootDir, nuxt.options.dir.shared)))),
        ],
        output: {
          entryFileNames: '[name].mjs',
          format: 'module',
          ...((vite as any).rolldownVersion
            // Wait for https://github.com/rolldown/rolldown/issues/206
            ? {}
            : {
                generatedCode: {
                  symbols: true, // temporary fix for https://github.com/vuejs/core/issues/8351,
                  constBindings: true,
                  // temporary fix for https://github.com/rollup/rollup/issues/5975
                  arrowFunctions: true,
                },
              }),
        },
        onwarn (warning, rollupWarn) {
          if (warning.code && 'UNUSED_EXTERNAL_IMPORT' === warning.code) {
            return
          }
          rollupWarn(warning)
        },
      },
    },
    define: {
      'process.server': true,
      'process.client': false,
      'process.browser': false,
      'import.meta.server': true,
      'import.meta.client': false,
      'import.meta.browser': false,
      'window': 'undefined',
      'document': 'undefined',
      'navigator': 'undefined',
      'location': 'undefined',
      'XMLHttpRequest': 'undefined',
    },
    optimizeDeps: {
      noDiscovery: true,
      include: undefined,
      exclude: getTranspileStrings({ isDev: nuxt.options.dev, isClient: false }),
    },
    resolve: {
      conditions: useNitro().options.exportConditions,
    },
  } satisfies EnvironmentOptions
}
</file>

<file path="packages/vite/src/utils/config.ts">
import type { ResolvedConfig } from 'vite'

export function resolveClientEntry (config: ResolvedConfig) {
  const input = config.environments.client?.build.rollupOptions.input ?? config.build.rollupOptions.input
  if (input) {
    if (typeof input === 'string') {
      return input
    }
    if (!Array.isArray(input) && input.entry) {
      return input.entry
    }
  }

  throw new Error('No entry found in rollupOptions.input')
}

export function resolveServerEntry (config: ResolvedConfig) {
  const input = config.environments.ssr?.build.rollupOptions.input ?? config.build.rollupOptions.input
  if (input) {
    if (typeof input === 'string') {
      return input
    }
    if (!Array.isArray(input) && input.server) {
      return input.server
    }
  }

  throw new Error('No entry found in rollupOptions.input')
}
</file>

<file path="packages/vite/src/utils/index.ts">
export { isVue } from '../../../nuxt/src/core/utils/plugins.ts'

// Copied from vue-bundle-renderer utils
export const IS_CSS_RE = /\.(?:css|scss|sass|postcss|pcss|less|stylus|styl)(?:\?[^.]+)?$/

export function isCSS (file: string) {
  return IS_CSS_RE.test(file)
}

/** @since 3.9.0 */
export function toArray<T> (value: T | T[]): T[] {
  return Array.isArray(value) ? value : [value]
}
</file>

<file path="packages/vite/src/utils/logger.ts">
import process from 'node:process'
import type * as vite from 'vite'
import { createLogger } from 'vite'
import { logger } from '@nuxt/kit'
import { colorize } from 'consola/utils'
import { hasTTY, isCI } from 'std-env'
import type { NuxtOptions } from '@nuxt/schema'
import { relative } from 'pathe'
import { useResolveFromPublicAssets } from '../plugins/public-dirs.ts'

let duplicateCount = 0
let lastType: vite.LogType | null = null
let lastMsg: string | null = null

export const logLevelMap: Record<NuxtOptions['logLevel'], vite.UserConfig['logLevel']> = {
  silent: 'silent',
  info: 'info',
  verbose: 'info',
}

const logLevelMapReverse: Record<NonNullable<vite.UserConfig['logLevel']>, number> = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3,
}

const RUNTIME_RESOLVE_REF_RE = /^([^ ]+) referenced in/m
export function createViteLogger (config: vite.InlineConfig, ctx: { hideOutput?: boolean } = {}): vite.Logger {
  const loggedErrors = new WeakSet<any>()
  const canClearScreen = hasTTY && !isCI && config.clearScreen
  const _logger = createLogger()
  const relativeOutDir = relative(config.root!, config.build!.outDir || '')
  const clear = () => {
    _logger.clearScreen(
      // @ts-expect-error silent is a log level but not a valid option for clearScreens
      'silent',
    )
  }
  const clearScreen = canClearScreen ? clear : () => {}

  const { resolveFromPublicAssets } = useResolveFromPublicAssets()

  function output (type: vite.LogType, msg: string, options: vite.LogErrorOptions = {}) {
    if (typeof msg === 'string' && !process.env.DEBUG) {
      // TODO: resolve upstream in Vite
      // Hide sourcemap warnings related to node_modules
      if (msg.startsWith('Sourcemap') && msg.includes('node_modules')) { return }
      // Hide warnings about externals produced by https://github.com/vitejs/vite/blob/v5.2.11/packages/vite/src/node/plugins/css.ts#L350-L355
      if (msg.includes('didn\'t resolve at build time, it will remain unchanged to be resolved at runtime')) {
        const id = msg.trim().match(RUNTIME_RESOLVE_REF_RE)?.[1]
        if (id && resolveFromPublicAssets(id)) { return }
      }
      if (type === 'info' && ctx.hideOutput && msg.includes(relativeOutDir)) { return }
    }

    const sameAsLast = lastType === type && lastMsg === msg
    if (sameAsLast) {
      duplicateCount += 1
      clearScreen()
    } else {
      duplicateCount = 0
      lastType = type
      lastMsg = msg

      if (options.clear) {
        clearScreen()
      }
    }

    if (options.error) {
      loggedErrors.add(options.error)
    }

    const prevLevel = logger.level
    logger.level = logLevelMapReverse[config.logLevel || 'info']
    logger[type](msg + (sameAsLast ? colorize('dim', ` (x${duplicateCount + 1})`) : ''))
    logger.level = prevLevel
  }

  const warnedMessages = new Set<string>()

  const viteLogger: vite.Logger = {
    hasWarned: false,
    info (msg, opts) {
      output('info', msg, opts)
    },
    warn (msg, opts) {
      viteLogger.hasWarned = true
      output('warn', msg, opts)
    },
    warnOnce (msg, opts) {
      if (warnedMessages.has(msg)) { return }
      viteLogger.hasWarned = true
      output('warn', msg, opts)
      warnedMessages.add(msg)
    },
    error (msg, opts) {
      viteLogger.hasWarned = true
      output('error', msg, opts)
    },
    clearScreen () {
      clear()
    },
    hasErrorLogged (error) {
      return loggedErrors.has(error)
    },
  }

  return viteLogger
}
</file>

<file path="packages/vite/src/utils/transpile.test.ts">
import { fileURLToPath } from 'node:url'
import { mkdir, rm, writeFile } from 'node:fs/promises'
import { join } from 'pathe'
import { afterAll, beforeAll, describe, expect, it } from 'vitest'
import { buildNuxt, loadNuxt } from '@nuxt/kit'

const fixtureDir = fileURLToPath(new URL('../../../../test/fixtures-temp/transpile-test', import.meta.url))

// https://github.com/nuxt/nuxt/issues/33828
describe('async transpile to optimizeDeps.exclude', () => {
  let capturedExclude: string[] = []

  beforeAll(async () => {
    await rm(fixtureDir, { recursive: true, force: true })
    await mkdir(join(fixtureDir, 'app'), { recursive: true })
    await writeFile(join(fixtureDir, 'app/app.vue'), '<template><div/></template>')
    await writeFile(join(fixtureDir, 'nuxt.config.ts'), `
export default defineNuxtConfig({
  modules: [
    (_, nuxt) => {
      nuxt.options.build.transpile.push('my-async-package')
    },
  ],
})
`)
  }, 30000)

  afterAll(async () => {
    await rm(fixtureDir, { recursive: true, force: true })
  })

  it('includes async transpile entry in optimizeDeps.exclude', async () => {
    const nuxt = await loadNuxt({
      cwd: fixtureDir,
      dev: true,
    })

    nuxt.hook('vite:configResolved', (config, { isClient }) => {
      if (isClient) {
        capturedExclude = config.optimizeDeps?.exclude || []
      }
    })

    await buildNuxt(nuxt)
    await nuxt.close()

    expect(capturedExclude).toContain('my-async-package')
  }, 60000)
})
</file>

<file path="packages/vite/src/utils/transpile.ts">
import { useNuxt } from '@nuxt/kit'
import escapeRegExp from 'escape-string-regexp'
import { normalize } from 'pathe'

interface Envs {
  isDev: boolean
  isClient?: boolean
  isServer?: boolean
}

export function getTranspilePatterns (envs: Envs): Array<string | RegExp> {
  const nuxt = useNuxt()
  const transpile: RegExp[] = []

  for (let pattern of nuxt.options.build.transpile) {
    if (typeof pattern === 'function') {
      const result = pattern(envs)
      if (result) { pattern = result }
    }
    if (typeof pattern === 'string') {
      transpile.push(new RegExp(escapeRegExp(normalize(pattern))))
    } else if (pattern instanceof RegExp) {
      transpile.push(pattern)
    }
  }

  return transpile
}

/**
 * Get transpile patterns as strings for use with Vite's optimizeDeps.exclude
 * This resolves functions and filters to only string patterns
 */
export function getTranspileStrings (envs: Envs): string[] {
  const nuxt = useNuxt()
  const patterns: string[] = []

  for (let pattern of nuxt.options.build.transpile) {
    if (typeof pattern === 'function') {
      const result = pattern(envs)
      if (result) { pattern = result }
    }
    if (typeof pattern === 'string') {
      patterns.push(normalize(pattern))
    }
  }

  return patterns
}
</file>

<file path="packages/vite/src/utils/warmup.ts">
import { isBuiltin } from 'node:module'
import { logger } from '@nuxt/kit'
import { join, normalize, relative } from 'pathe'
import { withoutBase } from 'ufo'
import { isCSSRequest } from 'vite'
import type { ViteDevServer } from 'vite'

// https://github.com/vitejs/vite/blob/main/packages/vite/src/node/server/warmup.ts#L62-L70
function fileToUrl (file: string, root: string) {
  const url = relative(root, file)
  // out of root, use /@fs/ prefix
  if (url[0] === '.') {
    return join('/@fs/', normalize(file))
  }
  // file within root, create root-relative url
  return '/' + normalize(url)
}

function normaliseURL (url: string, base: string) {
  // remove any base url
  url = withoutBase(url, base)
  // unwrap record
  if (url.startsWith('/@id/')) {
    url = url.slice('/@id/'.length).replace('__x00__', '\0')
  }
  // strip query
  url = url.replace(/[?&]import=?(?:&|$)/, '').replace(/[?&]$/, '')
  return url
}

// TODO: use built-in warmup logic when we update to vite 5
export async function warmupViteServer (
  server: ViteDevServer,
  entries: string[],
  isServer: boolean,
) {
  const warmedUrls = new Set<string>()

  const warmup = async (url: string) => {
    try {
      url = normaliseURL(url, server.config.base)

      if (warmedUrls.has(url) || isBuiltin(url)) { return }
      const m = await server.moduleGraph.getModuleByUrl(url, isServer)
      // a module that is already compiled (and can't be warmed up anyway)
      if (m?.transformResult?.code || m?.ssrTransformResult?.code) {
        return
      }
      warmedUrls.add(url)
      await server.transformRequest(url, { ssr: isServer })
    } catch (e) {
      logger.debug('[nuxt] warmup for %s failed with: %s', url, e)
    }

    // Don't warmup CSS file dependencies as they have already all been loaded to produce result
    if (isCSSRequest(url)) { return }

    try {
      const mod = await server.moduleGraph.getModuleByUrl(url, isServer)
      const deps = mod?.ssrTransformResult?.deps /* server */ || (mod?.importedModules.size ? Array.from(mod?.importedModules /* client */).map(m => m.url) : [])
      await Promise.all(deps.map(m => warmup(m)))
    } catch (e) {
      logger.debug('[warmup] tracking dependencies for %s failed with: %s', url, e)
    }
  }

  await Promise.all(entries.map(entry => warmup(fileToUrl(entry, server.config.root))))
}
</file>

<file path="packages/vite/src/client.ts">
import { resolve } from 'pathe'
import * as vite from 'vite'
import vuePlugin from '@vitejs/plugin-vue'
import viteJsxPlugin from '@vitejs/plugin-vue-jsx'
import { logger } from '@nuxt/kit'
import { joinURL } from 'ufo'
import type { Nuxt, ViteConfig } from '@nuxt/schema'

import type { ViteBuildContext } from './vite.ts'
import { DevStyleSSRPlugin } from './plugins/dev-style-ssr.ts'
import { RuntimePathsPlugin } from './plugins/runtime-paths.ts'
import { TypeCheckPlugin } from './plugins/type-check.ts'
import { ModulePreloadPolyfillPlugin } from './plugins/module-preload-polyfill.ts'
import { ViteNodePlugin } from './plugins/vite-node.ts'
import { createViteLogger } from './utils/logger.ts'
import { StableEntryPlugin } from './plugins/stable-entry.ts'
import { AnalyzePlugin } from './plugins/analyze.ts'
import { DevServerPlugin } from './plugins/dev-server.ts'
import { VitePluginCheckerPlugin } from './plugins/vite-plugin-checker.ts'
import { clientEnvironment } from './shared/client.ts'

export async function buildClient (nuxt: Nuxt, ctx: ViteBuildContext) {
  const clientConfig: ViteConfig = vite.mergeConfig(ctx.config, vite.mergeConfig({
    configFile: false,
    base: nuxt.options.dev
      ? joinURL(nuxt.options.app.baseURL.replace(/^\.\//, '/') || '/', nuxt.options.app.buildAssetsDir)
      : './',
    css: {
      devSourcemap: !!nuxt.options.sourcemap.client,
    },
    cacheDir: resolve(nuxt.options.rootDir, ctx.config.cacheDir ?? 'node_modules/.cache/vite', 'client'),
    plugins: [
      DevStyleSSRPlugin({
        srcDir: nuxt.options.srcDir,
        buildAssetsURL: joinURL(nuxt.options.app.baseURL, nuxt.options.app.buildAssetsDir),
      }),
      RuntimePathsPlugin(),
      ViteNodePlugin(nuxt),
      // Type checking client panel
      TypeCheckPlugin(nuxt),
      ModulePreloadPolyfillPlugin(),
      // ensure changes in chunks do not invalidate whole build
      StableEntryPlugin(nuxt),
      AnalyzePlugin(nuxt),
      DevServerPlugin(nuxt),
      VitePluginCheckerPlugin(nuxt, 'client'),
    ],
    appType: 'custom',
    server: {
      warmup: {
        clientFiles: [ctx.entry],
      },
      middlewareMode: true,
    },
    ...clientEnvironment(nuxt, ctx.entry),
  } satisfies vite.InlineConfig, nuxt.options.vite.$client || {}))

  clientConfig.customLogger = createViteLogger(clientConfig)

  await nuxt.callHook('vite:extendConfig', clientConfig, { isClient: true, isServer: false })

  clientConfig.plugins!.unshift(
    vuePlugin(clientConfig.vue),
    viteJsxPlugin(clientConfig.vueJsx),
  )

  await nuxt.callHook('vite:configResolved', clientConfig, { isClient: true, isServer: false })

  if (nuxt.options.dev) {
    // Dev
    const viteServer = await vite.createServer(clientConfig)
    ctx.clientServer = viteServer
    nuxt.hook('close', () => viteServer.close())
    await nuxt.callHook('vite:serverCreated', viteServer, { isClient: true, isServer: false })
  } else {
    // Build
    logger.info('Building client...')
    const start = Date.now()
    logger.restoreAll()
    await vite.build(clientConfig)
    logger.wrapAll()
    await nuxt.callHook('vite:compiled')
    logger.success(`Client built in ${Date.now() - start}ms`)
  }
}
</file>

<file path="packages/vite/src/css.ts">
import type { Nuxt, NuxtOptions } from '@nuxt/schema'
import type { InlineConfig as ViteConfig } from 'vite'
import type { Plugin } from 'postcss'
import { createJiti } from 'jiti'

function sortPlugins ({ plugins, order }: NuxtOptions['postcss']): string[] {
  const names = Object.keys(plugins)
  return typeof order === 'function' ? order(names) : (order || names)
}

export async function resolveCSSOptions (nuxt: Nuxt): Promise<ViteConfig['css']> {
  const css: ViteConfig['css'] & { postcss: NonNullable<Exclude<NonNullable<ViteConfig['css']>['postcss'], string>> & { plugins: Plugin[] } } = {
    postcss: {
      plugins: [],
    },
  }

  const postcssOptions = nuxt.options.postcss

  const jiti = createJiti(nuxt.options.rootDir, { alias: nuxt.options.alias })

  for (const pluginName of sortPlugins(postcssOptions)) {
    const pluginOptions = postcssOptions.plugins[pluginName]
    if (!pluginOptions) { continue }

    let pluginFn: ((opts: Record<string, any>) => Plugin) | undefined
    for (const parentURL of nuxt.options.modulesDir) {
      pluginFn = await jiti.import(pluginName, { parentURL: parentURL.replace(/\/node_modules\/?$/, ''), try: true, default: true }) as (opts: Record<string, any>) => Plugin
      if (typeof pluginFn === 'function') {
        css.postcss.plugins.push(pluginFn(pluginOptions))
        break
      }
    }

    if (typeof pluginFn !== 'function') {
      console.warn(`[nuxt] could not import postcss plugin \`${pluginName}\`. Please report this as a bug.`)
    }
  }

  return css
}
</file>

<file path="packages/vite/src/dirs.ts">
import { fileURLToPath } from 'node:url'
import { dirname } from 'pathe'

let _distDir = dirname(fileURLToPath(import.meta.url))
if (/(?:chunks|shared)$/.test(_distDir)) { _distDir = dirname(_distDir) }
export const distDir = _distDir
</file>

<file path="packages/vite/src/index.ts">
import type { ViteConfig } from 'nuxt/schema'
import type { EnvironmentOptions } from 'vite'

export { bundle } from './vite.ts'

declare module 'nuxt/schema' {
  interface ViteOptions extends ViteConfig {
    $client?: EnvironmentOptions
    $server?: EnvironmentOptions
    viteNode?: {
      maxRetryAttempts?: number
      /** in milliseconds */
      baseRetryDelay?: number
      /** in milliseconds */
      maxRetryDelay?: number
      /** in milliseconds */
      requestTimeout?: number
    }
  }
}
</file>

<file path="packages/vite/src/manifest.ts">
import { readFileSync } from 'node:fs'
import { mkdir, rm, writeFile } from 'node:fs/promises'

import { relative, resolve } from 'pathe'
import { withTrailingSlash, withoutLeadingSlash } from 'ufo'
import escapeRE from 'escape-string-regexp'
import { normalizeViteManifest, precomputeDependencies } from 'vue-bundle-renderer'
import type { Manifest as RendererManifest } from 'vue-bundle-renderer'
import type { Manifest as ViteClientManifest } from 'vite'
import { serialize } from 'seroval'
import type { ViteBuildContext } from './vite.ts'

export async function writeManifest (ctx: ViteBuildContext) {
  const { nuxt } = ctx
  // This is only used for ssr: false - when ssr is enabled we use vite-node runtime manifest
  const devClientManifest: RendererManifest = {
    '@vite/client': {
      isEntry: true,
      file: '@vite/client',
      css: [],
      module: true,
      resourceType: 'script',
    },
    ...nuxt.options.features.noScripts === 'all'
      ? {}
      : {
          [ctx.entry]: {
            isEntry: true,
            file: ctx.entry,
            module: true,
            resourceType: 'script',
          },
        },
  }

  // Write client manifest for use in vue-bundle-renderer
  const clientDist = resolve(nuxt.options.buildDir, 'dist/client')
  const serverDist = resolve(nuxt.options.buildDir, 'dist/server')

  const manifestFile = resolve(clientDist, 'manifest.json')
  const clientManifest = nuxt.options.dev ? devClientManifest : JSON.parse(readFileSync(manifestFile, 'utf-8')) as ViteClientManifest
  const manifestEntries = Object.values(clientManifest)

  const buildAssetsDir = withTrailingSlash(withoutLeadingSlash(nuxt.options.app.buildAssetsDir))
  const BASE_RE = new RegExp(`^${escapeRE(buildAssetsDir)}`)

  for (const entry of manifestEntries) {
    entry.file &&= entry.file.replace(BASE_RE, '')
    for (const item of ['css', 'assets'] as const) {
      entry[item] &&= entry[item].map((i: string) => i.replace(BASE_RE, ''))
    }
  }

  await mkdir(serverDist, { recursive: true })

  if (ctx.config.build?.cssCodeSplit === false) {
    for (const entry of manifestEntries) {
      if (entry.file?.endsWith('.css')) {
        const key = relative(ctx.config.root!, ctx.entry)
        clientManifest[key]!.css ||= []
        ;(clientManifest[key]!.css as string[]).push(entry.file)
        break
      }
    }
  }

  const manifest = normalizeViteManifest(clientManifest)
  await nuxt.callHook('build:manifest', manifest)
  const precomputed = precomputeDependencies(manifest)
  await writeFile(resolve(serverDist, 'client.manifest.mjs'), 'export default ' + serialize(manifest), 'utf8')
  await writeFile(resolve(serverDist, 'client.precomputed.mjs'), 'export default ' + serialize(precomputed), 'utf8')

  if (!nuxt.options.dev) {
    await rm(manifestFile, { force: true })
  }
}
</file>

<file path="packages/vite/src/server.ts">
import { resolve } from 'pathe'
import * as vite from 'vite'
import vuePlugin from '@vitejs/plugin-vue'
import viteJsxPlugin from '@vitejs/plugin-vue-jsx'
import { logger, resolvePath } from '@nuxt/kit'
import { joinURL } from 'ufo'
import type { Nuxt, ViteConfig } from '@nuxt/schema'
import type { Nitro } from 'nitropack/types'
import type { ViteBuildContext } from './vite.ts'
import { createViteLogger } from './utils/logger.ts'
import { writeDevServer } from './plugins/vite-node.ts'
import { writeManifest } from './manifest.ts'
import { SourcemapPreserverPlugin } from './plugins/sourcemap-preserver.ts'
import { VueFeatureFlagsPlugin } from './plugins/vue-feature-flags.ts'
import { VitePluginCheckerPlugin } from './plugins/vite-plugin-checker.ts'
import { ssr, ssrEnvironment } from './shared/server.ts'

export async function buildServer (nuxt: Nuxt, ctx: ViteBuildContext) {
  const serverEntry = nuxt.options.ssr ? ctx.entry : await resolvePath(resolve(nuxt.options.appDir, 'entry-spa'))
  const serverConfig: ViteConfig = vite.mergeConfig(ctx.config, vite.mergeConfig({
    configFile: false,
    base: nuxt.options.dev
      ? joinURL(nuxt.options.app.baseURL.replace(/^\.\//, '/') || '/', nuxt.options.app.buildAssetsDir)
      : undefined,
    css: {
      devSourcemap: !!nuxt.options.sourcemap.server,
    },
    plugins: [
      VueFeatureFlagsPlugin(nuxt),
      // tell rollup's nitro build about the original sources of the generated vite server build
      SourcemapPreserverPlugin(nuxt),
      VitePluginCheckerPlugin(nuxt, 'ssr'),
    ],
    environments: {
      ssr: {
        resolve: {
          conditions: ((nuxt as any)._nitro as Nitro)?.options.exportConditions,
        },
      },
    },
    ssr: ssr(nuxt),
    cacheDir: resolve(nuxt.options.rootDir, ctx.config.cacheDir ?? 'node_modules/.cache/vite', 'server'),
    server: {
      warmup: {
        ssrFiles: [serverEntry],
      },
      // https://github.com/vitest-dev/vitest/issues/229#issuecomment-1002685027
      preTransformRequests: false,
      hmr: false,
    },
    ...ssrEnvironment(nuxt, serverEntry),
  } satisfies vite.InlineConfig, nuxt.options.vite.$server || {}))

  serverConfig.customLogger = createViteLogger(serverConfig, { hideOutput: !nuxt.options.dev })

  await nuxt.callHook('vite:extendConfig', serverConfig, { isClient: false, isServer: true })

  serverConfig.plugins!.unshift(
    vuePlugin(serverConfig.vue),
    viteJsxPlugin(serverConfig.vueJsx),
  )

  await nuxt.callHook('vite:configResolved', serverConfig, { isClient: false, isServer: true })

  // Production build
  if (!nuxt.options.dev) {
    const start = Date.now()
    logger.info('Building server...')
    logger.restoreAll()
    await vite.build(serverConfig)
    logger.wrapAll()
    // Write production client manifest
    await writeManifest(ctx)
    await nuxt.callHook('vite:compiled')
    logger.success(`Server built in ${Date.now() - start}ms`)
    return
  }

  if (!nuxt.options.ssr) {
    await writeManifest(ctx)
    await nuxt.callHook('vite:compiled')
    return
  }

  // Start development server
  const ssrServer = await vite.createServer(serverConfig)
  ctx.ssrServer = ssrServer

  // Close server on exit
  nuxt.hook('close', () => ssrServer.close())

  await nuxt.callHook('vite:serverCreated', ssrServer, { isClient: false, isServer: true })

  // Invalidate virtual modules when templates are re-generated
  nuxt.hook('app:templatesGenerated', async (_app, changedTemplates) => {
    await Promise.all(changedTemplates.map(async (template) => {
      for (const mod of ssrServer.moduleGraph.getModulesByFile(`virtual:nuxt:${encodeURIComponent(template.dst)}`) || []) {
        ssrServer.moduleGraph.invalidateModule(mod)
        await ssrServer.reloadModule(mod)
      }
    }))
  })

  // Initialize plugins
  await ssrServer.pluginContainer.buildStart({})

  await writeDevServer(nuxt)
}
</file>

<file path="packages/vite/src/vite-node-entry.ts">
import process from 'node:process'
import { performance } from 'node:perf_hooks'
import { createError } from 'h3'
import { ViteNodeRunner } from 'vite-node/client'
import { consola } from 'consola'
import { viteNodeFetch, viteNodeOptions } from '#vite-node'
import type { NuxtSSRContext } from 'nuxt/app'

const runner = createRunner()

let render: (ssrContext: NuxtSSRContext) => Promise<any>

export default async (ssrContext: NuxtSSRContext) => {
  // Workaround for stub mode
  // https://github.com/nuxt/framework/pull/3983
  // eslint-disable-next-line nuxt/prefer-import-meta,@typescript-eslint/no-deprecated
  process.server = true
  import.meta.server = true

  // Invalidate cache for files changed since last rendering
  const invalidates = await viteNodeFetch.getInvalidates()
  const updates = runner.moduleCache.invalidateDepTree(invalidates)

  // Execute SSR bundle on demand
  const start = performance.now()
  render = (updates.has(viteNodeOptions.entryPath) || !render) ? (await runner.executeFile(viteNodeOptions.entryPath)).default : render
  if (updates.size) {
    const time = Math.round((performance.now() - start) * 1000) / 1000
    consola.success(`Vite server hmr ${updates.size} files`, time ? `in ${time}ms` : '')
  }

  const result = await render(ssrContext)
  return result
}

function createRunner () {
  return new ViteNodeRunner({
    root: viteNodeOptions.root, // Equals to Nuxt `srcDir`
    base: viteNodeOptions.base,
    async resolveId (id, importer) {
      return await viteNodeFetch.resolveId(id, importer)
    },
    async fetchModule (id) {
      id = id.replace(/\/\//g, '/') // TODO: fix in vite-node
      return await viteNodeFetch.fetchModule(id).catch((err) => {
        const errorData = err?.data?.data
        if (!errorData) {
          throw err
        }
        let _err
        try {
          const { message, stack } = formatViteError(errorData, id)
          _err = createError({
            statusText: 'Vite Error',
            message,
            stack,
          })
        } catch (formatError) {
          consola.warn('Internal nuxt error while formatting vite-node error. Please report this!', formatError)
          const message = `[vite-node] [TransformError] ${errorData?.message || '-'}`
          consola.error(message, errorData)
          throw createError({
            statusText: 'Vite Error',
            message,
            stack: `${message}\nat ${id}\n` + (errorData?.stack || ''),
          })
        }
        throw _err
      })
    },
  })
}

function formatViteError (errorData: any, id: string) {
  const errorCode = errorData.name || errorData.reasonCode || errorData.code
  const frame = errorData.frame || errorData.source || errorData.pluginCode

  const getLocId = (locObj: { file?: string, id?: string, url?: string } = {}) => locObj.file || locObj.id || locObj.url || id || ''
  const getLocPos = (locObj: { line?: string, column?: string } = {}) => locObj.line ? `${locObj.line}:${locObj.column || 0}` : ''
  const locId = getLocId(errorData.loc) || getLocId(errorData.location) || getLocId(errorData.input) || getLocId(errorData)
  const locPos = getLocPos(errorData.loc) || getLocPos(errorData.location) || getLocPos(errorData.input) || getLocPos(errorData)
  const loc = locId.replace(process.cwd(), '.') + (locPos ? `:${locPos}` : '')

  const message = [
    '[vite-node]',
    errorData.plugin && `[plugin:${errorData.plugin}]`,
    errorCode && `[${errorCode}]`,
    loc,
    errorData.reason && `: ${errorData.reason}`,
    frame && `<br><pre>${frame.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre><br>`,
  ].filter(Boolean).join(' ')

  const stack = [
    message,
    `at ${loc}`,
    errorData.stack,
  ].filter(Boolean).join('\n')

  return {
    message,
    stack,
  }
}
</file>

<file path="packages/vite/src/vite-node.ts">
import process from 'node:process'
import type { Socket } from 'node:net'
import net from 'node:net'
import { Buffer } from 'node:buffer'
import { isTest } from 'std-env'
import type { ViteNodeFetch, ViteNodeRequestMap, ViteNodeServerOptions } from './plugins/vite-node.ts'

function getViteNodeOptionsEnvVar () {
  const envVar = process.env.NUXT_VITE_NODE_OPTIONS
  try {
    return JSON.parse(envVar || '{}')
  } catch (e) {
    console.error('vite-node-shared: Failed to parse NUXT_VITE_NODE_OPTIONS environment variable.', e)
    return {}
  }
}

export const viteNodeOptions: ViteNodeServerOptions = getViteNodeOptionsEnvVar()

const pendingRequests = new Map<number, { resolve: (value: any) => void, reject: (reason?: any) => void }>()
let requestIdCounter = 0
let clientSocket: Socket | undefined
let currentConnectPromise: Promise<Socket> | undefined
const MAX_RETRY_ATTEMPTS = viteNodeOptions.maxRetryAttempts ?? 5
const BASE_RETRY_DELAY_MS = viteNodeOptions.baseRetryDelay ?? 100
const MAX_RETRY_DELAY_MS = viteNodeOptions.maxRetryDelay ?? 2000
const REQUEST_TIMEOUT_MS = viteNodeOptions.requestTimeout ?? 60000

/**
 * Calculates exponential backoff delay with jitter.
 * @param attempt - The current attempt number (0-based).
 * @returns Delay in milliseconds.
 */
function calculateRetryDelay (attempt: number): number {
  const exponentialDelay = BASE_RETRY_DELAY_MS * Math.pow(2, attempt)
  const jitter = Math.random() * 0.1 * exponentialDelay // Add 10% jitter
  return Math.min(exponentialDelay + jitter, MAX_RETRY_DELAY_MS)
}

/**
 * Establishes or returns an existing IPC socket connection with retry logic.
 * @returns A promise that resolves with the connected socket.
 */
function connectSocket (): Promise<Socket> {
  if (clientSocket && !clientSocket.destroyed) {
    return Promise.resolve(clientSocket)
  }

  if (currentConnectPromise) {
    return currentConnectPromise
  }

  const thisPromise = new Promise<Socket>((resolve, reject) => {
    if (!viteNodeOptions.socketPath) {
      console.error('vite-node-shared: NUXT_VITE_NODE_OPTIONS.socketPath is not defined.')
      return reject(new Error('Vite Node IPC socket path not configured.'))
    }

    const attemptConnection = (attempt = 0) => {
      const socket = net.createConnection(viteNodeOptions.socketPath)

      const INITIAL_BUFFER_SIZE = 64 * 1024 // 64KB
      const MAX_BUFFER_SIZE = 1024 * 1024 * 1024 // 1GB

      let buffer = Buffer.alloc(INITIAL_BUFFER_SIZE)
      let writeOffset = 0
      let readOffset = 0

      // optimize socket for high-frequency IPC
      socket.setNoDelay(true)
      socket.setKeepAlive(true, 30000) // 30s

      const cleanup = () => {
        socket.off('connect', onConnect)
        socket.off('data', onData)
        socket.off('error', onError)
        socket.off('close', onClose)
      }

      const resetBuffer = () => {
        writeOffset = 0
        readOffset = 0
      }

      const compactBuffer = () => {
        if (readOffset > 0) {
          const remainingData = writeOffset - readOffset
          if (remainingData > 0) {
            buffer.copy(buffer, 0, readOffset, writeOffset)
          }
          writeOffset = remainingData
          readOffset = 0
        }
      }

      const ensureBufferCapacity = (additionalBytes: number) => {
        const requiredSize = writeOffset + additionalBytes

        if (requiredSize > MAX_BUFFER_SIZE) {
          throw new Error(`Buffer size limit exceeded: ${requiredSize} > ${MAX_BUFFER_SIZE}`)
        }

        if (requiredSize > buffer.length) {
          // Try compacting first
          compactBuffer()

          // ... then if we still need more space, grow the buffer
          if (writeOffset + additionalBytes > buffer.length) {
            const newSize = Math.min(
              Math.max(buffer.length * 2, requiredSize),
              MAX_BUFFER_SIZE,
            )
            const newBuffer = Buffer.alloc(newSize)
            buffer.copy(newBuffer, 0, 0, writeOffset)
            buffer = newBuffer
          }
        }
      }

      const onConnect = () => {
        clientSocket = socket
        resolve(socket)
      }

      const onData = (data: Buffer) => {
        try {
          ensureBufferCapacity(data.length)
          data.copy(buffer, writeOffset)
          writeOffset += data.length

          while (writeOffset - readOffset >= 4) {
            const messageLength = buffer.readUInt32BE(readOffset)

            if (writeOffset - readOffset < 4 + messageLength) {
              return // Wait for more data
            }

            const message = buffer.subarray(readOffset + 4, readOffset + 4 + messageLength).toString('utf-8')
            readOffset += 4 + messageLength

            try {
              const response = JSON.parse(message)
              const requestHandlers = pendingRequests.get(response.id)
              if (requestHandlers) {
                const { resolve: resolveRequest, reject: rejectRequest } = requestHandlers
                if (response.type === 'error') {
                  const err = new Error(response.error.message)
                  err.stack = response.error.stack
                  // @ts-expect-error We are augmenting the error object
                  err.data = response.error.data
                  // @ts-expect-error We are augmenting the error object
                  err.statusCode = err.status = response.error.status || response.error.statusCode
                  rejectRequest(err)
                } else {
                  resolveRequest(response.data)
                }
                pendingRequests.delete(response.id)
              }
            } catch (parseError) {
              console.warn('vite-node-shared: Failed to parse IPC response:', parseError)
              // ignore malformed messages
            }
          }

          // compact buffer periodically to prevent memory waste
          if (readOffset > buffer.length / 2) {
            compactBuffer()
          }
        } catch (error) {
          socket.destroy(error instanceof Error ? error : new Error('Buffer management error'))
        }
      }

      const onError = (err: Error) => {
        cleanup()
        resetBuffer()

        if (attempt < MAX_RETRY_ATTEMPTS) {
          const delay = calculateRetryDelay(attempt)
          setTimeout(() => attemptConnection(attempt + 1), delay)
        } else {
          if (currentConnectPromise === thisPromise) {
            reject(err)
          }
          for (const { reject: rejectRequest } of pendingRequests.values()) {
            rejectRequest(err)
          }
          pendingRequests.clear()
          if (clientSocket === socket) { clientSocket = undefined }
          if (currentConnectPromise === thisPromise) { currentConnectPromise = undefined }
        }
      }

      const onClose = () => {
        cleanup()
        resetBuffer()
        for (const { reject: rejectRequest } of pendingRequests.values()) {
          rejectRequest(new Error('IPC connection closed'))
        }
        pendingRequests.clear()
        if (clientSocket === socket) { clientSocket = undefined }
        if (currentConnectPromise === thisPromise) { currentConnectPromise = undefined }
      }

      socket.on('connect', onConnect)
      socket.on('data', onData)
      socket.on('error', onError)
      socket.on('close', onClose)
    }

    attemptConnection()
  })

  currentConnectPromise = thisPromise
  return currentConnectPromise
}

/**
 * Sends a request over the IPC socket with automatic reconnection.
 */
async function sendRequest<T extends keyof ViteNodeRequestMap> (type: T, payload: ViteNodeRequestMap[T]['request']): Promise<ViteNodeRequestMap[T]['response']> {
  const requestId = requestIdCounter++
  let lastError

  // retry the entire request (including reconnection) up to MAX_RETRY_ATTEMPTS times
  for (let requestAttempt = 0; requestAttempt <= MAX_RETRY_ATTEMPTS; requestAttempt++) {
    try {
      const socket = await connectSocket()

      return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          pendingRequests.delete(requestId)
          reject(new Error(`Request timeout after ${REQUEST_TIMEOUT_MS}ms for type: ${type}`))
        }, REQUEST_TIMEOUT_MS)

        pendingRequests.set(requestId, {
          resolve: (value) => {
            clearTimeout(timeoutId)
            resolve(value)
          },
          reject: (reason) => {
            clearTimeout(timeoutId)
            reject(reason)
          },
        })

        const message = JSON.stringify({ id: requestId, type, payload })
        const messageBuffer = Buffer.from(message, 'utf-8')
        const messageLength = messageBuffer.length

        // pre-allocate single buffer for length + message to avoid Buffer.concat()
        const fullMessage = Buffer.alloc(4 + messageLength)
        fullMessage.writeUInt32BE(messageLength, 0)
        messageBuffer.copy(fullMessage, 4)

        try {
          socket.write(fullMessage)
        } catch (error) {
          clearTimeout(timeoutId)
          pendingRequests.delete(requestId)
          reject(error)
        }
      })
    } catch (error) {
      lastError = error
      if (requestAttempt < MAX_RETRY_ATTEMPTS) {
        const delay = calculateRetryDelay(requestAttempt)
        await new Promise(resolve => setTimeout(resolve, delay))
        // clear current connection state to force reconnection
        if (clientSocket) {
          clientSocket.destroy()
          clientSocket = undefined
        }
        currentConnectPromise = undefined
      }
    }
  }

  throw lastError || new Error('Request failed after all retry attempts')
}

export const viteNodeFetch: ViteNodeFetch = {
  getManifest () {
    return sendRequest('manifest', undefined)
  },
  getInvalidates () {
    return sendRequest('invalidates', undefined)
  },
  resolveId (id, importer) {
    return sendRequest('resolve', { id, importer })
  },
  fetchModule (moduleId) {
    return sendRequest('module', { moduleId })
  },
  ensureConnected () {
    return connectSocket()
  },
}

// attempt to pre-establish the IPC connection to reduce latency on first request
let preConnectAttempted = false
function preConnect () {
  if (preConnectAttempted || !viteNodeOptions.socketPath) {
    return
  }
  preConnectAttempted = true

  return connectSocket().catch(() => {})
}

if (typeof process !== 'undefined' && !isTest) {
  setTimeout(preConnect, 100)
}
</file>

<file path="packages/vite/src/vite.ts">
import { existsSync } from 'node:fs'
import { performance } from 'node:perf_hooks'
import { createBuilder, createServer, mergeConfig } from 'vite'
import * as vite from 'vite'
import { basename, dirname, join, resolve } from 'pathe'
import type { Nuxt, NuxtBuilder, ViteConfig } from '@nuxt/schema'
import { createIsIgnored, getLayerDirectories, logger, resolvePath, useNitro } from '@nuxt/kit'
import { sanitizeFilePath } from 'mlly'
import viteJsxPlugin from '@vitejs/plugin-vue-jsx'
import vuePlugin from '@vitejs/plugin-vue'
import { joinURL, withTrailingSlash, withoutLeadingSlash } from 'ufo'
import { filename } from 'pathe/utils'
import { resolveModulePath } from 'exsolve'

import { buildClient } from './client.ts'
import { buildServer } from './server.ts'
import { ssr, ssrEnvironment } from './shared/server.ts'
import { clientEnvironment } from './shared/client.ts'
import { warmupViteServer } from './utils/warmup.ts'
import { resolveCSSOptions } from './css.ts'
import { createViteLogger, logLevelMap } from './utils/logger.ts'

import { SSRStylesPlugin } from './plugins/ssr-styles.ts'
import { PublicDirsPlugin } from './plugins/public-dirs.ts'
import { ReplacePlugin } from './plugins/replace.ts'
import { LayerDepOptimizePlugin } from './plugins/layer-dep-optimize.ts'
import { distDir } from './dirs.ts'
import { VueFeatureFlagsPlugin } from './plugins/vue-feature-flags.ts'
import { SourcemapPreserverPlugin } from './plugins/sourcemap-preserver.ts'
import { DevStyleSSRPlugin } from './plugins/dev-style-ssr.ts'
import { RuntimePathsPlugin } from './plugins/runtime-paths.ts'
import { TypeCheckPlugin } from './plugins/type-check.ts'
import { ModulePreloadPolyfillPlugin } from './plugins/module-preload-polyfill.ts'
import { StableEntryPlugin } from './plugins/stable-entry.ts'
import { VitePluginCheckerPlugin } from './plugins/vite-plugin-checker.ts'
import { AnalyzePlugin } from './plugins/analyze.ts'
import { DevServerPlugin } from './plugins/dev-server.ts'
import { EnvironmentsPlugin } from './plugins/environments.ts'
import { ViteNodePlugin, writeDevServer } from './plugins/vite-node.ts'
import { ClientManifestPlugin } from './plugins/client-manifest.ts'
import { ResolveDeepImportsPlugin } from './plugins/resolve-deep-imports.ts'
import { ResolveExternalsPlugin } from './plugins/resolved-externals.ts'

export const bundle: NuxtBuilder['bundle'] = async (nuxt) => {
  const useAsyncEntry = nuxt.options.experimental.asyncEntry || nuxt.options.dev
  const entry = await resolvePath(resolve(nuxt.options.appDir, useAsyncEntry ? 'entry.async' : 'entry'))

  nuxt.options.modulesDir.push(distDir)

  let allowDirs = [
    nuxt.options.appDir,
    nuxt.options.workspaceDir,
    ...nuxt.options.modulesDir,
    ...getLayerDirectories(nuxt).map(d => d.root),
    ...Object.values(nuxt.apps).flatMap(app => [
      ...app.components.map(c => dirname(c.filePath)),
      ...app.plugins.map(p => dirname(p.src)),
      ...app.middleware.map(m => dirname(m.path)),
      ...Object.values(app.layouts || {}).map(l => dirname(l.file)),
      dirname(nuxt.apps.default!.rootComponent!),
      dirname(nuxt.apps.default!.errorComponent!),
    ]),
  ].filter(d => d && existsSync(d))

  for (const dir of allowDirs) {
    allowDirs = allowDirs.filter(d => !d.startsWith(dir) || d === dir)
  }

  const { $client, $server, ...viteConfig } = nuxt.options.vite

  if ((vite as any).rolldownVersion) {
    // esbuild is not used in `rolldown-vite`
    if (viteConfig.esbuild) {
      delete viteConfig.esbuild
    }
    if (viteConfig.optimizeDeps?.esbuildOptions) {
      delete viteConfig.optimizeDeps.esbuildOptions
    }
  }

  const mockEmpty = resolveModulePath('mocked-exports/empty', { from: import.meta.url })

  const helper = nuxt.options.nitro.imports !== false ? '' : 'globalThis.'

  const isIgnored = createIsIgnored(nuxt)
  const serverEntry = nuxt.options.ssr ? entry : await resolvePath(resolve(nuxt.options.appDir, 'entry-spa'))
  const config: vite.InlineConfig = mergeConfig(
    {
      base: nuxt.options.dev
        ? joinURL(nuxt.options.app.baseURL.replace(/^\.\//, '/') || '/', nuxt.options.app.buildAssetsDir)
        : undefined,
      logLevel: logLevelMap[nuxt.options.logLevel] ?? logLevelMap.info,
      experimental: {
        renderBuiltUrl: (filename, { type, hostType, ssr }) => {
          if (hostType !== 'js') {
            // In CSS we only use relative paths until we craft a clever runtime CSS hack
            return { relative: true }
          }
          if (!ssr) {
            if (type === 'asset') {
              return { relative: true }
            }
            return { runtime: `globalThis.__publicAssetsURL(${JSON.stringify(filename)})` }
          }
          if (type === 'public') {
            return { runtime: `${helper}__publicAssetsURL(${JSON.stringify(filename)})` }
          }
          if (type === 'asset') {
            const relativeFilename = filename.replace(withTrailingSlash(withoutLeadingSlash(nuxt.options.app.buildAssetsDir)), '')
            return { runtime: `${helper}__buildAssetsURL(${JSON.stringify(relativeFilename)})` }
          }
        },
      },
      ...nuxt.options.experimental.viteEnvironmentApi
        ? {
            builder: {
              async buildApp (builder) {
                // run serially to preserve the order of client, server builds
                const environments = Object.values(builder.environments)
                for (const environment of environments) {
                  logger.restoreAll()
                  await builder.build(environment)
                  logger.wrapAll()
                  await nuxt.callHook('vite:compiled')
                }
              },
            },
            environments: {
              client: {
                consumer: 'client',
                keepProcessEnv: false,
                dev: {
                  warmup: [entry],
                },
                ...clientEnvironment(nuxt, entry),
              },
              ssr: {
                consumer: 'server',
                dev: {
                  warmup: [serverEntry],
                },
                ...ssrEnvironment(nuxt, serverEntry),
              },
            },
            ssr: ssr(nuxt),
          }
        : {},
      resolve: {
        alias: {
          [basename(nuxt.options.dir.assets)]: resolve(nuxt.options.srcDir, nuxt.options.dir.assets),
          ...nuxt.options.alias,
          '#app': nuxt.options.appDir,
          'web-streams-polyfill/ponyfill/es2018': mockEmpty,
          // Cannot destructure property 'AbortController' of ..
          'abort-controller': mockEmpty,
        },
        dedupe: [
          'vue',
        ],
      },
      // TODO: devSourcemap
      css: await resolveCSSOptions(nuxt),
      define: {
        __NUXT_VERSION__: JSON.stringify(nuxt._version),
        __NUXT_ASYNC_CONTEXT__: nuxt.options.experimental.asyncContext,
      },
      build: {
        copyPublicDir: false,
        rollupOptions: {
          output: {
            sourcemapIgnoreList: (relativeSourcePath) => {
              return relativeSourcePath.includes('node_modules') || relativeSourcePath.includes(nuxt.options.buildDir)
            },
            sanitizeFileName: sanitizeFilePath,
            // https://github.com/vitejs/vite/blob/main/packages/vite/src/node/build.ts#L464-L478
            assetFileNames: nuxt.options.dev
              ? undefined
              : chunk => withoutLeadingSlash(join(nuxt.options.app.buildAssetsDir, `${sanitizeFilePath(filename(chunk.names[0]!))}.[hash].[ext]`)),
          },
        },

        // @ts-expect-error non-public property
        watch: (vite.rolldownVersion
          // TODO: https://github.com/rolldown/rolldown/issues/5799 for ignored fn
          ? { exclude: [...nuxt.options.ignore, /[\\/]node_modules[\\/]/] }
          : {
              chokidar: { ...nuxt.options.watchers.chokidar, ignored: [isIgnored, /[\\/]node_modules[\\/]/] },
              exclude: nuxt.options.ignore,
            }
        ),
      },
      plugins: [
        // add resolver for modules used in virtual files
        ResolveDeepImportsPlugin(nuxt),
        ResolveExternalsPlugin(nuxt),
        ...nuxt.options.experimental.viteEnvironmentApi
          ? [
              vuePlugin(viteConfig.vue),
              viteJsxPlugin(viteConfig.vueJsx),
              ViteNodePlugin(nuxt),
              ClientManifestPlugin(nuxt),
              DevServerPlugin(nuxt),
            ]
          : [],
        // add resolver for files in public assets directories
        PublicDirsPlugin({
          dev: nuxt.options.dev,
          baseURL: nuxt.options.app.baseURL,
        }),
        ReplacePlugin(),
        LayerDepOptimizePlugin(nuxt),
        SSRStylesPlugin(nuxt),
        EnvironmentsPlugin(nuxt),
        ...nuxt.options.experimental.viteEnvironmentApi
          ? [
              // Add type-checking
              VitePluginCheckerPlugin(nuxt),

              // server-only plugins
              VueFeatureFlagsPlugin(nuxt),
              // tell rollup's nitro build about the original sources of the generated vite server build
              SourcemapPreserverPlugin(nuxt),

              // client-only plugins
              DevStyleSSRPlugin({
                srcDir: nuxt.options.srcDir,
                buildAssetsURL: joinURL(nuxt.options.app.baseURL, nuxt.options.app.buildAssetsDir),
              }),
              RuntimePathsPlugin(),
              // Type checking client panel
              TypeCheckPlugin(nuxt),
              ModulePreloadPolyfillPlugin(),
              // ensure changes in chunks do not invalidate whole build
              StableEntryPlugin(nuxt),
              AnalyzePlugin(nuxt),
            ]
          : [],
      ],
      appType: 'custom',
      server: {
        middlewareMode: true,
        watch: { ...nuxt.options.watchers.chokidar, ignored: [isIgnored, /[\\/]node_modules[\\/]/] },
        fs: {
          allow: [...new Set(allowDirs)],
        },
      },
    } satisfies ViteConfig,
    nuxt.options.experimental.viteEnvironmentApi
      ? {
          ...viteConfig,
          environments: {
            ssr: $server,
            client: $client,
          },
        }
      : viteConfig,
  )

  // In build mode we explicitly override any vite options that vite is relying on
  // to detect whether to inject production or development code (such as HMR code)
  if (!nuxt.options.dev) {
    config.server!.watch = undefined
    config.build!.watch = undefined
  }

  const ctx = { nuxt, entry, config: config as ViteConfig }
  await nuxt.callHook('vite:extend', ctx)

  if (nuxt.options.experimental.viteEnvironmentApi) {
    await handleEnvironments(nuxt, config)
  } else {
    await handleSerialBuilds(nuxt, ctx)
  }
}

async function handleEnvironments (nuxt: Nuxt, config: vite.InlineConfig) {
  config.customLogger = createViteLogger(config)
  config.configFile = false

  for (const environment of ['client', 'ssr']) {
    const environments = { [environment]: config.environments![environment]! }
    const strippedConfig = { ...config, environments } as ViteConfig
    const ctx = { isServer: environment === 'ssr', isClient: environment === 'client' }
    await nuxt.hooks.callHook('vite:extendConfig', strippedConfig, ctx)
    await nuxt.hooks.callHook('vite:configResolved', strippedConfig, ctx)
  }

  if (!nuxt.options.dev) {
    const builder = await createBuilder(config)
    await builder.buildApp()
    return
  }

  await withLogs(async () => {
    const server = await createServer(config)
    await server.environments.ssr.pluginContainer.buildStart({})
  }, 'Vite dev server built')

  await writeDevServer(nuxt)
}

export interface ViteBuildContext {
  nuxt: Nuxt
  config: ViteConfig
  entry: string
  clientServer?: vite.ViteDevServer
  ssrServer?: vite.ViteDevServer
}

async function handleSerialBuilds (nuxt: Nuxt, ctx: ViteBuildContext) {
  nuxt.hook('vite:serverCreated', (server: vite.ViteDevServer, env) => {
    if (nuxt.options.vite.warmupEntry !== false) {
      // Don't delay nitro build for warmup
      useNitro().hooks.hookOnce('compiled', () => {
        const start = Date.now()
        warmupViteServer(server, [ctx.entry], env.isServer)
          .then(() => logger.info(`Vite ${env.isClient ? 'client' : 'server'} warmed up in ${Date.now() - start}ms`))
          .catch(logger.error)
      })
    }
  })

  await withLogs(() => buildClient(nuxt, ctx), 'Vite client built', nuxt.options.dev)
  await withLogs(() => buildServer(nuxt, ctx), 'Vite server built', nuxt.options.dev)
}

async function withLogs (fn: () => Promise<unknown>, message: string, enabled = true) {
  if (!enabled) { return fn() }

  const start = performance.now()
  await fn()
  const duration = performance.now() - start
  logger.success(`${message} in ${Math.round(duration)}ms`)
}
</file>

<file path="packages/vite/.attw.json">
{
  "ignoreRules": ["cjs-resolves-to-esm"]
}
</file>

<file path="packages/vite/build.config.ts">
import { defineBuildConfig } from 'unbuild'
import { addRollupTimingsPlugin } from '../../debug/build-config.ts'

export default defineBuildConfig({
  declaration: true,
  entries: [
    'src/index',
    'src/vite-node',
    'src/vite-node-entry',
  ],
  hooks: {
    'rollup:options' (ctx, options) {
      addRollupTimingsPlugin(options)
    },
  },
  dependencies: [
    'vue',
  ],
  externals: [
    '@nuxt/schema',
  ],
})
</file>

<file path="packages/vite/package.json">
{
  "name": "@nuxt/vite-builder",
  "version": "4.2.2",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nuxt/nuxt.git",
    "directory": "packages/vite"
  },
  "description": "Vite bundler for Nuxt",
  "homepage": "https://nuxt.com",
  "license": "MIT",
  "type": "module",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs"
    }
  },
  "imports": {
    "#vite-node": "./dist/vite-node.mjs",
    "#vite-node-entry": "./dist/vite-node-entry.mjs"
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "prepack": "unbuild",
    "build:stub": "unbuild --stub",
    "test:attw": "attw --pack"
  },
  "devDependencies": {
    "@nuxt/schema": "workspace:*",
    "nitropack": "2.12.9",
    "rolldown": "1.0.0-beta.58",
    "rollup": "4.54.0",
    "unbuild": "3.6.1",
    "vue": "3.5.26"
  },
  "dependencies": {
    "@nuxt/kit": "workspace:*",
    "@rollup/plugin-replace": "^6.0.3",
    "@vitejs/plugin-vue": "^6.0.3",
    "@vitejs/plugin-vue-jsx": "^5.1.3",
    "autoprefixer": "^10.4.23",
    "consola": "^3.4.2",
    "cssnano": "^7.1.2",
    "defu": "^6.1.4",
    "esbuild": "^0.27.2",
    "escape-string-regexp": "^5.0.0",
    "exsolve": "^1.0.8",
    "get-port-please": "^3.2.0",
    "h3": "^1.15.4",
    "jiti": "^2.6.1",
    "knitwork": "^1.3.0",
    "magic-string": "^0.30.21",
    "mlly": "^1.8.0",
    "mocked-exports": "^0.1.1",
    "pathe": "^2.0.3",
    "pkg-types": "^2.3.0",
    "postcss": "^8.5.6",
    "rollup-plugin-visualizer": "^6.0.5",
    "seroval": "^1.4.2",
    "std-env": "^3.10.0",
    "ufo": "^1.6.1",
    "unenv": "^2.0.0-rc.24",
    "vite": "^7.3.0",
    "vite-node": "^5.2.0",
    "vite-plugin-checker": "^0.12.0",
    "vue-bundle-renderer": "^2.2.0"
  },
  "peerDependencies": {
    "nuxt": "workspace:*",
    "rolldown": "^1.0.0-beta.38",
    "vue": "^3.3.4"
  },
  "peerDependenciesMeta": {
    "rolldown": {
      "optional": true
    }
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="packages/webpack/src/configs/client.ts">
import querystring from 'node:querystring'
import { normalize, resolve } from 'pathe'
import { BundleAnalyzerPlugin } from 'webpack-bundle-analyzer'
import { logger, resolveAlias } from '@nuxt/kit'
import type { Module } from 'webpack'
import { joinURL } from 'ufo'
import { defineEnv } from 'unenv'

import type { WebpackConfigContext } from '../utils/config.ts'
import { applyPresets } from '../utils/config.ts'
import { nuxt } from '../presets/nuxt.ts'
import { TsCheckerPlugin, webpack } from '#builder'

export async function client (ctx: WebpackConfigContext) {
  ctx.name = 'client'
  ctx.isClient = true

  await applyPresets(ctx, [
    nuxt,
    clientPlugins,
    clientOptimization,
    clientDevtool,
    clientPerformance,
    clientHMR,
    clientNodeCompat,
  ])
}

function clientDevtool (ctx: WebpackConfigContext) {
  if (!ctx.nuxt.options.sourcemap.client) {
    ctx.config.devtool = false
    return
  }

  const prefix = ctx.nuxt.options.sourcemap.client === 'hidden' ? 'hidden-' : ''

  if (!ctx.isDev) {
    ctx.config.devtool = prefix + 'source-map'
    return
  }

  ctx.config.devtool = prefix + 'eval-cheap-module-source-map'
}

function clientPerformance (ctx: WebpackConfigContext) {
  ctx.config.performance = {
    maxEntrypointSize: 1000 * 1024,
    hints: ctx.isDev ? false : 'warning',
    ...ctx.config.performance,
  }
}

function clientNodeCompat (ctx: WebpackConfigContext) {
  if (!ctx.nuxt.options.experimental.clientNodeCompat) {
    return
  }
  ctx.config.plugins!.push(new webpack.DefinePlugin({ global: 'globalThis' }))

  ctx.config.resolve ||= {}
  ctx.config.resolve.fallback = {
    ...defineEnv({
      nodeCompat: true,
      resolve: true,
    }).env.alias,
    ...ctx.config.resolve.fallback,
  }

  // https://github.com/webpack/webpack/issues/13290#issuecomment-1188760779
  ctx.config.plugins!.unshift(new webpack.NormalModuleReplacementPlugin(/node:/, (resource) => {
    resource.request = resource.request.replace(/^node:/, '')
  }))
}

function clientHMR (ctx: WebpackConfigContext) {
  if (!ctx.isDev) {
    return
  }

  const clientOptions = ctx.userConfig.hotMiddleware?.client || {}
  const hotMiddlewareClientOptions = {
    reload: true,
    timeout: 30000,
    path: joinURL(ctx.options.app.baseURL, '__webpack_hmr', ctx.name),
    ...clientOptions,
    ansiColors: JSON.stringify(clientOptions.ansiColors || {}),
    overlayStyles: JSON.stringify(clientOptions.overlayStyles || {}),
    name: ctx.name,
  }
  const hotMiddlewareClientOptionsStr = querystring.stringify(hotMiddlewareClientOptions)

  // Add HMR support
  const app = (ctx.config.entry as any).app as any
  app.unshift(
    // https://github.com/webpack/webpack-hot-middleware#config
    `webpack-hot-middleware/client?${hotMiddlewareClientOptionsStr}`,
  )

  ctx.config.plugins ||= []
  ctx.config.plugins.push(new webpack.HotModuleReplacementPlugin())
}

function clientOptimization (ctx: WebpackConfigContext) {
  if (!ctx.nuxt.options.features.inlineStyles) {
    return
  }

  // separate global CSS into a dedicated chunk
  const globalCSSPaths = new Set<string>()

  // Resolve global CSS paths from nuxt.options.css
  for (const css of ctx.options.css) {
    if (typeof css === 'string') {
      const resolved = resolveAlias(css, ctx.options.alias)
      globalCSSPaths.add(normalize(resolved))
    }
  }

  if (globalCSSPaths.size > 0) {
    ctx.config.optimization ||= {}
    ctx.config.optimization.splitChunks ||= {}
    ctx.config.optimization.splitChunks.cacheGroups ||= {}

    ctx.config.optimization.splitChunks.cacheGroups.nuxtGlobalCSS = {
      name: 'nuxt-global-css',
      chunks: 'all',
      enforce: true,
      test: (module: Module) => {
        if (module.type !== 'css/mini-extract') { return false }
        const identifier = normalize(module.identifier())
        for (const globalPath of globalCSSPaths) {
          if (identifier.includes(globalPath)) {
            return true
          }
        }
        return false
      },
    }
  }
}

function clientPlugins (ctx: WebpackConfigContext) {
  // webpack Bundle Analyzer
  // https://github.com/webpack/webpack-bundle-analyzer
  if (!ctx.isDev && !ctx.nuxt.options.test && ctx.name === 'client' && ctx.userConfig.analyze && (ctx.userConfig.analyze === true || ctx.userConfig.analyze.enabled)) {
    const statsDir = resolve(ctx.options.analyzeDir)

    ctx.config.plugins!.push(new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      defaultSizes: 'gzip',
      generateStatsFile: true,
      openAnalyzer: true,
      reportFilename: resolve(statsDir, `${ctx.name}.html`),
      statsFilename: resolve(statsDir, `${ctx.name}.json`),
      ...ctx.userConfig.analyze === true ? {} : ctx.userConfig.analyze,
    }))
  }

  // Normally type checking runs in server config, but in `ssr: false` there is
  // no server build, so we inject here instead.
  if (!ctx.nuxt.options.ssr) {
    if (!ctx.nuxt.options.test && (ctx.nuxt.options.typescript.typeCheck === true || (ctx.nuxt.options.typescript.typeCheck === 'build' && !ctx.nuxt.options.dev))) {
      ctx.config.plugins!.push(new TsCheckerPlugin({
        logger,
      }))
    }
  }
}
</file>

<file path="packages/webpack/src/configs/index.ts">
export { client } from './client.ts'
export { server } from './server.ts'
</file>

<file path="packages/webpack/src/configs/server.ts">
import { isAbsolute, normalize, resolve } from 'pathe'
import { directoryToURL, logger, resolveAlias, tryImportModule } from '@nuxt/kit'
import { parseNodeModulePath } from 'mlly'
import { resolveModulePath } from 'exsolve'
import { runtimeDependencies as runtimeNuxtDependencies } from 'nuxt/meta'
import type { WebpackConfigContext } from '../utils/config.ts'
import { applyPresets } from '../utils/config.ts'
import { nuxt } from '../presets/nuxt.ts'
import { node } from '../presets/node.ts'
import { TsCheckerPlugin, webpack } from '#builder'

const assetPattern = /\.(?:css|s[ca]ss|png|jpe?g|gif|svg|woff2?|eot|ttf|otf|webp|webm|mp4|ogv)(?:\?.*)?$/i
const VIRTUAL_RE = /^\0?virtual:(?:nuxt:)?/

export async function server (ctx: WebpackConfigContext) {
  ctx.name = 'server'
  ctx.isServer = true

  await applyPresets(ctx, [
    nuxt,
    node,
    serverStandalone,
    serverPreset,
    serverPlugins,
  ])
}

function serverPreset (ctx: WebpackConfigContext) {
  ctx.config.output!.filename = 'server.mjs'

  if (ctx.nuxt.options.sourcemap.server) {
    const prefix = ctx.nuxt.options.sourcemap.server === 'hidden' ? 'hidden-' : ''
    ctx.config.devtool = prefix + (ctx.isDev ? 'cheap-module-source-map' : 'source-map')
  } else {
    ctx.config.devtool = false
  }

  ctx.config.optimization = {
    splitChunks: false,
    minimize: false,
  }

  if (ctx.isDev) {
    ctx.config.output!.asyncChunks = false
  }
}

async function serverStandalone (ctx: WebpackConfigContext) {
  // TODO: Refactor this out of webpack
  const inline = [
    'src/',
    '#app',
    'nuxt',
    'nuxt3',
    'nuxt-nightly',
    '!',
    '-!',
    '~',
    '@/',
    '#',
    ...ctx.options.build.transpile,
  ]

  const { runtimeDependencies: runtimeNitroDependencies = [] } = await tryImportModule<typeof import('nitropack/runtime/meta')>('nitropack/runtime/meta', {
    url: new URL(import.meta.url),
  }) || {}

  const external = new Set([
    'nitro/runtime',
    // TODO: remove in v5
    '#internal/nitro',
    'nitropack/runtime',
    '#shared',
    resolve(ctx.nuxt.options.rootDir, ctx.nuxt.options.dir.shared),
    // explicit dependencies we use in our ssr renderer
    'unhead', '@unhead/vue', '@nuxt/devalue', 'rou3', 'unstorage',
    ...runtimeNuxtDependencies,
    ...runtimeNitroDependencies,
  ])
  if (!ctx.nuxt.options.dev) {
    external.add('#internal/nuxt/paths')
    external.add('#internal/nuxt/app-config')
    external.add('#app-manifest')
  }

  if (!Array.isArray(ctx.config.externals)) { return }

  // Resolve conditions for server build
  const conditions = [
    ctx.nuxt.options.dev ? 'development' : 'production',
    'node',
    'import',
    'require',
  ]

  ctx.config.externals.push(({ request, context }, cb) => {
    if (!request) {
      return cb(undefined, false)
    }
    if (external.has(request)) {
      // Resolve to absolute path so nitro can handle version resolution
      const resolved = resolveModulePath(request, {
        from: context ? [context, ...ctx.nuxt.options.modulesDir].map(d => directoryToURL(d)) : ctx.nuxt.options.modulesDir.map(d => directoryToURL(d)),
        suffixes: ['', 'index'],
        conditions,
        try: true,
      })
      if (resolved && isAbsolute(resolved)) {
        return cb(undefined, resolved)
      }
      return cb(undefined, true)
    }
    if (
      request[0] === '.' ||
      isAbsolute(request) ||
      inline.find(prefix => typeof prefix === 'string' && request.startsWith(prefix)) ||
      assetPattern.test(request)
    ) {
      // console.log('Inline', request)
      return cb(undefined, false)
    }

    if (context && request && !request.startsWith('node:') && (isAbsolute(context) || VIRTUAL_RE.test(context))) {
      try {
        const normalisedRequest = resolveAlias(normalize(request), ctx.nuxt.options.alias)
        const dir = parseNodeModulePath(context).dir || ctx.nuxt.options.rootDir

        const resolved = resolveModulePath(normalisedRequest, {
          from: [dir, ...ctx.nuxt.options.modulesDir].map(d => directoryToURL(d)),
          suffixes: ['', 'index'],
          conditions,
          try: true,
        })

        if (resolved && isAbsolute(resolved)) {
          return cb(undefined, false)
        }
      } catch {
        // Ignore resolution errors, fall through to externalize
      }
    }

    // console.log('Ext', request)
    return cb(undefined, true)
  })
}

function serverPlugins (ctx: WebpackConfigContext) {
  ctx.config.plugins ||= []

  // Server polyfills
  if (ctx.userConfig.serverURLPolyfill) {
    ctx.config.plugins.push(new webpack.ProvidePlugin({
      URL: [ctx.userConfig.serverURLPolyfill, 'URL'],
      URLSearchParams: [ctx.userConfig.serverURLPolyfill, 'URLSearchParams'],
    }))
  }

  // Add type-checking
  if (!ctx.nuxt.options.test && (ctx.nuxt.options.typescript.typeCheck === true || (ctx.nuxt.options.typescript.typeCheck === 'build' && !ctx.nuxt.options.dev))) {
    ctx.config.plugins!.push(new TsCheckerPlugin({
      logger,
    }))
  }
}
</file>

<file path="packages/webpack/src/loaders/vue-module-identifier.ts">
import type { LoaderDefinitionFunction } from 'webpack'
import { normalize, relative } from 'pathe'

interface LoaderOptions {
  srcDir?: string
}

const vueModuleIdentifierLoader: LoaderDefinitionFunction<LoaderOptions> = function (source) {
  this.cacheable?.()

  const { srcDir } = this.getOptions() || {}

  const resourcePath = this.resourcePath || this._module?.resource
  if (!resourcePath || !source.includes('__exports__')) {
    return source
  }

  const context = srcDir || this.rootContext || this.context || this._compiler?.options?.context
  const relativePath = context ? relative(context, resourcePath) : resourcePath
  const moduleId = normalize(relativePath).replace(/^\.\//, '').replace(/\\/g, '/')

  const snippet = `\n;__exports__.__moduleIdentifier = ${JSON.stringify(moduleId)};`
  return source + snippet
}

export default vueModuleIdentifierLoader
</file>

<file path="packages/webpack/src/plugins/vue/client.ts">
/**
 * This file is based on Vue.js (MIT) webpack plugins
 * https://github.com/vuejs/vue/blob/dev/src/server/webpack-plugin/client.js
 */

import { mkdir, writeFile } from 'node:fs/promises'

import { normalizeWebpackManifest, precomputeDependencies } from 'vue-bundle-renderer'
import { join, normalize, relative, resolve } from 'pathe'
import { hash } from 'ohash'
import { serialize } from 'seroval'

import type { Nuxt } from '@nuxt/schema'
import type { Compilation, Compiler } from 'webpack'

import { isCSS, isHotUpdate, isJS } from './util.ts'

interface PluginOptions {
  nuxt: Nuxt
}

export default class VueSSRClientPlugin {
  serverDist: string
  nuxt: Nuxt

  constructor (options: PluginOptions) {
    this.serverDist = resolve(options.nuxt.options.buildDir, 'dist/server')
    this.nuxt = options.nuxt
  }

  private getRelativeModuleId (identifier: string, context: string): string {
    const id = identifier.replace(/\s\w+$/, '') // remove appended hash
    // Module identifier format: /path/loaders!resource?query
    const resourceMatch = id.match(/([^!]*\.vue)(?:\?|$)/)
    // Extract relative resource path
    return resourceMatch && resourceMatch[1]
      ? normalize(relative(context, resourceMatch[1])).replace(/^\.\//, '').replace(/\\/g, '/')
      : id
  }

  apply (compiler: Compiler) {
    compiler.hooks.afterEmit.tap('VueSSRClientPlugin', async (compilation: Compilation) => {
      const stats = compilation.getStats().toJson()
      const context = this.nuxt.options.srcDir

      const initialFiles = new Set<string>()
      for (const { assets } of Object.values(stats.entrypoints!)) {
        if (!assets) { continue }

        for (const asset of assets) {
          const file = asset.name
          if ((isJS(file) || isCSS(file)) && !isHotUpdate(file)) {
            initialFiles.add(file)
          }
        }
      }

      const allFiles = new Set<string>()
      const asyncFiles = new Set<string>()
      const assetsMapping: Record<string, string[]> = {}

      for (const { name: file, chunkNames = [] } of stats.assets!) {
        if (isHotUpdate(file)) { continue }
        allFiles.add(file)
        const isFileJS = isJS(file)
        if (!initialFiles.has(file) && (isFileJS || isCSS(file))) {
          asyncFiles.add(file)
        }
        if (isFileJS) {
          const componentHash = hash(chunkNames.join('|'))
          const map = assetsMapping[componentHash] ||= []
          map.push(file)
        }
      }

      const webpackManifest = {
        publicPath: stats.publicPath,
        all: [...allFiles],
        initial: [...initialFiles],
        async: [...asyncFiles],
        modules: { /* [identifier: string]: Array<index: number> */ } as Record<string, number[]>,
        assetsMapping,
      }

      const { entrypoints = {}, namedChunkGroups = {} } = stats
      const fileToIndex = (file: string | number) => webpackManifest.all.indexOf(String(file))
      for (const m of stats.modules!) {
        // Ignore modules duplicated in multiple chunks
        if (m.chunks?.length !== 1) { continue }

        const [cid] = m.chunks
        const chunk = stats.chunks!.find(c => c.id === cid)
        if (!chunk || !chunk.files || !cid) {
          continue
        }
        const relativeId = this.getRelativeModuleId(m.identifier!, context)

        const filesSet = new Set<number>()
        for (const file of chunk.files) {
          const index = fileToIndex(file)
          if (index !== -1) {
            filesSet.add(index)
          }
        }

        for (const chunkName of chunk.names!) {
          if (!entrypoints[chunkName]) {
            const chunkGroup = namedChunkGroups[chunkName]
            if (chunkGroup) {
              for (const asset of chunkGroup.assets!) {
                filesSet.add(fileToIndex(asset.name))
              }
            }
          }
        }

        const files = Array.from(filesSet)
        webpackManifest.modules[relativeId] = files

        // In production mode, modules may be concatenated by scope hoisting
        // Include ConcatenatedModule for not losing module-component mapping
        if (Array.isArray(m.modules)) {
          for (const concatenatedModule of m.modules) {
            const relativeId = this.getRelativeModuleId(concatenatedModule.identifier!, context)
            webpackManifest.modules[relativeId] ||= files
          }
        }

        // Find all asset modules associated with the same chunk
        if (stats.modules) {
          for (const m of stats.modules) {
            if (m.assets?.length && m.chunks?.includes(cid)) {
              files.push(...m.assets.map(fileToIndex))
            }
          }
        }
      }

      const manifest = normalizeWebpackManifest(webpackManifest as any)
      await this.nuxt.callHook('build:manifest', manifest)

      await mkdir(this.serverDist, { recursive: true })

      const precomputed = precomputeDependencies(manifest)
      await writeFile(join(this.serverDist, `client.manifest.json`), JSON.stringify(manifest, null, 2))
      await writeFile(join(this.serverDist, 'client.manifest.mjs'), 'export default ' + serialize(manifest), 'utf8')
      await writeFile(join(this.serverDist, 'client.precomputed.mjs'), 'export default ' + serialize(precomputed), 'utf8')

      // assets[this.options.filename] = {
      //   source: () => src,
      //   size: () => src.length
      // }
    })
  }
}
</file>

<file path="packages/webpack/src/plugins/vue/server.ts">
import type { Compilation, Compiler } from 'webpack'
import { extractQueryPartJS, isJS, validate } from './util.ts'
import { webpack } from '#builder'

interface VueSSRServerPluginOptions {
  filename: string
}

const JS_MAP_RE = /\.js\.map$/

export default class VueSSRServerPlugin {
  options: VueSSRServerPluginOptions

  constructor (options: Partial<VueSSRServerPluginOptions> = {}) {
    this.options = Object.assign({
      filename: null,
    }, options) as VueSSRServerPluginOptions
  }

  apply (compiler: Compiler) {
    validate(compiler)
    compiler.hooks.make.tap('VueSSRServerPlugin', (compilation: Compilation) => {
      compilation.hooks.processAssets.tapAsync({
        name: 'VueSSRServerPlugin',
        stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL,
      }, (assets: any, cb: any) => {
        const stats = compilation.getStats().toJson()
        const [entryName] = Object.keys(stats.entrypoints!)
        const entryInfo = stats.entrypoints![entryName!]

        if (!entryInfo) {
          // #5553
          return cb()
        }

        const entryAssets = entryInfo.assets!.filter((asset: { name: string }) => isJS(asset.name))

        if (entryAssets.length > 1) {
          throw new Error(
            'Server-side bundle should have one single entry file. ' +
            'Avoid using CommonsChunkPlugin in the server config.',
          )
        }

        const [entry] = entryAssets
        if (!entry || typeof entry.name !== 'string') {
          throw new Error(
            `Entry "${entryName}" not found. Did you specify the correct entry option?`,
          )
        }

        const bundle = {
          entry: entry.name,
          files: {} as Record<string, string>,
          maps: {} as Record<string, string>,
        }

        for (const asset of stats.assets!) {
          if (isJS(asset.name)) {
            const queryPart = extractQueryPartJS(asset.name)
            if (queryPart !== undefined) {
              bundle.files[asset.name] = asset.name.replace(queryPart, '')
            } else {
              bundle.files[asset.name] = asset.name
            }
          } else if (JS_MAP_RE.test(asset.name)) {
            bundle.maps[asset.name.replace(/\.map$/, '')] = asset.name
          } else {
            // Do not emit non-js assets for server
            delete assets[asset.name]
          }
        }

        const src = JSON.stringify(bundle, null, 2)

        assets[this.options.filename] = {
          source: () => src,
          size: () => src.length,
        }

        const mjsSrc = 'export default ' + src
        assets[this.options.filename.replace('.json', '.mjs')] = {
          source: () => mjsSrc,
          map: () => null,
          size: () => mjsSrc.length,
        }

        cb()
      })
    })
  }
}
</file>

<file path="packages/webpack/src/plugins/vue/util.ts">
/**
 * This file is based on Vue.js (MIT) webpack plugins
 * https://github.com/vuejs/vue/blob/dev/src/server/webpack-plugin/util.js
 */

import { logger } from '@nuxt/kit'
import type { Compiler } from 'webpack'

export const validate = (compiler: Compiler) => {
  if (compiler.options.target !== 'node') {
    logger.warn('webpack config `target` should be "node".')
  }

  if (!compiler.options.externals) {
    logger.info(
      'It is recommended to externalize dependencies in the server build for better build performance.',
    )
  }
}

const isJSRegExp = /\.[cm]?js(\?[^.]+)?$/

export const isJS = (file: string) => isJSRegExp.test(file)

export const extractQueryPartJS = (file: string) => isJSRegExp.exec(file)?.[1]

const isCSSRegExp = /\.css(?:\?[^.]+)?$/

export const isCSS = (file: string) => isCSSRegExp.test(file)

export const isHotUpdate = (file: string) => file.includes('hot-update')
</file>

<file path="packages/webpack/src/plugins/chunk.ts">
import type { Compiler } from 'webpack'
import { webpack } from '#builder'

const pluginName = 'ChunkErrorPlugin'

export class ChunkErrorPlugin {
  apply (compiler: Compiler) {
    compiler.hooks.thisCompilation.tap(pluginName, (compilation) => {
      compilation.hooks.runtimeRequirementInTree
        .for(webpack.RuntimeGlobals.ensureChunk)
        .tap(pluginName, (chunk) => {
          compilation.addRuntimeModule(
            chunk,
            new ChunkErrorRuntimeModule(),
          )
        })
    })
  }
}

class ChunkErrorRuntimeModule extends webpack.RuntimeModule {
  constructor () {
    super('chunk preload error handler', webpack.RuntimeModule.STAGE_ATTACH)
  }

  override generate () {
    const { ensureChunk } = webpack.RuntimeGlobals
    return `
if (typeof ${ensureChunk} !== "undefined") {
  var _ensureChunk = ${ensureChunk};
  ${ensureChunk} = function (chunkId) {
    return Promise.resolve(_ensureChunk(chunkId)).catch(function(error) {
      var e = new Event('nuxt:preloadError', { cancelable: true });
      e.payload = error;
      window.dispatchEvent(e);
      throw error;
    });
  };
}
`
  }
}
</file>

<file path="packages/webpack/src/plugins/dynamic-base.ts">
import { createUnplugin } from 'unplugin'
import MagicString from 'magic-string'

interface DynamicBasePluginOptions {
  globalPublicPath?: string
  sourcemap?: boolean
}

const defaults: DynamicBasePluginOptions = {
  globalPublicPath: '__webpack_public_path__',
  sourcemap: true,
}

const ENTRY_RE = /import ["']#build\/css["'];/

export const DynamicBasePlugin = createUnplugin((options: DynamicBasePluginOptions = {}) => {
  options = { ...defaults, ...options }
  return {
    name: 'nuxt:dynamic-base-path',
    enforce: 'post' as const,
    transform: {
      filter: {
        id: { include: /entry/ },
        code: { include: ENTRY_RE },
      },
      handler (code) {
        const s = new MagicString(code)
        s.prepend(`import { buildAssetsURL } from '#internal/nuxt/paths';\n${options.globalPublicPath} = buildAssetsURL();\n`)
        return {
          code: s.toString(),
          map: options.sourcemap
            ? s.generateMap({ hires: true })
            : undefined,
        }
      },
    },
  }
})
</file>

<file path="packages/webpack/src/plugins/rollup-compat-dynamic-import.ts">
import { genObjectFromRawEntries, genString } from 'knitwork'
import type { Compilation, Compiler, WebpackPluginInstance } from 'webpack'
import { isJS } from './vue/util.ts'

const DYNAMIC_IMPORT_RE = /import\([^)]*\+\s*__webpack_require__[^+]*\)\.then/
const DYNAMIC_IMPORT_REPLACE_RE = /import\([^)]*\+\s*(__webpack_require__[^+]*)\)\.then/g
const HELPER_FILENAME = '_dynamic-import-helper.mjs'
const HELPER_IMPORT = `import { _rollupDynamicImport } from "./${HELPER_FILENAME}";\n`

/**
 * Webpack plugin that generates rollup-compatible dynamic imports.
 * This plugin uses webpack's native compilation hooks to override dynamic import generation
 * and create rollup-compatible code directly during webpack's compilation process.
 */
export class RollupCompatDynamicImportPlugin implements WebpackPluginInstance {
  apply (compiler: Compiler) {
    compiler.hooks.compilation.tap('RollupCompatDynamicImportPlugin', (compilation) => {
      compilation.hooks.processAssets.tapAsync({
        name: 'RollupCompatDynamicImportPlugin',
        stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE,
      }, (assets, callback) => {
        try {
          const targetFiles = new Set<string>()

          for (const chunk of compilation.chunks) {
            // Include entry chunks and runtime chunks as they contain webpack runtime
            if (chunk.canBeInitial() || chunk.hasRuntime()) {
              for (const file of chunk.files || []) {
                targetFiles.add(file)
              }
            }
          }

          // Transform JavaScript files that contain dynamic imports
          for (const [filename, asset] of Object.entries(assets)) {
            if (!isJS(filename)) {
              continue
            }

            // Skip non-target chunks to improve performance
            if (!targetFiles.has(filename)) {
              continue
            }

            const source = asset.source()
            const originalCode = typeof source === 'string' ? source : source.toString()

            if (!DYNAMIC_IMPORT_RE.test(originalCode)) {
              continue
            }

            // Transform dynamic imports in this file
            const transformedCode = this.transformDynamicImports(originalCode)

            if (transformedCode !== originalCode) {
              assets[filename] = new compiler.webpack.sources.RawSource(transformedCode)
            }
          }

          // Generate helper file
          this.generateDynamicImportHelper(compilation)
          callback()
        } catch (error) {
          callback(error as Error)
        }
      },
      )
    })
  }

  private transformDynamicImports (source: string): string {
    let transformed = source
    let needsHelperImport = false

    // Transform webpack-style dynamic imports to rollup-compatible ones
    transformed = transformed.replace(DYNAMIC_IMPORT_REPLACE_RE, (match, filename) => {
      needsHelperImport = true
      // Generate a rollup-compatible dynamic import using the module ID
      return `_rollupDynamicImport(${filename}).then`
    })

    // Add import statement at the top if we made any transformations
    if (needsHelperImport && !transformed.includes(HELPER_IMPORT)) {
      transformed = HELPER_IMPORT + transformed
    }

    return transformed
  }

  private generateDynamicImportHelper (compilation: Compilation) {
    const chunkFiles: string[] = []
    for (const chunk of compilation.chunks) {
      // Skip runtime chunks as they don't contain loadable modules
      if (chunk.hasRuntime()) {
        continue
      }

      for (const filename of chunk.files) {
        if (filename && isJS(filename)) {
          chunkFiles.push(filename)
        }
      }
    }

    if (chunkFiles.length === 0) {
      return
    }

    // Generate the helper that provides rollup-compatible dynamic imports
    const helperContent = this.generateHelperContent(chunkFiles)
    compilation.emitAsset(HELPER_FILENAME, new compilation.compiler.webpack.sources.RawSource(helperContent))
  }

  private generateHelperContent (chunkFiles: string[]): string {
    return `
// Rollup-compatible dynamic import helper generated by webpack
// This helper enables rollup to consume webpack chunks directly

const chunkMap = ${genObjectFromRawEntries(chunkFiles.map(filename => [filename, `() => import(${genString('./' + filename)})`]))}

// Dynamic import function that rollup can understand
export function _rollupDynamicImport(chunkId) {
  const chunk = chunkMap[chunkId]
  if (!chunk) {
    return Promise.reject(new Error(\`Chunk \${chunkId} not found in chunkMap. Available chunks: \${Object.keys(chunkMap).join(', ')}\`))
  }
  
  // Use actual dynamic import for the chunk
  return chunk()
}
`
  }
}
</file>

<file path="packages/webpack/src/plugins/ssr-styles.ts">
import { existsSync, readFileSync } from 'node:fs'
import { createRequire } from 'node:module'
import { pathToFileURL } from 'node:url'
import { isAbsolute, relative, resolve } from 'pathe'
import { parseURL, withTrailingSlash } from 'ufo'
import { genArrayFromRaw, genObjectFromRawEntries } from 'knitwork'
import type { Nuxt } from '@nuxt/schema'
import { resolveAlias, useNitro } from '@nuxt/kit'
import type { Compilation, Compiler, Module, NormalModule } from 'webpack'
import type { CssModule } from 'mini-css-extract-plugin'
import { compileStyle, parse } from '@vue/compiler-sfc'
import { createHash } from 'node:crypto'

const CSS_URL_RE = /url\((['"]?)(\/[^)]+?)\1\)/g

const isVueFile = (id: string) => /\.vue(?:\?|$)/.test(id)
const isCSSLike = (name: string) => /\.(?:css|scss|sass|less|styl(?:us)?|postcss|pcss)(?:\?|$)/.test(name)

function normalizePath (nuxt: Nuxt, id?: string | null): string | null {
  if (!id) { return null }
  const { pathname } = parseURL(decodeURIComponent(pathToFileURL(id).href))
  const rel = relative(nuxt.options.srcDir, pathname)
  if (rel.startsWith('..')) { return null }
  return rel
}

function resolveFilePath (id?: string | null): string | null {
  if (!id) { return null }
  return parseURL(decodeURIComponent(pathToFileURL(id).href)).pathname || null
}

function sanitizeStyleAssetName (rel: string) {
  return rel.replace(/[\\/]/g, '_').replace(/\.{2,}/g, '_')
}

function normalizeCSSContent (css: string) {
  return css
    .trim()
    .replace(/(--[^:]+):\s*'([^']*)'/g, '$1:"$2"')
    .replace(/:\s+/g, ':')
    .replace(/\s*\{\s*/g, '{')
    .replace(/;\s*\}/g, '}')
    .replace(/\s*\}\s*/g, '}')
}

// Fallback to extract styles directly from .vue files
// (for server-only components not in client build)
// Uses vue-compiler-sfc to properly process scoped styles
function extractVueStyles (filePath: string): string[] {
  try {
    const src = readFileSync(filePath, 'utf8')
    const { descriptor } = parse(src, { filename: filePath })
    const styles: string[] = []

    // Generate scope ID using the same format as vue-loader (8-char hex hash)
    const scopeId = createHash('sha256').update(filePath).digest('hex').slice(0, 8)

    for (let i = 0; i < descriptor.styles.length; i++) {
      const style = descriptor.styles[i]!
      const result = compileStyle({
        source: style.content,
        filename: filePath,
        id: `data-v-${scopeId}`,
        scoped: style.scoped,
      })

      if (!result.errors.length && result.code) {
        styles.push(normalizeCSSContent(result.code))
      }
    }

    return styles
  } catch {
    return []
  }
}

export class SSRStylesPlugin {
  private nuxt: Nuxt
  private clientCSSByIssuer = new Map<string, Set<string>>()
  private chunksWithInlinedCSS = new Set<string>()
  private globalCSSPaths = new Set<string>()

  constructor (nuxt: Nuxt) {
    this.nuxt = nuxt
    this.globalCSSPaths = this.resolveGlobalCSS()

    // Remove CSS entries from manifest for global CSS and files that will have inlined styles
    nuxt.hook('build:manifest', (manifest) => {
      for (const [id, chunk] of Object.entries(manifest)) {
        if (chunk.isEntry && chunk.src) {
          // Track entry modules
          this.chunksWithInlinedCSS.add(chunk.src)
        } else if (this.chunksWithInlinedCSS.has(id)) {
          // Remove CSS for chunks with inlined styles
          chunk.css &&= []
        }

        // Remove global CSS from all chunks
        if (chunk.css?.length) {
          chunk.css = chunk.css.filter((cssPath) => {
            // Check if this CSS file corresponds to a global CSS module
            for (const globalPath of this.globalCSSPaths) {
              if (cssPath.includes(globalPath.split('/').pop() || '')) {
                return false
              }
            }
            return true
          })
        }
      }
    })
  }

  private shouldInline (mod: Module) {
    const shouldInline = this.nuxt.options.features.inlineStyles
    if (typeof shouldInline === 'boolean') {
      return shouldInline
    }
    return shouldInline(mod.identifier())
  }

  private escapeTemplateLiteral (str: string) {
    return str.replace(/[`\\$]/g, m => m === '$' ? '\\$' : `\\${m}`)
  }

  private isBuildAsset (url: string) {
    const buildDir = withTrailingSlash(this.nuxt.options.app.buildAssetsDir || '/_nuxt/')
    return url.startsWith(buildDir)
  }

  private isPublicAsset (url: string, nitro: ReturnType<typeof useNitro>) {
    const cleaned = url.replace(/[?#].*$/, '')
    for (const dir of nitro.options.publicAssets) {
      const base = withTrailingSlash(dir.baseURL || '/')
      if (!url.startsWith(base)) { continue }
      const path = cleaned.replace(base, withTrailingSlash(dir.dir))
      if (existsSync(path)) {
        return true
      }
    }
    return false
  }

  private rewriteStyle (css: string, nitro: ReturnType<typeof useNitro>) {
    let changed = false
    let needsPublicAsset = false
    let needsBuildAsset = false
    let lastIndex = 0
    let out = '`'

    for (const match of css.matchAll(CSS_URL_RE)) {
      const index = match.index ?? 0
      const before = css.slice(lastIndex, index)
      if (before) {
        out += this.escapeTemplateLiteral(before)
      }

      const full = match[0]
      const rawUrl = match[2] || ''
      const stripped = rawUrl.replace(/[?#].*$/, '')

      if (this.isPublicAsset(stripped, nitro)) {
        needsPublicAsset = true
        changed = true
        out += '${publicAssetsURL(' + JSON.stringify(rawUrl) + ')}'
      } else if (this.isBuildAsset(stripped)) {
        needsBuildAsset = true
        changed = true
        out += '${buildAssetsURL(' + JSON.stringify(rawUrl) + ')}'
      } else {
        out += this.escapeTemplateLiteral(full)
      }

      lastIndex = index + full.length
    }

    const tail = css.slice(lastIndex)
    if (tail) {
      out += this.escapeTemplateLiteral(tail)
    }
    out += '`'

    return {
      code: changed ? out : JSON.stringify(css),
      needsPublicAsset,
      needsBuildAsset,
    }
  }

  private resolveGlobalCSS (): Set<string> {
    const req = createRequire(this.nuxt.options.rootDir)
    const resolved = new Set<string>()
    const entries = (this.nuxt.options.css as GlobalCSSEntry[] | undefined) || []

    for (const entry of entries) {
      const src = typeof entry === 'string' ? entry : entry?.src
      if (!src) { continue }
      const path = this.resolveCSSRequest(src, req)
      if (path) {
        resolved.add(path)
      }
    }

    return resolved
  }

  private resolveCSSRequest (request: string, req: ReturnType<typeof createRequire>): string | null {
    const candidates = new Set<string>()

    const resolved = resolveAlias(request, this.nuxt.options.alias)
    if (isAbsolute(resolved)) {
      candidates.add(resolved)
    } else {
      candidates.add(resolve(this.nuxt.options.srcDir, resolved))
    }

    try {
      candidates.add(req.resolve(request))
    } catch {
      // ignore modules that can't be found
    }

    for (const candidate of candidates) {
      const path = resolveFilePath(candidate)
      if (path) {
        return path
      }
    }

    return null
  }

  private normalizeResourcePath (resource?: string | null): string | null {
    if (!resource) { return null }
    const withoutQuery = resource.split('?')[0]
    return resolveFilePath(withoutQuery)
  }

  apply (compiler: Compiler) {
    if (this.nuxt.options.dev) { return }
    const isClient = compiler.options.name === 'client'
    const isServer = compiler.options.name === 'server'
    if (!isClient && !isServer) { return }

    compiler.hooks.thisCompilation.tap('SSRStylesPlugin', (compilation) => {
      // Server build may have server-only components (islands) not in client build
      this.collectCSS(compilation)

      if (isClient) {
        this.removeGlobalCSSFromClient(compilation)
      }

      if (isServer) {
        this.emitServerStyles(compilation)
      }
    })
  }

  private emitServerStyles (compilation: Compilation) {
    const { webpack } = compilation.compiler
    const stage = webpack.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE
    compilation.hooks.processAssets.tap({ name: 'SSRStylesPlugin', stage }, () => {
      const nitro = useNitro()
      // Start with client CSS as baseline, then add server-specific CSS from bundle parsing
      // Client CSS includes styles from mini-css-extract-plugin that may not appear in server bundle
      const collected = new Map<string, Set<string>>(this.clientCSSByIssuer)

      // Collect entry module IDs first (including CSS files and Vue files)
      const entryModules = new Set<string>()
      for (const entrypoint of compilation.entrypoints.values()) {
        const primaryChunk = typeof entrypoint.getEntrypointChunk === 'function' ? entrypoint.getEntrypointChunk() : undefined
        const chunks = primaryChunk ? [primaryChunk] : entrypoint.chunks
        for (const chunk of chunks) {
          for (const mod of compilation.chunkGraph.getChunkModulesIterable(chunk)) {
            if ('resource' in mod && typeof mod.resource === 'string') {
              // For entry modules, use resolveFilePath to get the absolute path
              const resolved = resolveFilePath(mod.resource)
              if (resolved) {
                // Try normalized path first (relative to srcDir)
                const rel = normalizePath(this.nuxt, resolved)
                if (rel) {
                  entryModules.add(rel)
                } else {
                  // For files outside srcDir, use the absolute path
                  entryModules.add(resolved)
                }
              }
            }
          }
        }
      }

      // Fallback: extract styles from server-only Vue components
      for (const module of compilation.modules) {
        const normal = module as NormalModule
        const resource = normal.resource
        if (!resource || !isVueFile(resource)) { continue }
        const rel = normalizePath(this.nuxt, resource)
        if (!rel) { continue }
        if (collected.has(rel)) { continue }

        const vueStyles = extractVueStyles(resolveFilePath(resource) || resource)
        if (vueStyles.length) {
          collected.set(rel, new Set(vueStyles))
        }
      }

      const emitted: Record<string, string> = {}
      const rawSource = webpack.sources.RawSource

      for (const [rel, cssSet] of collected.entries()) {
        if (!cssSet.size) { continue }
        const stylesArray = Array.from(cssSet)
        const transformed = stylesArray.map(style => this.rewriteStyle(style, nitro))
        const needsPublicAssets = transformed.some(t => t.needsPublicAsset)
        const needsBuildAssets = transformed.some(t => t.needsBuildAsset)
        const imports: string[] = []
        if (needsPublicAssets || needsBuildAssets) {
          const names = [] as string[]
          if (needsBuildAssets) { names.push('buildAssetsURL') }
          if (needsPublicAssets) { names.push('publicAssetsURL') }
          imports.push(`import { ${names.join(', ')} } from '#internal/nuxt/paths'`)
        }
        const moduleSource = [
          ...imports,
          `export default ${genArrayFromRaw(transformed.map(t => t.code))}`,
        ].filter(Boolean).join('\n')
        const styleModuleName = `${sanitizeStyleAssetName(rel)}-styles.mjs`
        compilation.emitAsset(styleModuleName, new rawSource(moduleSource))
        emitted[rel] = styleModuleName
        this.chunksWithInlinedCSS.add(rel)
      }

      const stylesSource = [
        'const interopDefault = r => r.default || r || []',
        `export default ${genObjectFromRawEntries(
          Object.entries(emitted).map(([key, value]) => [key, `() => import('./${value}').then(interopDefault)`]) as [string, string][],
        )}`,
      ].join('\n')

      compilation.emitAsset('styles.mjs', new rawSource(stylesSource))

      const entryIds = Array.from(this.chunksWithInlinedCSS).filter(id => entryModules.has(id))
      nitro.options.virtual['#internal/nuxt/entry-ids.mjs'] = () => `export default ${JSON.stringify(entryIds)}`
      nitro.options._config.virtual ||= {}
      nitro.options._config.virtual['#internal/nuxt/entry-ids.mjs'] = nitro.options.virtual['#internal/nuxt/entry-ids.mjs']
    })
  }

  private findIssuerPath (compilation: Compilation, mod: Module): string | null {
    let issuer: Module | null | undefined = compilation.moduleGraph.getIssuer(mod)
    while (issuer) {
      if ('resource' in issuer && typeof issuer.resource === 'string') {
        return issuer.resource
      }
      issuer = compilation.moduleGraph.getIssuer(issuer)
    }
    return null
  }

  private removeGlobalCSSFromClient (compilation: Compilation) {
    // this runs at stage 650, before the main CSS collection at stage 700.
    const stage = 650

    compilation.hooks.processAssets.tap({ name: 'SSRStylesPlugin:RemoveGlobalCSS', stage }, () => {
      for (const chunk of compilation.chunks) {
        if (chunk.name === 'nuxt-global-css') {
          // collect CSS from this chunk before deleting
          const cssAssets: string[] = []
          for (const file of Array.from(chunk.files)) {
            const filename = String(file)
            if (isCSSLike(filename)) {
              const asset = compilation.getAsset(filename)
              const source = asset?.source
              const content = source && typeof source.source === 'function' ? source.source() : null
              const text = typeof content === 'string' ? content : (content instanceof Buffer ? content.toString('utf8') : '')
              if (text) {
                cssAssets.push(text)
              }
            }
          }

          // store CSS for all modules in this chunk
          if (cssAssets.length > 0) {
            for (const mod of compilation.chunkGraph.getChunkModulesIterable(chunk)) {
              const issuerPath = this.findIssuerPath(compilation, mod) || ('resource' in mod && typeof mod.resource === 'string' ? mod.resource : null)
              const normalized = normalizePath(this.nuxt, issuerPath)
              if (!normalized) { continue }
              const set = this.clientCSSByIssuer.get(normalized) || new Set<string>()
              for (const css of cssAssets) {
                set.add(normalizeCSSContent(css))
              }
              this.clientCSSByIssuer.set(normalized, set)
            }
          }

          // delete the CSS files from the client build
          for (const file of Array.from(chunk.files)) {
            const filename = String(file)
            if (isCSSLike(filename)) {
              compilation.deleteAsset(filename)
              chunk.files.delete(file)
            }
          }
        }
      }
    })
  }

  private collectCSS (compilation: Compilation) {
    const { webpack } = compilation.compiler
    const isServer = compilation.compiler.options.name === 'server'
    const stage = isServer
      ? webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
      : webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER

    const chunkCSSMeta = new Map<any, { files: string[], modules: NormalModule[] }>()

    compilation.hooks.processAssets.tap({ name: 'SSRStylesPlugin', stage }, () => {
      // First, associate emitted CSS assets with the modules in their chunks
      const cssAssetsByChunk = new Map<any, string[]>()
      for (const chunk of compilation.chunks) {
        const cssAssets: string[] = []
        const chunkCSSFiles: string[] = []
        for (const file of chunk.files) {
          if (!isCSSLike(file)) { continue }
          chunkCSSFiles.push(file)
          const asset = compilation.getAsset(file)
          const source = asset?.source
          const content = source && typeof source.source === 'function' ? source.source() : null
          const text = typeof content === 'string' ? content : (content instanceof Buffer ? content.toString('utf8') : '')
          if (text) {
            cssAssets.push(text)
          }
        }
        if (chunkCSSFiles.length) {
          const chunkCSSModules = Array.from(compilation.chunkGraph.getChunkModulesIterable(chunk)) as NormalModule[]
          chunkCSSMeta.set(chunk, { files: chunkCSSFiles, modules: chunkCSSModules })
        }
        if (cssAssets.length) {
          cssAssetsByChunk.set(chunk, cssAssets)
        }
      }

      for (const [chunk, cssAssets] of cssAssetsByChunk) {
        for (const mod of compilation.chunkGraph.getChunkModulesIterable(chunk)) {
          if (!this.shouldInline(mod)) {
            continue
          }
          const issuerPath = this.findIssuerPath(compilation, mod) || ('resource' in mod && typeof mod.resource === 'string' ? mod.resource : null)
          const normalized = normalizePath(this.nuxt, issuerPath)
          if (!normalized) { continue }
          const set = this.clientCSSByIssuer.get(normalized) || new Set<string>()
          for (const css of cssAssets) {
            set.add(normalizeCSSContent(css))
          }
          this.clientCSSByIssuer.set(normalized, set)
        }
      }

      for (const mod of compilation.modules) {
        if (!this.shouldInline(mod)) {
          continue
        }
        const issuerPath = this.findIssuerPath(compilation, mod)
        const normalized = normalizePath(this.nuxt, issuerPath)
        if (!normalized) {
          continue
        }

        const cssChunks = this.getModuleCSS(mod, compilation)

        if (!cssChunks.length) { continue }
        const set = this.clientCSSByIssuer.get(normalized) || new Set<string>()
        set.add(cssChunks.join('\n'))
        this.clientCSSByIssuer.set(normalized, set)
      }
    })
  }

  private getModuleCSS (mod: Module, _compilation: Compilation): string[] {
    const cssModule = mod as CssModule
    const cssChunks: string[] = []

    // Extract from mini-css-extract-plugin modules which have processed CSS
    if (mod.type === 'css/mini-extract' && Array.isArray(cssModule.content)) {
      for (const part of cssModule.content as Array<[string, string]>) {
        const css = part?.[1]
        if (css && typeof css === 'string') {
          cssChunks.push(normalizeCSSContent(css))
        }
      }
    }

    return cssChunks
  }
}

type GlobalCSSEntry = string | { src?: string }
</file>

<file path="packages/webpack/src/plugins/warning-ignore.ts">
import type { Compiler, WebpackError } from 'webpack'

export type WarningFilter = (warn: WebpackError | Error) => boolean

export default class WarningIgnorePlugin {
  filter: WarningFilter

  constructor (filter: WarningFilter) {
    this.filter = filter
  }

  apply (compiler: Compiler) {
    compiler.hooks.done.tap('warnfix-plugin', (stats) => {
      stats.compilation.warnings = stats.compilation.warnings.filter(this.filter)
    })
  }
}
</file>

<file path="packages/webpack/src/presets/assets.ts">
import type { WebpackConfigContext } from '../utils/config.ts'
import { fileName } from '../utils/config.ts'

export function assets (ctx: WebpackConfigContext) {
  ctx.config.module!.rules!.push(
    {
      test: /\.(png|jpe?g|gif|svg|webp)$/i,
      use: [{
        loader: 'url-loader',
        options: {
          ...ctx.userConfig.loaders.imgUrl,
          name: fileName(ctx, 'img'),
        },
      }],
    },
    {
      test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/i,
      use: [{
        loader: 'url-loader',
        options: {
          ...ctx.userConfig.loaders.fontUrl,
          name: fileName(ctx, 'font'),
        },
      }],
    },
    {
      test: /\.(webm|mp4|ogv)$/i,
      use: [{
        loader: 'file-loader',
        options: {
          ...ctx.userConfig.loaders.file,
          name: fileName(ctx, 'video'),
        },
      }],
    },
  )
}
</file>

<file path="packages/webpack/src/presets/base.ts">
import { basename, normalize, resolve } from 'pathe'
// @ts-expect-error missing types
import TimeFixPlugin from 'time-fix-plugin'
import type { Configuration } from 'webpack'
import { logger } from '@nuxt/kit'
// @ts-expect-error missing types
import FriendlyErrorsWebpackPlugin from '@nuxt/friendly-errors-webpack-plugin'
import escapeRegExp from 'escape-string-regexp'
import { joinURL } from 'ufo'
import type { NuxtOptions } from '@nuxt/schema'
import { isTest } from 'std-env'
import { defu } from 'defu'
import type { WarningFilter } from '../plugins/warning-ignore.ts'
import WarningIgnorePlugin from '../plugins/warning-ignore.ts'
import type { WebpackConfigContext } from '../utils/config.ts'
import { applyPresets, fileName } from '../utils/config.ts'
import { RollupCompatDynamicImportPlugin } from '../plugins/rollup-compat-dynamic-import.ts'

import { WebpackBarPlugin, builder, webpack } from '#builder'

export async function base (ctx: WebpackConfigContext) {
  await applyPresets(ctx, [
    baseAlias,
    baseConfig,
    basePlugins,
    baseResolve,
    baseTranspile,
  ])
}

function baseConfig (ctx: WebpackConfigContext) {
  ctx.config = defu({}, {
    name: ctx.name,
    entry: { app: [resolve(ctx.options.appDir, ctx.options.experimental.asyncEntry ? 'entry.async' : 'entry')] },
    module: { rules: [] },
    plugins: [],
    externals: [],
    optimization: {
      ...ctx.userConfig.optimization,
      minimizer: [],
    },
    experiments: {
      ...ctx.userConfig.experiments,
    },
    mode: ctx.isDev ? 'development' : 'production',
    cache: getCache(ctx),
    output: getOutput(ctx),
    stats: statsMap[ctx.nuxt.options.logLevel] ?? statsMap.info,
    ...ctx.config,
  } satisfies Configuration)
}

function basePlugins (ctx: WebpackConfigContext) {
  ctx.config.plugins ||= []

  // Add timefix-plugin before other plugins
  if (ctx.options.dev) {
    if (ctx.nuxt.options.builder !== '@nuxt/rspack-builder') {
      ctx.config.plugins.push(new TimeFixPlugin())
    }
  }

  // User plugins
  ctx.config.plugins.push(...(ctx.userConfig.plugins || []))

  // Ignore empty warnings
  if (ctx.nuxt.options.builder !== '@nuxt/rspack-builder') {
    ctx.config.plugins.push(new WarningIgnorePlugin(getWarningIgnoreFilter(ctx)))
  }

  // Provide env via DefinePlugin
  ctx.config.plugins.push(new webpack.DefinePlugin(getEnv(ctx)))

  // Friendly errors
  if (ctx.isServer || (ctx.isDev && ctx.userConfig.friendlyErrors)) {
    ctx.config.plugins.push(
      new FriendlyErrorsWebpackPlugin({
        clearConsole: false,
        reporter: 'consola',
        logLevel: 'ERROR', // TODO
      }),
    )
  }

  if (ctx.nuxt.options.webpack.profile) {
    // Webpackbar
    const colors = {
      client: 'green',
      server: 'orange',
      modern: 'blue',
    }
    ctx.config.plugins.push(new WebpackBarPlugin({
      name: ctx.name,
      color: colors[ctx.name as keyof typeof colors],
      reporters: ['stats'],
      // @ts-expect-error TODO: this is a valid option for Webpack.ProgressPlugin and needs to be declared for WebpackBar
      stats: !ctx.isDev,
      reporter: {
        reporter: {
          change: (_, { shortPath }) => {
            if (!ctx.isServer) {
              ctx.nuxt.callHook(`${builder}:change`, shortPath)
            }
          },
          done: (_, { stats }) => {
            if (stats.hasErrors()) {
              ctx.nuxt.callHook(`${builder}:error`)
            } else {
              logger.success(`Finished building ${stats.compilation.name ?? 'Nuxt app'}`)
            }
          },
          allDone: () => {
            ctx.nuxt.callHook(`${builder}:done`)
          },
          progress: ({ webpackbar }) => {
            ctx.nuxt.callHook(`${builder}:progress`, webpackbar.statesArray)
          },
        },
      },
    }))
  }

  // Emit explicit dynamic import statements for rollup compatibility
  if (ctx.isServer && !ctx.isDev) {
    ctx.config.plugins.push(new RollupCompatDynamicImportPlugin())
  }
}

function baseAlias (ctx: WebpackConfigContext) {
  ctx.alias = {
    '#app': ctx.options.appDir,
    [basename(ctx.nuxt.options.dir.assets)]: resolve(ctx.nuxt.options.srcDir, ctx.nuxt.options.dir.assets),
    ...ctx.options.alias,
    ...ctx.alias,
  }
  if (ctx.isClient) {
    ctx.alias['nitro/runtime'] = resolve(ctx.nuxt.options.buildDir, 'nitro.client.mjs')
    // TODO: remove in v5
    ctx.alias['#internal/nitro'] = resolve(ctx.nuxt.options.buildDir, 'nitro.client.mjs')
    ctx.alias['nitropack/runtime'] = resolve(ctx.nuxt.options.buildDir, 'nitro.client.mjs')
  }
}

function baseResolve (ctx: WebpackConfigContext) {
  // Prioritize nested node_modules in webpack search path (#2558)
  // TODO: this might be refactored as default modulesDir?
  const webpackModulesDir = ['node_modules'].concat(ctx.options.modulesDir)

  ctx.config.resolve = {
    extensions: ['.wasm', '.mjs', '.js', '.ts', '.json', '.vue', '.jsx', '.tsx'],
    alias: ctx.alias,
    modules: webpackModulesDir,
    fullySpecified: false,
    ...ctx.config.resolve,
  }

  ctx.config.resolveLoader = {
    modules: webpackModulesDir,
    ...ctx.config.resolveLoader,
  }
}

function baseTranspile (ctx: WebpackConfigContext) {
  const transpile = [
    /\.vue\.js/i, // include SFCs in node_modules
    /consola\/src/,
    /vue-demi/,
    /(^|\/)nuxt\/(src\/|dist\/)?(app|[^/]+\/runtime)($|\/)/,
  ]

  for (let pattern of ctx.options.build.transpile) {
    if (typeof pattern === 'function') {
      const result = pattern(ctx)
      if (result) { pattern = result }
    }
    if (typeof pattern === 'string') {
      transpile.push(new RegExp(escapeRegExp(normalize(pattern))))
    } else if (pattern instanceof RegExp) {
      transpile.push(pattern)
    }
  }

  // TODO: unique
  ctx.transpile = [...transpile, ...ctx.transpile]
}

function getCache (ctx: WebpackConfigContext): Configuration['cache'] {
  if (!ctx.options.dev) {
    return false
  }

  // TODO: Disable for nuxt internal dev due to inconsistencies
  // return {
  //   name: ctx.name,
  //   type: 'filesystem',
  //   cacheDirectory: resolve(ctx.options.rootDir, 'node_modules/.cache/webpack'),
  //   managedPaths: [
  //     ...ctx.options.modulesDir
  //   ],
  //   buildDependencies: {
  //     config: [
  //       ...ctx.options._nuxtConfigFiles
  //     ]
  //   }
  // }
}

function getOutput (ctx: WebpackConfigContext): Configuration['output'] {
  return {
    path: resolve(ctx.options.buildDir, 'dist', ctx.isServer ? 'server' : joinURL('client', ctx.options.app.buildAssetsDir)),
    filename: fileName(ctx, 'app'),
    chunkFilename: fileName(ctx, 'chunk'),
    publicPath: joinURL(ctx.options.app.baseURL, ctx.options.app.buildAssetsDir),
  }
}

function getWarningIgnoreFilter (ctx: WebpackConfigContext): WarningFilter {
  const filters: WarningFilter[] = [
    // Hide warnings about plugins without a default export (#1179)
    warn => warn.name === 'ModuleDependencyWarning' &&
      warn.message.includes('export \'default\'') &&
      warn.message.includes('nuxt_plugin_'),
    ...(ctx.userConfig.warningIgnoreFilters || []),
  ]

  return warn => !filters.some(ignoreFilter => ignoreFilter(warn))
}

function getEnv (ctx: WebpackConfigContext) {
  const _env: Record<string, string | boolean | InstanceType<typeof webpack.DefinePlugin>['definitions'][string]> = {
    'process.env.NODE_ENV': JSON.stringify(ctx.config.mode),
    '__NUXT_VERSION__': JSON.stringify(ctx.nuxt._version),
    '__NUXT_ASYNC_CONTEXT__': ctx.options.experimental.asyncContext,
    'process.env.VUE_ENV': JSON.stringify(ctx.name),
    'process.dev': ctx.options.dev,
    'process.test': isTest,
    'process.browser': ctx.isClient,
    'process.client': ctx.isClient,
    'process.server': ctx.isServer,
    'import.meta.dev': ctx.options.dev,
    'import.meta.test': isTest,
    'import.meta.browser': ctx.isClient,
    'import.meta.client': ctx.isClient,
    'import.meta.server': ctx.isServer,
  }

  if (ctx.isClient) {
    _env['process.prerender'] = false
    _env['process.nitro'] = false
    _env['import.meta.prerender'] = false
    _env['import.meta.nitro'] = false
  } else {
    // wrap in an IIFE, forcing it to be evaluated at runtime
    _env['process.prerender'] = '(()=>process.prerender)()'
    _env['process.nitro'] = '(()=>process.nitro)()'
    _env['import.meta.prerender'] = '(()=>import.meta.prerender)()'
    _env['import.meta.nitro'] = '(()=>import.meta.nitro)()'
  }

  if (ctx.userConfig.aggressiveCodeRemoval) {
    _env['typeof process'] = JSON.stringify(ctx.isServer ? 'object' : 'undefined')
    _env['typeof window'] = _env['typeof document'] = JSON.stringify(!ctx.isServer ? 'object' : 'undefined')
  }

  return _env
}

const statsMap: Record<NuxtOptions['logLevel'], Configuration['stats']> = {
  silent: 'none',
  info: 'normal',
  verbose: 'verbose',
}
</file>

<file path="packages/webpack/src/presets/esbuild.ts">
import { EsbuildPlugin } from 'esbuild-loader'
import type { WebpackConfigContext } from '../utils/config.ts'

export function esbuild (ctx: WebpackConfigContext) {
  // https://esbuild.github.io/getting-started/#bundling-for-the-browser
  // https://gs.statcounter.com/browser-version-market-share
  // https://nodejs.org/en/
  const target = ctx.isServer ? 'es2020' : 'chrome85'

  // https://github.com/nuxt/nuxt/issues/13052
  ctx.config.optimization!.minimizer!.push(new EsbuildPlugin())

  ctx.config.module!.rules!.push(
    {
      test: /\.m?[jt]s$/i,
      loader: 'esbuild-loader',
      exclude: (file) => {
        // Not exclude files outside node_modules
        const lastSegment = file.split('node_modules', 2)[1]
        if (!lastSegment) { return false }

        return !ctx.transpile.some(module => module.test(lastSegment))
      },
      resolve: {
        fullySpecified: false,
      },
      options: {
        target,
        ...ctx.nuxt.options.webpack.loaders.esbuild,
        loader: 'ts',
      },
    },
    {
      test: /\.m?[jt]sx$/,
      loader: 'esbuild-loader',
      options: {
        target,
        ...ctx.nuxt.options.webpack.loaders.esbuild,
        loader: 'tsx',
      },
    },
  )
}
</file>

<file path="packages/webpack/src/presets/node.ts">
import type { WebpackConfigContext } from '../utils/config.ts'

export function node (ctx: WebpackConfigContext) {
  ctx.config.target = 'node'
  ctx.config.node = false

  ctx.config.experiments!.outputModule = true

  ctx.config.output = {
    ...ctx.config.output,
    chunkFilename: '[name].mjs',
    chunkFormat: 'module',
    chunkLoading: 'import',
    module: true,
    environment: {
      module: true,
      arrowFunction: true,
      bigIntLiteral: true,
      const: true,
      destructuring: true,
      dynamicImport: true,
      forOf: true,
    },
    library: {
      type: 'module',
    },
  }

  ctx.config.performance = {
    ...ctx.config.performance,
    hints: false,
    maxEntrypointSize: Number.POSITIVE_INFINITY,
    maxAssetSize: Number.POSITIVE_INFINITY,
  }
}
</file>

<file path="packages/webpack/src/presets/nuxt.ts">
import type { WebpackConfigContext } from '../utils/config.ts'
import { applyPresets } from '../utils/config.ts'

import { assets } from './assets.ts'
import { base } from './base.ts'
import { esbuild } from './esbuild.ts'
import { pug } from './pug.ts'
import { style } from './style.ts'
import { vue } from './vue.ts'

export async function nuxt (ctx: WebpackConfigContext) {
  await applyPresets(ctx, [
    base,
    assets,
    esbuild,
    pug,
    style,
    vue,
  ])
}
</file>

<file path="packages/webpack/src/presets/pug.ts">
import type { WebpackConfigContext } from '../utils/config.ts'

export function pug (ctx: WebpackConfigContext) {
  ctx.config.module!.rules!.push({
    test: /\.pug$/i,
    oneOf: [
      {
        resourceQuery: /^\?vue/i,
        use: [{
          loader: 'pug-plain-loader',
          options: ctx.userConfig.loaders.pugPlain,
        }],
      },
      {
        use: [
          'raw-loader',
          {
            loader: 'pug-plain-loader',
            options: ctx.userConfig.loaders.pugPlain,
          },
        ],
      },
    ],
  })
}
</file>

<file path="packages/webpack/src/presets/style.ts">
import CssMinimizerPlugin from 'css-minimizer-webpack-plugin'
import type { WebpackConfigContext } from '../utils/config.ts'
import { applyPresets, fileName } from '../utils/config.ts'
import { getPostcssConfig } from '../utils/postcss.ts'

import { MiniCssExtractPlugin } from '#builder'

export async function style (ctx: WebpackConfigContext) {
  await applyPresets(ctx, [
    loaders,
    extractCSS,
    minimizer,
  ])
}

function minimizer (ctx: WebpackConfigContext) {
  if (ctx.userConfig.optimizeCSS && Array.isArray(ctx.config.optimization!.minimizer)) {
    ctx.config.optimization!.minimizer.push(new CssMinimizerPlugin({
      ...ctx.userConfig.optimizeCSS,
    }))
  }
}

function extractCSS (ctx: WebpackConfigContext) {
  const config = ctx.userConfig.extractCSS
  if (!config) { return }
  // CSS extraction
  const filename = fileName(ctx, 'css')
  ctx.config.plugins!.push(new MiniCssExtractPlugin({
    filename,
    chunkFilename: filename,
    ...config === true ? {} : config,
  }))
}

async function loaders (ctx: WebpackConfigContext) {
  // CSS
  ctx.config.module!.rules!.push(await createdStyleRule('css', /\.css$/i, null, ctx))

  // PostCSS
  ctx.config.module!.rules!.push(await createdStyleRule('postcss', /\.p(ost)?css$/i, null, ctx))

  // Less
  const lessLoader = { loader: 'less-loader', options: ctx.userConfig.loaders.less }
  ctx.config.module!.rules!.push(await createdStyleRule('less', /\.less$/i, lessLoader, ctx))

  // Sass (TODO: optional dependency)
  const sassLoader = { loader: 'sass-loader', options: ctx.userConfig.loaders.sass }
  ctx.config.module!.rules!.push(await createdStyleRule('sass', /\.sass$/i, sassLoader, ctx))

  const scssLoader = { loader: 'sass-loader', options: ctx.userConfig.loaders.scss }
  ctx.config.module!.rules!.push(await createdStyleRule('scss', /\.scss$/i, scssLoader, ctx))

  // Stylus
  const stylusLoader = { loader: 'stylus-loader', options: ctx.userConfig.loaders.stylus }
  ctx.config.module!.rules!.push(await createdStyleRule('stylus', /\.styl(us)?$/i, stylusLoader, ctx))
}

async function createdStyleRule (lang: string, test: RegExp, processorLoader: any, ctx: WebpackConfigContext) {
  const styleLoaders = [
    await createPostcssLoadersRule(ctx),
    processorLoader,
  ].filter(Boolean)

  ctx.userConfig.loaders.css.importLoaders =
    ctx.userConfig.loaders.cssModules.importLoaders =
      styleLoaders.length

  const cssLoaders = createCssLoadersRule(ctx, ctx.userConfig.loaders.css)
  const cssModuleLoaders = createCssLoadersRule(ctx, ctx.userConfig.loaders.cssModules)

  return {
    test,
    oneOf: [
      // This matches <style module>
      {
        resourceQuery: /module/,
        use: cssModuleLoaders.concat(styleLoaders),
      },
      // This matches plain <style> or <style scoped>
      {
        use: cssLoaders.concat(styleLoaders),
      },
    ],
  }
}

function createCssLoadersRule (ctx: WebpackConfigContext, cssLoaderOptions: any) {
  const cssLoader = { loader: 'css-loader', options: cssLoaderOptions }

  if (ctx.userConfig.extractCSS) {
    if (ctx.isServer) {
      // https://webpack.js.org/loaders/css-loader/#exportonlylocals
      if (cssLoader.options.modules) {
        cssLoader.options.modules.exportOnlyLocals ??= true
      }
      return [cssLoader]
    }

    return [
      {
        loader: MiniCssExtractPlugin.loader,
      },
      cssLoader,
    ]
  }

  return [
    // https://github.com/vuejs/vue-style-loader/issues/56
    // {
    //   loader: 'vue-style-loader',
    //   options: options.webpack.loaders.vueStyle
    // },
    cssLoader,
  ]
}

async function createPostcssLoadersRule (ctx: WebpackConfigContext) {
  if (!ctx.options.postcss) { return }

  const config = await getPostcssConfig(ctx.nuxt)

  if (!config) {
    return
  }

  return {
    loader: 'postcss-loader',
    options: config,
  }
}
</file>

<file path="packages/webpack/src/presets/vue.ts">
import VueLoaderPlugin from 'vue-loader/dist/pluginWebpack5.js'
import { resolveModulePath } from 'exsolve'
import VueSSRClientPlugin from '../plugins/vue/client.ts'
import VueSSRServerPlugin from '../plugins/vue/server.ts'
import type { WebpackConfigContext } from '../utils/config.ts'

import { webpack } from '#builder'

export function vue (ctx: WebpackConfigContext) {
  // @ts-expect-error de-default vue-loader
  ctx.config.plugins!.push(new (VueLoaderPlugin.default || VueLoaderPlugin)())

  ctx.config.module!.rules!.push({
    test: /\.vue$/i,
    loader: 'vue-loader',
    options: { ...ctx.userConfig.loaders.vue, isServerBuild: ctx.isServer },
  })

  if (ctx.isClient) {
    ctx.config.plugins!.push(new VueSSRClientPlugin({ nuxt: ctx.nuxt }))
  } else {
    ctx.config.plugins!.push(new VueSSRServerPlugin({
      filename: `${ctx.name}.manifest.json`,
    }))

    const loaderPath = resolveModulePath('#vue-module-identifier', { from: import.meta.url })
    ctx.config.module!.rules!.push({
      test: /\.vue$/i,
      enforce: 'post',
      use: [{
        loader: loaderPath,
        options: { srcDir: ctx.nuxt.options.srcDir },
      }],
    })
  }

  // Feature flags
  // https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags
  // TODO: Provide options to toggle
  ctx.config.plugins!.push(new webpack.DefinePlugin({
    '__VUE_OPTIONS_API__': 'true',
    '__VUE_PROD_DEVTOOLS__': 'false',
    '__VUE_PROD_HYDRATION_MISMATCH_DETAILS__': ctx.nuxt.options.debug && ctx.nuxt.options.debug.hydration,
  }))
}
</file>

<file path="packages/webpack/src/utils/config.ts">
import type { Configuration } from 'webpack'
import type { Nuxt, NuxtOptions } from '@nuxt/schema'
import { logger } from '@nuxt/kit'
import { toArray } from './index.ts'

export interface WebpackConfigContext {
  nuxt: Nuxt
  options: NuxtOptions
  userConfig: Omit<NuxtOptions['webpack'], '$client' | '$server'>
  config: Configuration
  name: string
  isDev: boolean
  isServer: boolean
  isClient: boolean
  alias: { [index: string]: string | false | string[] }
  transpile: RegExp[]
}

type WebpackConfigPreset = (ctx: WebpackConfigContext, options?: object) => void | Promise<void>
type WebpackConfigPresetItem = WebpackConfigPreset | [WebpackConfigPreset, any]

export function createWebpackConfigContext (nuxt: Nuxt): WebpackConfigContext {
  return {
    nuxt,
    options: nuxt.options,
    userConfig: nuxt.options.webpack,
    config: {},

    name: 'base',
    isDev: nuxt.options.dev,
    isServer: false,
    isClient: false,

    alias: {},
    transpile: [],
  }
}

export async function applyPresets (ctx: WebpackConfigContext, presets: WebpackConfigPresetItem | WebpackConfigPresetItem[]) {
  for (const preset of toArray(presets)) {
    if (Array.isArray(preset)) {
      await preset[0](ctx, preset[1])
    } else {
      await preset(ctx)
    }
  }
}

export function fileName (ctx: WebpackConfigContext, key: string) {
  let fileName = ctx.userConfig.filenames[key]

  if (typeof fileName === 'function') {
    fileName = fileName(ctx)
  }

  if (typeof fileName === 'string' && ctx.options.dev) {
    const hash = /\[(chunkhash|contenthash|hash)(?::\d+)?\]/.exec(fileName)
    if (hash) {
      logger.warn(`Notice: Please do not use ${hash[1]} in dev mode to prevent memory leak`)
    }
  }

  return fileName
}
</file>

<file path="packages/webpack/src/utils/index.ts">
/** @since 3.9.0 */
export function toArray<T> (value: T | T[]): T[] {
  return Array.isArray(value) ? value : [value]
}
</file>

<file path="packages/webpack/src/utils/mfs.ts">
import { join } from 'pathe'
import pify from 'pify'
import { Volume, createFsFromVolume } from 'memfs'

import type { IFs } from 'memfs'

export function createMFS () {
  // Create a new volume
  const fs = createFsFromVolume(new Volume())

  // Clone to extend
  const _fs: IFs & { join?(...paths: string[]): string } = { ...fs } as any

  // fs.join method is (still) expected by webpack-dev-middleware
  // There might be differences with https://github.com/webpack/memory-fs/blob/master/lib/join.js
  _fs.join = join

  // Used by vue-renderer
  _fs.exists = p => Promise.resolve(_fs.existsSync(p))
  // @ts-expect-error need better types for `pify`
  _fs.readFile = pify(_fs.readFile)

  return _fs as IFs & { join?(...paths: string[]): string }
}
</file>

<file path="packages/webpack/src/utils/postcss.ts">
import createResolver from 'postcss-import-resolver'
import type { Nuxt, NuxtOptions } from '@nuxt/schema'
import { defu } from 'defu'
import { createJiti } from 'jiti'
import type { Plugin } from 'postcss'

const isPureObject = (obj: unknown): obj is object => obj !== null && !Array.isArray(obj) && typeof obj === 'object'

function sortPlugins ({ plugins, order }: NuxtOptions['postcss']): string[] {
  const names = Object.keys(plugins)
  return typeof order === 'function' ? order(names) : (order || names)
}

export async function getPostcssConfig (nuxt: Nuxt) {
  if (!nuxt.options.webpack.postcss || !nuxt.options.postcss) {
    return false
  }

  const postcssOptions = defu({}, nuxt.options.postcss, {
    plugins: {
      /**
       * https://github.com/postcss/postcss-import
       */
      'postcss-import': {
        resolve: createResolver({
          alias: { ...nuxt.options.alias },
          modules: nuxt.options.modulesDir,
        }),
      },

      /**
       * https://github.com/postcss/postcss-url
       */
      'postcss-url': {},
    },
    sourceMap: nuxt.options.webpack.cssSourceMap,
  })

  const jiti = createJiti(nuxt.options.rootDir, { alias: nuxt.options.alias })

  // Keep the order of default plugins
  if (!Array.isArray(postcssOptions.plugins) && isPureObject(postcssOptions.plugins)) {
    // Map postcss plugins into instances on object mode once
    const plugins: Plugin[] = []
    for (const pluginName of sortPlugins(postcssOptions)) {
      const pluginOptions = postcssOptions.plugins[pluginName]
      if (!pluginOptions) { continue }

      let pluginFn: ((opts: Record<string, any>) => Plugin) | undefined
      for (const parentURL of nuxt.options.modulesDir) {
        pluginFn = await jiti.import(pluginName, { parentURL: parentURL.replace(/\/node_modules\/?$/, ''), try: true, default: true }) as (opts: Record<string, any>) => Plugin
        if (typeof pluginFn === 'function') {
          plugins.push(pluginFn(pluginOptions))
          break
        }
      }

      if (typeof pluginFn !== 'function') {
        console.warn(`[nuxt] could not import postcss plugin \`${pluginName}\`. Please report this as a bug.`)
      }
    }

    // @ts-expect-error we are mutating type here from object to array
    postcssOptions.plugins = plugins
  }

  return {
    sourceMap: nuxt.options.webpack.cssSourceMap,
    ...nuxt.options.webpack.postcss,
    postcssOptions,
  }
}
</file>

<file path="packages/webpack/src/index.ts">
export { bundle } from './webpack.ts'
</file>

<file path="packages/webpack/src/webpack.ts">
import pify from 'pify'
import { createError, defineEventHandler, fromNodeMiddleware, getRequestHeader, handleCors, setHeader } from 'h3'
import type { H3CorsOptions } from 'h3'
import type { IncomingMessage, MultiWatching, ServerResponse } from 'webpack-dev-middleware'
import webpackDevMiddleware from 'webpack-dev-middleware'
import webpackHotMiddleware from 'webpack-hot-middleware'
import type { Compiler, Stats, Watching } from 'webpack'
import { defu } from 'defu'
import type { NuxtBuilder } from '@nuxt/schema'
import { joinURL } from 'ufo'
import { logger, useNitro, useNuxt } from '@nuxt/kit'
import type { InputPluginOption } from 'rollup'

import { DynamicBasePlugin } from './plugins/dynamic-base.ts'
import { ChunkErrorPlugin } from './plugins/chunk.ts'
import { SSRStylesPlugin } from './plugins/ssr-styles.ts'
import { createMFS } from './utils/mfs.ts'
import { client, server } from './configs/index.ts'
import { applyPresets, createWebpackConfigContext } from './utils/config.ts'

import { builder, webpack } from '#builder'

// TODO: Support plugins
// const plugins: string[] = []

export const bundle: NuxtBuilder['bundle'] = async (nuxt) => {
  const webpackConfigs = await Promise.all([client, ...(nuxt.options.ssr ? [server] : [])].map(async (preset) => {
    const ctx = createWebpackConfigContext(nuxt)
    ctx.userConfig = defu(nuxt.options.webpack[`$${preset.name as 'client' | 'server'}`], ctx.userConfig)
    await applyPresets(ctx, preset)
    return ctx.config
  }))

  /** Remove Nitro rollup plugin for handling dynamic imports from webpack chunks */
  if (!nuxt.options.dev) {
    const nitro = useNitro()
    nitro.hooks.hook('rollup:before', (_nitro, config) => {
      const plugins = config.plugins as InputPluginOption[]

      const existingPlugin = plugins.findIndex(i => i && 'name' in i && i.name === 'dynamic-require')
      if (existingPlugin >= 0) {
        plugins.splice(existingPlugin, 1)
      }
    })
  }

  await nuxt.callHook(`${builder}:config`, webpackConfigs)

  // Initialize shared MFS for dev
  const mfs = nuxt.options.dev ? createMFS() : null

  const ssrStylesPlugin = nuxt.options.ssr && !nuxt.options.dev && nuxt.options.features.inlineStyles ? new SSRStylesPlugin(nuxt) : null

  for (const config of webpackConfigs) {
    config.plugins!.push(DynamicBasePlugin.webpack({
      sourcemap: !!nuxt.options.sourcemap[config.name as 'client' | 'server'],
    }))
    // Emit chunk errors if the user has opted in to `experimental.emitRouteChunkError`
    if (config.name === 'client' && nuxt.options.experimental.emitRouteChunkError && nuxt.options.builder !== '@nuxt/rspack-builder') {
      config.plugins!.push(new ChunkErrorPlugin())
    }
    if (ssrStylesPlugin) {
      config.plugins!.push(ssrStylesPlugin)
    }
  }

  await nuxt.callHook(`${builder}:configResolved`, webpackConfigs)

  // Configure compilers
  const compilers = webpackConfigs.map((config) => {
    // Create compiler
    const compiler = webpack(config)

    // In dev, write files in memory FS
    if (nuxt.options.dev && compiler) {
      compiler.outputFileSystem = mfs! as unknown as Compiler['outputFileSystem']
    }

    return compiler
  })

  nuxt.hook('close', async () => {
    for (const compiler of compilers) {
      await new Promise(resolve => compiler.close(resolve))
    }
  })

  // Start Builds
  if (nuxt.options.dev) {
    await Promise.all(compilers.map(c => compile(c)))
    return
  }

  for (const c of compilers) {
    await compile(c)
  }
}

async function createDevMiddleware (compiler: Compiler) {
  const nuxt = useNuxt()

  logger.debug('Creating webpack middleware...')

  // Create webpack dev middleware
  const devMiddleware = webpackDevMiddleware(compiler, {
    publicPath: joinURL(nuxt.options.app.baseURL, nuxt.options.app.buildAssetsDir),
    outputFileSystem: compiler.outputFileSystem as any,
    stats: 'none',
    ...nuxt.options.webpack.devMiddleware,
  })

  // @ts-expect-error need better types for `pify`
  nuxt.hook('close', () => pify(devMiddleware.close.bind(devMiddleware))())

  const { client: _client, ...hotMiddlewareOptions } = nuxt.options.webpack.hotMiddleware || {}
  const hotMiddleware = webpackHotMiddleware(compiler, {
    log: false,
    heartbeat: 10000,
    path: joinURL(nuxt.options.app.baseURL, '__webpack_hmr', compiler.options.name!),
    ...hotMiddlewareOptions,
  })

  // Register devMiddleware on server
  const devHandler = wdmToH3Handler(devMiddleware, nuxt.options.devServer.cors)
  const hotHandler = fromNodeMiddleware(hotMiddleware)
  await nuxt.callHook('server:devHandler', defineEventHandler(async (event) => {
    const body = await devHandler(event)
    if (body !== undefined) {
      return body
    }
    await hotHandler(event)
  }))

  return devMiddleware
}

// TODO: implement upstream in `webpack-dev-middleware`
function wdmToH3Handler (devMiddleware: webpackDevMiddleware.API<IncomingMessage, ServerResponse>, corsOptions: H3CorsOptions) {
  return defineEventHandler(async (event) => {
    const isPreflight = handleCors(event, corsOptions)
    if (isPreflight) {
      return null
    }

    // disallow cross-site requests in no-cors mode
    if (getRequestHeader(event, 'sec-fetch-mode') === 'no-cors' && getRequestHeader(event, 'sec-fetch-site') === 'cross-site') {
      throw createError({ status: 403 })
    }

    setHeader(event, 'Vary', 'Origin')

    event.context.webpack = {
      ...event.context.webpack,
      devMiddleware: devMiddleware.context,
    }
    const { req, res } = event.node
    const body = await new Promise((resolve, reject) => {
      // @ts-expect-error handle injected methods
      res.stream = (stream) => {
        resolve(stream)
      }
      // @ts-expect-error handle injected methods
      res.send = (data) => {
        resolve(data)
      }
      // @ts-expect-error handle injected methods
      res.finish = (data) => {
        resolve(data)
      }
      devMiddleware(req, res, (err) => {
        if (err) {
          reject(err)
        } else {
          resolve(undefined)
        }
      })
    })
    return body
  })
}

async function compile (compiler: Compiler) {
  const nuxt = useNuxt()

  await nuxt.callHook(`${builder}:compile`, { name: compiler.options.name!, compiler })

  // Load renderer resources after build
  compiler.hooks.done.tap('load-resources', async (stats) => {
    await nuxt.callHook(`${builder}:compiled`, { name: compiler.options.name!, compiler, stats })
  })

  // --- Dev Build ---
  if (nuxt.options.dev) {
    const compilersWatching: Array<Watching | MultiWatching> = []

    nuxt.hook('close', async () => {
      await Promise.all(compilersWatching.map(watching => watching && pify(watching.close.bind(watching))()))
    })

    // Client build
    if (compiler.options.name === 'client') {
      return new Promise((resolve, reject) => {
        compiler.hooks.done.tap('nuxt-dev', () => { resolve(null) })
        compiler.hooks.failed.tap('nuxt-errorlog', (err) => { reject(err) })
        // Start watch
        createDevMiddleware(compiler).then((devMiddleware) => {
          if (devMiddleware.context.watching) {
            compilersWatching.push(devMiddleware.context.watching)
          }
        })
      })
    }

    // Server, build and watch for changes
    return new Promise((resolve, reject) => {
      const watching = compiler.watch(nuxt.options.watchers.webpack, (err) => {
        if (err) { return reject(err) }
        resolve(null)
      })

      compilersWatching.push(watching)
    })
  }

  // --- Production Build ---
  const stats = await new Promise<Stats>((resolve, reject) => compiler.run((err, stats) => err ? reject(err) : resolve(stats!)))

  if (stats.hasErrors()) {
    const error = new Error('Nuxt build error')
    error.stack = stats.toString('errors-only')
    throw error
  }
}
</file>

<file path="packages/webpack/.attw.json">
{
  "ignoreRules": ["cjs-resolves-to-esm"]
}
</file>

<file path="packages/webpack/build.config.ts">
import { defineBuildConfig } from 'unbuild'
import { addRollupTimingsPlugin } from '../../debug/build-config.ts'

export default defineBuildConfig({
  declaration: true,
  rollup: {
    dts: {
      respectExternal: false,
    },
  },
  entries: [
    'src/index',
    'src/loaders/vue-module-identifier',
  ],
  hooks: {
    'rollup:options' (ctx, options) {
      addRollupTimingsPlugin(options)
    },
  },
  dependencies: [
    '@nuxt/kit',
    'unplugin',
    'postcss',
    'postcss-loader',
    'vue-loader',
    'css-loader',
    'file-loader',
    'url-loader',
    'vue',
  ],
  externals: [
    '#builder',
    '@nuxt/schema',
  ],
})
</file>

<file path="packages/webpack/builder.d.ts">
declare module '#builder' {
  import type Webpack from 'webpack'
  import type MiniCssExtractPlugin from 'mini-css-extract-plugin'
  import type TsCheckerPlugin from 'fork-ts-checker-webpack-plugin'

  export const webpack: typeof Webpack
  export const WebpackBarPlugin: typeof import('webpackbar').default
  export const MiniCssExtractPlugin: typeof MiniCssExtractPlugin
  export const TsCheckerPlugin: typeof TsCheckerPlugin
  export const builder: 'webpack' | 'rspack'
}
</file>

<file path="packages/webpack/builder.mjs">
export const builder = 'webpack'
export { default as webpack } from 'webpack'
export { default as MiniCssExtractPlugin } from 'mini-css-extract-plugin'
export { default as WebpackBarPlugin } from 'webpackbar'
export { default as TsCheckerPlugin } from 'fork-ts-checker-webpack-plugin'
</file>

<file path="packages/webpack/package.json">
{
  "name": "@nuxt/webpack-builder",
  "version": "4.2.2",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nuxt/nuxt.git",
    "directory": "packages/webpack"
  },
  "description": "Webpack bundler for Nuxt",
  "homepage": "https://nuxt.com",
  "license": "MIT",
  "type": "module",
  "types": "./dist/index.d.ts",
  "imports": {
    "#builder": "./builder.mjs",
    "#vue-module-identifier": "./dist/loaders/vue-module-identifier.mjs"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs"
    },
    "./dist/*": "./dist/*"
  },
  "files": [
    "dist",
    "builder.mjs"
  ],
  "scripts": {
    "prepack": "unbuild",
    "build:stub": "unbuild --stub",
    "test:attw": "attw --pack"
  },
  "dependencies": {
    "@nuxt/friendly-errors-webpack-plugin": "^2.6.0",
    "@nuxt/kit": "workspace:*",
    "@vue/compiler-sfc": "3.5.26",
    "autoprefixer": "^10.4.23",
    "css-loader": "^7.1.2",
    "css-minimizer-webpack-plugin": "^7.0.4",
    "cssnano": "^7.1.2",
    "defu": "^6.1.4",
    "esbuild-loader": "^4.4.2",
    "escape-string-regexp": "^5.0.0",
    "exsolve": "^1.0.8",
    "file-loader": "^6.2.0",
    "fork-ts-checker-webpack-plugin": "^9.1.0",
    "h3": "^1.15.4",
    "jiti": "^2.6.1",
    "knitwork": "^1.3.0",
    "magic-string": "^0.30.21",
    "memfs": "^4.51.1",
    "mini-css-extract-plugin": "^2.9.4",
    "mlly": "^1.8.0",
    "ohash": "^2.0.11",
    "pathe": "^2.0.3",
    "pify": "^6.1.0",
    "postcss": "^8.5.6",
    "postcss-import": "^16.1.1",
    "postcss-import-resolver": "^2.0.0",
    "postcss-loader": "^8.2.0",
    "postcss-url": "^10.1.3",
    "pug-plain-loader": "^1.1.0",
    "seroval": "^1.4.2",
    "std-env": "^3.10.0",
    "time-fix-plugin": "^2.0.7",
    "tinyglobby": "^0.2.15",
    "ufo": "^1.6.1",
    "unenv": "^2.0.0-rc.24",
    "unplugin": "^2.3.11",
    "url-loader": "^4.1.1",
    "vue-bundle-renderer": "^2.2.0",
    "vue-loader": "^17.4.2",
    "webpack": "^5.104.1",
    "webpack-bundle-analyzer": "^5.1.0",
    "webpack-dev-middleware": "^7.4.5",
    "webpack-hot-middleware": "^2.26.1",
    "webpackbar": "^7.0.0"
  },
  "devDependencies": {
    "@nuxt/schema": "workspace:*",
    "@rspack/core": "1.7.0",
    "@types/webpack-bundle-analyzer": "4.7.0",
    "@types/webpack-hot-middleware": "2.25.12",
    "rollup": "4.54.0",
    "unbuild": "3.6.1",
    "vue": "3.5.26"
  },
  "peerDependencies": {
    "nuxt": "workspace:*",
    "vue": "^3.3.4"
  },
  "engines": {
    "node": "^20.9.0 || >=22.0.0"
  }
}
</file>

<file path="patches/changelogen.patch">
diff --git a/dist/shared/changelogen.D-9f3HTX.mjs b/dist/shared/changelogen.D-9f3HTX.mjs
index dd70b3f4651f1691c1f4e4cb22862079f8c02c05..6420bbf7698a591a37cefdd9bd515b13c2d10fed 100644
--- a/dist/shared/changelogen.D-9f3HTX.mjs
+++ b/dist/shared/changelogen.D-9f3HTX.mjs
@@ -11,7 +11,7 @@ import { execSync } from 'node:child_process';
 import { readPackageJSON } from 'pkg-types';
 
 function execCommand(cmd, cwd) {
-  return execSync(cmd, { encoding: "utf8", cwd }).trim();
+  return execSync(cmd, { encoding: "utf8", cwd, maxBuffer: 10 * 1024 * 1024 }).trim();
 }
 
 async function getLastGitTag(cwd) {
</file>

<file path="playground/app/app.vue">
<script setup lang="ts">
</script>

<template>
  <!-- Edit this file to play around with Nuxt but never commit changes! -->
  <div>
    Nuxt Playground
  </div>
</template>

<style scoped>

</style>
</file>

<file path="playground/server/api/test.ts">
export default eventHandler((_event) => {
  return 'Hello!'
})
</file>

<file path="playground/nuxt.config.ts">
export default defineNuxtConfig({
  devtools: { enabled: true },
  compatibilityDate: 'latest',
})
</file>

<file path="playground/package.json">
{
  "name": "nuxt-playground",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "nuxt dev",
    "build": "nuxt build",
    "start": "nuxt preview"
  },
  "dependencies": {
    "nuxt": "workspace:*"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="playground/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="scripts/_utils.ts">
import process from 'node:process'
import { promises as fsp } from 'node:fs'
import { $fetch } from 'ofetch'
import { resolve } from 'pathe'
import { compare } from 'semver'
import { glob } from 'tinyglobby'
import { exec } from 'tinyexec'
import { determineSemverChange, getGitDiff, loadChangelogConfig, parseCommits } from 'changelogen'

export interface Dep {
  name: string
  range: string
  type: string
}

type ThenArg<T> = T extends PromiseLike<infer U> ? U : T
export type Package = ThenArg<ReturnType<typeof loadPackage>>

export async function loadPackage (dir: string) {
  const pkgPath = resolve(dir, 'package.json')
  const data = JSON.parse(await fsp.readFile(pkgPath, 'utf-8').catch(() => '{}'))
  const save = () => fsp.writeFile(pkgPath, JSON.stringify(data, null, 2) + '\n')

  const updateDeps = (reviver: (dep: Dep) => Dep | void) => {
    for (const type of ['dependencies', 'devDependencies', 'optionalDependencies', 'peerDependencies']) {
      if (!data[type]) { continue }
      for (const e of Object.entries(data[type])) {
        const dep: Dep = { name: e[0], range: e[1] as string, type }
        delete data[type][dep.name]
        const updated = reviver(dep) || dep
        data[updated.type] ||= {}
        data[updated.type][updated.name] = updated.range
      }
    }
  }

  return {
    dir,
    data,
    save,
    updateDeps,
  }
}

export async function loadWorkspace (dir: string) {
  const workspacePkg = await loadPackage(dir)
  const pkgDirs = (await glob(['packages/*', 'docs'], { onlyDirectories: true })).sort()

  const packages: Package[] = []

  for (const pkgDir of pkgDirs) {
    const pkg = await loadPackage(pkgDir)
    if (!pkg.data.name) { continue }
    packages.push(pkg)
  }

  const find = (name: string) => {
    const pkg = packages.find(pkg => pkg.data.name === name)
    if (!pkg) {
      throw new Error('Workspace package not found: ' + name)
    }
    return pkg
  }

  const rename = (from: string, to: string) => {
    find(from).data._name = find(from).data.name
    find(from).data.name = to
    for (const pkg of packages) {
      pkg.updateDeps((dep) => {
        if (dep.name === from && !dep.range.startsWith('npm:')) {
          dep.range = 'npm:' + to + '@' + dep.range
        }
      })
    }
  }

  const setVersion = (name: string, newVersion: string, opts: { updateDeps?: boolean } = {}) => {
    find(name).data.version = newVersion
    if (!opts.updateDeps) { return }

    for (const pkg of packages) {
      pkg.updateDeps((dep) => {
        if (dep.name === name) {
          dep.range = newVersion
        }
      })
    }
  }

  const save = () => Promise.all(packages.map(pkg => pkg.save()))

  return {
    dir,
    workspacePkg,
    packages,
    save,
    find,
    rename,
    setVersion,
  }
}

export async function determineBumpType (since?: string) {
  const config = await loadChangelogConfig(process.cwd())
  const commits = await getLatestCommits(since)

  return determineSemverChange(commits, config)
}

export async function getLatestTag () {
  const { stdout: latestTag } = await exec('git', ['describe', '--tags', '--abbrev=0'])
  return latestTag.trim()
}

export async function getLatestReleasedTag () {
  const latestReleasedTag = await exec('git', ['tag', '-l']).then(r => r.stdout.trim().split('\n').filter(t => /v3\.\d+\.\d+/.test(t)).sort(compare)).then(r => r.pop()!.trim())
  return latestReleasedTag
}

export async function getPreviousReleasedCommits () {
  const config = await loadChangelogConfig(process.cwd())
  const latestTag = await getLatestTag()
  const latestReleasedTag = await getLatestReleasedTag()
  const commits = parseCommits(await getGitDiff(latestTag, latestReleasedTag), config)
  return commits
}

export async function getLatestCommits (since?: string) {
  const config = await loadChangelogConfig(process.cwd())
  const latestTag = await getLatestTag()

  // If filtering by date, get commits with git log --since
  if (since) {
    const { stdout } = await exec('git', ['log', `${latestTag}..HEAD`, '--since', since, '--pretty=format:%H'])
    const commitHashes = new Set(stdout.trim().split('\n').filter(Boolean))

    const allCommits = parseCommits(await getGitDiff(latestTag), config)
    return allCommits.filter((commit) => {
      // Match against full hash (shortHash is abbreviated)
      return Array.from(commitHashes).some(hash => hash.startsWith(commit.shortHash))
    })
  }

  return parseCommits(await getGitDiff(latestTag), config)
}

export async function getContributors (since?: string) {
  const contributors = [] as Array<{ name: string, username: string }>
  const emails = new Set<string>()
  const latestTag = await getLatestTag()

  const rawCommits = await getGitDiff(latestTag)

  // Get commit hashes filtered by date if specified
  let allowedHashes: Set<string> | null = null
  if (since) {
    const { stdout } = await exec('git', ['log', `${latestTag}..HEAD`, '--since', since, '--pretty=format:%H'])
    allowedHashes = new Set(stdout.trim().split('\n').filter(Boolean))
  }

  for (const commit of rawCommits) {
    // Filter by date if specified
    if (allowedHashes && !Array.from(allowedHashes).some(hash => hash.startsWith(commit.shortHash))) {
      continue
    }

    if (emails.has(commit.author.email) || commit.author.name === 'renovate[bot]') { continue }
    const { author } = await $fetch<{ author: { login: string, email: string } }>(`https://api.github.com/repos/nuxt/nuxt/commits/${commit.shortHash}`, {
      headers: {
        'User-Agent': 'nuxt/nuxt',
        'Accept': 'application/vnd.github.v3+json',
        'Authorization': `token ${process.env.GITHUB_TOKEN}`,
      },
    }).catch(() => ({ author: null }))
    if (!author) { continue }
    if (!contributors.some(c => c.username === author.login)) {
      contributors.push({ name: commit.author.name, username: author.login })
    }
    emails.add(author.email)
  }
  return contributors
}
</file>

<file path="scripts/bump-nightly.ts">
import process from 'node:process'
import { execSync } from 'node:child_process'
import { inc } from 'semver'
import { determineBumpType, getLatestTag, loadWorkspace } from './_utils.ts'

const nightlyPackages = {
  // nitro: 'nitro-nightly',
  // h3: 'h3-nightly',
  'nuxi': 'nuxi-nightly',
  '@nuxt/cli': '@nuxt/cli-nightly',
}

export async function bumpNightly () {
  const workspace = await loadWorkspace(process.cwd())

  const commit = execSync('git rev-parse --short HEAD').toString('utf-8').trim().slice(0, 8)
  const date = Math.round(Date.now() / (1000 * 60))

  // TODO: revert after release of v4.2.0
  // Get the date of the latest tag to filter out merged history commits
  const latestTagName = await getLatestTag()
  const tagDate = execSync(`git log -1 --format=%ai ${latestTagName}`, { encoding: 'utf-8' })
  const sinceDate = tagDate.trim()

  const bumpType = await determineBumpType(sinceDate)

  for (const pkg of workspace.packages.filter(p => !p.data.private)) {
    const newVersion = inc(pkg.data.version, bumpType || 'patch')
    if (!newVersion) {
      throw new Error(`Failed to increment version for package ${pkg.data.name} with version ${pkg.data.version}`)
    }

    workspace.setVersion(pkg.data.name, `${newVersion}-${date}.${commit}`, {
      updateDeps: true,
    })
    for (const [name, nightlyName] of Object.entries(nightlyPackages)) {
      if (pkg.data.dependencies && name in pkg.data.dependencies) {
        pkg.data.dependencies[name] = `npm:${nightlyName}@latest`
      }
    }
    const newname = pkg.data.name + '-nightly'
    workspace.rename(pkg.data.name, newname)
  }

  await workspace.save()
}
</file>

<file path="scripts/bump.ts">
import process from 'node:process'
import { consola } from 'consola'
import { loadWorkspace } from './_utils'

async function main () {
  const workspace = await loadWorkspace(process.cwd())

  const newVersion = process.argv[2]
  if (!newVersion) {
    throw new Error('Please provide version!')
  }

  for (const pkg of workspace.packages.filter(p => !p.data.private)) {
    workspace.setVersion(pkg.data.name, newVersion!)
  }

  await workspace.save()
}

main().catch((err) => {
  consola.error(err)
  process.exit(1)
})
</file>

<file path="scripts/example.sh">
#!/bin/bash

pnpm --filter example-$2 $1
</file>

<file path="scripts/release.ts">
/* eslint-disable no-console */
import process from 'node:process'
import { execSync } from 'node:child_process'
import { copyFileSync, readFileSync, readdirSync, writeFileSync } from 'node:fs'
import { resolve } from 'node:path'

interface PackageJson {
  name: string
  version: string
}

function execCommand (command: string, cwd?: string): void {
  console.info(`🔧 Running: ${command}`)
  execSync(command, { stdio: 'inherit', cwd })
}

function readPackageJson (dir: string): PackageJson {
  const pkgPath = resolve(dir, 'package.json')
  return JSON.parse(readFileSync(pkgPath, 'utf-8'))
}

async function main () {
  const originalCwd = process.cwd()
  const isNightly = process.argv.includes('--nightly')
  const tagsInput = process.env.TAG || 'latest'
  const allTags = tagsInput
    .split(',')
    .map(tag => tag.trim())
    .filter(Boolean)

  console.info(`🚀 ${isNightly ? 'Nightly' : 'Regular'} release with tags: ${allTags.join(', ')}`)

  const [tag, ...additionalTags] = allTags

  try {
    // Restore all git changes
    console.info('🔄 Restoring git changes...')
    execCommand('git restore -s@ -SW -- packages examples docs')

    if (isNightly) {
      // Bump versions to nightly
      console.info('🌙 Bumping versions to nightly...')
      await import('./bump-nightly.ts').then(r => r.bumpNightly())
    } else {
      execCommand('pnpm build')
    }

    // Use absolute URLs for better rendering on npm
    console.info('🔗 Updating README URLs...')
    const originalReadme = readFileSync('README.md', 'utf-8')
    const readme = originalReadme.replace(
      /\.\/\.github\/assets/g,
      'https://github.com/nuxt/nuxt/blob/main/.github/assets',
    )
    writeFileSync('README.md', readme)

    const repoRoot = resolve(import.meta.dirname, '..')

    // Get all package directories
    const packageDirs = [
      ...readdirSync('packages', { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => `packages/${dirent.name}`),
      'docs',
    ]

    // Release packages
    const packagesToSkip = ['packages/nuxi', 'packages/test-utils', 'packages/ui-templates']
    for (const pkgDir of packageDirs) {
      if (packagesToSkip.includes(pkgDir)) {
        continue
      }

      console.info(`📦 Publishing ${pkgDir}`)
      process.chdir(pkgDir)

      // Copy LICENSE
      copyFileSync(resolve(repoRoot, 'LICENSE'), 'LICENSE')

      // Copy README if not docs
      if (pkgDir !== 'docs') {
        copyFileSync(resolve(repoRoot, 'README.md'), 'README.md')
      }

      // Publish with first tag, then add additional tags
      console.info(`🏷️ Publishing ${pkgDir} with tag: ${tag}`)
      execCommand(`pnpm publish --access public --no-git-checks --tag ${tag}`)

      // Add additional tags if there are more than one
      const pkg = readPackageJson('.')
      for (const additionalTag of additionalTags) {
        console.info(`🏷️ Adding tag ${additionalTag} to ${pkg.name}@${pkg.version}`)
        try {
          execCommand(`npm dist-tag add "${pkg.name}@${pkg.version}" ${additionalTag}`)
        } catch (error) {
          console.error(`❌ Failed to add tag ${additionalTag} to ${pkg.name}@${pkg.version}:`, error)
          throw error
        }
      }

      process.chdir(repoRoot)
    }

    // Restore README
    writeFileSync('README.md', originalReadme)

    console.info(`🎉 ${isNightly ? 'Nightly' : 'Regular'} release completed successfully!`)
  } catch (error) {
    console.error('💥 Release failed:', error)
    process.exit(1)
  } finally {
    process.chdir(originalCwd)
  }
}

main()
</file>

<file path="scripts/update-changelog.ts">
import process from 'node:process'
import { execSync } from 'node:child_process'
import { $fetch } from 'ofetch'
import { inc } from 'semver'
import { generateMarkDown, getCurrentGitBranch, loadChangelogConfig } from 'changelogen'
import { consola } from 'consola'
import { determineBumpType, getContributors, getLatestCommits, getLatestReleasedTag, getLatestTag, getPreviousReleasedCommits, loadWorkspace } from './_utils.ts'

const handleSeparateBranch = false

async function main () {
  const releaseBranch = getCurrentGitBranch()
  const workspace = await loadWorkspace(process.cwd())
  const config = await loadChangelogConfig(process.cwd(), {})

  const prevMessages = new Set(handleSeparateBranch ? await getPreviousReleasedCommits().then(r => r.map(c => c.message)) : [])

  // TODO: revert after release of v4.2.0
  // Get the date of the latest tag to filter out merged history commits
  const latestTagName = await getLatestTag()
  const tagDate = execSync(`git log -1 --format=%ai ${latestTagName}`, { encoding: 'utf-8' })
  const sinceDate = tagDate.trim()

  const commits = await getLatestCommits(sinceDate).then(commits => commits.filter(
    c => config.types[c.type] && !(c.type === 'chore' && c.scope === 'deps') && !prevMessages.has(c.message),
  ))
  const bumpType = await determineBumpType(sinceDate) || 'patch'

  const newVersion = inc(workspace.find('nuxt').data.version, bumpType)
  const changelog = await generateMarkDown(commits, config)

  // Create and push a branch with bumped versions if it has not already been created
  const branchExists = execSync(`git ls-remote --heads origin v${newVersion}`).toString().trim().length > 0
  if (!branchExists) {
    execSync('git config --global user.email "daniel@roe.dev"')
    execSync('git config --global user.name "Daniel Roe"')
    execSync(`git checkout -b v${newVersion}`)

    for (const pkg of workspace.packages.filter(p => !p.data.private)) {
      workspace.setVersion(pkg.data.name, newVersion!)
    }
    await workspace.save()

    execSync(`git commit -am v${newVersion}`)
    execSync(`git push -u origin v${newVersion}`)
  }

  // Get the current PR for this release, if it exists
  const [currentPR] = await $fetch(`https://api.github.com/repos/nuxt/nuxt/pulls?head=nuxt:v${newVersion}`)
  const contributors = await getContributors(sinceDate)

  const latestTag = latestTagName
  const previousReleasedTag = handleSeparateBranch ? await getLatestReleasedTag() : latestTag

  const releaseNotes = [
    currentPR?.body.replace(/## 👉 Changelog[\s\S]*$/, '') || `> ${newVersion} is the next ${bumpType} release.\n>\n> **Timetable**: to be announced.`,
    '## 👉 Changelog',
    changelog
      .replace(/^## v.*\n/, '')
      .replace(`...${releaseBranch}`, `...v${newVersion}`)
      .replace(/### ❤️ Contributors[\s\S]*$/, '')
      .replace(/[\n\r]+/g, '\n')
      .replace(latestTag, previousReleasedTag),
    '### ❤️ Contributors',
    contributors.map(c => `- ${c.name} (@${c.username})`).join('\n'),
  ].join('\n')

  // Create a PR with release notes if none exists
  if (!currentPR) {
    return await $fetch('https://api.github.com/repos/nuxt/nuxt/pulls', {
      method: 'POST',
      headers: {
        Authorization: `token ${process.env.GITHUB_TOKEN}`,
      },
      body: {
        title: `v${newVersion}`,
        head: `v${newVersion}`,
        base: releaseBranch,
        body: releaseNotes,
        draft: true,
      },
    })
  }

  // Update release notes if the pull request does exist
  await $fetch(`https://api.github.com/repos/nuxt/nuxt/pulls/${currentPR.number}`, {
    method: 'PATCH',
    headers: {
      Authorization: `token ${process.env.GITHUB_TOKEN}`,
    },
    body: {
      body: releaseNotes,
    },
  })
}

main().catch((err) => {
  consola.error(err)
  process.exit(1)
})
</file>

<file path="test/e2e/global.setup.ts">
import { existsSync } from 'node:fs'
import { fileURLToPath } from 'node:url'
import { cp, rm } from 'node:fs/promises'
import { test as setup } from '@playwright/test'

const fixtureDir = fileURLToPath(new URL('../fixtures-temp/hmr', import.meta.url))
const sourceDir = fileURLToPath(new URL('../fixtures/hmr', import.meta.url))

setup('create temporary hmr fixture directory', async () => {
  if (existsSync(fixtureDir)) {
    await rm(fixtureDir, { force: true, recursive: true })
  }
  await cp(sourceDir, fixtureDir, {
    recursive: true,
    filter: (src) => {
      return !src.includes('.cache') && !src.endsWith('.sock') && !src.includes('.output') && !src.includes('.nuxt-')
    },
  })
})
</file>

<file path="test/e2e/global.teardown.ts">
import { existsSync } from 'node:fs'
import { fileURLToPath } from 'node:url'
import { rm } from 'node:fs/promises'
import { test as teardown } from '@playwright/test'

const fixtureDir = fileURLToPath(new URL('../fixtures-temp/hmr', import.meta.url))

teardown('remove temporary hmr fixture directory', async () => {
  if (existsSync(fixtureDir)) {
    await rm(fixtureDir, { force: true, recursive: true })
  }
})
</file>

<file path="test/e2e/hmr.test.ts">
import { readFileSync, renameSync, writeFileSync } from 'node:fs'
import { fileURLToPath } from 'node:url'
import { rm } from 'node:fs/promises'
import { isWindows } from 'std-env'
import { join } from 'pathe'
import { expect, test } from './test-utils'
import { isBuilt, isWebpack } from '../matrix'

const fixtureDir = fileURLToPath(new URL('../fixtures-temp/hmr', import.meta.url))
const sourceDir = fileURLToPath(new URL('../fixtures/hmr', import.meta.url))

test.use({
  nuxt: {
    rootDir: fixtureDir,
    dev: true,
    setupTimeout: (isWindows ? 360 : 120) * 1000,
    env: { TEST: '1' },
    nuxtConfig: {
      test: true,
    },
  },
})

if (isBuilt || isWindows) {
  test.skip('Skipped: HMR tests are skipped on Windows or in built mode', () => {})
} else {
  test.describe.configure({ mode: 'serial' })

  // Load the fixture file
  const indexVue = readFileSync(join(sourceDir, 'app/pages/index.vue'), 'utf8')

  test('basic HMR functionality', async ({ page, goto }) => {
    // Navigate to the page
    writeFileSync(join(fixtureDir, 'app/pages/index.vue'), indexVue)
    await goto('/')

    // Check initial state
    await expect(page).toHaveTitle('HMR fixture')
    await expect(page.locator('[data-testid="count"]')).toHaveText('1')

    // Test reactivity
    await page.locator('button').click()
    await expect(page.locator('[data-testid="count"]')).toHaveText('2')

    // Modify the file and check for HMR updates
    let newContents = indexVue
      .replace('<Title>HMR fixture</Title>', '<Title>HMR fixture HMR</Title>')
      .replace('<h1>Home page</h1>', '<h1>Home page - but not as you knew it</h1>')
    newContents += '<style scoped>\nh1 { color: red }\n</style>'

    writeFileSync(join(fixtureDir, 'app/pages/index.vue'), newContents)

    // Wait for the title to be updated via HMR
    await expect(page).toHaveTitle('HMR fixture HMR')

    // Check content HMR
    const h1 = page.locator('h1')
    await expect(h1).toHaveText('Home page - but not as you knew it')

    // Check style HMR
    const h1Color = await h1.evaluate(el => window.getComputedStyle(el).getPropertyValue('color'))
    expect(h1Color).toBe('rgb(255, 0, 0)')

    expect(page).toHaveNoErrorsOrWarnings()
  })

  test('detecting new routes', async ({ fetch }) => {
    // Try accessing a non-existent route
    await rm(join(fixtureDir, 'app/pages/some-404.vue'), { force: true })
    const res = await fetch('/some-404')
    expect(res.status).toBe(404)

    // Create a new page file
    writeFileSync(join(fixtureDir, 'app/pages/some-404.vue'), indexVue)

    // Wait for the new route to be available
    await expect(() => fetch('/some-404').then(r => r.status).catch(() => false)).toBeWithPolling(200)
  })

  test('hot reloading route rules', async ({ fetch }) => {
    // Check the initial header
    const file = readFileSync(join(sourceDir, 'app/pages/route-rules.vue'), 'utf8')
    writeFileSync(join(fixtureDir, 'app/pages/route-rules.vue'), file)

    await expect(() => fetch('/route-rules').then(r => r.headers.get('x-extend')).catch(() => null)).toBeWithPolling('added in routeRules')

    await new Promise(resolve => setTimeout(resolve, 100))

    // Modify the route rules
    writeFileSync(join(fixtureDir, 'app/pages/route-rules.vue'), file.replace('added in routeRules', 'edited in dev'))

    // Wait for the route rule to be hot reloaded
    await expect(() => fetch('/route-rules').then(r => r.headers.get('x-extend')).catch(() => null)).toBeWithPolling('edited in dev')
  })

  test('HMR for island components', async ({ page, goto }) => {
    // Navigate to the page with the island components
    await goto('/server-component')

    const componentPath = join(fixtureDir, 'app/components/islands/HmrComponent.vue')
    const componentContents = readFileSync(componentPath, 'utf8')

    // Test initial state of the component
    await expect(page.getByTestId('hmr-id')).toHaveText('0')

    // Function to update the component and check for changes
    const triggerHmr = (number: string) => writeFileSync(componentPath, componentContents.replace('ref(0)', `ref(${number})`))

    // First edit
    triggerHmr('1')
    await expect(page.getByTestId('hmr-id')).toHaveText('1', { timeout: 10000 })

    // Second edit to make sure HMR is working consistently
    triggerHmr('2')
    await expect(page.getByTestId('hmr-id')).toHaveText('2', { timeout: 10000 })

    expect(page).toHaveNoErrorsOrWarnings()
  })

  // Skip if using webpack since this test only works with Vite
  if (!isWebpack) {
    test('HMR for page meta', async ({ page, goto }) => {
      const pageContents = readFileSync(join(sourceDir, 'app/pages/page-meta.vue'), 'utf8')
      writeFileSync(join(fixtureDir, 'app/pages/page-meta.vue'), pageContents)

      await goto('/page-meta')

      // Check initial meta state
      await expect(page.getByTestId('meta')).toHaveText(JSON.stringify({ some: 'stuff' }, null, 2))

      // Update the meta
      writeFileSync(join(fixtureDir, 'app/pages/page-meta.vue'), pageContents.replace(`some: 'stuff'`, `some: 'other stuff'`))

      // Check if meta updates
      await expect(page.getByTestId('meta')).toHaveText(JSON.stringify({ some: 'other stuff' }, null, 2))

      // Verify no errors in console
      expect(page).toHaveNoErrorsOrWarnings()
    })

    test('HMR on page should keep ref state when updating template', async ({ goto, page }) => {
      await goto('/state-component')

      const pagePath = join(fixtureDir, 'app/pages/state-component.vue')
      const pageContents = readFileSync(pagePath, 'utf8')

      const button = page.getByTestId('button')
      await expect(button).toHaveText('0')
      await button.click()
      await expect(button).toHaveText('1')

      writeFileSync(
        pagePath,
        pageContents.replace('#hmr-template', '#hmr-template updated'),
      )
      const consoleLogs: Array<{ type: string, text: string }> = []
      page.on('console', (msg) => {
        consoleLogs.push({
          type: msg.type(),
          text: msg.text(),
        })
      })

      // Wait for HMR to process the new route
      await expect(() => consoleLogs.some(log => log.text.includes('hmr'))).toBeWithPolling(true)

      await expect.soft(button).toHaveText('1')
    })

    test('HMR on page should keep ref state when updating script', async ({ goto, page }) => {
      await goto('/state-component')

      const pagePath = join(fixtureDir, 'app/pages/state-component.vue')
      const pageContents = readFileSync(pagePath, 'utf8')

      const button = page.getByTestId('button')
      await expect(button).toHaveText('0')
      await button.click()
      await expect(button).toHaveText('1')

      writeFileSync(
        pagePath,
        pageContents.replace('#hmr-script', '#hmr-script updated'),
      )
      const consoleLogs: Array<{ type: string, text: string }> = []
      page.on('console', (msg) => {
        consoleLogs.push({
          type: msg.type(),
          text: msg.text(),
        })
      })

      // Wait for HMR to process the new route
      await expect(() => consoleLogs.some(log => log.text.includes('hmr'))).toBeWithPolling(true)

      await expect.soft(button).toHaveText('1')
    })

    test('HMR for routes', async ({ page, goto }) => {
      await goto('/routes')

      // Create a new route that doesn't exist yet
      writeFileSync(
        join(fixtureDir, 'app/pages/routes/non-existent.vue'),
        `<template><div data-testid="contents">A new route!</div></template>`,
      )

      // Track console logs
      const consoleLogs: Array<{ type: string, text: string }> = []
      page.on('console', (msg) => {
        consoleLogs.push({
          type: msg.type(),
          text: msg.text(),
        })
      })

      // Wait for HMR to process the new route
      await expect(() => consoleLogs.some(log => log.text.includes('hmr'))).toBeWithPolling(true)

      // Navigate to the new route
      await page.locator('a[href="/routes/non-existent"]').click()

      // Verify the new route content is rendered
      await expect(page.getByTestId('contents')).toHaveText('A new route!')

      // Filter expected warnings about route not existing before the update
      const filteredLogs = consoleLogs.filter(log => (log.type === 'warning' || log.type === 'error') && !log.text.includes('No match found for location with path "/routes/non-existent"'))

      // Verify no unexpected errors
      expect(filteredLogs).toStrictEqual([])
    })

    test.fail('should support renaming files to same import name', async ({ page, goto }) => {
      await goto('/rename-component')

      await expect(page.getByTestId('example')).toHaveText('test.vue')

      renameSync(join(fixtureDir, 'app/components/example/test.vue'), join(fixtureDir, 'app/components/example/example-test.vue'))

      writeFileSync(
        join(fixtureDir, 'app/components/example/example-test.vue'),
        `<template><div data-testid="example">example-test.vue</div></template>`,
      )

      await expect.soft(page.getByTestId('example')).toHaveText('example-test.vue')

      await page.reload()

      await expect(page.getByTestId('example')).toHaveText('example-test.vue')
    })

    test('should allow hmr with useAsyncData (#32177)', async ({ page, goto }) => {
      await goto('/issues/32177')

      const pageContents = readFileSync(join(sourceDir, 'app/pages/issues/32177.vue'), 'utf8')
      writeFileSync(join(fixtureDir, 'app/pages/issues/32177.vue'), pageContents.replace('// #HMR_REPLACE', 'console.log("hmr")'))
      await expect(page.getByTestId('contents')).toHaveText('Element 1, Element 2')
    })

    test('HMR with top-level await', async ({ page, goto }) => {
      const pageContents = readFileSync(join(sourceDir, 'app/pages/top-level-await.vue'), 'utf8')
      writeFileSync(join(fixtureDir, 'app/pages/top-level-await.vue'), pageContents)

      // Navigate and wait for full load
      await goto('/top-level-await')
      await expect(page.getByTestId('content')).toHaveText('loaded')

      // Trigger HMR by editing script
      writeFileSync(
        join(fixtureDir, 'app/pages/top-level-await.vue'),
        pageContents.replace('console.log(\'page loaded\')', '// console.log(\'page loaded\')'),
      )

      // Wait for HMR to process and check no errors
      await page.waitForTimeout(1000)
      expect(page).toHaveNoErrorsOrWarnings()
    })
  }
}
</file>

<file path="test/e2e/runtime-compiler.test.ts">
import { fileURLToPath } from 'node:url'
import { isWindows } from 'std-env'
import { join } from 'pathe'
import { expect, test } from './test-utils'
import { isDev } from '../matrix'

/**
 * This test suite verifies that Vue's runtime compiler works correctly within Nuxt,
 * testing various ways of using runtime-compiled components across multiple pages.
 */

const fixtureDir = fileURLToPath(new URL('../fixtures/runtime-compiler', import.meta.url))

// Run tests in parallel in production mode, but serially in dev mode
// to avoid interference between HMR and test execution
test.describe.configure({ mode: isDev ? 'serial' : 'parallel' })

test.use({
  nuxt: {
    rootDir: fixtureDir,
    dev: isDev,
    server: true,
    browser: true,
    setupTimeout: (isWindows ? 360 : 120) * 1000,
    nuxtConfig: {
      buildDir: isDev ? join(fixtureDir, '.nuxt', 'test', Math.random().toString(36).slice(2, 8)) : undefined,
    },
  },
})

test.describe('Runtime compiler functionality', () => {
  /**
   * Tests that the overview page loads without errors
   */
  test('should render the overview page without errors', async ({ page, goto }) => {
    await goto('/')
    await expect(page.getByTestId('page-title')).toHaveText('Nuxt Runtime Compiler Tests')
    expect(page).toHaveNoErrorsOrWarnings()
  })

  /**
   * Tests the basic component with template string
   */
  test('should render HelloWorld.vue with template string via runtime compiler', async ({ page, goto }) => {
    await goto('/basic-component')

    await expect(page.getByTestId('hello-world')).toHaveText('hello, Helloworld.vue here !')
    expect(page).toHaveNoErrorsOrWarnings()
  })

  /**
   * Tests the component with computed template
   */
  test('should render and update ComponentDefinedInSetup with reactive template', async ({ page, goto }) => {
    await goto('/component-in-setup')

    // Check initial render
    await expect(page.getByTestId('component-defined-in-setup')).toContainText('hello i am defined in the setup of app.vue')
    await expect(page.getByTestId('computed-count')).toHaveText('0')

    // Update counter
    await page.getByTestId('increment-count').click()

    // Check updated template
    await expect(page.getByTestId('computed-count')).toHaveText('1')

    // Multiple updates
    await page.getByTestId('increment-count').click()
    await expect(page.getByTestId('computed-count')).toHaveText('2')

    expect(page).toHaveNoErrorsOrWarnings()
  })

  /**
   * Tests the TypeScript component with render function
   */
  test('should render Name.ts component using render function', async ({ page, goto }) => {
    await goto('/typescript-component')

    await expect(page.getByTestId('name')).toHaveText('I am the Name.ts component')
    expect(page).toHaveNoErrorsOrWarnings()
  })

  /**
   * Tests a component with template from API
   */
  test('should render ShowTemplate component with template from API', async ({ page, goto }) => {
    await goto('/api-template')

    const expectedText = 'Hello my name is : John, i am defined by ShowTemplate.vue and my template is retrieved from the API'
    await expect(page.getByTestId('show-template')).toHaveText(expectedText)
    expect(page).toHaveNoErrorsOrWarnings()
  })

  /**
   * Tests a fully dynamic component with both template and script from API
   */
  test('should render and update Interactive component with template and script from API', async ({ page, goto }) => {
    await goto('/full-dynamic')

    // Check initial render
    await expect(page.getByTestId('interactive')).toContainText('I am defined by Interactive in the setup of App.vue')
    await expect(page.getByTestId('interactive')).toContainText('my name is Doe John')

    // Test reactivity
    const button = page.getByTestId('inc-interactive-count')
    await button.click()
    await expect(page.getByTestId('interactive-count')).toHaveText('1')

    // Test continued reactivity
    await button.click()
    await expect(page.getByTestId('interactive-count')).toHaveText('2')

    expect(page).toHaveNoErrorsOrWarnings()
  })

  /**
   * Tests navigation between pages and verifies all components are reachable
   */
  test('should allow navigation between all test cases', async ({ page, goto }) => {
    await goto('/')

    // Navigate to each page and verify
    const pages = [
      { path: '/basic-component', text: 'Basic Component Test' },
      { path: '/component-in-setup', text: 'Computed Template Test' },
      { path: '/typescript-component', text: 'TypeScript Component Test' },
      { path: '/api-template', text: 'API Template Test' },
      { path: '/full-dynamic', text: 'Full Dynamic Component Test' },
    ]

    for (const { path, text } of pages) {
      // Click navigation link
      await page.getByRole('link', { name: new RegExp(text.split(' ')[0]!, 'i') }).click()

      // Verify page title
      await expect(page.locator('h2')).toContainText(text)

      // Check URL
      expect(page.url()).toContain(path)

      // Verify no errors
      expect(page).toHaveNoErrorsOrWarnings()
    }
  })
})
</file>

<file path="test/e2e/spa-preloader-body.test.ts">
import { fileURLToPath } from 'node:url'
import { isWindows } from 'std-env'
import { join } from 'pathe'
import type { Page } from 'playwright-core'
import { waitForHydration } from '@nuxt/test-utils'
import { expect, test } from './test-utils'
import { isDev } from '../matrix'

/**
 * This test suite verifies that the SPA loading template is correctly rendered
 * outside the app tag when spaLoadingTemplateLocation is set to 'body'.
 */

const fixtureDir = fileURLToPath(new URL('../fixtures/spa-loader', import.meta.url))

// Skip tests in dev mode
test.skip(isDev, 'These tests are only relevant in production mode')

const loaderHTML = '<div id="__nuxt"></div><div id="__nuxt-loader"><div data-testid="loader">loading...</div></div>'

test.use({
  nuxt: {
    rootDir: fixtureDir,
    server: true,
    browser: true,
    setupTimeout: (isWindows ? 360 : 120) * 1000,
    nuxtConfig: {
      buildDir: isDev ? join(fixtureDir, '.nuxt', 'test', Math.random().toString(36).slice(2, 8)) : undefined,
      spaLoadingTemplate: true,
      experimental: {
        spaLoadingTemplateLocation: 'body',
      },
    },
  },
})

test.describe('spaLoadingTemplateLocation flag is set to `body`', () => {
  test('should render loader alongside appTag', async ({ request }) => {
    const response = await request.get('/spa')
    const html = await response.text()

    expect(html).toContain(loaderHTML)
  })

  test('should render spa-loader', async ({ page, fetch }) => {
    expect(await fetch('/spa').then(r => r.text())).toContain(loaderHTML)

    // Navigate to the SPA page
    await page.goto('/spa')

    // Verify the loader is visible first and content is hidden
    expect(await getState(page)).toEqual({
      loader: true,
      content: false,
    })

    page.dispatchEvent('html', 'finishHydration')
    await waitForHydration(page, '/spa', 'hydration')

    expect(await getState(page)).toEqual({
      loader: false,
      content: true,
    })
  })

  test('should render content without spa-loader for SSR pages', async ({ page, fetch }) => {
    expect(await fetch('/ssr').then(r => r.text())).not.toContain(loaderHTML)

    // Navigate to SSR page
    await page.goto('/ssr')

    // Verify the loader is hidden and content is visible for SSR pages
    expect(await getState(page)).toEqual({
      loader: false,
      content: true,
    })
  })
})

// isVisible is preferred here as we want to snapshot the state of the page at a specific moment, since waiting would make this test flake.
// https://github.com/nuxt/nuxt/pull/31273#issuecomment-2731002417
async function getState (page: Page) {
  const [loader, content] = await Promise.all([
    page.getByTestId('loader').isVisible(),
    page.getByTestId('content').isVisible(),
  ])
  const state = {
    loader,
    content,
  }
  return state
}
</file>

<file path="test/e2e/spa-preloader-within.test.ts">
import { fileURLToPath } from 'node:url'
import { isWindows } from 'std-env'
import { join } from 'pathe'
import type { Page } from 'playwright-core'
import { waitForHydration } from '@nuxt/test-utils'
import { expect, test } from './test-utils'
import { isDev } from '../matrix'

/**
 * This test suite verifies that the SPA loading template is correctly rendered
 * inside the app tag when spaLoadingTemplateLocation is set to 'within'.
 */

const fixtureDir = fileURLToPath(new URL('../fixtures/spa-loader', import.meta.url))

// Skip tests in dev mode
test.skip(isDev, 'These tests are only relevant in production mode')

const loaderHTML = '<div id="__nuxt"><div data-testid="loader">loading...</div></div>'

test.use({
  nuxt: {
    rootDir: fixtureDir,
    dev: isDev,
    server: true,
    browser: true,
    setupTimeout: (isWindows ? 360 : 120) * 1000,
    nuxtConfig: {
      buildDir: isDev ? join(fixtureDir, '.nuxt', 'test', Math.random().toString(36).slice(2, 8)) : undefined,
      spaLoadingTemplate: true,
      experimental: {
        spaLoadingTemplateLocation: 'within',
      },
    },
  },
})

test.describe('spaLoadingTemplateLocation flag is set to `within`', () => {
  test('should render loader inside appTag', async ({ request }) => {
    const response = await request.get('/spa')
    const html = await response.text()

    expect(html).toContain(loaderHTML)
  })

  test('spa-loader does not appear while the app is mounting', async ({ page }) => {
    // Navigate to the SPA page
    await page.goto('/spa')

    // wait for intervening (less optimal!) current behaviour
    await expect(page.getByTestId('loader')).toBeHidden()
    await expect(page.getByTestId('content')).toBeHidden()

    expect(await getState(page)).toEqual({
      loader: false,
      content: false,
    })

    page.dispatchEvent('html', 'finishHydration')
    await waitForHydration(page, '/spa', 'hydration')

    // Wait for content to become visible after hydration
    await expect(page.getByTestId('content')).toBeVisible()
  })

  test('should render content without spa-loader for SSR pages', async ({ page, fetch }) => {
    expect(await fetch('/ssr').then(r => r.text())).not.toContain(loaderHTML)

    // Navigate to SSR page
    await page.goto('/ssr')

    // Verify the loader is hidden and content is visible for SSR pages
    expect(await getState(page)).toEqual({
      loader: false,
      content: true,
    })
  })
})

// isVisible is preferred here as we want to snapshot the state of the page at a specific moment, since waiting that would make this test flake.
// https://github.com/nuxt/nuxt/pull/31273#issuecomment-2731002417
async function getState (page: Page) {
  const [loader, content] = await Promise.all([
    page.getByTestId('loader').isVisible(),
    page.getByTestId('content').isVisible(),
  ])
  const state = {
    loader,
    content,
  }
  return state
}
</file>

<file path="test/e2e/suspense.test.ts">
import { fileURLToPath } from 'node:url'
import { isWindows } from 'std-env'
import { join } from 'pathe'
import { expect, test } from './test-utils'
import { isDev } from '../matrix'

/**
 * This test suite verifies that Nuxt's suspense integration works correctly,
 * testing navigation between pages with suspense boundaries.
 */

const fixtureDir = fileURLToPath(new URL('../fixtures/suspense', import.meta.url))

// Run tests in parallel in production mode, but serially in dev mode
test.describe.configure({ mode: isDev ? 'serial' : 'parallel' })

test.use({
  nuxt: {
    rootDir: fixtureDir,
    dev: isDev,
    server: true,
    browser: true,
    setupTimeout: (isWindows ? 360 : 120) * 1000,
    nuxtConfig: {
      buildDir: isDev ? join(fixtureDir, '.nuxt', 'test', Math.random().toString(36).slice(2, 8)) : undefined,
    },
  },
})

test.describe('Suspense multiple navigation', () => {
  test('should not throw error during multiple rapid navigation', async ({ page, goto }) => {
    // Navigate to the index page
    await goto('/')

    // Verify initial state
    await expect(page.getByTestId('btn-a')).toHaveText(' Target A ')

    // Navigate to target page using button A
    await page.getByTestId('btn-a').click()
    await page.waitForFunction(() => window.useNuxtApp?.()._route.path === '/target')

    // Verify content after navigation
    await expect(page.getByTestId('content')).toContainText('Hello a')

    // Go back to index page
    await page.goBack()
    await page.waitForFunction(() => window.useNuxtApp?.()._route.path === '/')

    // Verify back at index page
    await expect(page.getByTestId('index-title')).toBeVisible()

    // Test multiple rapid navigation (clicking both buttons before first navigation completes)
    await Promise.all([
      page.getByTestId('btn-a').click(),
      page.getByTestId('btn-b').click(),
      page.getByTestId('btn-a').click(),
      page.getByTestId('btn-b').click(),
      page.getByTestId('btn-a').click(),
      page.getByTestId('btn-b').click(),
      page.getByTestId('btn-a').click(),
      page.getByTestId('btn-b').click(),
    ])

    // Verify we reached the target page with the correct content (from the second navigation)
    await page.waitForFunction(() => window.useNuxtApp?.()._route.path === '/target')
    await expect(page.getByTestId('content')).toContainText('Hello b')

    // Verify no errors or warnings occurred
    expect(page).toHaveNoErrorsOrWarnings()
  })
})
</file>

<file path="test/e2e/test-utils.ts">
import { waitForHydration } from '@nuxt/test-utils/e2e'
import { test as base, expect as baseExpect } from '@nuxt/test-utils/playwright'
import type { Page } from '@playwright/test'
import { fetch } from 'ofetch'
import { joinURL } from 'ufo'

const test = base.extend<{ fetch: (path: string) => Promise<Response> }>({
  fetch: ({ request, _nuxtHooks }, use) => {
    use(async (path) => {
      let res: Response | undefined
      do {
        res = await fetch(joinURL(_nuxtHooks.ctx.url!, path), {
          headers: { 'accept': 'text/html' },
          signal: AbortSignal.timeout(1000),
        }).catch(() => undefined)
      } while (!res || res?.status === 503 || res?.status === 500)

      if (!res) {
        await request.get(path, { headers: { 'accept': 'text/html' } })
      }

      return res
    })
  },
})

test.use({
  page: ({ page }, use) => {
    const consoleLogs: Array<{ type: string, text: string }> = []
    page.on('console', (msg) => {
      consoleLogs.push({
        type: msg.type(),
        text: msg.text(),
      })
    })
    // @ts-expect-error untyped
    page._consoleLogs = consoleLogs
    return use(page)
  },
  goto: ({ page }, use) => {
    use(async (path, options) => {
      const result = await page.goto(path, options as any)
      await waitForHydration(page, path, 'hydration')
      return result
    })
  },
})

const expect = baseExpect.extend({
  // Utility function to wait for a condition to be true
  async toBeWithPolling <T = true> (
    getter: () => Promise<T> | T,
    expected: T | ((val: T) => boolean) = true as T,
    options: { timeout?: number, interval?: number, message?: string } = {},
  ) {
    const { timeout = 8000, interval = 300 } = options
    const startTime = Date.now()
    let lastValue: T | undefined
    let lastError: Error | undefined

    // Create a matcher function
    const matcher = typeof expected === 'function'
      ? expected as ((val: T) => boolean)
      : (val: T) => val === expected

    let pass = false

    while (Date.now() - startTime < timeout) {
      try {
        lastValue = await getter()
        if (matcher(lastValue)) {
          pass = true
          break
        }
      } catch (err) {
        lastError = err as Error
      }

      // Wait before next attempt
      await new Promise(resolve => setTimeout(resolve, interval))
    }

    const message = options.message || `Timed out after ${timeout}ms waiting for condition to be met.`

    // if (lastError) {
    //   throw new Error(`${errorMessage}\nLast error: ${lastError.message}`)
    // }

    // throw new Error(`${errorMessage}\nExpected: ${expected}\nReceived: ${lastValue!}`)
    return {
      message: () => pass ? '' : lastError ? `${message}\nLast error: ${lastError.message}` : `${message}\nExpected: ${expected}\nReceived: ${lastValue!}`,
      pass,
      name: 'toBeWithPolling',
      expected,
      actual: lastValue,
    }
  },
  toHaveNoErrorsOrWarnings (page: Page) {
    // @ts-expect-error untyped
    const consoleLogs: Array<{ text: string, type: string }> = page._consoleLogs
    const errorLogs = consoleLogs.filter(log =>
      log.type === 'error' || (log.type === 'warning' && !log.text.includes('webpack/hot/dev-server')))

    const pass = errorLogs.length === 0
    const message = pass ? '' : `Found error logs: ${errorLogs.map(log => log.text).join('\n')}`

    return {
      message: () => message,
      pass,
      name: 'toHaveNoErrorsOrWarnings',
      expected: [],
      actual: errorLogs,
    }
  },
})

export { test, expect }
</file>

<file path="test/fixtures/basic/app/assets/assets.css">
:root {
  --assets: 'assets';
}
</file>

<file path="test/fixtures/basic/app/assets/css-only-asset.svg">
<svg viewBox="0 0 221 65" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-8">
  <defs>
    <clipPath id="a">
      <path fill="#fff" d="M0 0h221v65H0z"></path>
    </clipPath>
  </defs>
</svg>
</file>

<file path="test/fixtures/basic/app/assets/functional.css">
:root {
  --functional: 'functional';
}
</file>

<file path="test/fixtures/basic/app/assets/global.css">
:root {
  --global: 'global';
  --asset: url('~/assets/css-only-asset.svg');
  --public-asset: url('/css-only-public-asset.svg');
}
</file>

<file path="test/fixtures/basic/app/assets/inline-only.css">
:root {
  --inline-only: 'inline-only';
}
</file>

<file path="test/fixtures/basic/app/assets/logo.svg">
<svg viewBox="0 0 221 65" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-8">
  <g clip-path="url(#a)">
    <path fill="currentColor"
      d="M82.5623 18.5705h7.3017l15.474 24.7415V18.5705h6.741v35.0576h-7.252L89.3025 28.938v24.6901h-6.7402V18.5705ZM142.207 53.628h-6.282v-3.916c-1.429 2.7559-4.339 4.3076-8.015 4.3076-5.822 0-9.603-4.1069-9.603-10.0175V28.3847h6.282v14.3251c0 3.4558 2.146 5.8592 5.362 5.8592 3.524 0 5.974-2.7044 5.974-6.4099V28.3847h6.282V53.628ZM164.064 53.2289l-6.026-8.4144-6.027 8.4144h-6.69l9.296-13.1723-8.58-12.0709h6.843l5.158 7.2641 5.106-7.2641h6.895l-8.632 12.0709 9.295 13.1723h-6.638ZM183.469 20.7726v7.6116h7.149v5.1593h-7.149v12.5311c0 .4208.17.8245.473 1.1223.303.2978.715.4654 1.144.4661h5.532v5.9547h-4.137c-5.617 0-9.293-3.2062-9.293-8.8109V33.5484h-5.056v-5.1642h3.172c1.479 0 2.34-.8639 2.34-2.2932v-5.3184h5.825Z">
    </path>
    <path fill-rule="evenodd" clip-rule="evenodd"
      d="M30.1185 11.5456c-1.8853-3.24168-6.5987-3.24169-8.484 0L1.08737 46.8747c-1.885324 3.2417.47133 7.2938 4.24199 7.2938H21.3695c-1.6112-1.4081-2.2079-3.8441-.9886-5.9341l15.5615-26.675-5.8239-10.0138Z"
      fill="#80EEC0"></path>
    <path
      d="M43.1374 19.2952c1.5603-2.6523 5.461-2.6523 7.0212 0l17.0045 28.9057c1.5603 2.6522-.39 5.9676-3.5106 5.9676h-34.009c-3.1206 0-5.0709-3.3154-3.5106-5.9676l17.0045-28.9057ZM209.174 53.8005H198.483c0-1.8514.067-3.4526 0-6.0213h10.641c1.868 0 3.353.1001 4.354-.934 1-1.0341 1.501-2.3351 1.501-3.9029 0-1.8347-.667-3.2191-2.002-4.1532-1.301-.9674-2.985-1.4511-5.054-1.4511h-2.601v-5.2539h2.652c1.701 0 3.119-.4003 4.253-1.2009 1.134-.8006 1.701-1.9849 1.701-3.5527 0-1.301-.434-2.3351-1.301-3.1023-.834-.8007-2.001-1.201-3.503-1.201-1.634 0-2.918.4837-3.853 1.4511-.9.9674-1.401 2.1517-1.501 3.5527h-6.254c.133-3.2358 1.251-5.7877 3.352-7.6558 2.135-1.868 4.887-2.8021 8.256-2.8021 2.402 0 4.42.4337 6.055 1.301 1.668.834 2.919 1.9515 3.753 3.3525.867 1.4011 1.301 2.9523 1.301 4.6536 0 1.9681-.551 3.636-1.651 5.0037-1.068 1.3344-2.402 2.235-4.004 2.7021 1.969.4003 3.57 1.3677 4.804 2.9022 1.234 1.5011 1.852 3.4025 1.852 5.7043 0 1.9347-.468 3.7028-1.402 5.304-.934 1.6012-2.301 2.8855-4.103 3.8529-1.768.9674-3.953 1.4511-6.555 1.4511Z"
      fill="#00DC82"></path>
  </g>
  <defs>
    <clipPath id="a">
      <path fill="#fff" d="M0 0h221v65H0z"></path>
    </clipPath>
  </defs>
</svg>
</file>

<file path="test/fixtures/basic/app/assets/plugin.css">
:root {
  --plugin: 'plugin';
}
</file>

<file path="test/fixtures/basic/app/components/client/Binding.client.ts">
export default defineComponent({
  name: 'Foo',
  methods: {
    getMessage () {
      return 'Hello world'
    },
  },
  render () {
    return h('div', {}, this.getMessage())
  },
})
</file>

<file path="test/fixtures/basic/app/components/client/FragmentServer.client.vue">
<template>
  <div class="client-fragment-server client">
    world
  </div>
  <div class="client-fragment-server client">
    world
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/client/FragmentServer.server.vue">
<template>
  <div class="client-fragment-server server">
    hello
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/client/FragmentServerFragment.client.vue">
<template>
  <div class="client-fragment-server-fragment client">
    world
  </div>
  <div class="client-fragment-server-fragment client">
    world
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/client/FragmentServerFragment.server.vue">
<template>
  <div class="client-fragment-server-fragment server">
    hello
  </div>
  <div class="client-fragment-server-fragment server">
    hello
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/client/MultiRootNode.client.vue">
<template>
  <div
    v-bind="$attrs"
    class="multi-root-node-count"
  >
    {{ count }}
  </div>
  <button
    class="multi-root-node-button"
    @click="add"
  >
    add 1 to count
  </button>
</template>

<script setup>
const count = ref(0)

const add = () => count.value++
</script>
</file>

<file path="test/fixtures/basic/app/components/client/MultiRootNodeScript.client.vue">
<template>
  <div
    v-bind="$attrs"
    class="multi-root-node-script-count"
  >
    {{ count }}
  </div>
  <button
    class="multi-root-node-script-button"
    @click="add"
  >
    add 1 to count
  </button>
</template>

<script>
export default defineNuxtComponent({
  setup () {
    const count = ref(0)

    const add = () => count.value++
    return { count, add }
  },
})
</script>
</file>

<file path="test/fixtures/basic/app/components/client/NoState.client.vue">
<template>
  <div>Hello world !</div>
</template>
</file>

<file path="test/fixtures/basic/app/components/client/Script.client.vue">
<script lang="ts">
export default defineNuxtComponent({
  name: 'ClientScript',
  props: {
    foo: {
      type: String,
    },
  },
  setup (_p, ctx) {
    const count = ref(0)
    const add = () => count.value++

    ctx.expose({ add })

    return {
      count,
      add,
    }
  },
})
</script>

<template>
  <div>
    <div class="client-only-css">
      client only script component {{ foo }}
    </div>
    <button @click="add">
      {{ count }}
    </button>
    <slot name="test" />
  </div>
</template>

<style>
:root {
  --client-only: "client-only";
}
</style>

<style scoped>
.client-only-css {
  color: rgb(50, 50, 50);
}
</style>
</file>

<file path="test/fixtures/basic/app/components/client/Server.client.vue">
<template>
  <div class="client-server client">
    world !
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/client/Server.server.vue">
<template>
  <div class="client-server server">
    hello
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/client/ServerFragment.client.vue">
<template>
  <div class="client-server-fragment client">
    world
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/client/ServerFragment.server.vue">
<template>
  <div class="client-server-fragment server">
    hello
  </div>
  <div class="client-server-fragment server">
    hello
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/client/SetupScript.client.vue">
<script setup lang="ts">
const props = defineProps<{ foo: string }>()
const count = ref(0)
const add = () => count.value++

defineExpose({ add })
</script>

<template>
  <div class="bg-red">
    <div>client only script setup component {{ props.foo }}</div>
    <button @click="add">
      {{ count }}
    </button>

    <slot name="test" />
  </div>
</template>

<style scoped>
.bg-red{
  background-color: rgb(255, 0, 0);
}
</style>
</file>

<file path="test/fixtures/basic/app/components/client/StringChildStateful.client.vue">
<script setup lang="ts">
const state = ref(0)

const add = () => state.value++

defineExpose({
  state,
  add,
})
</script>

<template>
  <div>Hi i should be rendered {{ state }}</div>
</template>
</file>

<file path="test/fixtures/basic/app/components/client/StringChildStatefulScript.client.vue">
<script lang="ts">
export default defineNuxtComponent({
  setup (_p, ctx) {
    const state = ref(0)

    const add = () => state.value++

    ctx.expose({ add, state })
    return {
      state,
    }
  },
})
</script>

<template>
  <div>Hi i should be rendered {{ state }}</div>
</template>
</file>

<file path="test/fixtures/basic/app/components/clientFallback/AsyncSetup.vue">
<template>
  <div>
    async setup
    <NuxtClientFallback>
      <BreakInAsyncSetup class="clientfallback-async-setup" />
      <template #fallback>
        <div>Work with async setup</div>
      </template>
    </NuxtClientFallback>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/clientFallback/NonStateful.vue">
<template>
  <div>
    non stateful
    <NuxtClientFallback>
      <BreakInSetup class="clientfallback-non-stateful" />
    </NuxtClientFallback>
  </div>
</template>

<script>
export default defineNuxtComponent({
  name: 'ClientFallbackStateful',
})
</script>
</file>

<file path="test/fixtures/basic/app/components/clientFallback/NonStatefulSetup.vue">
<template>
  <div>
    non stateful setup
    <NuxtClientFallback>
      <BreakInSetup class="clientfallback-non-stateful-setup" />
    </NuxtClientFallback>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/clientFallback/Stateful.vue">
<template>
  <div>
    stateful test {{ state }}
    <NuxtClientFallback>
      <BreakInSetup class="clientfallback-stateful" />
    </NuxtClientFallback>
  </div>
</template>

<script>
export default defineNuxtComponent({
  name: 'ClientFallbackStateful',
  setup () {
    const state = ref(0)
    return {
      state,
    }
  },
})
</script>
</file>

<file path="test/fixtures/basic/app/components/clientFallback/StatefulSetup.vue">
<template>
  <div>
    stateful setup {{ state }}
    <NuxtClientFallback>
      <BreakInSetup class="clientfallback-stateful-setup" />
    </NuxtClientFallback>
  </div>
</template>

<script setup>
const state = ref(1)
</script>
</file>

<file path="test/fixtures/basic/app/components/global/ClientGlobal.client.vue">
<template>
  <div>
    global component (client-only) registered automatically
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/global/ServerComponentGlobal.server.vue">
<template>
  <div>
    Test globally-registered server component
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/global/TestGlobal.vue">
<template>
  <div>
    global component registered automatically
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/islands/LongAsyncComponent.vue">
<template>
  <div>
    <div v-if="count > 2">
      count is above 2
    </div>
    <slot />
    {{ data }}
    <div id="long-async-component-count">
      {{ count }}
    </div>
    {{ headers['custom-head'] }}
    <slot
      name="test"
      :count="count"
    />
    <p>hello world !!!</p>
    <slot
      v-for="(t, index) in 3"
      name="hello"
      :t="t"
    >
      <div :key="t">
        fallback slot -- index: {{ index }}
      </div>
    </slot>

    <slot
      v-for="(t, index) in ['fall', 'back']"
      name="fallback"
      :t="t"
    >
      <div :key="t">
        {{ t }} slot -- index: {{ index }}
      </div>
      <div
        :key="t"
        class="fallback-slot-content"
      >
        wonderful fallback
      </div>
    </slot>
  </div>
</template>

<script setup lang="ts">
import { getResponseHeaders } from 'h3'

defineProps<{
  count: number
}>()

const evt = useRequestEvent()
const headers = evt ? getResponseHeaders(evt) : {}
const { data } = await useFetch('/api/very-long-request')
</script>
</file>

<file path="test/fixtures/basic/app/components/islands/PureComponent.vue">
<script setup lang="ts">
const props = defineProps({
  bool: Boolean,
  number: Number,
  str: String,
  obj: Object,
})

const hasRouter = useState('hasRouter', () => !!useRouter())
</script>

<template>
  <div>
    Was router enabled: {{ hasRouter }}
    <br>
    Props:
    <!-- eslint-disable-next-line vue/no-v-html -->
    <pre v-html="JSON.stringify(props, null, 2)" />
  </div>
</template>

<style scoped>
pre {
  color: blue
}
</style>
</file>

<file path="test/fixtures/basic/app/components/islands/RouteComponent.vue">
<template>
  <pre>
    Route: {{ $route.fullPath }}
  </pre>
</template>
</file>

<file path="test/fixtures/basic/app/components/Nested/Counter.vue">
<script setup lang="ts">
defineProps({
  multiplier: {
    type: Number,
    required: true,
  },
})
</script>

<template>
  <div>
    <Counter :multiplier="multiplier" />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/1thing.island.vue">
<!-- eslint-disable vue/multi-word-component-names -->

<template>
  <div>
    Meant to detect syntax error when `components.islands.mjs` is created
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/AsyncServerComponent.server.vue">
<template>
  <div>
    This is a .server (20ms) async component
    {{ data }}
    <div id="async-server-component-count">
      {{ count }}
    </div>

    <Counter :multiplier="1" />
    <slot />
  </div>
</template>

<script setup lang="ts">
defineProps<{
  count: number
}>()

const { data } = await useFetch('/api/very-long-request')
</script>
</file>

<file path="test/fixtures/basic/app/components/BreakInAsyncSetup.vue">
<script setup>
async function getData () { }
await getData()

// break server-side
const data = window.useNuxtApp().payload
</script>

<template>
  <div>
    This breaks in server-side async setup. {{ data.serverRendered }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/BreakInSetup.vue">
<script setup>
// break server-side
const data = window.useNuxtApp().payload
</script>

<template>
  <div>
    This breaks in server-side setup. {{ data.serverRendered }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/BreaksServer.client.ts">
// @ts-expect-error assigning property to window object to break SSR
window.test = true

export default defineComponent({
  render: () => 'hi',
})
</file>

<file path="test/fixtures/basic/app/components/ClientOnlyScript.client.vue">
<script lang="ts">
export default defineNuxtComponent({
  name: 'ClientOnlyScript',
  props: {
    foo: {
      type: String,
    },
  },
})
</script>

<template>
  <div>
    <div class="client-only-css">
      client only script component {{ foo }}
    </div>
    <slot name="test" />
  </div>
</template>

<style>
  :root {
    --client-only: 'client-only';
  }
</style>

<style scoped>
  .client-only-css {
    color: rgb(50, 50, 50);
  }
</style>
</file>

<file path="test/fixtures/basic/app/components/ClientOnlySetupScript.client.vue">
<script setup lang="ts">
const props = defineProps<{ foo: string }>()
</script>

<template>
  <div>
    <div>client only script setup component {{ props.foo }}</div>
    <slot name="test" />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/ClientWrapped.client.vue">
<script setup lang="ts">
function exposedFunc () {
  console.log('ok')
}

defineExpose({ exposedFunc })
const $hello = ref('hello')
await new Promise(resolve => setTimeout(resolve, 300))

onMounted(() => {
  console.log('mounted', $hello.value)
})
</script>

<template>
  <div>
    client-only component
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/ComponentUsingCookie.vue">
<script setup>
import { useCookieManager } from '../composables/cookie-manager'

const { showCookieBanner } = useCookieManager()
</script>

<template>
  <div
    v-if="showCookieBanner"
    id="child-banner"
  >
    child banner
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/ComponentWithIds.vue">
<script setup>
const emailId = useId()
const passwordId = useId()
</script>

<template>
  <div>
    <label :for="emailId">Email</label>
    <input
      :id="emailId"
      name="email"
      type="email"
    >
    <label :for="passwordId">Password</label>
    <input
      :id="passwordId"
      name="password"
      type="password"
    >
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/ComponentWithRef.vue">
<script setup lang="ts">
const list = ['a', 'b', 'c']
const templateRef = ref<HTMLElement[] | null>(null)
</script>

<template>
  <div>
    <div
      v-for="item in list"
      ref="templateRef"
      :key="item"
    >
      {{ item }}
    </div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/Counter.vue">
<!-- eslint-disable vue/multi-word-component-names -->
<script setup lang="ts">
const props = defineProps<{
  multiplier: number
}>()
const count = ref(12)
const doubled = computed(() => count.value * props.multiplier)
</script>

<template>
  <div class="sugar-counter">
    Sugar Counter {{ count }} x {{ multiplier }} = {{ doubled }}
    <button @click="count += 1">
      Inc
    </button>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/CounterWithNuxtClient.vue">
<template>
  <div>
    this is a normal component within a server component
    <Counter
      nuxt-client
      :multiplier="1"
    />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/DelayedComponent.vue">
<template>
  <div>
    This {{ mounted ? 'is' : 'is not' }} mounted.
  </div>
</template>

<script setup lang="ts">
const mounted = ref(false)
onMounted(() => { mounted.value = true })

const props = defineProps<{ logHydration?: true }>()

if (props.logHydration) {
  console.log('hydrated')
}
</script>
</file>

<file path="test/fixtures/basic/app/components/DelayedModel.vue">
<template>
  <div>
    <span data-testid="count">{{ model }}</span>
    <button
      data-testid="increment"
      @click="model++"
    >
      Increment
    </button>
  </div>
</template>

<script setup lang="ts">
const model = defineModel<number>()
</script>
</file>

<file path="test/fixtures/basic/app/components/EventView.vue">
<template>
  <div>
    This {{ mounted ? 'is' : 'is not' }} mounted.
  </div>
</template>

<script setup lang="ts">
const mounted = ref(false)
onMounted(() => { mounted.value = true })
</script>
</file>

<file path="test/fixtures/basic/app/components/FunctionalComponent.ts">
import '~/assets/functional.css'

export default defineComponent({
  render: () => 'hi',
})
</file>

<file path="test/fixtures/basic/app/components/GlobalSync.vue">
<template>
  <div>
    This is a synchronously registered global component
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/ServerOnlyComponent.server.vue">
<script setup>
prerenderRoutes(['/catchall/some/url/from/server-only/component'])
</script>

<template>
  <div>
    server-only component
    <ServerOnlyComponentChild />
  </div>
</template>

<style>
:root {
  --server-only: 'server-only';
}
</style>
</file>

<file path="test/fixtures/basic/app/components/ServerOnlyComponentChild.vue">
<template>
  <div>
    server-only component child (non-server-only)
  </div>
</template>

<style>
:root {
  --server-only-child: 'server-only-child';
}
</style>
</file>

<file path="test/fixtures/basic/app/components/ServerWithClient.server.vue">
<template>
  <div>
    ServerWithClient.server.vue :
    <p>count: {{ count }}</p>

    This component should not be preloaded
    <ComponentWithRef />

    This is not interactive
    <Counter :multiplier="1" />

    <div
      class="interactive-component-wrapper"
      style="border: solid 1px red;"
    >
      The component below is not a slot but declared as interactive

      <Counter
        nuxt-client
        :multiplier="1"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
const count = ref(0)
</script>
</file>

<file path="test/fixtures/basic/app/components/ServerWithNestedClient.server.vue">
<template>
  <div class="server-with-nested-client">
    <CounterWithNuxtClient />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/SharedComponent.vue">
<template>
  <span class="shared-component" />
</template>

<style scoped>
.shared-component {
  --shared-component: 'shared-component';
}
</style>
</file>

<file path="test/fixtures/basic/app/components/Tsx.tsx">
export default defineComponent({
  render () {
    return (
      <div>
        TSX component
        <custom-component>custom</custom-component>
        <Counter multiplier={2} />
      </div>
    )
  },
})
</file>

<file path="test/fixtures/basic/app/components/WithSuffix.global.vue">
<template>
  <div>
    global component via suffix
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/components/WrapClientComponent.vue">
<template>
  <div>
    <ClientSetupScript
      ref="clientSetupScript"
      class="client-only-script-setup"
      foo="hello"
    />
  </div>
</template>

<script setup lang="ts">
const clientSetupScript = ref<{ $el: HTMLElement }>()
onMounted(() => {
  console.log(clientSetupScript.value?.$el as HTMLElement ? 'has $el' : 'no $el')
})
</script>
</file>

<file path="test/fixtures/basic/app/composables/nested/bar.ts">
export function useNestedBar () {
  return 'auto imported from ~/composables/nested/bar.ts via star export'
}
</file>

<file path="test/fixtures/basic/app/composables/async-context.ts">
const delay = () => new Promise(resolve => setTimeout(resolve, 10))

export async function nestedAsyncComposable () {
  await delay()
  return await fn1()
}

async function fn1 () {
  await delay()
  return await fn2()
}

async function fn2 () {
  await delay()
  const app = tryUseNuxtApp()
  return {
    hasApp: !!app,
  }
}
</file>

<file path="test/fixtures/basic/app/composables/asyncDataTests.ts">
export const useSleep = () => useAsyncData('sleep', async () => {
  await new Promise(resolve => setTimeout(resolve, 50))

  return 'Slept!'
})

export const useCounter = () => useFetch('/api/useAsyncData/count')
</file>

<file path="test/fixtures/basic/app/composables/badSideEffect.ts">
export function badSideEffect () {
  // ...
}

throw new Error('composables/badSideEffect.ts should be tree-shaken')
</file>

<file path="test/fixtures/basic/app/composables/cookie-manager.ts">
export function useCookieManager () {
  const theCookie = useCookie<null | string>('theCookie', {
    default: () => 'show',
  })

  const showCookieBanner = computed(() => {
    return theCookie.value === 'show'
  })

  function toggle () {
    theCookie.value = theCookie.value === 'show' ? null : 'show'
  }

  return {
    showCookieBanner,
    toggle,
  }
}
</file>

<file path="test/fixtures/basic/app/composables/export-star.ts">
export * from './nested/bar'
</file>

<file path="test/fixtures/basic/app/composables/foo.ts">
export function useFoo () {
  return 'auto imported from ~/composables/foo.ts'
}
</file>

<file path="test/fixtures/basic/app/composables/ignored.ts">
export function useIgnoredImport () {

}
</file>

<file path="test/fixtures/basic/app/composables/keep-alive.ts">
export function useLifecycleLogs (name: string) {
  onMounted(() => console.log(`${name}: onMounted`))
  onUnmounted(() => console.log(`${name}: onUnmounted`))
  onActivated(() => console.log(`${name}: onActivated`))
  onDeactivated(() => console.log(`${name}: onDeactivated`))
}
</file>

<file path="test/fixtures/basic/app/composables/override-base.ts">
export const useOverridableComposable = () => 'test from project'
</file>

<file path="test/fixtures/basic/app/composables/random.ts">
export function useRandomState (max = 100, name = 'default') {
  return useState('random:' + name, () => Math.round(Math.random() * max))
}
</file>

<file path="test/fixtures/basic/app/composables/template.ts">
export const templateAutoImport = 'auto imported from ~/composables/template.ts'
</file>

<file path="test/fixtures/basic/app/composables/tree-shake.ts">
export function useServerOnlyComposable () {
  if (import.meta.client) {
    throw new Error('this should not be called in the browser')
  }
}

export function useClientOnlyComposable () {
  // need to do some code that fails in node but not in the browser
  if (import.meta.server) {
    throw new Error('this should not be called on the server')
  }
}

export function setTitleToPink () {
  document.querySelector('h1')!.style.color = 'pink'
}
</file>

<file path="test/fixtures/basic/app/layouts/custom-async.vue">
<template>
  <div>
    Custom Async Layout:
    <slot />
    <ComponentWithRef />
  </div>
</template>

<script setup>
await Promise.resolve()
if (import.meta.client) {
  console.log('isHydrating: ' + useNuxtApp().isHydrating)
}
</script>
</file>

<file path="test/fixtures/basic/app/layouts/custom.vue">
<template>
  <div>
    Custom Layout:
    <slot />

    <div class="count">
      {{ count }}
    </div>
    <button
      class="add-count"
      @click="count++"
    >
      add count
    </button>
    <p>{{ foo }}</p>
  </div>
</template>

<script setup lang="ts">
const count = ref(0)

defineProps<{
  foo?: string
}>()
function logHello () {
  console.log('world')
}

defineExpose({
  logHello,
})
</script>
</file>

<file path="test/fixtures/basic/app/layouts/custom2.vue">
<template>
  <div>
    Custom2 Layout:
    <slot />

    <div class="count">
      {{ count }}
    </div>
    <button
      class="add-count"
      @click="count++"
    >
      add count
    </button>
  </div>
</template>

<script setup lang="ts">
const count = ref(0)

function logFoo () {
  console.log('bar')
}

defineExpose({
  logFoo,
})
</script>
</file>

<file path="test/fixtures/basic/app/layouts/invalid-root.vue">
<!-- eslint-disable vue/no-multiple-template-root -->

<template>
  <div />
  <slot />
</template>
</file>

<file path="test/fixtures/basic/app/layouts/PascalCase.ts">

</file>

<file path="test/fixtures/basic/app/layouts/with-props.vue">
<template>
  <div>
    <p>{{ someProp }}</p>
    <slot />
  </div>
</template>

<script lang="ts" setup>
defineProps<{
  someProp: string
}>()
</script>
</file>

<file path="test/fixtures/basic/app/layouts/with-route-announcer.vue">
<template>
  <div>
    <NuxtRouteAnnouncer />
    <slot />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/middleware/abort.global.ts">
export default defineNuxtRouteMiddleware((to) => {
  if ('abort' in to.query) {
    return abortNavigation({
      statusCode: 401,
    })
  }
  return true
})
</file>

<file path="test/fixtures/basic/app/middleware/b.global.ts">
export default defineNuxtRouteMiddleware((to) => {
  if (to.path === '/middleware/ordering' && !useNuxtApp().extendsMiddleware) {
    return createError('extendsMiddleware not set in layer')
  }
})
</file>

<file path="test/fixtures/basic/app/middleware/injectAuth.ts">
export default defineNuxtRouteMiddleware((to) => {
  to.meta.auth = 'Injected by injectAuth middleware'
})
</file>

<file path="test/fixtures/basic/app/middleware/redirect.global.ts">
import { withoutTrailingSlash } from 'ufo'

export default defineNuxtRouteMiddleware(async (to) => {
  const nuxtApp = useNuxtApp()
  if (useRequestHeaders(['trailing-slash'])['trailing-slash'] && to.fullPath.endsWith('/')) {
    return navigateTo(withoutTrailingSlash(to.fullPath), { redirectCode: 307 })
  }
  if (to.path.startsWith('/redirect/')) {
    await new Promise(resolve => setTimeout(resolve, 100))
    return navigateTo(to.path.slice('/redirect/'.length - 1))
  }
  if (to.path === '/catchall/redirect-infinite') {
    // the path will be the same in this new route and vue-router should send a 500 response
    return navigateTo('/catchall/redirect-infinite?test=true')
  }
  if (to.path === '/navigate-to-external') {
    return navigateTo('/', { external: true })
  }
  if (to.path === '/navigate-to-false') {
    return false
  }
  const pluginPath = nuxtApp.$path()
  if (import.meta.server && !/redirect|navigate/.test(pluginPath) && to.path !== pluginPath) {
    throw new Error('plugin did not run before middleware')
  }
})
</file>

<file path="test/fixtures/basic/app/middleware/routeRulesMiddleware.ts">
export default defineNuxtRouteMiddleware((to) => {
  to.meta.hello = 'Hello from routeRules!'
})
</file>

<file path="test/fixtures/basic/app/middleware/sets-layout.ts">
export default defineNuxtRouteMiddleware(async () => {
  await new Promise(resolve => setTimeout(resolve, 10))
  setPageLayout('custom', {
    foo: 'set from sets-layouts middleware',
  })
})
</file>

<file path="test/fixtures/basic/app/other-components-folder/named-export.ts">
export const namedExport = defineComponent({
  setup: () => () => h('div', 'This is a custom component with a named export.'),
})
</file>

<file path="test/fixtures/basic/app/other-composables-folder/custom-keyed-composable.ts">
export function useCustomKeyedComposable (arg?: string) {
  return arg
}
</file>

<file path="test/fixtures/basic/app/other-composables-folder/local.ts">
function useAsyncData (s?: any) { return s }

export const ShouldNotBeKeyed = (() => {
  return useAsyncData()
})()
</file>

<file path="test/fixtures/basic/app/pages/(new-group)/group-page.vue">
<template>
  <div>
    Hello from new group
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/another-parent/index.vue">
<template>
  <div>
    another-parent/index
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/async-parent/child.vue">
<template>
  <div>
    another-parent/child
  </div>
</template>

<script setup>
await Promise.resolve()
if (import.meta.client) {
  console.log('isHydrating: ' + useNuxtApp().isHydrating)
}
definePageMeta({
  layout: 'custom-async',
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/catchall/[...slug].vue">
<template>
  <div>
    <h1>[...slug].vue</h1>
    <div>catchall at {{ route.params.slug?.[0] }}</div>
    <div>Middleware ran: {{ !!($route.meta.override as any)?.includes('extended middleware') }}</div>
  </div>
</template>

<script setup lang="ts">
definePageMeta({
  middleware: ['override', (to) => {
    if (to.path === '/catchall/forbidden') {
      throw createError({
        statusCode: 500,
        message: 'This middleware should not be run',
      })
    }
  }],
  validate: to => to.path !== '/catchall/forbidden',
})
const route = useRoute('catchall-slug')
if (route.path.includes('navigate-some-path')) {
  throw createError('navigate-some-path setup running')
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/client-only-page/index.client.vue">
<script setup lang="ts">
definePageMeta({
  // Disable page transition for this page to avoid having multiple time the same page during transition
  pageTransition: false,
  layoutTransition: false,
})

const state = useState('test', () => {
  let hasAccessToWindow = null as null | boolean

  try {
    hasAccessToWindow = !!Object.keys(window).at(0)
  } catch {
    hasAccessToWindow = null
  }

  return {
    hasAccessToWindow,
    isServer: import.meta.server,
  }
})

const serverRendered = useState(() => import.meta.server)
</script>

<template>
  <div>
    <NuxtLink to="/client-only-page/normal">
      normal
    </NuxtLink>

    <p id="state">
      {{ state }}
    </p>

    <p id="server-rendered">
      {{ serverRendered }}
    </p>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/client-only-page/normal.vue">
<script setup lang="ts">
const renderedOnServer = useState(() => import.meta.server)
definePageMeta({
  // Disable page transition for this page to avoid having multiple time the same page during transition
  pageTransition: false,
  layoutTransition: false,
})
</script>

<template>
  <div>
    <NuxtLink to="/client-only-page">
      to client only page
    </NuxtLink>

    <p id="server-rendered">
      {{ renderedOnServer }}
    </p>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/components/nuxt-time.vue">
<script setup lang="ts">
const locale = ref()
const switchLocale = () => {
  locale.value = locale.value !== 'fr' ? 'fr' : 'en-GB'
}
const date = ref(new Date('2023-02-11T08:24:08.396Z').valueOf())
const changeDate = () => {
  date.value = Date.now()
}
</script>

<template>
  <div>
    <NuxtTime
      :locale="locale"
      data-testid="switchable"
      :datetime="date"
      second="numeric"
      month="long"
      day="numeric"
    />
    <br>
    <NuxtTime
      :locale="locale"
      data-testid="present"
      :datetime="new Date()"
      second="numeric"
      month="long"
      day="numeric"
    />
    <br>
    <NuxtTime
      :locale="locale"
      data-testid="fixed"
      datetime="2023-02-11T08:24:08.396Z"
      month="long"
      day="numeric"
    />
    <br>
    <NuxtTime
      datetime="2023-08-19T02:57:00.000Z"
      time-zone="America/New_York"
    />
    <br>
    <NuxtTime
      data-testid="relative"
      :datetime="Date.now() - (1 * 30 * 1000)"
      relative
    />
    <br>
    <button @click="switchLocale">
      Switch locale
    </button>
    <br>
    <button @click="changeDate">
      Update time
    </button>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/composables/on-prehydrate.vue">
<script setup lang="ts">
onPrehydrate(() => {
  // This is guaranteed to run before Nuxt hydrates
  console.log(window)
})

onPrehydrate((el) => {
  console.log(el.outerHTML)
})
onPrehydrate((el) => {
  console.log(el.outerHTML)
})
onPrehydrate((el) => {
  console.log('other', el.outerHTML)
})
</script>

<template>
  <div>
    onPrehydrate testing
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/error/error-boundary.vue">
<template>
  <div>
    <NuxtErrorBoundary>
      <template #default>
        <MyBrokenComponent />
      </template>
      <template #error>
        <p>This is the error rendering</p>
      </template>
    </NuxtErrorBoundary>
  </div>
</template>

<script setup lang="ts">
const MyBrokenComponent = defineComponent({
  setup () {
    onMounted(() => {
      throw new Error('This is broken')
    })

    return () => h('div', 'This is a broken component')
  },
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/error/index.vue">
<template>
  <div>
    {{ state.attr }}
    {{ data.something }}
  </div>
</template>

<script setup>
const { data, error } = await useAsyncData(() => {
  throw new Error('some error')
}, { server: true })

if (error.value) {
  useCookie('some-error').value = 'was set'
  throw createError({ statusCode: 422, fatal: true, statusMessage: 'This is a custom error' })
}

const state = ref({ attr: 'Hello World' })
</script>
</file>

<file path="test/fixtures/basic/app/pages/experimental/decorators.vue">
<script setup lang="ts">
function something (_method: () => unknown) {
  return () => 'decorated'
}

class SomeClass {
  @something
  public someMethod () {
    return 'initial'
  }
}

const value = new SomeClass().someMethod()

const { data } = await useFetch('/api/experimental/decorators')
</script>

<template>
  <div>
    {{ value }}-{{ data }}
  </div>
</template>

<style scoped>

</style>
</file>

<file path="test/fixtures/basic/app/pages/experimental/node-compat.vue">
<script setup lang="ts">
import { Buffer } from 'node:buffer'
import process from 'node:process'

const base64 = atob(Buffer.from('Nuxt is Awesome!', 'utf8').toString('base64'))
const cwd = typeof process.cwd === 'function' && '[available]'
</script>

<template>
  <div>
    <ClientOnly>
      <div>
        {{ base64 }}
      </div>
      <div>
        CWD: {{ cwd }}
      </div>
    </ClientOnly>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/fixed-keyed-child-parent/[foo].vue">
<template>
  <div :id="`page-${route.params.foo}`">
    [fixed-keyed-child-parent/{{ route.params.foo }}]
    <NuxtLink to="../fixed-keyed-child-parent/1">
      To another
    </NuxtLink>
  </div>
</template>

<script setup>
if (import.meta.client) {
  console.log('Running Child Setup')
}
const route = useRoute()

definePageMeta({
  key: 'keyed',
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/hydration/spa-redirection/end.vue">
<script setup lang="ts">
const ready = ref('not yet hydrated')
onNuxtReady(() => {
  ready.value = 'fully hydrated and ready to go'
})
</script>

<template>
  <div>
    {{ ready }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/hydration/spa-redirection/start.vue">
<script setup lang="ts">
definePageMeta({
  middleware: () => '/hydration/spa-redirection/end',
})
</script>

<template>
  <div>
    Tests whether hydration is properly resolved when loading
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/hydration/layout.vue">
<script setup lang="ts">
definePageMeta({
  layout: 'custom-async',
})

if (import.meta.client && !useNuxtApp().isHydrating) {
  throw createError({
    fatal: true,
    message: '`useNuxtApp().isHydrating` is false by the time we run page setup',
  })
}
</script>

<template>
  <div>
    Tests whether hydration is properly resolved within an async layout
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/ignore/composables.vue">
<script setup lang="ts">
const wasImportIgnored = typeof useIgnoredImport === 'undefined'
</script>

<template>
  <div>
    was import ignored: {{ wasImportIgnored }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/import-components/index.vue">
<template>
  <div>
    <DCompAll message="default-comp-all" />
    <DCompClient message="default-comp-client" />
    <DCompServer message="default-comp-server" />
    <NCompAll message="named-comp-all" />
    <NCompClient message="named-comp-client" />
    <NCompServer message="named-comp-server" />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/instance/error.vue">
<script lang="ts">
export default defineComponent({
  data () {
    throw new Error('💀')
  },
})
</script>

<template>
  <div>
    This should not display.
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/instance/next-request.vue">
<script setup>
const nuxtApp = useNuxtApp()
await new Promise(resolve => setTimeout(resolve, 150))
const isSameApp = nuxtApp === useNuxtApp()
if (!isSameApp) {
  throw new Error('💀')
}
</script>

<template>
  <div>
    This should be false: {{ $wasVueAppInstanceWronglyPreserved }}
    This should be true: {{ isSameApp }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/invalid-root/1.vue">
<template>
  <!-- comment -->
  <div>Test</div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/invalid-root/2.vue">
<!-- eslint-disable vue/no-multiple-template-root -->

<template>
  Just some text
</template>
</file>

<file path="test/fixtures/basic/app/pages/invalid-root/3.vue">
<!-- eslint-disable vue/no-multiple-template-root -->
<template>
  <div>Multiple</div>
  <div>elements</div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/invalid-root/4.vue">
<template>
  <div>Fine</div>
</template>

<script setup>
definePageMeta({ layout: 'invalid-root' })
</script>
</file>

<file path="test/fixtures/basic/app/pages/invalid-root/fine.vue">
<!-- eslint-disable vue/no-multiple-template-root -->

<template>
  <div>Multiple</div>
  <div>elements</div>
</template>

<script setup>
definePageMeta({
  pageTransition: false,
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/keepalive/keepalive-in-config.vue">
<script setup lang="ts">
useLifecycleLogs('keepalive-in-config')
</script>

<template>
  <div>
    <h2>Keepalive in Config</h2>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/keepalive/keepalive-in-nuxtpage-2.vue">
<script setup lang="ts">
useLifecycleLogs('keepalive-in-nuxtpage-2')
</script>

<template>
  <div>
    <h2>Keepalive in `nuxt-page` 2</h2>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/keepalive/keepalive-in-nuxtpage.vue">
<script setup lang="ts">
useLifecycleLogs('keepalive-in-nuxtpage')
</script>

<template>
  <div>
    <h2>Keepalive in `nuxt-page`</h2>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/keepalive/not-keepalive-in-nuxtpage.vue">
<script setup lang="ts">
useLifecycleLogs('not-keepalive-in-nuxtpage')
</script>

<template>
  <div>
    <h2>Not Keepalive in `nuxt-page`</h2>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/keepalive/not-keepalive.vue">
<script setup lang="ts">
useLifecycleLogs('not-keepalive')
</script>

<template>
  <div>
    <h2>Not Keepalive</h2>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/keyed-child-parent/[foo].vue">
<template>
  <div :id="`page-${route.params.foo}`">
    [keyed-child-parent/{{ route.params.foo }}]
    <NuxtLink to="../keyed-child-parent/1">
      To another
    </NuxtLink>
  </div>
</template>

<script setup>
if (import.meta.client) {
  console.log('Running Child Setup')
}
const route = useRoute()

definePageMeta({
  key: r => 'keyed-' + r.params.foo,
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/keyed-composables/index.vue">
<script setup lang="ts">
import { useCustomKeyedComposable } from '~/other-composables-folder/custom-keyed-composable'

const useLocalState = () => useState(() => {
  if (import.meta.client) {
    console.error('running usestate')
  }
  return { foo: Math.random() }
})
const useStateTest1 = useLocalState()
const useStateTest2 = useLocalState()

const useLocalAsyncData = () => useAsyncData(() => {
  if (import.meta.client) {
    console.error('running asyncdata')
  }
  return Promise.resolve({ foo: Math.random() })
}, { transform: data => data.foo })
const { data: useAsyncDataTest1 } = await useLocalAsyncData()
const { data: useAsyncDataTest2 } = await useLocalAsyncData()

const useLocalLazyAsyncData = () => useLazyAsyncData(() => {
  if (import.meta.client) {
    console.error('running asyncdata')
  }
  return Promise.resolve({ foo: Math.random() })
}, { transform: data => data.foo })
const { data: useLazyAsyncDataTest1 } = await useLocalLazyAsyncData()
const { data: useLazyAsyncDataTest2 } = await useLocalLazyAsyncData()

const useLocalFetch = () => useFetch('/api/counter', {
  transform: (data) => {
    if (import.meta.client) {
      console.error('running client-side transform')
    }
    return data.count
  },
})
const { data: useFetchTest1 } = await useLocalFetch()
const { data: useFetchTest2 } = await useLocalFetch()

const useLocalLazyFetch = () => useLazyFetch(() => '/api/counter')
const { data: useLazyFetchTest1 } = await useLocalLazyFetch()
const { data: useLazyFetchTest2 } = await useLocalLazyFetch()

const useLocalCustomKeyedComposable = () => useCustomKeyedComposable()
const useMyAsyncDataTest1 = useLocalCustomKeyedComposable()
const useMyAsyncDataTest2 = useLocalCustomKeyedComposable()
</script>

<template>
  <div>
    {{ useStateTest1 === useStateTest2 }}
    {{ useAsyncDataTest1 === useAsyncDataTest2 }}
    {{ useLazyAsyncDataTest1 === useLazyAsyncDataTest2 }}
    {{ useFetchTest1 === useFetchTest2 }}
    {{ useLazyFetchTest1 === useLazyFetchTest2 }}
    {{ !!useMyAsyncDataTest1 && useMyAsyncDataTest1 === useMyAsyncDataTest2 }}
  </div>
</template>

<style scoped>
body {
  background-color: #000;
  color: #fff;
}
</style>
</file>

<file path="test/fixtures/basic/app/pages/keyed-composables/local.vue">
<script setup lang="ts">
import { ShouldNotBeKeyed } from '~/other-composables-folder/local'

function localScopedComposables () {
  const _assert = (key?: string) => key ?? 'was not keyed'

  function basic () {
    function useState (key?: string) {
      return _assert(key)
    }
    const useAsyncData = _assert

    return [useState(), useAsyncData()]
  }

  function hoisting () {
    return [useState()]

    function useState (key?: string) {
      return _assert(key)
    }
  }

  function complex () {
    const [useState] = [_assert]
    const { a: useAsyncData } = {
      a: _assert,
    }
    const [_, { b: useLazyAsyncData }] = [null, {
      b: _assert,
    }]

    return [useState(), useAsyncData(), useLazyAsyncData()]
  }

  function deeperScope () {
    const useState = _assert

    return [(function () {
      return useState()
    })()]
  }

  function fromNonComponentFile () {
    return [_assert(ShouldNotBeKeyed)]
  }

  function useCustomKeyedComposable (arg?: string) {
    return _assert(arg)
  }

  return [...basic(), ...hoisting(), ...complex(), ...deeperScope(), ...fromNonComponentFile(), useCustomKeyedComposable()]
}
const skippedLocalScopedComposables = localScopedComposables().every(res => res === 'was not keyed')
</script>

<template>
  <div>
    {{ skippedLocalScopedComposables }}
  </div>
</template>

<style scoped>
body {
  background-color: #000;
  color: #fff;
}
</style>
</file>

<file path="test/fixtures/basic/app/pages/layout-switch/end.vue">
<template>
  <div id="end" />
</template>
</file>

<file path="test/fixtures/basic/app/pages/layout-switch/start.vue">
<template>
  <div>
    <NuxtLink to="/layout-switch/end">
      Switch layout
    </NuxtLink>
  </div>
</template>

<script setup lang="ts">
definePageMeta({
  layout: 'custom-async',
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/layouts/with-props.vue">
<script setup>
definePageMeta({
  layoutTransition: false,
})
</script>

<template>
  <div>
    <NuxtLayout
      name="with-props"
      some-prop="some prop was passed"
    >
      <div>
        some page content
      </div>
    </NuxtLayout>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/lazy-import-components/delayed-hydration/macro/index.vue">
<template>
  <div>
    hydrate-on-visible:
    <LazyVisibleDelayedComponentMacro data-testid="hydrate-on-visible" />
    hydrate-on-idle:
    <LazyIdleDelayedComponentMacro data-testid="hydrate-on-idle" />
    hydrate-on-interaction-default:
    <LazyInteractionDelayedComponentMacro data-testid="hydrate-on-interaction-default" />
    hydrate-on-interaction-click:
    <LazyInteractionDelayedComponentMacro
      data-testid="hydrate-on-interaction-click"
      :hydrate-on-interaction="['click']"
    />
    hydrate-on-media-query:
    <LazyMediaQueryDelayedComponentMacro
      data-testid="hydrate-on-media-query"
      hydrate-on-media-query="(max-width: 768px)"
    />
    hydrate-when-always:
    <LazyIfDelayedComponentMacro
      data-testid="hydrate-when-always"
      :hydrate-when="true"
    />
    hydrate-when-state:
    <button
      data-testid="button-increase-state"
      @click="state++"
    >
      Increase state
    </button>
    <LazyIfDelayedComponentMacro
      data-testid="hydrate-when-state"
      :hydrate-when="state > 0"
    />
    hydrate-never:
    <LazyNeverDelayedComponentMacro data-testid="hydrate-never" />
    <div style="height:3000px">
      This is a very tall div
    </div>
    hydrate-on-visible-bottom:
    <LazyVisibleDelayedComponentMacro data-testid="hydrate-on-visible-bottom" />
  </div>
</template>

<script setup lang="ts">
const LazyVisibleDelayedComponentMacro = defineLazyHydrationComponent('visible', () => import('~/components/DelayedComponent.vue'))
const LazyIdleDelayedComponentMacro = defineLazyHydrationComponent('idle', () => import('~/components/DelayedComponent.vue'))
const LazyInteractionDelayedComponentMacro = defineLazyHydrationComponent('interaction', () => import('~/components/DelayedComponent.vue'))
const LazyMediaQueryDelayedComponentMacro = defineLazyHydrationComponent('mediaQuery', () => import('~/components/DelayedComponent.vue'))
const LazyIfDelayedComponentMacro = defineLazyHydrationComponent('if', () => import('~/components/DelayedComponent.vue'))
const LazyNeverDelayedComponentMacro = defineLazyHydrationComponent('never', () => import('~/components/DelayedComponent.vue'))

const state = ref(0)
</script>
</file>

<file path="test/fixtures/basic/app/pages/lazy-import-components/delayed-hydration/macro/model-event.vue">
<template>
  <div>
    <LazyInteractionDelayedComponentMacro
      v-model="model"
      @hydrated="log"
    />
  </div>
</template>

<script setup lang="ts">
const LazyInteractionDelayedComponentMacro = defineLazyHydrationComponent('interaction', () => import('~/components/DelayedModel.vue'))

const model = ref(0)
function log () {
  console.log('Component hydrated')
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/lazy-import-components/delayed-hydration/macro/time.vue">
<template>
  <div>
    <LazyTimeDelayedComponentMacro
      data-testid="hydrate-after"
      :hydrate-after="50"
    />
  </div>
</template>

<script setup lang="ts">
// [Vue warn]: Do not use built-in or reserved HTML elements as component id: time
defineOptions({
  name: 'LazyTimeDelayedComponentMacroPage',
})

const LazyTimeDelayedComponentMacro = defineLazyHydrationComponent('time', () => import('~/components/DelayedComponent.vue'))
</script>
</file>

<file path="test/fixtures/basic/app/pages/lazy-import-components/delayed-hydration/index.vue">
<template>
  <div>
    hydrate-on-interaction-default:
    <LazyDelayedComponent
      data-testid="hydrate-on-interaction-default"
      hydrate-on-interaction
    />
    event-view-normal-component:
    <LazyEventView data-testid="event-view-normal-component" />
    hydrate-on-visible:
    <LazyDelayedComponent
      data-testid="hydrate-on-visible"
      hydrate-on-visible
    />
    hydrate-never:
    <LazyDelayedComponent
      data-testid="hydrate-never"
      hydrate-never
    />
    hydrate-on-interaction-click:
    <LazyDelayedComponent
      data-testid="hydrate-on-interaction-click"
      :hydrate-on-interaction="['click']"
    />
    hydrate-when-always:
    <LazyDelayedComponent
      data-testid="hydrate-when-always"
      :hydrate-when="true"
    />
    button-increase-state:
    <button
      data-testid="button-increase-state"
      @click="state++"
    >
      Increase state
    </button>
    hydrate-when-state:
    <LazyDelayedComponent
      data-testid="hydrate-when-state"
      :hydrate-when="state > 1"
    />
    hydrate-on-idle:
    <LazyDelayedComponent
      data-testid="hydrate-on-idle"
      :hydrate-on-idle="3"
    />
    <div style="height:3000px">
      This is a very tall div
    </div>
    hydrate-on-visible-bottom:
    <LazyDelayedComponent
      data-testid="hydrate-on-visible-bottom"
      hydrate-on-visible
    />
  </div>
</template>

<script setup lang="ts">
const state = useState('delayedHydrationCondition', () => 1)
</script>
</file>

<file path="test/fixtures/basic/app/pages/lazy-import-components/delayed-hydration/model-event.vue">
<template>
  <div>
    <LazyDelayedModel
      v-model="model"
      hydrate-on-interaction
      @hydrated="log"
    />
  </div>
</template>

<script setup lang="ts">
const model = ref(0)
function log () {
  console.log('Component hydrated')
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/lazy-import-components/delayed-hydration/time.vue">
<template>
  <div>
    <LazyDelayedComponent
      data-testid="hydrate-after"
      :hydrate-after="50"
    />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/lazy-import-components/index.vue">
<template>
  <div>
    <LazyNCompAll message="lazy-named-comp-all" />
    <LazyNCompClient message="lazy-named-comp-client" />
    <LazyNCompServer message="lazy-named-comp-server" />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/nested/[foo]/[bar].vue">
<script setup lang="ts">
const route = useRoute('nested-foo-bar')
</script>

<template>
  <div>
    <div>nested/[foo]/[bar].vue</div>
    <div>foo: {{ route.params.foo }}</div>
    <div>bar: {{ route.params.bar }}</div>
    <NuxtLink
      id="user-test"
      to="/nested/foo/user-test"
    >
      to /nested/foo/user-test
    </NuxtLink>
    <NuxtLink
      id="test"
      to="/nested/foo/test"
    >
      to /nested/foo/test
    </NuxtLink>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/nested/[foo]/user-[group].vue">
<script setup lang="ts">
const route = useRoute('nested-foo-user-group')
</script>

<template>
  <div>
    <div>nested/[foo]/user-[group].vue</div>
    <div>foo: {{ route.params.foo }}</div>
    <div>group: {{ route.params.group }}</div>

    <NuxtLink
      id="user-test"
      to="/nested/foo/user-test"
    >
      to /nested/foo/user-test
    </NuxtLink>
    <NuxtLink
      id="test"
      to="/nested/foo/test"
    >
      to /nested/foo/test
    </NuxtLink>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/nested/[foo].vue">
<script setup lang="ts">
const route = useRoute('nested-foo')
</script>

<template>
  <div>
    <div>nested/[foo]/index.vue</div>
    <div>foo: {{ route.params.foo }}</div>

    <div class="big-block" />
    <div class="big-block" />
    <NuxtPage />
  </div>
</template>

<style scoped>
.big-block {
  height: 90vh;
  width: 100vw;
}
</style>
</file>

<file path="test/fixtures/basic/app/pages/nested-group/(deep-group)/group-page.vue">
<template>
  <div>
    Page deep in group
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/nested-group/(index-group)/index.vue">
<template>
  <div>
    Index page of a group
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/nested-group/more-nested/(more-deep)/group-page.vue">
<template>
  <div>
    Page deep, deep in group
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/non-ascii/ç.vue">
<script setup lang="ts">
</script>

<template>
  <div>
    <!--  -->
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/nuxt-link/custom-external.vue">
<script setup lang="ts">
const MyLink = defineNuxtLink({
  componentName: 'MyLink',
  trailingSlash: 'append',
})
</script>

<template>
  <div>
    <div>
      <MyLink to="https://thehackernews.com/2024/01/urgent-upgrade-gitlab-critical.html">
        Trailing slashes should not be applied to implicit external links
      </MyLink>
    </div>
    <div>
      <NuxtLink
        :to="{ path: 'https://thehackernews.com/2024/01/urgent-upgrade-gitlab-critical.html' }"
        external
      >
        External links within route objects should be respected and not have trailing slashes applied
      </NuxtLink>
    </div>
    <div>
      <MyLink
        :to="{ path: '/missing-page' }"
        external
      >
        External links within route objects should be respected and have trailing slashes applied
      </MyLink>
    </div>
    <div>
      <MyLink
        to="/missing-page"
        external
      >
        External links should be respected and have trailing slashes applied
      </MyLink>
    </div>
    <div>
      <NuxtLink
        custom
        to="https://google.com"
        external
      >
        <template #default="{ navigate }">
          <button @click="navigate()">
            Using navigate() with external link should work
          </button>
        </template>
      </NuxtLink>
    </div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/nuxt-link/trailing-slash.vue">
<script setup lang="ts">
const LinkWithTrailingSlash = defineNuxtLink({
  trailingSlash: 'append',
})
const LinkWithoutTrailingSlash = defineNuxtLink({
  trailingSlash: 'remove',
})
const links = [
  '/',
  '/nuxt-link/trailing-slash',
  '/nuxt-link/trailing-slash/',
  '/nuxt-link/trailing-slash?test=true&thing=other/thing#thing-other',
  '/nuxt-link/trailing-slash/?test=true&thing=other/thing#thing-other',
  { name: 'nuxt-link-trailing-slash' },
  { query: { 'with-state': 'true' }, state: { foo: 'bar' } },
  { query: { 'without-state': 'true' } },
] as const

const route = useRoute()
const windowState = computed(() => {
  if (import.meta.client) {
    console.log(route.fullPath)
    return window.history.state.foo
  }
  return ''
})
</script>

<template>
  <div>
    <div data-testid="window-state">
      <ClientOnly>
        {{ windowState }}
      </ClientOnly>
    </div>
    <ul>
      <li
        v-for="(link, index) in links"
        :key="index"
      >
        <LinkWithTrailingSlash
          :to="link"
          class="link-with-trailing-slash"
        >
          <LinkWithTrailingSlash
            v-slot="{ href }"
            custom
            :to="link"
          >
            {{ href }}
          </LinkWithTrailingSlash>
        </LinkWithTrailingSlash>
      </li>
    </ul>
    <hr>
    <ul>
      <li
        v-for="(link, index) in links"
        :key="index"
      >
        <LinkWithoutTrailingSlash
          :to="link"
          class="link-without-trailing-slash"
        >
          <LinkWithoutTrailingSlash
            v-slot="{ href }"
            custom
            :to="link"
          >
            {{ href }}
          </LinkWithoutTrailingSlash>
        </LinkWithoutTrailingSlash>
      </li>
    </ul>
    <hr>
    <ul>
      <li
        v-for="(link, index) in links"
        :key="index"
      >
        <NuxtLink
          :to="link"
          class="nuxt-link"
        >
          <NuxtLink
            v-slot="{ href }"
            custom
            :to="link"
          >
            {{ href }}
          </NuxtLink>
        </NuxtLink>
      </li>
    </ul>
    <hr>
    <ul>
      <li
        v-for="(link, index) in links"
        :key="index"
      >
        <RouterLink
          :to="link"
          class="router-link"
        >
          <RouterLink
            v-slot="{ href }"
            custom
            :to="link"
          >
            {{ href }}
          </RouterLink>
        </RouterLink>
      </li>
    </ul>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/nuxt-link/use-link.vue">
<script setup lang="ts">
import { resolveDynamicComponent } from 'vue'
import { NuxtLink } from '#components'

const useLinkPresent = 'useLink' in NuxtLink
const link = useLinkPresent ? NuxtLink.useLink({ to: '/nuxt-link/trailing-slash' }) : undefined
const route = computed(() => link?.route.value.path)
const href = computed(() => link?.href.value)

const NuxtLink2 = resolveComponent('NuxtLinkAlias') as unknown as any
const useLink2Present = typeof NuxtLink2 !== 'string' && 'useLink' in NuxtLink2
const link2 = useLink2Present ? NuxtLink2.useLink({ to: '/nuxt-link/trailing-slash' }) : undefined
const route2 = computed(() => link2?.route.value.path)
const href2 = computed(() => link2?.href.value)

const NuxtLink3 = resolveDynamicComponent('NuxtLinkAlias') as unknown as any
const useLink3Present = typeof NuxtLink3 !== 'string' && 'useLink' in NuxtLink3
const link3 = useLink3Present ? NuxtLink3.useLink({ to: '/nuxt-link/trailing-slash' }) : undefined
const route3 = computed(() => link3?.route.value.path)
const href3 = computed(() => link3?.href.value)
</script>

<template>
  <div>
    <div>useLink in NuxtLink: {{ useLinkPresent }}</div>
    <div>route using useLink: {{ route }}</div>
    <div>href using useLink: {{ href }}</div>
    <button
      id="button1"
      @click="link?.navigate()"
    >
      Test
    </button>
    <div>useLink2 in NuxtLink: {{ useLink2Present }}</div>
    <div>route2 using useLink: {{ route2 }}</div>
    <div>href2 using useLink: {{ href2 }}</div>
    <button
      id="button2"
      @click="link2?.navigate()"
    >
      Test
    </button>
    <div>useLink3 in NuxtLink: {{ useLink3Present }}</div>
    <div>route3 using useLink: {{ route3 }}</div>
    <div>href3 using useLink: {{ href3 }}</div>
    <button
      id="button3"
      @click="link3?.navigate()"
    >
      Test
    </button>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/page-load-hook/[slug].vue">
<template>
  <div>
    <NuxtLink to="/page-load-hook">
      Back to parent
    </NuxtLink>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/parent/index.vue">
<template>
  <div>
    parent/index
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/prefetch/components.vue">
<script setup lang="ts">
await prefetchComponents('TestGlobal')
</script>

<template>
  <div>
    Testing prefetching global components
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/prefetch/index.vue">
<template>
  <div>
    <NuxtLink :to="{ name: 'prefetch-server-components' }">
      Server components page
    </NuxtLink>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/prefetch/server-components.vue">
<template>
  <div>
    Testing prefetching server components:

    <AsyncServerComponent :count="34" />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/prerender/ç.vue">
<script setup lang="ts">
const wasPrerendered = useState(() => import.meta.prerender)
</script>

<template>
  <div>
    should be prerendered: {{ wasPrerendered }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/prerender/test.vue">
<script setup lang="ts">
const wasPrerendered = useState(() => import.meta.prerender)
</script>

<template>
  <div>
    should be prerendered: {{ wasPrerendered }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/preview/index.vue">
<script setup>
const { enabled: isPreview } = usePreviewMode()

const { data } = await useAsyncData(async () => {
  await new Promise(resolve => setTimeout(resolve, 200))

  const fetchedOnClient = import.meta.client

  console.log(fetchedOnClient)

  return { fetchedOnClient }
})
</script>

<template>
  <div>
    <NuxtLink
      id="use-fetch-check"
      href="/preview/with-use-fetch"
    >
      check useFetch
    </NuxtLink>

    <p
      v-if="data && data.fetchedOnClient"
      id="fetched-on-client"
    >
      fetched on client
    </p>

    <p
      v-if="isPreview"
      id="preview-mode"
    >
      preview mode enabled
    </p>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/preview/with-custom-enable.vue">
<script setup>
const route = useRoute()

const { enabled } = usePreviewMode({
  shouldEnable: () => {
    return !!route.query.customPreview
  },
})
</script>

<template>
  <div>
    <p id="enabled">
      {{ enabled }}
    </p>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/preview/with-custom-state.vue">
<script setup>
const data1 = ref('data1')

const { enabled, state } = usePreviewMode({
  getState: () => {
    return { data1, data2: 'data2' }
  },
})

onMounted(() => {
  data1.value = 'data1 updated'
})
</script>

<template>
  <div>
    <NuxtLink
      id="with-use-fetch"
      to="/preview/with-use-fetch"
    >
      fetch check
    </NuxtLink>

    <p id="data1">
      {{ state.data1 }}
    </p>

    <p id="data2">
      {{ state.data2 }}
    </p>

    <button
      id="toggle-preview"
      @click="enabled = !enabled"
    >
      toggle preview mode
    </button>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/preview/with-use-fetch.vue">
<script setup>
const { enabled, state } = usePreviewMode()

const { data } = await useFetch('/api/preview', {
  query: {
    apiKey: state.token || undefined,
  },
})
</script>

<template>
  <div>
    <p id="enabled">
      {{ enabled }}
    </p>

    <p id="token-check">
      {{ state.token }}
    </p>

    <p id="correct-api-key-check">
      {{ data && data.hehe }}
    </p>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/random/[id].vue">
<template>
  <div>
    <NuxtLink
      to="/"
      no-prefetch
    >
      Home
    </NuxtLink>
    <NuxtLink
      to="/random/a"
      prefetched-class="prefetched"
    >
      Random (A)
    </NuxtLink>
    <NuxtLink
      to="/random/b"
      prefetched-class="prefetched"
    >
      Random (B)
    </NuxtLink>
    <NuxtLink
      to="/random/c"
      prefetched-class="prefetched"
    >
      Random (C)
    </NuxtLink>
    <ServerOnlyComponent />
    <br>

    Random: {{ random }}

    Random: (global) {{ globalRandom }}

    Random page: <b>{{ route.params.id }}</b><br>

    Here are some random numbers for you:

    <ul>
      <li
        v-for="n in randomNumbers"
        :key="n"
      >
        {{ n }}
      </li>
    </ul>
    <button @click="() => refresh()">
      Give me another set
    </button>
  </div>
</template>

<script setup lang="ts">
const route = useRoute('random-id')

const pageKey = 'rand_' + route.params.id

const { data: randomNumbers, refresh } = await useFetch('/api/random', { key: pageKey as string })

const random = useRandomState(100, pageKey)
const globalRandom = useRandomState(100)
</script>

<style scoped>
  .prefetched {
    color: green;
  }
</style>
</file>

<file path="test/fixtures/basic/app/pages/route-provider/index/bar.vue">
<script setup lang="ts">
const route = useRoute()
await new Promise(resolve => setTimeout(resolve, 100))
</script>

<template>
  <div data-testid="bar">
    bar: {{ $route.path }} - {{ route.path }}
  </div>
</template>

<style scoped>

</style>
</file>

<file path="test/fixtures/basic/app/pages/route-provider/index/foo.vue">
<script setup lang="ts">
const route = useRoute()
await new Promise(resolve => setTimeout(resolve, 100))
</script>

<template>
  <div data-testid="foo">
    foo: {{ $route.path }} - {{ route.path }}
  </div>
</template>

<style scoped>

</style>
</file>

<file path="test/fixtures/basic/app/pages/route-provider/index.vue">
<template>
  <div>
    <NuxtPage />
    <NuxtLink to="/route-provider/foo">
      foo
    </NuxtLink>
    <NuxtLink to="/route-provider/bar">
      bar
    </NuxtLink>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/route-rules/inline.vue">
<script setup lang="ts">
defineRouteRules({
  headers: {
    'x-extend': 'added in routeRules',
  },
})
</script>

<template>
  <div>
    Route rules defined inline
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/route-rules/layout.vue">
<template>
  <div>
    <div>Should use layout set in route-rules</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/route-rules/middleware.vue">
<template>
  <div>
    <div>Greeting: {{ $route.meta.hello }}</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/route-rules/redirect.vue">
<template>
  <div>
    Should be redirected
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/route-rules/spa.vue">
<template>
  <div>
    should not be rendered on ssr
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/route-scroll-behavior/scroll-to-top/[id].vue">
<script setup lang="ts">
definePageMeta({
  scrollToTop (to) {
    return to.query.scrollToTop === 'true'
  },
})

const route = useRoute()
</script>

<template>
  <div>
    <h2>{{ route.params.id }}</h2>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/route-scroll-behavior/scroll-to-top.vue">
<script setup lang="ts">
const nuxtApp = useNuxtApp()

nuxtApp.hook('page:transition:finish', (Data) => {
  console.log('動畫完成', Data)
})
</script>

<template>
  <div>
    <NuxtPage />

    <div style="height: 150vh" />

    <NuxtLink
      :to="{
        name: 'route-scroll-behavior-scroll-to-top',
      }"
    >
      Back to scroll to top
    </NuxtLink> |
    <NuxtLink
      id="scroll-to-top"
      :to="{
        name: 'route-scroll-behavior-scroll-to-top-id',
        params: { id: 'scroll-to-top' },
        query: { scrollToTop: 'true' },
      }"
    >
      Scroll to top
    </NuxtLink> |
    <NuxtLink
      id="do-not-scroll-to-top"
      :to="{
        name: 'route-scroll-behavior-scroll-to-top-id',
        params: { id: 'do-not-scroll-to-top' },
        query: { scrollToTop: 'false' },
      }"
    >
      Do not scroll to top
    </NuxtLink>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/server-components/lazy/end.vue">
<script setup lang="ts">
const page = ref<HTMLDivElement | undefined>()
const mountedHTML = ref()
onMounted(() => {
  mountedHTML.value = page.value?.innerHTML
})

const lazy = useRoute().query.lazy === 'true'
</script>

<template>
  <div
    ref="page"
    class="end-page"
  >
    End page
    <pre>{{ mountedHTML }}</pre>
    <section id="fallback">
      <AsyncServerComponent
        :lazy="lazy"
        :count="42"
      >
        <template #fallback>
          Loading server component
        </template>
      </AsyncServerComponent>
    </section>
    <section id="no-fallback">
      <AsyncServerComponent
        :lazy="lazy"
        :count="42"
      />
    </section>

    <ServerWithClient :lazy="lazy" />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/server-components/lazy/start.vue">
<template>
  <div>
    <NuxtLink to="/server-components/lazy/end?lazy=true">
      Go to page with lazy server component
    </NuxtLink>
    <NuxtLink to="/server-components/lazy/end?lazy=false">
      Go to page without lazy server component
    </NuxtLink>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/server-components/lost-page.server.vue">
<template>
  <div />
</template>

<script setup lang="ts">
throw showError(createError({ statusCode: 404, statusMessage: 'not found' }))
</script>
</file>

<file path="test/fixtures/basic/app/pages/suspense/async-[parent]/async-[child].vue">
<script setup lang="ts">
if (import.meta.client) {
  console.log('[async] [async]')
}
const route = useRoute('suspense-async-parent-async-child')
await new Promise(resolve => setTimeout(resolve, 50))
if (import.meta.client) {
  console.log(`[async] [${route.params.parent}] [async] [${route.params.child}] running async data`)
}
const data = route.params
</script>

<template>
  <div :id="'child' + route.path.replace(/[/-]+/g, '-')">
    Async child: {{ route.params.parent }} - {{ route.params.child }}
    <hr>
    {{ data }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/suspense/async-[parent]/sync-[child].vue">
<script setup lang="ts">
if (import.meta.client) {
  console.log('[async] [sync]')
}
const route = useRoute('suspense-async-parent-sync-child')
</script>

<template>
  <div :id="'child' + route.path.replace(/[/-]+/g, '-')">
    Sync child: {{ route.params.parent }} - {{ route.params.child }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/suspense/sync-[parent]/async-[child].vue">
<script setup lang="ts">
if (import.meta.client) {
  console.log('[sync] [async]')
}
const route = useRoute('suspense-async-parent-sync-child')
await new Promise(resolve => setTimeout(resolve, 50))
if (import.meta.client) {
  console.log(`[sync] [${route.params.parent}] [async] [${route.params.child}] running async data`)
}
const data = route.params
</script>

<template>
  <div :id="'child' + route.path.replace(/[/-]+/g, '-')">
    Async child: {{ route.params.parent }} - {{ route.params.child }}
    <hr>
    {{ data }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/suspense/sync-[parent]/sync-[child].vue">
<script setup lang="ts">
if (import.meta.client) {
  console.log('[sync] [sync]')
}
const route = useRoute('suspense-sync-parent-sync-child')
</script>

<template>
  <div :id="'child' + route.path.replace(/[/-]+/g, '-')">
    Sync child: {{ route.params.parent }} - {{ route.params.child }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/suspense/async-[parent].vue">
<script setup lang="ts">
if (import.meta.client) {
  console.log('[async]')
}
const route = useRoute('suspense-async-parent')
await new Promise(resolve => setTimeout(resolve, 100))
if (import.meta.client) {
  console.log('[async] running async data')
}
</script>

<template>
  <main :id="route.path.replace(/[/-]+/g, '-')">
    Async parent: {{ route.params.parent }}
    <hr>
    <NuxtPage />
  </main>
</template>
</file>

<file path="test/fixtures/basic/app/pages/suspense/sync-[parent].vue">
<script setup lang="ts">
if (import.meta.client) {
  console.log('[sync]')
}
const route = useRoute('suspense-async-parent')
</script>

<template>
  <main :id="route.path.replace(/[/-]+/g, '-')">
    Sync parent: {{ route.params.parent }}
    <hr>
    <NuxtPage />
  </main>
</template>
</file>

<file path="test/fixtures/basic/app/pages/useAsyncData/double.vue">
<template>
  <div>
    Single
    <div>
      data1: {{ data1 }}
      data2: {{ data2 }}
    </div>
  </div>
</template>

<script setup lang="ts">
const { data: data1 } = await useSleep()
const { data: data2 } = await useSleep()

if (data1.value === null || data1.value === undefined || data1.value.length <= 0) {
  throw new Error('Data should never be null or empty.')
}

if (data2.value === null || data2.value === undefined || data2.value.length <= 0) {
  throw new Error('Data should never be null or empty.')
}

if (data1.value !== data2.value) {
  throw new Error('AsyncData not synchronised')
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/useAsyncData/immediate-remove-unmounted.vue">
<template>
  <div>
    <div>immediate-remove-unmounted.vue</div>
    <div id="immediate-data">
      {{ data === null ? "null" : (data === undefined ? 'undefined' : data) }}
    </div>
    <button
      id="execute-btn"
      @click="() => execute()"
    >
      execute
    </button>
    <NuxtLink
      id="to-index"
      to="/"
    >
      index
    </NuxtLink>
  </div>
</template>

<script setup lang="ts">
const { data, execute } = await useAsyncData('immediateFalse', () => $fetch('/api/random'), { immediate: false })

if (data.value !== undefined) {
  throw new Error(`Initial data should be undefined: ` + data.value)
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/useAsyncData/immediate.vue">
<template>
  <div>
    Single
    <div>
      data: {{ data }}
    </div>
  </div>
</template>

<script setup lang="ts">
const called = ref(0)
const { data, execute } = await useAsyncData(() => Promise.resolve(++called.value), { immediate: false })

if (called.value !== 0) {
  throw new Error('Handled should have not been called')
}

if (import.meta.server && data.value !== null) {
  throw new Error('Initial data should be null: ' + data.value)
}

await execute()
await execute()

if (import.meta.server && called.value as number !== 2) {
  throw new Error('Should have been called once after execute (server) but called ' + called.value + ' times')
}

if (import.meta.client && called.value as number !== 2) {
  throw new Error('Should have been called once after execute (client) but called ' + called.value + ' times')
}

if (data.value !== 2) {
  throw new Error('Data should be 1 after execute')
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/useAsyncData/nuxt-data.vue">
<template>
  <div
    v-if="status === 'success'"
    v-text="'resolved:' + data.resolved"
  />
  <div
    v-else
    v-text="'loading'"
  />
</template>

<script setup>
useNuxtData('call')
const { data, status } = await useAsyncData('call', () => Promise.resolve({ resolved: true }), { server: false })
</script>
</file>

<file path="test/fixtures/basic/app/pages/useAsyncData/promise-all.vue">
<template>
  <div>
    Single
    <div>
      data1: {{ result1.data.value }}
      data2: {{ result2.data.value }}
    </div>
  </div>
</template>

<script setup lang="ts">
const [result1, result2] = await Promise.all([useSleep(), useSleep()])

if (result1.data.value === null || result1.data.value === undefined || result1.data.value.length <= 0) {
  throw new Error('Data should never be null or empty.')
}

if (result2.data.value === null || result2.data.value === undefined || result2.data.value.length <= 0) {
  throw new Error('Data should never be null or empty.')
}

if (result1.data.value !== result2.data.value) {
  throw new Error('AsyncData not synchronised')
}

await result1.refresh()

if (result1.data.value !== result2.data.value) {
  throw new Error('AsyncData not synchronised')
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/useAsyncData/refresh.vue">
<template>
  <div>
    Single
    <div>
      {{ data }} - {{ data2 }}
    </div>
  </div>
</template>

<script setup lang="ts">
const { data, refresh } = await useCounter()
const { data: data2, refresh: refresh2 } = await useCounter()

let initial = data.value!.count

// Refresh on client and server side
await refresh()

if (data.value!.count !== initial + 1) {
  throw new Error('Data not refreshed?' + data.value!.count + ' : ' + data2.value!.count)
}

if (data.value!.count !== data2.value!.count) {
  throw new Error('AsyncData not synchronised')
}

initial = data.value!.count

await refresh2()

if (data.value!.count !== initial + 1) {
  throw new Error('data2 refresh not synchronised?')
}

if (data.value!.count !== data2.value!.count) {
  throw new Error('AsyncData not synchronised')
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/useAsyncData/single.vue">
<template>
  <div>
    Single
    <div>
      {{ data }}
    </div>
  </div>
</template>

<script setup lang="ts">
const { data } = await useSleep()

if (data.value === null || data.value === undefined || data.value.length <= 0) {
  throw new Error('Data should never be null or empty.')
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/useAsyncData/status.vue">
<script setup lang="ts">
const { status: status1 } = await useAsyncData(() => Promise.resolve(true))
if (status1.value !== 'success') {
  throw new Error('status1 should be "success"')
}

const { status: status2 } = await useAsyncData(() => Promise.reject(new Error('boom!')))
if (status2.value !== 'error') {
  throw new Error('status2 should be "error"')
}

const { status: status3 } = await useAsyncData(() => Promise.resolve(true), { immediate: false })
if (status3.value !== 'idle') {
  throw new Error('status3 should be "idle"')
}

const { status: status4, execute } = await useAsyncData(() => Promise.resolve(true), { immediate: false })
await execute()
if (status4.value !== 'success') {
  throw new Error('status4 should be "success"')
}

const { status: status5 } = await useAsyncData(() => Promise.resolve(true), { server: false })
if (import.meta.server && status5.value !== 'idle') {
  throw new Error('status5 should be "idle" server side')
}

const status5Values = ref<string[]>([])
watchEffect(() => {
  status5Values.value.push(status5.value)
})
</script>

<template>
  <div>
    Status
    <div>
      {{ status1 === 'success' }}
      {{ status2 === 'error' }}
      {{ status3 === 'idle' }}
      {{ status4 === 'success' }}
      <ClientOnly>
        <div id="status5-values">
          {{ status5Values.join(',') }}
        </div>
      </ClientOnly>
    </div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/useAsyncData/use-id.vue">
<script setup lang="ts">
const Child = defineComponent({
  setup () {
    const id = useId()
    return () => h('div', id)
  },
})

const id = useId()
useAsyncData('test', () => Promise.resolve('A'))
</script>

<template>
  <div>
    <Child />
    {{ id }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/wrapper-expose/page/another.vue">
<template>
  <div>
    <p>
      hello
    </p>
    <NuxtLink
      id="to-foo"
      to="/wrapper-expose/page"
    >
      to foo
    </NuxtLink>
  </div>
</template>

<script setup lang="ts">
function hello () {
  console.log('world')
}

defineExpose({
  hello,
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/wrapper-expose/page/index.vue">
<template>
  <div>
    <p>foo</p>
    <NuxtLink
      id="to-hello"
      to="/wrapper-expose/page/another"
    >
      to hello
    </NuxtLink>
  </div>
</template>

<script setup lang="ts">
function foo () {
  console.log('bar')
}

defineExpose({
  foo,
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/wrapper-expose/layout.vue">
<template>
  <div>
    <button
      class="swap-layout"
      @click="swapLayout"
    >
      swap layout
    </button>
    <button
      class="log-foo"
      @click="logFoo"
    >
      log foo
    </button>
    <button
      class="log-hello"
      @click="logHello"
    >
      log hello
    </button>
    <NuxtLayout ref="layout" />
  </div>
</template>

<script setup lang="ts">
const layout = ref()
const currentLayout = useState('current-layout', () => 'custom')

definePageMeta({
  layout: 'custom',
})

function logFoo () {
  layout.value.layoutRef.logFoo()
}
function logHello () {
  layout.value.layoutRef.logHello()
}

function swapLayout () {
  currentLayout.value = currentLayout.value === 'custom2' ? 'custom' : 'custom2'
  setPageLayout(currentLayout.value)
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/wrapper-expose/page.vue">
<template>
  <div>
    <NuxtPage ref="page" />

    <button
      id="log-hello"
      @click="logHello"
    >
      hello
    </button>
    <button
      id="log-foo"
      @click="logFoo"
    >
      foo
    </button>
  </div>
</template>

<script setup lang="ts">
const page = ref()

function logFoo () {
  page.value.pageRef.foo()
}

function logHello () {
  page.value.pageRef.hello()
}
</script>
</file>

<file path="test/fixtures/basic/app/pages/another-parent.vue">
<template>
  <div>
    another-parent
    <NuxtPage />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/app-config.vue">
<template>
  <div>
    App Config:
    <!-- eslint-disable-next-line vue/no-v-html -->
    <pre v-html="JSON.stringify(appConfig)" />
  </div>
</template>

<script setup lang="ts">
const appConfig = useAppConfig()
</script>
</file>

<file path="test/fixtures/basic/app/pages/assets-custom.vue">
<template>
  <div>
    <img src="/public.svg">
    <img src="/public.svg?123">
    <img src="/custom/file.svg">
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/assets.vue">
<template>
  <div>
    <img
      src="~/assets/logo.svg"
      class="h-20 mb-4"
    >
    <img
      src="/public.svg"
      class="h-20 mb-4"
    >
    <img
      :src="logo"
      class="h-20 mb-4"
    >
  </div>
</template>

<script setup>
import logo from '~/assets/logo.svg'
</script>

<style>
#__nuxt {
  background-image: url('~/assets/logo.svg');
  background-repeat: no-repeat;
  background-position: bottom right;
}
body {
  background-image: url('/public.svg');
  background-repeat: no-repeat;
  background-position: top;
}
@font-face {
  src: url('/public.svg') format('woff2');
}
</style>
</file>

<file path="test/fixtures/basic/app/pages/async-context.vue">
<template>
  <div>
    <Head>
      <Title>Native Async Context</Title>
    </Head>
    {{ data }}
  </div>
</template>

<script setup lang="ts">
const data = await nestedAsyncComposable()
</script>
</file>

<file path="test/fixtures/basic/app/pages/async-parent.vue">
<template>
  <div>
    async-parent
    <NuxtPage />
  </div>
</template>

<script setup>
await Promise.resolve()
if (import.meta.client) {
  console.log('isHydrating: ' + useNuxtApp().isHydrating)
}
definePageMeta({
  layout: 'custom',
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/auth.vue">
<script setup>
definePageMeta({
  middleware: 'inject-auth',
})
</script>

<template>
  <div>
    <div>auth.vue</div>
    <div>auth: {{ $route.meta.auth }}</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/chunk-error.vue">
<script setup lang="ts">
const someValue = useState('val', () => 1)
</script>

<template>
  <div>
    Chunk error page
    <hr>
    State: {{ someValue }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/client-fallback.vue">
<template>
  <div>
    Hello World
    <div id="locator-for-playwright">
      <!-- single child -->
      <NuxtClientFallback
        fallback-tag="span"
        class="break-in-ssr"
        fallback="this failed to render"
      >
        <BreakInSetup />
      </NuxtClientFallback>
      <!-- multi child -->
      <NuxtClientFallback>
        <BreakInSetup class="broke-in-ssr" />
        <BreakInSetup />
      </NuxtClientFallback>
      <!-- don't render if one child fails in ssr -->
      <NuxtClientFallback>
        <BreakInSetup />
        <Counter
          id="sugar-counter"
          :multiplier="multiplier"
        />
      </NuxtClientFallback>
      <!-- nested children fails -->
      <NuxtClientFallback>
        <div>
          <BreakInSetup />
        </div>
        <Counter :multiplier="multiplier" />
      </NuxtClientFallback>
      <!-- should be rendered -->
      <NuxtClientFallback fallback-tag="p">
        <FunctionalComponent />
      </NuxtClientFallback>
      <!-- fallback -->
      <NuxtClientFallback>
        <BreakInSetup />
        <template #fallback>
          <div>Hello world !</div>
        </template>
      </NuxtClientFallback>
      <ClientFallbackStateful />
      <ClientFallbackStatefulSetup />
      <ClientFallbackNonStatefulSetup />
      <ClientFallbackNonStateful />
      <ClientFallbackAsyncSetup />
      <NuxtClientFallback keep-fallback>
        <div>
          <BreakInSetup />
        </div>
        <template #fallback>
          <div id="keep-fallback">
            keep fallback in client
          </div>
        </template>
      </NuxtClientFallback>
    </div>
    <button
      id="increment-count"
      @click="multiplier++"
    >
      increment count
    </button>
  </div>
</template>

<script setup>
const multiplier = ref(0)
</script>
</file>

<file path="test/fixtures/basic/app/pages/client-only-components.vue">
<template>
  <div>
    <ClientBinding />
    <ClientScript
      ref="clientScript"
      class="client-only-script"
      foo="bar"
    />
    <ClientSetupScript
      ref="clientSetupScript"
      class="client-only-script-setup"
      foo="hello"
    >
      <template #test>
        <BreakServerComponent />
        <div class="slot-test">
          Hello
          <BreaksServer />
        </div>
      </template>
    </ClientSetupScript>
    <ClientOnly>
      Should not be server rendered.
      <BreakServerComponent />
      <template #fallback>
        <div>Fallback</div>
      </template>
    </ClientOnly>
    <!-- ensure multi root node components are correctly rendered (Fragment) -->
    <ClientMultiRootNode class="multi-root-node" />
    <ClientMultiRootNodeScript class="multi-root-node-script" />

    <!-- ensure components with a single single child are correctly rendered -->
    <ClientStringChildStateful
      ref="stringStatefulComp"
      class="string-stateful"
    />
    <ClientStringChildStatefulScript
      ref="stringStatefulScriptComp"
      class="string-stateful-script"
    />
    <ClientNoState class="no-state" />
    <!-- ensure directives are correctly passed -->
    <ClientStringChildStateful
      v-show="show"
      class="string-stateful-should-be-hidden"
    />
    <ClientSetupScript
      v-show="show"
      class="client-script-should-be-hidden"
      foo="bar"
    />
    <ClientStringChildStatefulScript
      v-show="show"
      class="string-stateful-script-should-be-hidden"
    />
    <ClientNoState
      v-show="show"
      class="no-state-hidden"
    />

    <WrapClientComponent v-if="show" />
    <button
      class="test-ref-1"
      @click="stringStatefulComp.add"
    >
      increment count
    </button>
    <button
      class="test-ref-2"
      @click="stringStatefulScriptComp.add"
    >
      increment count
    </button>
    <button
      class="test-ref-3"
      @click="clientScript.add"
    >
      increment count
    </button>
    <button
      class="test-ref-4"
      @click="clientSetupScript.add"
    >
      increment count
    </button>

    <button
      id="show-all"
      @click="show = true"
    >
      Show all
    </button>
  </div>
</template>

<script setup lang="ts">
// bypass client import protection to ensure this is treeshaken from .client components
import BreaksServer from '~/components/BreaksServer.client'

type Comp = { add: () => void }
const stringStatefulComp = ref<Comp>(null)
const stringStatefulScriptComp = ref<Comp>(null)
const clientScript = ref<Comp>(null)
const clientSetupScript = ref<Comp>(null)
const BreakServerComponent = defineAsyncComponent(() => {
  return import('./../components/BreaksServer.client')
})

const show = ref(false)
</script>
</file>

<file path="test/fixtures/basic/app/pages/client-only-explicit-import.vue">
<template>
  <div>
    <ClientOnlyScript
      class="client-only-script"
      foo="bar"
    />
    <LazyClientOnlySetupScript
      class="lazy-client-only-script-setup"
      foo="hello"
    />
  </div>
</template>

<script setup lang="ts">
import { ClientOnlyScript, LazyClientOnlySetupScript } from '#components'
</script>
</file>

<file path="test/fixtures/basic/app/pages/client-server.vue">
<template>
  <div>
    <div class="placeholder-to-ensure-no-override">
      this should not be removed by hydration
    </div>
    <ClientFragmentServer />

    <div class="placeholder-to-ensure-no-override">
      this should not be removed by hydration
    </div>
    <ClientServerFragment />

    <div class="placeholder-to-ensure-no-override">
      this should not be removed by hydration
    </div>
    <ClientServer />

    <div class="placeholder-to-ensure-no-override">
      this should not be removed by hydration
    </div>

    <ClientFragmentServerFragment />

    <div class="placeholder-to-ensure-no-override">
      this should not be removed by hydration
    </div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/client.vue">
<script setup lang="ts">
// explicit import to bypass client import protection
import BreaksServer from '../components/BreaksServer.client'
// ensure treeshake-client-only module remove these imports without breaking
import TestGlobal from '../components/global/TestGlobal.vue'
// direct import of .client components should be treeshaken
import { FunctionalComponent, LazyClientOnlyScript } from '#components'

onMounted(() => import('~/components/BreaksServer.client'))
onBeforeMount(() => import('~/components/BreaksServer.client'))
onBeforeUpdate(() => import('~/components/BreaksServer.client'))
onRenderTracked(() => import('~/components/BreaksServer.client'))
onRenderTriggered(() => import('~/components/BreaksServer.client'))
onActivated(() => import('~/components/BreaksServer.client'))
onDeactivated(() => import('~/components/BreaksServer.client'))
onBeforeUnmount(() => import('~/components/BreaksServer.client'))
</script>

<template>
  <div>
    This page should not crash when rendered.
    <ClientOnly class="something">
      <span>rendered client-side</span>
      <BreaksServer />
      <BreaksServer>Some slot content</BreaksServer>
    </ClientOnly>
    This should render.
    <div>
      <ClientOnly class="another">
        <span>rendered client-side</span>
        <BreaksServer />
      </ClientOnly>
    </div>
    <div>
      <LazyClientOnly>
        <div class="red">
          i'm red
        </div>
        <div>
          <BreaksServer />
          <FunctionalComponent />
          <TestGlobal />
        </div>
        <template #fallback>
          <div>fallback for ClientOnly</div>
        </template>
      </LazyClientOnly>
      <LazyClientOnlyScript>
        <template #test>
          <BreaksServer />
          <div id="client-side">
            This should be rendered client-side
          </div>
        </template>
        <template #fallback>
          <FunctionalComponent />
          <!-- this should be treeshaken on .client -->
          <BreaksServer />
        </template>
      </LazyClientOnlyScript>
      <div class="blue">
        i'm blue
      </div>
    </div>
  </div>
</template>

<style scoped>
.red {
  color: rgb(255, 0, 0);
}
.blue {
  color: rgb(0, 0, 255);
}
</style>
</file>

<file path="test/fixtures/basic/app/pages/cookies.vue">
<script setup lang="ts">
import CookieComponent from '../components/ComponentUsingCookie.vue'
import { useCookieManager } from '../composables/cookie-manager'

useCookie('accessed-but-not-used')
useCookie('accessed-with-default-value', { default: () => 'default' })
useCookie('set').value = 'set'
useCookie('set-to-null').value = null
useCookie<string | null>('set-to-null-with-default', { default: () => 'default' }).value = null

// the next set are all sent by browser
useCookie('browser-accessed-but-not-used')
useCookie('browser-accessed-with-default-value', { default: () => 'default' })
useCookie('browser-set').value = 'set'
// confirm that it only sets one `set-cookie` header
useCookie('browser-set').value = 'set'
useCookie('browser-set-to-null').value = null
useCookie<string | null>('browser-set-to-null-with-default', { default: () => 'default' }).value = null

const objectCookie = useCookie<{ foo: string } | undefined>('browser-object-default')
const objectCookieSecond = useCookie('browser-object-default', {
  default: () => ({ foo: 'bar' }),
})
function changeCookie () {
  if (objectCookie.value!.foo === 'baz') {
    objectCookie.value!.foo = 'bar'
  } else {
    objectCookie.value!.foo = 'baz'
  }
}

const { showCookieBanner, toggle } = useCookieManager()
</script>

<template>
  <div>
    <div>cookies testing page</div>
    <pre>{{ objectCookie?.foo }}</pre>
    <pre>{{ objectCookieSecond.foo }}</pre>
    <button @click="changeCookie">
      Change cookie
    </button>
    <button @click="refreshCookie('browser-object-default')">
      Refresh cookie
    </button>

    <CookieComponent />
    <div
      v-if="showCookieBanner"
      id="parent-banner"
    >
      parent banner
    </div>
    <button @click="toggle">
      Toggle cookie banner
    </button>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/empty.ts">

</file>

<file path="test/fixtures/basic/app/pages/extends.vue">
<template>
  <div>
    {{ useOverridableComposable() }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/fixed-keyed-child-parent.vue">
<template>
  <div>
    fixed-keyed-child-parent
    <NuxtPage />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/head-component.vue">
<template>
  <div>
    <Head>
      <Link
        rel="alternate"
        href="/"
      />
      <Link
        key="dedupe-key"
        rel="x-test"
        :href="isServer ? 'server' : 'client'"
      />
    </Head>
  </div>
</template>

<script setup lang="ts">
const isServer = import.meta.server
</script>
</file>

<file path="test/fixtures/basic/app/pages/head-script-setup.vue">
<script lang="ts" setup>
import { TemplateParamsPlugin } from '@unhead/vue/plugins'
// Unhead v2 requires an opt-in to template params
const head = injectHead()
head.use(TemplateParamsPlugin)

const description = ref('head script setup description for %site.name')
const siteName = ref()
// server meta
useServerSeoMeta({
  description,
  ogDescription: description,
  ogImage: '%site.url/og-image.png',
  ogTitle: '%s %separator %site.name',
  ogType: 'website',
  ogUrl: '%site.url/head-script-setup',
})

useServerHead({
  style: [
    '/* Custom styles */',
    'h1 { color: salmon; }',
  ],
})

useHead({
  title: 'head script setup',
  titleTemplate: '%s %separator %site.name',
  templateParams: {
    separator: () => '-',
    site: {
      url: 'https://example.com',
      name: siteName,
    },
  },
})

useHeadSafe({
  script: [
    {
      id: 'xss-script',
      // @ts-expect-error not allowed
      innerHTML: 'alert("xss")',
    },
  ],
  meta: [
    {
      // @ts-expect-error not allowed
      'http-equiv': 'refresh',
      'content': '0;javascript:alert(1)',
    },
  ],
})

siteName.value = 'Nuxt Playground'
</script>

<template>
  <div>
    <h1>head script setup</h1>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/head.vue">
<script>
export default defineNuxtComponent({
  setup () {
    const a = ref('')
    useHead({
      // title template function example
      titleTemplate: title => `${title} - Title Template Fn Change`,
      bodyAttrs: {
        class: 'body-attrs-test',
      },
      script: [
        {
          src: 'https://a-body-appended-script.com',
          tagPosition: 'bodyClose',
        },
      ],
      meta: [{ name: 'description', content: 'first' }],
    })
    useHead({ meta: [{ charset: 'utf-16' }, { name: 'description', content: computed(() => `${a.value} with an inline useHead call`) }] })
    a.value = 'overriding'
  },
  head () {
    return {
      htmlAttrs: {
        class: 'html-attrs-test',
      },
    }
  },
})
</script>

<template>
  <div>
    <Head>
      <Title>Using a dynamic component</Title>
      <Meta
        http-equiv="content-security-policy"
        content="default-src https"
      />
    </Head>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/index.vue">
<template>
  <div>
    <Head>
      <Title>Basic fixture</Title>
    </Head>
    <h1>Hello Nuxt 3!</h1>
    <div>RuntimeConfig | testConfig: {{ config.public.testConfig }}</div>
    <div>Composable | foo: {{ foo }}</div>
    <div>Composable | bar: {{ bar }}</div>
    <div>Composable | template: {{ templateAutoImport }}</div>
    <div>Composable | star: {{ useNestedBar() }}</div>
    <DevOnly>Some dev-only info</DevOnly>
    <div><DevOnly>Some dev-only info</DevOnly></div>
    <div>
      <DevOnly>
        Some dev-only info
        <template #fallback>
          Some prod-only info
        </template>
      </DevOnly>
    </div>
    <div>Path: {{ $route.fullPath }}</div>
    <NuxtLink to="/">
      Link
    </NuxtLink>
    <NuxtLink
      id="islands"
      to="/islands"
    >
      islands
    </NuxtLink>
    <NuxtLink
      id="to-immediate-remove-unmounted"
      to="/useAsyncData/immediate-remove-unmounted"
    >
      Immediate remove unmounted
    </NuxtLink>
    <NuxtLink
      no-prefetch
      to="/chunk-error"
    >
      Chunk error
    </NuxtLink>
    <NuxtLink
      id="to-client-only-components"
      to="/client-only-components"
    >
      createClientOnly()
    </NuxtLink>
    <NuxtLink
      id="middleware-abort-non-fatal"
      to="/middleware-abort-non-fatal"
      :prefetch="false"
    >
      Middleware abort navigation
    </NuxtLink>
    <NuxtLink
      id="middleware-abort-non-fatal-error"
      to="/middleware-abort-non-fatal?error=someerror"
      :prefetch="false"
    >
      Middleware abort navigation with error
    </NuxtLink>
    Some value: {{ someValue }}
    <button @click="someValue++">
      Increment state
    </button>
    <NuxtLink to="/no-scripts">
      to no script
    </NuxtLink>
    <NestedCounter :multiplier="2" />
    <CustomComponent />
    <component :is="`global${'-'.toString()}sync`" />
    <Spin>Test</Spin>
    <component :is="`test${'-'.toString()}global`" />
    <component :is="`with${'-'.toString()}suffix`" />
    <ClientWrapped
      ref="clientRef"
      style="color: red;"
      class="client-only"
    />
    <NuxtIsland
      ref="island"
      name="AsyncServerComponent"
      :props="{ count: 34 }"
    />
    <ServerOnlyComponent
      class="server-only"
      style="background-color: gray;"
    />
    <NuxtLink to="/big-page-1">
      to big 1
    </NuxtLink>
    <NuxtLink to="/server-page">
      to server page
    </NuxtLink>
    <NuxtLink to="/page-load-hook">
      to page load hook
    </NuxtLink>
    <NuxtLink
      data-testid="server-page-404"
      to="/server-components/lost-page"
    >
      to 404 server page
    </NuxtLink>

    <NuxtLink
      data-testid="route-rules-redirect"
      to="/route-rules/redirect#hello"
    >
      to redirect page with hash
    </NuxtLink>
  </div>
</template>

<script setup lang="ts">
import { setupDevtoolsPlugin } from '@vue/devtools-api'
import { toDisplayString } from 'vue'
import { useRuntimeConfig } from '#imports'
import { importedRE, importedValue } from '~/some-exports'
import type { NuxtIsland, ServerOnlyComponent } from '#build/components'

toDisplayString(useRoute())

setupDevtoolsPlugin({}, () => {}) as any
const island = ref<InstanceType<typeof ServerOnlyComponent>>()
const config = useRuntimeConfig()

const someValue = useState('val', () => 1)

const NestedCounter = resolveComponent('NestedCounter')
if (!NestedCounter) {
  throw new Error('Component not found')
}
useHead({
  meta: [
    {
      name: 'author',
      content: 'Nuxt',
      key: 'testkey',
    },
    {
      name: 'author',
      content: 'Nuxt',
      key: 'testkey',
    },
  ],
  script: [
    {
      innerHTML: 'console.log("my script")',
      key: 'my-script',
    },
    {
      innerHTML: 'console.log("my script")',
      key: 'my-script',
    },
  ],
}, { key: 'testkey' })
definePageMeta({
  alias: '/some-alias',
  other: ref('test'),
  imported: importedValue,
  something: importedRE.test('an imported regex'),
})

// reset title template example
useHead({
  titleTemplate: '',
})

const foo = useFoo()
const bar = useBar()
const clientRef = ref()

onMounted(() => {
  clientRef.value.exposedFunc()
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/inline-only-css.vue">
<script setup lang="ts">
import css from '~/assets/inline-only.css?inline'
</script>

<template>
  <pre>{{ css }}</pre>
</template>
</file>

<file path="test/fixtures/basic/app/pages/internal-layout.vue">
<script setup lang="ts">
definePageMeta({
  layout: false,
})

const route = useRoute()
</script>

<template>
  <div>
    <NuxtLayout :name="route.meta._layout as string || 'default'">
      <NuxtPage />
    </NuxtLayout>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/islands.vue">
<script setup lang="ts">
const islandProps = ref({
  bool: true,
  number: 100,
  str: 'hello world',
  obj: { json: 'works' },
})

const showIslandSlot = ref(false)
const routeIslandVisible = ref(false)
const testCount = ref(0)
const count = ref(0)
</script>

<template>
  <div>
    Pure island component:
    <div class="box">
      <NuxtIsland
        name="PureComponent"
        :props="islandProps"
      />
      <div id="wrapped-client-only">
        <ClientOnly>
          <NuxtIsland
            name="PureComponent"
            :props="islandProps"
          />
        </ClientOnly>
      </div>
    </div>
    <button
      id="increase-pure-component"
      @click="islandProps.number++"
    >
      Increase
    </button>
    <hr>
    Route island component:
    <div
      v-if="routeIslandVisible"
      class="box"
    >
      <NuxtIsland
        name="RouteComponent"
        :context="{ url: '/test' }"
      />
    </div>
    <button
      v-else
      id="show-route"
      @click="routeIslandVisible = true"
    >
      Show
    </button>

    <p>async .server component</p>
    <AsyncServerComponent :count="count">
      <div id="slot-in-server">
        Slot with in .server component
      </div>
    </AsyncServerComponent>
    <div>
      Async component (1000ms):
      <div>
        <NuxtIsland
          name="LongAsyncComponent"
          :props="{ count }"
        >
          <div>Interactive testing slot</div>
          <div id="first-sugar-counter">
            <Counter :multiplier="testCount" />
          </div>
          <template #test="scoped">
            <div id="test-slot">
              Slot with name test - scoped data {{ scoped }}
            </div>
          </template>
          <template #hello="scoped">
            <div id="test-slot">
              Slot with name hello - scoped data {{ scoped }}
            </div>
          </template>
        </NuxtIsland>
        <button
          id="update-server-components"
          @click="count++"
        >
          add +1 to count
        </button>
      </div>
    </div>
    <div>
      <p>Island with props mounted client side</p>
      <button
        id="show-island"
        @click="showIslandSlot = true"
      >
        Show Interactive island
      </button>
      <div id="island-mounted-client-side">
        <NuxtIsland
          v-if="showIslandSlot"
          name="LongAsyncComponent"
          :props="{ count }"
        >
          <div>Interactive testing slot post SSR</div>
          <Counter :multiplier="testCount" />
        </NuxtIsland>
      </div>
    </div>
    <server-with-client />
    <ServerWithNestedClient />
  </div>
</template>

<style scoped>
.box {
  border: 1px solid black;
  margin: 3px;
  display: flex;
}
</style>
</file>

<file path="test/fixtures/basic/app/pages/isr.vue">
<template>
  <div>
    <h1>ISR Page</h1>
    <div id="random-data">
      {{ data }}
    </div>
  </div>
</template>

<script setup lang="ts">
const { data } = await useFetch('/api/random', { key: 'isr-data' })
</script>
</file>

<file path="test/fixtures/basic/app/pages/json-payload.vue">
<script setup lang="ts">
const state = useState(() => shallowRef({} as Record<string, any>))
const nonDisplayedState = useState(() => shallowRef({} as Record<string, any>))
useState().value = '</scr' + 'ipt>'

if (import.meta.server) {
  const r = ref('')
  state.value.ref = r
  state.value.shallowReactive = shallowReactive({ nested: { ref: r } })
  state.value.shallowRef = shallowRef(false)
  state.value.undefined = shallowRef()
  state.value.reactive = reactive({ ref: r })
  state.value.error = createError({ message: 'error' })
  state.value.date = new Date()
  nonDisplayedState.value.bigint = 0n
  nonDisplayedState.value.bigintRef = ref(0n)
}
</script>

<template>
  <div>
    <pre>{{ state }}</pre>
    Date: {{ state.date instanceof Date }} <br>
    BigInt: {{ nonDisplayedState.bigint === 0n }} <br>
    Error: {{ isNuxtError(state.error) }} <hr>
    Shallow reactive: {{ isReactive(state.shallowReactive) && isShallow(state.shallowReactive) }} <br>
    Shallow ref: {{ isShallow(state.shallowRef) }} <br>
    Undefined ref: {{ isRef(state.undefined) }} <br>
    BigInt ref: {{ isRef(nonDisplayedState.bigintRef) && typeof nonDisplayedState.bigintRef.value === 'bigint' }} <br>
    Reactive: {{ isReactive(state.reactive) }} <br>
    Ref: {{ isRef(state.ref) }} <hr>
    Recursive objects: {{ state.ref === state.shallowReactive.nested.ref }} <br>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/jsx.vue">
<template>
  <div>
    <Tsx />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/keepalive.vue">
<script setup lang="ts">
const links = ['keepalive-in-config', 'not-keepalive', 'keepalive-in-nuxtpage', 'keepalive-in-nuxtpage-2', 'not-keepalive-in-nuxtpage']
</script>

<template>
  <div>
    <h1>Keepalive Test</h1>
    <NuxtLink
      id="keepalive-home"
      to="/keepalive"
    >
      Keepalive Home
    </NuxtLink>
    <div :style="{ display: 'flex', flexDirection: 'column', marginTop: '10px' }">
      <NuxtLink
        v-for="link in links"
        :id="link"
        :key="link"
        :to="`/keepalive/${link}`"
      >
        {{ link }}
      </NuxtLink>
    </div>
    <NuxtPage :keepalive="{ include: ['keepalive-in-nuxtpage', 'keepalive-in-nuxtpage-2'], exclude: ['not-keepalive-in-nuxtpage'] }" />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/keyed-child-parent.vue">
<template>
  <div>
    keyed-child-parent
    <NuxtPage />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/legacy-async-data-fail.vue">
<template>
  <div>
    don't look at this
  </div>
</template>

<script lang="ts">
export default defineNuxtComponent({
  asyncData () {
    throw new Error('OH NNNNNNOOOOOOOOOOO')
  },
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/meta.vue">
<script setup lang="ts">
definePageMeta({
  name: 'some-custom-name',
  path: '/some-custom-path',
  validate: () => true,
  middleware: [() => true],
  otherValue: {
    foo: 'bar',
  },
})

const serialisedMeta: Record<string, string> = {}
const route = useRoute()
const meta = route.meta
for (const key of ['name', 'path', ...Object.keys(meta)]) {
  const value = meta[key] || route[key]
  if (Array.isArray(value)) {
    serialisedMeta[key] = value.map((fn: () => unknown) => fn.toString())
    continue
  }
  if (typeof value === 'string') {
    serialisedMeta[key] = value
    continue
  }
  if (typeof value === 'object') {
    serialisedMeta[key] = JSON.stringify(value)
    continue
  }
  if (typeof value === 'function') {
    serialisedMeta[key] = value.toString()
    continue
  }
}
</script>

<template>
  <pre>{{ serialisedMeta }}</pre>
</template>
</file>

<file path="test/fixtures/basic/app/pages/middleware-abort-non-fatal.vue">
<template>
  <div>
    you should not see me
  </div>
</template>

<script setup lang="ts">
definePageMeta({
  middleware: [
    (to) => {
      return abortNavigation(to.query.error ? new Error(to.query.error.toString()) : undefined)
    },
  ],
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/middleware-abort.vue">
<script setup lang="ts">
definePageMeta({
  middleware: () => {
    if (import.meta.server || useNuxtApp().isHydrating) { return }
    return abortNavigation({
      fatal: true,
    })
  },
})
const router = useRouter()
onNuxtReady(() => router.push({ path: '/middleware-abort', force: true }))
</script>

<template>
  <div>
    <!--  -->
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/namespace-nuxt-app.vue">
<script setup lang="ts">
// Defaulting to buildId
useNuxtApp()
// Using correct configured buildId
useNuxtApp('nuxt-app-basic')
</script>

<template>
  <div>Nuxt instance available</div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/navigate-to-api.vue">
<template>
  <div>You should not see me</div>
</template>

<script setup>
await navigateTo('/api/test', { external: true })
</script>
</file>

<file path="test/fixtures/basic/app/pages/navigate-to-error.vue">
<template>
  <div>You should not see me</div>
</template>

<script setup>
definePageMeta({
  alias: ['/setup-should-not-run'],
  middleware: to => to.path === '/navigate-to-error' ? navigateTo('/setup-should-not-run') : undefined,
})
if (import.meta.client) {
  console.log('running setup')
}
useNuxtApp().hook('app:rendered', () => {
  throw new Error('this should not run')
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/navigate-to-external.vue">
<template>
  <div>You should not see me</div>
</template>

<script setup>
if (useRoute().path === '/navigate-to-external') {
  useNuxtApp().hook('app:rendered', () => {
    throw new Error('this should not run')
  })
}
await navigateTo({ path: 'https://example.com/', query: { redirect: false }, hash: '#test' }, { external: true, replace: true })
</script>
</file>

<file path="test/fixtures/basic/app/pages/navigate-to-forbidden.vue">
<template>
  <div>
    <div>navigate-to-forbidden.vue</div>
    <NuxtLink to="/catchall/forbidden">
      should throw a 404 error
    </NuxtLink>
    <NuxtLink to="/catchall/some-404">
      should be caught by catchall
    </NuxtLink>
  </div>
</template>

<script setup lang="ts">
definePageMeta({
  middleware: ['override'],
  validate: to => to.path !== '/forbidden',
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/navigate-to-redirect.vue">
<template>
  <div>You should not see me</div>
</template>

<script setup>
definePageMeta({
  middleware: async () => {
    await new Promise(resolve => setTimeout(resolve, 1))
    return navigateTo({ path: '/' }, { redirectCode: 307 })
  },
})
if (import.meta.client) {
  console.log('running setup')
}
useNuxtApp().hook('app:rendered', () => {
  throw new Error('this should not run')
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/navigate-to-validate-custom-error.vue">
<template>
  <div>
    <div>navigate-to-validate-custom-error.vue</div>
    <NuxtLink to="/validate-custom-error">
      should throw a 401 error with custom message
    </NuxtLink>
  </div>
</template>

<script setup lang="ts">
definePageMeta({
  middleware: ['override'],
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/navigate-to.vue">
<template>
  <div>You should not see me</div>
</template>

<script setup>
await navigateTo('/', { replace: true, redirectCode: 301 })
</script>
</file>

<file path="test/fixtures/basic/app/pages/no-auth.vue">
<script setup>
definePageMeta({
  title: 'l\'equipe',
  // middleware: 'inject-auth'
})
</script>

<template>
  <div>
    <div>no-auth.vue</div>
    <div>auth: {{ $route.meta.auth }}</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/no-scripts.vue">
<template>
  <div>
    {{ count }}
    <button @click="count++">
      ++
    </button>
  </div>
</template>

<script setup lang="ts">
const count = ref(0)
</script>
</file>

<file path="test/fixtures/basic/app/pages/nuxt-teleport.vue">
<template>
  <div>
    <teleport to="#nuxt-teleport">
      <div>Nuxt Teleport</div>
    </teleport>
    <h1>Normal content</h1>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/once-nav-initial.vue">
<script setup>
const counter = useState('once', () => 0)

await callOnce(() => counter.value++, { mode: 'navigation' })
await callOnce('same-key', () => counter.value++, { mode: 'navigation' })
await callOnce('same-key', () => counter.value++, { mode: 'navigation' })
</script>

<template>
  <div>
    <div>once.vue</div>
    <div>once: {{ counter }}</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/once.vue">
<script setup>
const counter = useState('once', () => 0)

await callOnce(() => counter.value++)
await callOnce('same-key', () => counter.value++)
await callOnce('same-key', () => counter.value++)
</script>

<template>
  <div>
    <div>once.vue</div>
    <div>once: {{ counter }}</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/page-load-hook.vue">
<template>
  <div>
    Page for hook tests.
    <NuxtLink to="/page-load-hook/subpage">
      To sub page
    </NuxtLink>
    <NuxtPage />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/parent.vue">
<template>
  <div>
    parent
    <NuxtPage />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/plugins.vue">
<template>
  <div>
    <div>myPlugin: {{ $myPlugin() }}</div>
    <div>asyncPlugin: {{ $asyncPlugin() }}</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/redirect-with-encode.vue">
<template>
  <div>
    oh no !
  </div>
</template>

<script setup lang="ts">
await navigateTo('/cœur?redirected=' + encodeURIComponent('https://google.com'))
</script>
</file>

<file path="test/fixtures/basic/app/pages/redirect.vue">
<script setup>
definePageMeta({
  redirect: () => '/',
})
</script>

<template>
  <div>
    <div>redirect.vue</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/route-announcer.vue">
<script setup>
useHead({
  title: 'First Page',
})
definePageMeta({
  layout: 'with-route-announcer',
})
</script>

<template>
  <div>
    <NuxtLink
      role="link"
      to="/route-announcer2"
    >
      Link
    </NuxtLink>
    <button
      role="button"
      @click="() => useHead({ title: 'Dynamically set title' })"
    >
      Button
    </button>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/route-announcer2.vue">
<script setup>
useHead({
  title: 'Second Page',
})
definePageMeta({
  layout: 'with-route-announcer',
})
</script>

<template>
  <div>Second page content</div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/server-page.server.vue">
<template>
  <div id="server-page">
    Hello this is a server page
    <NuxtLink
      to="/"
    >
      to home
    </NuxtLink>
  </div>
</template>

<script setup lang="ts">
useHead({
  title: 'Server Page',
  meta: [
    {
      name: 'author',
      content: 'Nuxt',
    },
  ],
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/ssr-modules.vue">
<script setup lang="ts">
const modules = useNuxtApp()?.ssrContext?.modules

const modulesState = useState<string[]>('ssr-modules', () => modules ? Array.from(modules) : [])
const modulesJson = computed(() => JSON.stringify(modulesState.value))
</script>

<template>
  <div
    id="ssr-modules"
    :data-modules="modulesJson"
  >
    SSR modules count: {{ modulesState.length }}
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/styles.vue">
<template>
  <div>
    <ClientOnlyScript />
    <FunctionalComponent />
    <ServerOnlyComponent />
    <SharedComponent />
  </div>
</template>

<script setup>
import '~/assets/assets.css'
</script>

<style lang="postcss">
  :root {
    --postcss: 'postcss';
  }
</style>

<style scoped>
  /* Regression test for https://github.com/nuxt/nuxt/issues/26057 */
  /* definePageMeta( */
  div {
    --scoped: 'scoped';
  }
</style>
</file>

<file path="test/fixtures/basic/app/pages/suspense.vue">
<script setup>
const links = new Set(['sync', 'async'].flatMap(parent => [1, 2].flatMap(p => ['sync', 'async'].flatMap(child => [null, 1, 2].map(c => !c ? `/suspense/${parent}-${p}/` : `/suspense/${parent}-${p}/${child}-${c}/`)))))

definePageMeta({
// Nested <Suspense> + <Transition> is still buggy
  pageTransition: false,
  layoutTransition: false,
  middleware: (to) => {
    if ('layout' in to.query) {
      if (to.query.layout === 'false') {
        to.meta.layout = false
      } else {
        to.meta.layout = to.query.layout
      }
    }
  },
})
</script>

<template>
  <div>
    This exists to test synchronous transitions between nested Suspense components.
    <hr>
    <div style="display: flex; flex-direction: row; gap: 10vw;">
      <div>
        <h1>With extended layout</h1>
        <NuxtLink
          v-for="link in links"
          :key="link"
          :to="link"
          style="display: block;"
        >
          {{ link }}
        </NuxtLink>
      </div>
      <div>
        <h1>With custom layout</h1>
        <NuxtLink
          v-for="link in links"
          :key="link"
          :to="`${link}?layout=custom`"
          style="display: block;"
        >
          {{ link }}
        </NuxtLink>
      </div>
    </div>
    <NuxtLink to="/internal-layout/async-parent/child">
      Internal layout page
    </NuxtLink>
    <hr>
    <div>
      <NuxtPage />
    </div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/swr.vue">
<template>
  <div>
    <h1>SWR Page</h1>
    <div id="random-data">
      {{ data }}
    </div>
  </div>
</template>

<script setup lang="ts">
const { data } = await useFetch('/api/random', { key: 'swr-data' })
</script>
</file>

<file path="test/fixtures/basic/app/pages/teleport.vue">
<template>
  <div>
    <teleport to="body">
      <div>Teleport</div>
    </teleport>
    <h1>Normal content</h1>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/tree-shake.vue">
<script lang="ts" setup>
// server only
useServerOnlyComposable()
// client only
useClientOnlyComposable()
// can only run client side, should be tree shaken from server build
setTitleToPink()
</script>

<template>
  <div>
    <h1>Tree Shake Example</h1>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/tsx-page-meta.vue">
<template>
  <PageContent />
</template>

<script setup lang="tsx">
definePageMeta({})
defineRouteRules({})
const PageContent = () => (<div>Home Page</div>)
</script>
</file>

<file path="test/fixtures/basic/app/pages/url.vue">
<script setup>
const url = useRequestURL()
</script>

<template>
  <div>
    <div>path: {{ url.pathname }}</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/use-id.vue">
<script setup>
const id = useId()
</script>

<template>
  <form>
    <h2 :id="id">
      id: {{ id }}
    </h2>
    <LazyComponentWithIds />
    <ClientOnly><ComponentWithIds /></ClientOnly>
    <ComponentWithIds />
  </form>
</template>
</file>

<file path="test/fixtures/basic/app/pages/validate-custom-error.vue">
<template>
  <div>You should not see this</div>
</template>

<script setup lang="ts">
definePageMeta({
  validate: to => ({
    statusCode: 401,
    statusMessage: 'Custom error message',
  }),
})
</script>
</file>

<file path="test/fixtures/basic/app/pages/vueuse-head.vue">
<script lang="ts" setup>
function useLegacyUseHead () {
  useHead({
    titleTemplate: '%s - VueUse head polyfill test',
  })
}
function useLegacyVueUseHead () {
  // get vm
  const vm = getCurrentInstance()
  const head = vm?.appContext.provides.usehead
  head.addHeadObjs({
    title: 'using provides usehead and updateDOM',
  })
  head.updateDOM()
}

useLegacyUseHead()
useLegacyVueUseHead()
</script>

<template>
  <div>
    <h1>VueUse head polyfill test</h1>
    <!-- This component is only here to make it a shared chunk for test in `styles.vue` -->
    <SharedComponent />
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/with-computed-layout.vue">
<script setup>
definePageMeta({
  layout: computed(() => 'custom'),
})
</script>

<template>
  <div>
    <div>with-computed-layout.vue</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/with-dynamic-layout.vue">
<script setup>
definePageMeta({
  middleware: 'sets-layout',
})
</script>

<template>
  <div>
    <div>with-dynamic-layout.vue</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/with-layout.vue">
<script setup>
definePageMeta({
  layout: 'custom',
})
</script>

<template>
  <div>
    <div>with-layout.vue</div>
    <NuxtLink to="./with-layout2">
      to another page
    </NuxtLink>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/pages/with-layout2.vue">
<script setup>
definePageMeta({
  layout: 'custom2',
})

if (import.meta.client) {
  console.log('Running With Layout2 Page Setup')
}
</script>

<template>
  <div id="with-layout2">
    <div>with-layout2.vue</div>
  </div>
</template>
</file>

<file path="test/fixtures/basic/app/plugins/10.layer-ordering.ts">
export default defineNuxtPlugin((nuxtApp) => {
  if (useRoute().path === '/plugins/ordering') {
    if (!nuxtApp.$layerPluginPre) {
      throw createError('layer plugin failed to run before end project plugin')
    }
    if (!nuxtApp.$layerPluginPost) {
      throw createError('layer plugin failed to run before end project plugin')
    }
  }
})
</file>

<file path="test/fixtures/basic/app/plugins/add-nuxt-link-alias.ts">
import { NuxtLink } from '#components'

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.component('NuxtLinkAlias', NuxtLink)
})
</file>

<file path="test/fixtures/basic/app/plugins/add-route.ts">
export default defineNuxtPlugin((_nuxtApp) => {
  const router = useRouter()

  router.beforeEach((to) => {
    if (to.path !== '/add-route-test') { return }
    if (router.getRoutes().some(route => route.path === to.path)) {
      return
    }

    router.addRoute({
      path: to.path,
      name: to.path,
      component: () => import('~/pages/index.vue'),
    })

    return to.path
  })
})
</file>

<file path="test/fixtures/basic/app/plugins/async-plugin.ts">
export default defineNuxtPlugin({
  name: 'async-plugin',
  async setup (/* nuxtApp */) {
    const config1 = useRuntimeConfig()
    await new Promise(resolve => setTimeout(resolve, 100))
    const { data } = useFetch('/api/hey', { key: 'hey' })
    const config2 = useRuntimeConfig()
    return {
      provide: {
        asyncPlugin: () => config1 && config1 === config2
          ? 'Async plugin works! ' + config1.public.testConfig + (data.value?.baz ? 'useFetch works!' : 'useFetch does not work')
          : 'Async plugin failed!',
      },
    }
  },
  parallel: true,
})
</file>

<file path="test/fixtures/basic/app/plugins/chunk-error.ts">
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.hook('app:chunkError', () => {
    console.log('caught chunk load error')
  })
})
</file>

<file path="test/fixtures/basic/app/plugins/context-error.ts">
export default defineNuxtPlugin(() => {
  // this should be undefined
  const vueApp = getCurrentInstance()
  return {
    provide: {
      wasVueAppInstanceWronglyPreserved: !!vueApp,
    },
  }
})
</file>

<file path="test/fixtures/basic/app/plugins/cookie.ts">
export default defineNuxtPlugin(() => {
  useCookie('set-in-plugin').value = 'true'
})
</file>

<file path="test/fixtures/basic/app/plugins/custom-type-assertion.client.ts">
export default defineNuxtPlugin((nuxtApp) => {
  if (nuxtApp.payload.serverRendered && nuxtApp.payload.blinkable !== '<revivified-blink>' && document.querySelector('#__NUXT_DATA__')) {
    throw createError({
      message: 'Custom type in Nuxt payload was not revived correctly',
    })
  }
})
</file>

<file path="test/fixtures/basic/app/plugins/custom-type-registration.ts">
export default definePayloadPlugin((nuxtApp) => {
  definePayloadReducer('BlinkingText', data => data === '<original-blink>' && '_')
  definePayloadReviver('BlinkingText', () => '<revivified-blink>')
  if (import.meta.server) {
    nuxtApp.payload.blinkable = '<original-blink>'
  }
})
</file>

<file path="test/fixtures/basic/app/plugins/dependsOnPlugin.ts">
export default defineNuxtPlugin({
  name: 'depends-on-plugin',
  dependsOn: ['async-plugin'],
  async setup () {
    const nuxtApp = useNuxtApp()
    if (!nuxtApp.$asyncPlugin) {
      throw new Error('$asyncPlugin is not defined')
    }
    await new Promise(resolve => setTimeout(resolve, 100))
  },
  parallel: true,
})
</file>

<file path="test/fixtures/basic/app/plugins/error.server.ts">
export default defineNuxtPlugin(async () => {
  if (useRequestHeaders(['x-test-recurse-error'])['x-test-recurse-error']) {
    await useRequestFetch()('/api/error').catch(() => {})
  }
})
</file>

<file path="test/fixtures/basic/app/plugins/invalid-plugin-1.ts">
import 'nonexistent-package'
</file>

<file path="test/fixtures/basic/app/plugins/my-plugin.ts">
export default defineNuxtPlugin(() => {
  useHead({
    titleTemplate: '%s - Fixture',
    style: [{
      innerHTML: () => 'body { color: red }',
      tagPriority: -2,
      id: 'plugin-style',
    }],
  })
  const path = useRoute()?.path
  return {
    provide: {
      myPlugin: () => 'Injected by my-plugin',
      path: () => path,
    },
  }
})
</file>

<file path="test/fixtures/basic/app/plugins/page-hook-plugin.ts">
export default defineNuxtPlugin((nuxtApp) => {
  const route = useRoute()
  nuxtApp.hook('page:loading:end', () => {
    if (route.path === '/page-load-hook') {
      console.log('page:loading:end')
    }
  })
})
</file>

<file path="test/fixtures/basic/app/plugins/prerender.server.ts">
export default defineNuxtPlugin((nuxtApp) => {
  // Pretend to be prerendered
  nuxtApp.payload.prerenderedAt = Date.now()
})
</file>

<file path="test/fixtures/basic/app/plugins/register.ts">
import { defineComponent, h } from 'vue'

const Spin = defineComponent({
  setup (props, { slots }) {
    return () => {
      return h('div', slots.default?.())
    }
  },
})

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.component('Spin', Spin)
})
</file>

<file path="test/fixtures/basic/app/plugins/server-only.server.ts">
import { setHeader } from 'h3'

export default defineNuxtPlugin({
  name: 'server-only-plugin',
  setup () {
    const evt = useRequestEvent()
    if (evt) {
      setHeader(evt, 'custom-head', 'hello')
    }
  },
  env: {
    islands: false,
  },
})
</file>

<file path="test/fixtures/basic/app/plugins/style.ts">
import '~/assets/plugin.css'

export class OnMountedMethod {
  public onMounted () {
    console.log('public onMounted')
  }

  onBeforeMount () {
    console.log('onBeforeMount')
  }
}
export default defineNuxtPlugin(() => {
  //
})
</file>

<file path="test/fixtures/basic/app/plugins/test.d.ts">
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
interface MyInterface {}
export {}
</file>

<file path="test/fixtures/basic/app/plugins/this-should-not-load.spec.js">
throw new Error('this-should-not-load.spec.js should not be loaded')
</file>

<file path="test/fixtures/basic/app/utils/useBar.ts">
export default function () {
  return 'auto imported from ~/utils/useBar.ts'
}
</file>

<file path="test/fixtures/basic/app/app.config.js">
// eslint-disable-next-line no-undef
export default defineAppConfig({
  userConfig: 123,
  nested: {
    val: 2,
  },
})
</file>

<file path="test/fixtures/basic/app/app.vue">
<template>
  <NuxtLoadingIndicator :throttle="0" />
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>
</file>

<file path="test/fixtures/basic/app/error.vue">
<template>
  <div>
    <div>
      <h1>{{ error?.message }}</h1>
      This is the error page 😱
      <div
        v-if="error?.data?.path"
        data-testid="path"
      >
        Path: {{ error.data.path }}
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { NuxtError } from '#app'

defineProps({
  error: Object as () => NuxtError,
})
</script>
</file>

<file path="test/fixtures/basic/app/some-exports.ts">
export const importedValue = 'an imported value'
export const importedRE = /an imported regex/
</file>

<file path="test/fixtures/basic/custom-modules/subpath/index.ts">
export const someUtil = () => {}
</file>

<file path="test/fixtures/basic/custom-modules/subpath/module.ts">
import { defineNuxtModule } from 'nuxt/kit'

export default defineNuxtModule({
  meta: { name: 'subpath' },
})
</file>

<file path="test/fixtures/basic/custom-public/file.svg">
<svg viewBox="0 0 221 65" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-8">
  <g clip-path="url(#a)">
    <path fill="currentColor"
      d="M82.5623 18.5705h7.3017l15.474 24.7415V18.5705h6.741v35.0576h-7.252L89.3025 28.938v24.6901h-6.7402V18.5705ZM142.207 53.628h-6.282v-3.916c-1.429 2.7559-4.339 4.3076-8.015 4.3076-5.822 0-9.603-4.1069-9.603-10.0175V28.3847h6.282v14.3251c0 3.4558 2.146 5.8592 5.362 5.8592 3.524 0 5.974-2.7044 5.974-6.4099V28.3847h6.282V53.628ZM164.064 53.2289l-6.026-8.4144-6.027 8.4144h-6.69l9.296-13.1723-8.58-12.0709h6.843l5.158 7.2641 5.106-7.2641h6.895l-8.632 12.0709 9.295 13.1723h-6.638ZM183.469 20.7726v7.6116h7.149v5.1593h-7.149v12.5311c0 .4208.17.8245.473 1.1223.303.2978.715.4654 1.144.4661h5.532v5.9547h-4.137c-5.617 0-9.293-3.2062-9.293-8.8109V33.5484h-5.056v-5.1642h3.172c1.479 0 2.34-.8639 2.34-2.2932v-5.3184h5.825Z">
    </path>
    <path fill-rule="evenodd" clip-rule="evenodd"
      d="M30.1185 11.5456c-1.8853-3.24168-6.5987-3.24169-8.484 0L1.08737 46.8747c-1.885324 3.2417.47133 7.2938 4.24199 7.2938H21.3695c-1.6112-1.4081-2.2079-3.8441-.9886-5.9341l15.5615-26.675-5.8239-10.0138Z"
      fill="#80EEC0"></path>
    <path
      d="M43.1374 19.2952c1.5603-2.6523 5.461-2.6523 7.0212 0l17.0045 28.9057c1.5603 2.6522-.39 5.9676-3.5106 5.9676h-34.009c-3.1206 0-5.0709-3.3154-3.5106-5.9676l17.0045-28.9057ZM209.174 53.8005H198.483c0-1.8514.067-3.4526 0-6.0213h10.641c1.868 0 3.353.1001 4.354-.934 1-1.0341 1.501-2.3351 1.501-3.9029 0-1.8347-.667-3.2191-2.002-4.1532-1.301-.9674-2.985-1.4511-5.054-1.4511h-2.601v-5.2539h2.652c1.701 0 3.119-.4003 4.253-1.2009 1.134-.8006 1.701-1.9849 1.701-3.5527 0-1.301-.434-2.3351-1.301-3.1023-.834-.8007-2.001-1.201-3.503-1.201-1.634 0-2.918.4837-3.853 1.4511-.9.9674-1.401 2.1517-1.501 3.5527h-6.254c.133-3.2358 1.251-5.7877 3.352-7.6558 2.135-1.868 4.887-2.8021 8.256-2.8021 2.402 0 4.42.4337 6.055 1.301 1.668.834 2.919 1.9515 3.753 3.3525.867 1.4011 1.301 2.9523 1.301 4.6536 0 1.9681-.551 3.636-1.651 5.0037-1.068 1.3344-2.402 2.235-4.004 2.7021 1.969.4003 3.57 1.3677 4.804 2.9022 1.234 1.5011 1.852 3.4025 1.852 5.7043 0 1.9347-.468 3.7028-1.402 5.304-.934 1.6012-2.301 2.8855-4.103 3.8529-1.768.9674-3.953 1.4511-6.555 1.4511Z"
      fill="#00DC82"></path>
  </g>
  <defs>
    <clipPath id="a">
      <path fill="#fff" d="M0 0h221v65H0z"></path>
    </clipPath>
  </defs>
</svg>
</file>

<file path="test/fixtures/basic/extends/bar/app/router.options.ts">
import type { RouterOptions } from 'nuxt/schema'

export default <RouterOptions> {
  linkExactActiveClass: 'bar-exact-active-class',
}
</file>

<file path="test/fixtures/basic/extends/bar/components/ExtendsOverride.vue">
<template>
  <div>Extended component from bar</div>
  <img src="/nuxt.svg">
</template>
</file>

<file path="test/fixtures/basic/extends/bar/composables/base.ts">
export const useOverridableComposable = () => 'test from layer'
</file>

<file path="test/fixtures/basic/extends/bar/layouts/override.vue">
<template>
  <div>
    <div>Extended layout from bar</div>
    <NuxtPage />
  </div>
</template>
</file>

<file path="test/fixtures/basic/extends/bar/middleware/a.global.ts">
export default defineNuxtRouteMiddleware(() => {
  useNuxtApp().extendsMiddleware = true
})
</file>

<file path="test/fixtures/basic/extends/bar/middleware/override.ts">
export default defineNuxtRouteMiddleware((to) => {
  to.meta.override = 'Injected by extended middleware from bar'
})
</file>

<file path="test/fixtures/basic/extends/bar/pages/override.vue">
<script setup>
definePageMeta({
  layout: 'override',
  middleware: 'override',
})
</script>

<template>
  <div>
    <div>Extended page from bar</div>
    <div>Middleware | override: {{ $route.meta.override }}</div>
    <ExtendsOverride />
    <NuxtPage />
  </div>
</template>
</file>

<file path="test/fixtures/basic/extends/bar/plugins/09.layer-plugin-pre.ts">
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.provide('layerPluginPre', 'layer-plugin')
})
</file>

<file path="test/fixtures/basic/extends/bar/plugins/11.layer-plugin-post.ts">
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.provide('layerPluginPost', 'layer-plugin')
})
</file>

<file path="test/fixtures/basic/extends/bar/public/nuxt.svg">
<svg viewBox="0 0 221 65" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-8">
  <g clip-path="url(#a)">
    <path fill="currentColor"
      d="M82.5623 18.5705h7.3017l15.474 24.7415V18.5705h6.741v35.0576h-7.252L89.3025 28.938v24.6901h-6.7402V18.5705ZM142.207 53.628h-6.282v-3.916c-1.429 2.7559-4.339 4.3076-8.015 4.3076-5.822 0-9.603-4.1069-9.603-10.0175V28.3847h6.282v14.3251c0 3.4558 2.146 5.8592 5.362 5.8592 3.524 0 5.974-2.7044 5.974-6.4099V28.3847h6.282V53.628ZM164.064 53.2289l-6.026-8.4144-6.027 8.4144h-6.69l9.296-13.1723-8.58-12.0709h6.843l5.158 7.2641 5.106-7.2641h6.895l-8.632 12.0709 9.295 13.1723h-6.638ZM183.469 20.7726v7.6116h7.149v5.1593h-7.149v12.5311c0 .4208.17.8245.473 1.1223.303.2978.715.4654 1.144.4661h5.532v5.9547h-4.137c-5.617 0-9.293-3.2062-9.293-8.8109V33.5484h-5.056v-5.1642h3.172c1.479 0 2.34-.8639 2.34-2.2932v-5.3184h5.825Z">
    </path>
    <path fill-rule="evenodd" clip-rule="evenodd"
      d="M30.1185 11.5456c-1.8853-3.24168-6.5987-3.24169-8.484 0L1.08737 46.8747c-1.885324 3.2417.47133 7.2938 4.24199 7.2938H21.3695c-1.6112-1.4081-2.2079-3.8441-.9886-5.9341l15.5615-26.675-5.8239-10.0138Z"
      fill="#80EEC0"></path>
    <path
      d="M43.1374 19.2952c1.5603-2.6523 5.461-2.6523 7.0212 0l17.0045 28.9057c1.5603 2.6522-.39 5.9676-3.5106 5.9676h-34.009c-3.1206 0-5.0709-3.3154-3.5106-5.9676l17.0045-28.9057ZM209.174 53.8005H198.483c0-1.8514.067-3.4526 0-6.0213h10.641c1.868 0 3.353.1001 4.354-.934 1-1.0341 1.501-2.3351 1.501-3.9029 0-1.8347-.667-3.2191-2.002-4.1532-1.301-.9674-2.985-1.4511-5.054-1.4511h-2.601v-5.2539h2.652c1.701 0 3.119-.4003 4.253-1.2009 1.134-.8006 1.701-1.9849 1.701-3.5527 0-1.301-.434-2.3351-1.301-3.1023-.834-.8007-2.001-1.201-3.503-1.201-1.634 0-2.918.4837-3.853 1.4511-.9.9674-1.401 2.1517-1.501 3.5527h-6.254c.133-3.2358 1.251-5.7877 3.352-7.6558 2.135-1.868 4.887-2.8021 8.256-2.8021 2.402 0 4.42.4337 6.055 1.301 1.668.834 2.919 1.9515 3.753 3.3525.867 1.4011 1.301 2.9523 1.301 4.6536 0 1.9681-.551 3.636-1.651 5.0037-1.068 1.3344-2.402 2.235-4.004 2.7021 1.969.4003 3.57 1.3677 4.804 2.9022 1.234 1.5011 1.852 3.4025 1.852 5.7043 0 1.9347-.468 3.7028-1.402 5.304-.934 1.6012-2.301 2.8855-4.103 3.8529-1.768.9674-3.953 1.4511-6.555 1.4511Z"
      fill="#00DC82"></path>
  </g>
  <defs>
    <clipPath id="a">
      <path fill="#fff" d="M0 0h221v65H0z"></path>
    </clipPath>
  </defs>
</svg>
</file>

<file path="test/fixtures/basic/extends/bar/app.config.ts">
export default {
  fromLayer: true,
}
</file>

<file path="test/fixtures/basic/extends/bar/index.d.ts">
declare module 'bing' {
  interface BingInterface {
    foo: 'bar'
  }
}
</file>

<file path="test/fixtures/basic/extends/bar/nuxt.config.ts">
export default defineNuxtConfig({
  modules: [undefined],
  app: {
    head: {
      meta: [
        { name: 'viewport', content: 'width=1024, initial-scale=1' },
        { charset: 'utf-8' },
      ],
    },
  },
})
</file>

<file path="test/fixtures/basic/layers/bar/nuxt.config.ts">
export default defineNuxtConfig({
  modules: [
    function (_options, nuxt) {
      // @ts-expect-error not valid nuxt option
      nuxt.options.__installed_layer = true
    },
  ],
})
</file>

<file path="test/fixtures/basic/modules/auto-registered/runtime/server/utils/some-utils.ts">
export const testUtils = 'test-utils'
</file>

<file path="test/fixtures/basic/modules/auto-registered/runtime/handler.ts">
export default defineEventHandler(() => 'handler added by auto-registered module')
</file>

<file path="test/fixtures/basic/modules/auto-registered/runtime/some-server-import.ts">
export function serverAutoImported () {
  return 'serverAutoImported'
}

export const someUtils = 'utils'
</file>

<file path="test/fixtures/basic/modules/auto-registered/index.ts">
import { addServerHandler, addServerImports, addServerImportsDir, createResolver, defineNuxtModule } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'auto-registered-module',
  },
  setup () {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      handler: resolver.resolve('./runtime/handler'),
      route: '/auto-registered-module',
    })

    addServerImports([{
      from: resolver.resolve('./runtime/some-server-import'),
      name: 'serverAutoImported',
      as: 'autoimportedFunction',
    }, {
      from: resolver.resolve('./runtime/some-server-import'),
      name: 'someUtils',
    }])

    addServerImportsDir(resolver.resolve('./runtime/server/utils'))
  },
})
</file>

<file path="test/fixtures/basic/modules/import-components/runtime/components.ts">
import { defineComponent, h } from 'vue'

export default defineComponent({
  name: 'DComp',
  props: { message: String },
  render: (props: any) => h('h1', props.message),
})

export const NComp = defineComponent({
  name: 'NComp',
  props: { message: String },
  render: (props: any) => h('h1', props.message),
})
</file>

<file path="test/fixtures/basic/modules/import-components/index.ts">
import { addComponent, createResolver, defineNuxtModule } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'import-components',
  },
  setup () {
    const resolver = createResolver(import.meta.url)

    addComponent({
      name: 'DCompClient',
      filePath: resolver.resolve('./runtime/components'),
      mode: 'client',
    })

    addComponent({
      name: 'DCompServer',
      filePath: resolver.resolve('./runtime/components'),
      mode: 'server',
    })

    addComponent({
      name: 'DCompAll',
      filePath: resolver.resolve('./runtime/components'),
      mode: 'all',
    })

    addComponent({
      name: 'NCompClient',
      export: 'NComp',
      filePath: resolver.resolve('./runtime/components'),
      mode: 'client',
    })

    addComponent({
      name: 'NCompServer',
      export: 'NComp',
      filePath: resolver.resolve('./runtime/components'),
      mode: 'server',
    })

    addComponent({
      name: 'NCompAll',
      export: 'NComp',
      filePath: resolver.resolve('./runtime/components'),
      mode: 'all',
    })
  },
})
</file>

<file path="test/fixtures/basic/modules/lazy-import-components/runtime/components.ts">
import { defineComponent, h } from 'vue'

export const NComp = defineComponent({
  name: 'NComp',
  props: { message: String },
  render: (props: any) => h('h1', props.message),
})
</file>

<file path="test/fixtures/basic/modules/lazy-import-components/index.ts">
import { addComponent, createResolver, defineNuxtModule } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'lazy-import-components',
  },
  setup () {
    const resolver = createResolver(import.meta.url)

    addComponent({
      name: 'NCompClient',
      export: 'NComp',
      filePath: resolver.resolve('./runtime/components'),
      mode: 'client',
    })

    addComponent({
      name: 'NCompServer',
      export: 'NComp',
      filePath: resolver.resolve('./runtime/components'),
      mode: 'server',
    })

    addComponent({
      name: 'NCompAll',
      export: 'NComp',
      filePath: resolver.resolve('./runtime/components'),
      mode: 'all',
    })
  },
})
</file>

<file path="test/fixtures/basic/modules/page-extend/pages/big-page.vue">
<template>
  <div>
    <div class="big-block">
      big
    </div>
    <div class="big-block">
      page
    </div>
    <NuxtLink
      id="big-page-1"
      to="/big-page-1"
    >
      to big page 1
    </NuxtLink>
    <NuxtLink
      id="big-page-2"
      to="/big-page-2"
    >
      to big page 2
    </NuxtLink>
    <NuxtLink
      id="big-page-2-test-test"
      to="/big-page-2?test=test"
    >
      to big page 2 with ?test=test
    </NuxtLink>
    <NuxtLink
      id="big-page-2-test-super-test"
      to="/big-page-2?test=super-test"
    >
      to big page 2 with ?test=super-test
    </NuxtLink>
  </div>
</template>

<script setup>
definePageMeta({
  layout: false,
})
</script>

<style scoped>
.big-block {
    height: 90vh;
    width: 100vw;
    background-color: brown;
}
</style>
</file>

<file path="test/fixtures/basic/modules/page-extend/index.ts">
import { createResolver, defineNuxtModule, useNuxt } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'page-extend',
  },
  setup () {
    const nuxt = useNuxt()
    const resolver = createResolver(import.meta.url)

    nuxt.hook('pages:extend', (pages) => {
      pages.push({
        name: 'page-extend',
        path: '/page-extend',
        file: resolver.resolve('../runtime/page.vue'),
      })
    })

    nuxt.hook('pages:resolved', (pages) => {
      pages.push({
        path: '/big-page-1',
        file: resolver.resolve('./pages/big-page.vue'),
        meta: {
          layout: false,
        },
      },
      {
        path: '/big-page-2',
        file: resolver.resolve('./pages/big-page.vue'),
        meta: {
          layout: false,
        },
      })
    })
  },
})
</file>

<file path="test/fixtures/basic/modules/runtime/middleware.ts">
export default defineNuxtRouteMiddleware(async () => {
  await new Promise(resolve => setTimeout(resolve, 1))
  useNuxtApp()
})
</file>

<file path="test/fixtures/basic/modules/runtime/page.vue">
<!-- eslint-disable vue/multi-word-component-names -->

<script setup lang="ts">
import { setResponseHeader } from 'h3'

definePageMeta({
  value: 'added in pages:extend',
})

if (import.meta.server) {
  setResponseHeader(useRequestEvent()!, 'x-extend', useRoute().meta.value as string)
}
</script>

<template>
  <div>
    added in pages:extend
  </div>
</template>
</file>

<file path="test/fixtures/basic/modules/runtime/plugin.ts">
export default defineNuxtPlugin(async () => {
  await new Promise(resolve => setTimeout(resolve, 1))
  useNuxtApp()
})
</file>

<file path="test/fixtures/basic/modules/test/index.ts">
import { defineNuxtModule } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'test',
  },
})
</file>

<file path="test/fixtures/basic/modules/example.ts">
import { addPlugin, createResolver, defineNuxtModule, useNuxt } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'my-module',
    configKey: 'sampleModule',
  },
  setup () {
    const resolver = createResolver(import.meta.url)

    addPlugin(resolver.resolve('./runtime/plugin'))
    useNuxt().hook('app:resolve', (app) => {
      app.middleware.push({
        name: 'unctx-test',
        path: resolver.resolve('./runtime/middleware'),
        global: true,
      })
    })
  },
})
</file>

<file path="test/fixtures/basic/modules/functional.ts">
import { join } from 'pathe'
import { defineNuxtModule } from 'nuxt/kit'

export default defineNuxtModule(
  function (_, nuxt) {
    nuxt.options.optimization.treeShake.composables.server[join(nuxt.options.rootDir, 'app/composables/tree-shake.ts')] = ['useClientOnlyComposable', 'setTitleToPink']
    nuxt.options.optimization.treeShake.composables.client[join(nuxt.options.rootDir, 'app/composables/tree-shake.ts')] = ['useServerOnlyComposable']
  },
)
</file>

<file path="test/fixtures/basic/postcss/plugin.ts">
import type { Plugin } from 'postcss'

const componentRoot = (_opts = {}): Plugin => {
  console.log('loaded custom postcss plugin')
  return {
    postcssPlugin: 'custom-postcss-plugin',
  }
}
componentRoot.postcss = true

export default componentRoot
</file>

<file path="test/fixtures/basic/public/ignore/public-asset">
this should be ignored
</file>

<file path="test/fixtures/basic/public/css-only-public-asset.svg">
<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"></svg>
</file>

<file path="test/fixtures/basic/public/public.svg">
<svg viewBox="0 0 221 65" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-8">
  <g clip-path="url(#a)">
    <path fill="currentColor"
      d="M82.5623 18.5705h7.3017l15.474 24.7415V18.5705h6.741v35.0576h-7.252L89.3025 28.938v24.6901h-6.7402V18.5705ZM142.207 53.628h-6.282v-3.916c-1.429 2.7559-4.339 4.3076-8.015 4.3076-5.822 0-9.603-4.1069-9.603-10.0175V28.3847h6.282v14.3251c0 3.4558 2.146 5.8592 5.362 5.8592 3.524 0 5.974-2.7044 5.974-6.4099V28.3847h6.282V53.628ZM164.064 53.2289l-6.026-8.4144-6.027 8.4144h-6.69l9.296-13.1723-8.58-12.0709h6.843l5.158 7.2641 5.106-7.2641h6.895l-8.632 12.0709 9.295 13.1723h-6.638ZM183.469 20.7726v7.6116h7.149v5.1593h-7.149v12.5311c0 .4208.17.8245.473 1.1223.303.2978.715.4654 1.144.4661h5.532v5.9547h-4.137c-5.617 0-9.293-3.2062-9.293-8.8109V33.5484h-5.056v-5.1642h3.172c1.479 0 2.34-.8639 2.34-2.2932v-5.3184h5.825Z">
    </path>
    <path fill-rule="evenodd" clip-rule="evenodd"
      d="M30.1185 11.5456c-1.8853-3.24168-6.5987-3.24169-8.484 0L1.08737 46.8747c-1.885324 3.2417.47133 7.2938 4.24199 7.2938H21.3695c-1.6112-1.4081-2.2079-3.8441-.9886-5.9341l15.5615-26.675-5.8239-10.0138Z"
      fill="#80EEC0"></path>
    <path
      d="M43.1374 19.2952c1.5603-2.6523 5.461-2.6523 7.0212 0l17.0045 28.9057c1.5603 2.6522-.39 5.9676-3.5106 5.9676h-34.009c-3.1206 0-5.0709-3.3154-3.5106-5.9676l17.0045-28.9057ZM209.174 53.8005H198.483c0-1.8514.067-3.4526 0-6.0213h10.641c1.868 0 3.353.1001 4.354-.934 1-1.0341 1.501-2.3351 1.501-3.9029 0-1.8347-.667-3.2191-2.002-4.1532-1.301-.9674-2.985-1.4511-5.054-1.4511h-2.601v-5.2539h2.652c1.701 0 3.119-.4003 4.253-1.2009 1.134-.8006 1.701-1.9849 1.701-3.5527 0-1.301-.434-2.3351-1.301-3.1023-.834-.8007-2.001-1.201-3.503-1.201-1.634 0-2.918.4837-3.853 1.4511-.9.9674-1.401 2.1517-1.501 3.5527h-6.254c.133-3.2358 1.251-5.7877 3.352-7.6558 2.135-1.868 4.887-2.8021 8.256-2.8021 2.402 0 4.42.4337 6.055 1.301 1.668.834 2.919 1.9515 3.753 3.3525.867 1.4011 1.301 2.9523 1.301 4.6536 0 1.9681-.551 3.636-1.651 5.0037-1.068 1.3344-2.402 2.235-4.004 2.7021 1.969.4003 3.57 1.3677 4.804 2.9022 1.234 1.5011 1.852 3.4025 1.852 5.7043 0 1.9347-.468 3.7028-1.402 5.304-.934 1.6012-2.301 2.8855-4.103 3.8529-1.768.9674-3.953 1.4511-6.555 1.4511Z"
      fill="#00DC82"></path>
  </g>
  <defs>
    <clipPath id="a">
      <path fill="#fff" d="M0 0h221v65H0z"></path>
    </clipPath>
  </defs>
</svg>
</file>

<file path="test/fixtures/basic/server/api/experimental/decorators.ts">
export default eventHandler((_event) => {
  function something (_method: () => unknown) {
    return () => 'decorated'
  }

  class SomeClass {
    @something
    public someMethod () {
      return 'initial'
    }
  }

  return new SomeClass().someMethod()
})
</file>

<file path="test/fixtures/basic/server/api/hey/index.get.ts">
export default defineEventHandler(() => ({
  foo: 'bar',
  baz: 'qux',
}))
</file>

<file path="test/fixtures/basic/server/api/hey/index.post.ts">
export default defineEventHandler(() => ({
  method: 'post' as const,
}))
</file>

<file path="test/fixtures/basic/server/api/useAsyncData/count.ts">
let counter = 0

const test = () => () => {
  // TODO: useNuxtApp should be undefined when type-testing a nitro route
  useNuxtApp()
}
test()

export default defineEventHandler(() => ({ count: counter++ }))
</file>

<file path="test/fixtures/basic/server/api/app-config.ts">
export default defineEventHandler(() => {
  const appConfig = useAppConfig()
  return {
    appConfig,
  }
})
</file>

<file path="test/fixtures/basic/server/api/auto-imports.ts">
export default defineEventHandler(() => {
  return {
    thisIs: autoimportedFunction(),
    autoImported: someUtils,
    fromServerDir: testUtils,
  }
})
</file>

<file path="test/fixtures/basic/server/api/counter.ts">
let counter = 0

export default defineEventHandler(() => ({ count: counter++ }))
</file>

<file path="test/fixtures/basic/server/api/error.ts">
export default defineEventHandler(() => {
  throw createError({ statusCode: 400 })
})
</file>

<file path="test/fixtures/basic/server/api/hello.ts">
export default defineEventHandler(() => 'Hello API')
</file>

<file path="test/fixtures/basic/server/api/preview.ts">
const apiKeyName = 'apiKey'
const apiKey = 'hehe'

export default defineEventHandler((event) => {
  return {
    hehe: getQuery(event)[apiKeyName] === apiKey,
  }
})
</file>

<file path="test/fixtures/basic/server/api/random.ts">
export default defineEventHandler(() => {
  return new Array(10).fill(0).map(() => Math.round(Math.random() * 10000))
})
</file>

<file path="test/fixtures/basic/server/api/union.ts">
export default defineEventHandler(() => ({
  type: 'a',
  foo: 'bar',
}) as { type: 'a', foo: string } | { type: 'b', baz: string })
</file>

<file path="test/fixtures/basic/server/api/very-long-request.ts">
export default defineEventHandler(async () => {
  await timeout(20)
  return 'that was very long ...'
})
function timeout (ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms))
}
</file>

<file path="test/fixtures/basic/server/plugins/headers.ts">
export default defineNitroPlugin((nitroApp) => {
  if (!import.meta.dev) { return }

  const onError = nitroApp.h3App.options.onError!
  nitroApp.h3App.options.onError = (error, event) => {
    // TODO: somehow add error logging assertion to @nuxt/test-utils
    if (error.message?.includes('Cannot set headers after they are sent to the client')) {
      process.exit(1)
    }
    return onError(error, event)
  }
})
</file>

<file path="test/fixtures/basic/server/routes/ignore/scanned.ts">
export default defineEventHandler(() => {
  return 'this should be ignored'
})
</file>

<file path="test/fixtures/basic/server/routes/proxy.ts">
export default defineEventHandler(async () => {
  return await $fetch<string>('/')
})
</file>

<file path="test/fixtures/basic/.gitignore">
!extends/node_modules
</file>

<file path="test/fixtures/basic/.nuxtignore">
composables/ignored.*
**/ignore/public-asset
server/routes/ignore/scanned.ts
</file>

<file path="test/fixtures/basic/nuxt.config.ts">
import { addBuildPlugin, addComponent } from 'nuxt/kit'
import type { NuxtPage } from 'nuxt/schema'
import { defu } from 'defu'
import { createUnplugin } from 'unplugin'
import { withoutLeadingSlash } from 'ufo'
import { withMatrix } from '../../matrix'

export default withMatrix({
  appId: 'nuxt-app-basic',
  extends: [
    './extends/node_modules/foo',
  ],
  // this produces an order of `~` > `~/extends/bar` > `~/extends/node_modules/foo`
  theme: './extends/bar',
  modules: [
    function (_options, nuxt) {
      // ensure setting `runtimeConfig` also sets `nitro.runtimeConfig`
      nuxt.options.runtimeConfig = defu(nuxt.options.runtimeConfig, {
        public: {
          testConfig: 123,
        },
      })
    },
    function (_options, nuxt) {
      nuxt.hook('modules:done', () => {
        // @ts-expect-error not valid nuxt option
        if (!nuxt.options.__installed_layer) {
          throw new Error('layer in layers/ directory was not auto-registered')
        }
      })
    },
    '~~/custom-modules/subpath',
    './modules/test',
    '~~/modules/example',
    function (_, nuxt) {
      // Virtual CSS modules only work with Vite, not with webpack/rspack
      if (typeof nuxt.options.builder === 'string' && (nuxt.options.builder.includes('webpack') || nuxt.options.builder.includes('rspack'))) { return }

      nuxt.options.css.push('virtual.css')
      nuxt.options.build.transpile.push('virtual.css')
      const plugin = createUnplugin(() => ({
        name: 'virtual',
        resolveId (id) {
          if (id === 'virtual.css') { return 'virtual.css' }
        },
        load (id) {
          if (id.includes('virtual.css')) { return ':root { --virtual: red }' }
        },
      }))
      addBuildPlugin(plugin)
    },
    function (_options, nuxt) {
      nuxt.hook('pages:extend', (pages) => {
        pages.push({
          path: '/manual-redirect',
          redirect: '/',
        })
      })
    },
    function (_options, nuxt) {
      const routesToDuplicate = ['/async-parent', '/fixed-keyed-child-parent', '/keyed-child-parent', '/with-layout', '/with-layout2']
      const stripLayout = (page: NuxtPage): NuxtPage => ({
        ...page,
        children: page.children?.map(child => stripLayout(child)),
        name: 'internal-' + page.name,
        path: withoutLeadingSlash(page.path),
        meta: {
          ...page.meta,
          layout: undefined,
          _layout: page.meta?.layout,
        },
      })
      nuxt.hook('pages:resolved', (pages) => {
        const newPages = []
        for (const page of pages) {
          if (routesToDuplicate.includes(page.path)) {
            newPages.push(stripLayout(page))
          }
        }
        const internalParent = pages.find(page => page.path === '/internal-layout')
        internalParent!.children = newPages
      })
    },
    function (_options, nuxt) {
      // to check that page metadata is preserved
      nuxt.hook('pages:resolved', (pages) => {
        const customName = pages.find(page => page.name === 'some-custom-name')
        if (!customName) { throw new Error('Page with custom name not found') }
        if (customName.path !== '/some-custom-path') { throw new Error('Page path not extracted') }

        customName.meta ||= {}
        customName.meta.someProp = true
      })
    },
    // To test falsy module values
    undefined,
  ],
  app: {
    pageTransition: true,
    layoutTransition: true,
    teleportId: 'nuxt-teleport',
    teleportTag: 'span',
    head: {
      charset: 'utf-8',
      link: [undefined],
      meta: [
        { name: 'viewport', content: 'width=1024, initial-scale=1' },
        { charset: 'utf-8' },
        { name: 'description', content: 'Nuxt Fixture' },
      ],
    },
    keepalive: {
      include: ['keepalive-in-config', 'not-keepalive-in-nuxtpage'],
    },
  },
  css: ['~/assets/global.css'],
  vue: {
    compilerOptions: {
      isCustomElement: (tag) => {
        return tag === 'custom-component'
      },
    },
  },
  appConfig: {
    fromNuxtConfig: true,
    nested: {
      val: 1,
    },
  },
  runtimeConfig: {
    public: {
      needsFallback: undefined,
    },
  },
  build: {
    transpile: [
      (ctx) => {
        if (typeof ctx.isDev !== 'boolean') { throw new TypeError('context not passed') }
        return false
      },
    ],
  },
  optimization: {
    keyedComposables: [
      {
        name: 'useCustomKeyedComposable',
        source: '~/other-composables-folder/custom-keyed-composable',
        argumentLength: 1,
      },
    ],
  },
  features: {
    inlineStyles: id => !!id && !id.includes('assets.vue'),
  },
  experimental: {
    decorators: true,
    typedPages: true,
    clientFallback: true,
    restoreState: true,
    clientNodeCompat: true,
    componentIslands: {
      selectiveClient: 'deep',
    },
    inlineRouteRules: true,
  },
  nitro: {
    publicAssets: [
      {
        dir: '../custom-public',
        baseURL: '/custom',
      },
    ],
    esbuild: {
      options: {
        // in order to test bigint serialization
        target: 'es2022',
      },
    },
    routeRules: {
      '/route-rules/spa': { ssr: false },
      '/redirect/catchall': { ssr: false },
      '/head-spa': { ssr: false },
      '/route-rules/middleware': { appMiddleware: 'route-rules-middleware' },
      '/route-rules/layout': { appLayout: 'custom' },
      '/hydration/spa-redirection/**': { ssr: false },
      '/no-scripts': { noScripts: true },
      '/prerender/**': { prerender: true },
      '/route-rules/redirect': { redirect: '/' },
      '/isr': { isr: 60 },
      '/swr': { swr: 60 },
    },
    prerender: {
      routes: [
        '/random/a',
        '/random/b',
        '/random/c',
        '/prefetch/server-components',
      ],
    },
  },
  vite: {
    $client: {
      build: {
        target: ['chrome107', 'edge107', 'firefox108', 'safari17'],
      },
    },
    logLevel: 'silent',
    build: {
      assetsInlineLimit: 100, // keep SVG as assets URL
    },
  },
  postcss: {
    plugins: {
      '~~/postcss/plugin': {},
    },
  },
  telemetry: false, // for testing telemetry types - it is auto-disabled in tests
  hooks: {
    'webpack:config' (configs) {
      // in order to test bigint serialization we need to set target to a more modern one
      for (const config of configs) {
        const esbuildRules = config.module!.rules!.filter(
          rule => typeof rule === 'object' && rule && 'loader' in rule && rule.loader === 'esbuild-loader',
        )
        for (const rule of esbuildRules) {
          if (typeof rule === 'object' && typeof rule?.options === 'object') {
            rule.options.target = 'es2022'
          }
        }
      }
    },
    'modules:done' () {
      addComponent({
        name: 'CustomComponent',
        export: 'namedExport',
        filePath: '~/other-components-folder/named-export',
      })
    },
    'components:extend' (components) {
      for (const comp of components) {
        if (comp.pascalName === 'GlobalSync') {
          comp.global = 'sync'
        }
      }
    },
    'vite:extend' ({ config }) {
      config.plugins!.push({
        name: 'nuxt:server',
        enforce: 'pre',
        configureServer (server) {
          server.middlewares.use((req, res, next) => {
            if (req.url === '/vite-plugin-without-path') {
              res.end('vite-plugin without path')
              return
            }
            next()
          })

          server.middlewares.use((req, res, next) => {
            if (req.url === '/__nuxt-test') {
              res.end('vite-plugin with __nuxt prefix')
              return
            }
            next()
          })
        },
      })
    },
  },
})
</file>

<file path="test/fixtures/basic/package.json">
{
  "private": true,
  "name": "fixture-basic",
  "scripts": {
    "build": "nuxt build"
  },
  "dependencies": {
    "@nuxt/rspack-builder": "workspace:*",
    "@nuxt/webpack-builder": "workspace:*",
    "nuxt": "workspace:*"
  },
  "devDependencies": {
    "@vue/devtools-api": "latest",
    "defu": "latest",
    "postcss": "^8.4.47",
    "ufo": "latest",
    "unplugin": "latest",
    "vue": "latest"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="test/fixtures/basic/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="test/fixtures/basic-types/app/components/ServerComponent.server.vue">
<template>
  <div>
    Hello from server component !
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/app/components/WithTypes.vue">
<script setup lang="ts">
defineProps({
  aProp: Number,
})
defineSlots<{
  fallback: { id: string }
}>()
defineExpose<{
  _exposedValue: boolean
}>()

const _exposedValue = 42

const emit = defineEmits<{
  'some-event': [id: string]
}>()
emit('some-event', '42')
// @ts-expect-error an invalid argument
emit('some-event', 42)
// @ts-expect-error an unknown event
// eslint-disable-next-line vue/require-explicit-emits
emit('unknown-event', 42)
</script>

<template>
  <div>
    <!--  -->
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/app/layouts/custom.vue">
<template>
  <div>
    Custom Layout:
    <slot />
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/app/layouts/PascalCase.ts">

</file>

<file path="test/fixtures/basic-types/app/layouts/with-props.vue">
<template>
  <div>
    <slot />
  </div>
</template>

<script setup lang="ts">
defineProps<{
  aProp: number
}>()
</script>
</file>

<file path="test/fixtures/basic-types/app/middleware/global.global.ts">
export default defineNuxtRouteMiddleware((to) => {
  if ('abort' in to.query) {
    return abortNavigation({
      statusCode: 401,
    })
  }
})
</file>

<file path="test/fixtures/basic-types/app/middleware/named.ts">
export default defineNuxtRouteMiddleware((to) => {
  to.meta.auth = 'Injected by injectAuth middleware'
})
</file>

<file path="test/fixtures/basic-types/app/pages/param/[id]/view.vue">
<script setup lang="ts">
definePageMeta({
  name: 'param-id-view-custom',
  // Deliberately passing absolute path here to test if params are not being duplicated in RouteNamedMap
  path: '/param/:id()/view-custom',
})
</script>

<template>
  <div>
    <!--  -->
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/app/pages/param/[id].vue">
<template>
  <div>
    <NuxtPage />
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/app/pages/param/index.vue">
<script setup lang="ts">
definePageMeta({
  name: 'param2',
  alias: ['/param-other'],
})
</script>

<template>
  <div>
    <!--  -->
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/app/pages/custom-name.vue">
<script setup lang="ts">
definePageMeta({
  validate: () => true,
  middleware: [
    function () {},
  ],
  name: 'some-custom-name',
})
</script>

<template>
  <div>
    <!--  -->
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/app/pages/page.vue">
<template>
  <div>
    <!--  -->
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/app/pages/param.vue">
<template>
  <div>
    <!--  -->
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/app/plugins/injection.ts">
export default defineNuxtPlugin(() => {
  return {
    provide: {
      pluginInjection: () => '',
    },
  }
})
</file>

<file path="test/fixtures/basic-types/app/app-types.ts">
import { describe, expectTypeOf, it } from 'vitest'
import type { Ref, SlotsType } from 'vue'
import type { FetchError } from 'ofetch'
import type { NavigationFailure, RouteLocationNormalized, RouteLocationRaw, Router, useRouter as vueUseRouter } from 'vue-router'
import type { H3Event } from 'h3'
import { getRouteRules as getNitroRouteRules } from 'nitropack/runtime'
import type { NitroRouteRules } from 'nitropack/types'

import type { AppConfig } from 'nuxt/schema'
import { defineNuxtConfig } from 'nuxt/config'
import { callWithNuxt, isVue3 } from '#app'
import type { NuxtError } from '#app'
import type { NavigateToOptions } from '#app/composables/router'
import { LazyWithTypes, NuxtLayout, NuxtLink, NuxtPage, ServerComponent, WithTypes } from '#components'
import type { IslandComponent, LazyComponent } from '#components'
import { useRouter } from '#imports'

type DefaultAsyncDataErrorValue = undefined
type DefaultAsyncDataValue = undefined

interface TestResponse { message: string }

declare module 'nuxt/app' {
  interface NuxtLayouts {
    withFunction: {
      someProp: number
      function: () => void
    }
  }
}

describe('API routes', () => {
  it('generates types for routes', () => {
    expectTypeOf($fetch('/api/hello')).toEqualTypeOf<Promise<string>>()
    // registered in extends
    expectTypeOf($fetch('/api/foo')).toEqualTypeOf<Promise<string>>()
    // registered in module
    expectTypeOf($fetch('/auto-registered-module')).toEqualTypeOf<Promise<string>>()
    expectTypeOf($fetch('/api/hey')).toEqualTypeOf<Promise<{ foo: string, baz: string }>>()
    expectTypeOf($fetch('/api/hey', { method: 'get' })).toEqualTypeOf<Promise<{ foo: string, baz: string }>>()
    expectTypeOf($fetch('/api/hey', { method: 'post' })).toEqualTypeOf<Promise<{ method: 'post' }>>()
    // @ts-expect-error not a valid method
    expectTypeOf($fetch('/api/hey', { method: 'patch ' })).toEqualTypeOf<Promise<{ foo: string, baz: string }>>()
    expectTypeOf($fetch('/api/union')).toEqualTypeOf<Promise<{ type: 'a', foo: string } | { type: 'b', baz: string }>>()
    expectTypeOf($fetch('/api/other')).toEqualTypeOf<Promise<unknown>>()
    expectTypeOf($fetch<TestResponse>('/test')).toEqualTypeOf<Promise<TestResponse>>()
  })

  it('works with useRequestFetch', () => {
    const $fetch = useRequestFetch()
    expectTypeOf($fetch('/api/hello')).toEqualTypeOf<Promise<string>>()
    // registered in extends
    expectTypeOf($fetch('/api/foo')).toEqualTypeOf<Promise<string>>()
    // registered in module
    expectTypeOf($fetch('/auto-registered-module')).toEqualTypeOf<Promise<string>>()
    expectTypeOf($fetch('/api/hey')).toEqualTypeOf<Promise<{ foo: string, baz: string }>>()
    expectTypeOf($fetch('/api/hey', { method: 'get' })).toEqualTypeOf<Promise<{ foo: string, baz: string }>>()
    expectTypeOf($fetch('/api/hey', { method: 'post' })).toEqualTypeOf<Promise<{ method: 'post' }>>()
    // @ts-expect-error not a valid method
    expectTypeOf($fetch('/api/hey', { method: 'patch ' })).toEqualTypeOf<Promise<{ foo: string, baz: string }>>()
    expectTypeOf($fetch('/api/union')).toEqualTypeOf<Promise<{ type: 'a', foo: string } | { type: 'b', baz: string }>>()
    expectTypeOf($fetch('/api/other')).toEqualTypeOf<Promise<unknown>>()
    expectTypeOf($fetch<TestResponse>('/test')).toEqualTypeOf<Promise<TestResponse>>()
  })

  it('works with useAsyncData', () => {
    expectTypeOf(useAsyncData('api-hello', () => $fetch('/api/hello')).data).toEqualTypeOf<Ref<string | DefaultAsyncDataValue>>()
    expectTypeOf(useAsyncData('api-hey', () => $fetch('/api/hey')).data).toEqualTypeOf<Ref<{ foo: string, baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useAsyncData('api-hey-with-pick', () => $fetch('/api/hey'), { pick: ['baz'] }).data).toEqualTypeOf<Ref<{ baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useAsyncData('api-union', () => $fetch('/api/union')).data).toEqualTypeOf<Ref<{ type: 'a', foo: string } | { type: 'b', baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useAsyncData('api-union-with-pick', () => $fetch('/api/union'), { pick: ['type'] }).data).toEqualTypeOf<Ref<{ type: 'a' } | { type: 'b' } | DefaultAsyncDataValue>>()
    expectTypeOf(useAsyncData('api-other', () => $fetch('/api/other')).data).toEqualTypeOf<Ref<unknown>>()
    expectTypeOf(useAsyncData<TestResponse>('api-generics', () => $fetch('/test')).data).toEqualTypeOf<Ref<TestResponse | DefaultAsyncDataValue>>()

    expectTypeOf(useAsyncData('api-error-generics', () => $fetch('/error')).error).toEqualTypeOf<Ref<NuxtError<unknown> | DefaultAsyncDataErrorValue>>()
    expectTypeOf(useAsyncData<any, string>('api-error-generics', () => $fetch('/error')).error).toEqualTypeOf<Ref<NuxtError<string> | DefaultAsyncDataErrorValue>>()
    // backwards compatibility
    expectTypeOf(useAsyncData<any, Error>('api-error-generics', () => $fetch('/error')).error).toEqualTypeOf<Ref<Error | DefaultAsyncDataErrorValue>>()
    expectTypeOf(useAsyncData<any, NuxtError<string>>('api-error-generics', () => $fetch('/error')).error).toEqualTypeOf<Ref<NuxtError<string> | DefaultAsyncDataErrorValue>>()

    expectTypeOf(useLazyAsyncData('lazy-api-hello', () => $fetch('/api/hello')).data).toEqualTypeOf<Ref<string | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyAsyncData('lazy-api-hey', () => $fetch('/api/hey')).data).toEqualTypeOf<Ref<{ foo: string, baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyAsyncData('lazy-api-hey-with-pick', () => $fetch('/api/hey'), { pick: ['baz'] }).data).toEqualTypeOf<Ref<{ baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyAsyncData('lazy-api-union', () => $fetch('/api/union')).data).toEqualTypeOf<Ref<{ type: 'a', foo: string } | { type: 'b', baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyAsyncData('lazy-api-union-with-pick', () => $fetch('/api/union'), { pick: ['type'] }).data).toEqualTypeOf<Ref<{ type: 'a' } | { type: 'b' } | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyAsyncData('lazy-api-other', () => $fetch('/api/other')).data).toEqualTypeOf<Ref<unknown>>()
    expectTypeOf(useLazyAsyncData<TestResponse>('lazy-api-generics', () => $fetch('/test')).data).toEqualTypeOf<Ref<TestResponse | DefaultAsyncDataValue>>()

    expectTypeOf(useLazyAsyncData('lazy-error-generics', () => $fetch('/error')).error).toEqualTypeOf<Ref<NuxtError<unknown> | DefaultAsyncDataErrorValue>>()
    expectTypeOf(useLazyAsyncData<any, string>('lazy-error-generics', () => $fetch('/error')).error).toEqualTypeOf<Ref<NuxtError<string> | DefaultAsyncDataErrorValue>>()
  })

  it('works with useFetch', () => {
    expectTypeOf(useFetch('/api/hello').data).toEqualTypeOf<Ref<string | DefaultAsyncDataValue>>()
    expectTypeOf(useFetch('/api/hey').data).toEqualTypeOf<Ref<{ foo: string, baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useFetch('/api/hey', { method: 'GET' }).data).toEqualTypeOf<Ref<{ foo: string, baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useFetch('/api/hey', { method: 'get' }).data).toEqualTypeOf<Ref<{ foo: string, baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useFetch('/api/hey', { method: 'POST' }).data).toEqualTypeOf<Ref<{ method: 'post' } | DefaultAsyncDataValue>>()
    expectTypeOf(useFetch('/api/hey', { method: 'post' }).data).toEqualTypeOf<Ref<{ method: 'post' } | DefaultAsyncDataValue>>()
    // @ts-expect-error not a valid method
    useFetch('/api/hey', { method: 'PATCH' })
    expectTypeOf(useFetch('/api/hey', { pick: ['baz'] }).data).toEqualTypeOf<Ref<{ baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useFetch('/api/union').data).toEqualTypeOf<Ref<{ type: 'a', foo: string } | { type: 'b', baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useFetch('/api/union', { pick: ['type'] }).data).toEqualTypeOf<Ref<{ type: 'a' } | { type: 'b' } | DefaultAsyncDataValue>>()
    expectTypeOf(useFetch('/api/other').data).toEqualTypeOf<Ref<unknown>>()
    expectTypeOf(useFetch<TestResponse>('/test').data).toEqualTypeOf<Ref<TestResponse | DefaultAsyncDataValue>>()
    expectTypeOf(useFetch<TestResponse>('/test', { method: 'POST' }).data).toEqualTypeOf<Ref<TestResponse | DefaultAsyncDataValue>>()

    expectTypeOf(useFetch('/error').error).toEqualTypeOf<Ref<FetchError | DefaultAsyncDataErrorValue>>()
    expectTypeOf(useFetch<any, string>('/error').error).toEqualTypeOf<Ref<string | DefaultAsyncDataErrorValue>>()

    expectTypeOf(useLazyFetch('/api/hello').data).toEqualTypeOf<Ref<string | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyFetch('/api/hey').data).toEqualTypeOf<Ref<{ foo: string, baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyFetch('/api/hey', { pick: ['baz'] }).data).toEqualTypeOf<Ref<{ baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyFetch('/api/union').data).toEqualTypeOf<Ref<{ type: 'a', foo: string } | { type: 'b', baz: string } | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyFetch('/api/union', { pick: ['type'] }).data).toEqualTypeOf<Ref<{ type: 'a' } | { type: 'b' } | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyFetch('/api/other').data).toEqualTypeOf<Ref<unknown>>()
    expectTypeOf(useLazyFetch<TestResponse>('/test').data).toEqualTypeOf<Ref<TestResponse | DefaultAsyncDataValue>>()

    expectTypeOf(useLazyFetch('/error').error).toEqualTypeOf<Ref<FetchError | DefaultAsyncDataErrorValue>>()
    expectTypeOf(useLazyFetch<any, string>('/error').error).toEqualTypeOf<Ref<string | DefaultAsyncDataErrorValue>>()
  })

  it('works with useFetch and generic type', () => {
    type ApiResponse = { message: string }

    useFetch<ApiResponse>('/api/v1/users', {
      onResponse ({ response }) {
        expectTypeOf(response._data).toEqualTypeOf<ApiResponse | undefined>()
      },
    })
  })
})

describe('nitro compatible APIs', () => {
  it('getRouteRules', async () => {
    const a = await getRouteRules('/test')
    const b = await getRouteRules({} as H3Event)
    const c = getNitroRouteRules({} as H3Event)

    expectTypeOf(b).toEqualTypeOf(c)
    expectTypeOf(c).toEqualTypeOf<NitroRouteRules>()
    expectTypeOf(a).toEqualTypeOf<Record<string, any>>()
  })
  it('useRuntimeConfig', () => {
    useRuntimeConfig({} as H3Event)
  })
})

describe('aliases', () => {
  it('allows importing from path aliases', () => {
    expectTypeOf(useRouter).toEqualTypeOf<typeof vueUseRouter>()
    expectTypeOf(isVue3).toEqualTypeOf<boolean>()
  })
})

describe('middleware', () => {
  it('recognizes named middleware', () => {
    definePageMeta({ middleware: 'named' })
    // provided by layer
    definePageMeta({ middleware: 'override' })
    definePageMeta({ middleware: 'foo' })
    // @ts-expect-error ignore global middleware
    definePageMeta({ middleware: 'global' })
    // @ts-expect-error Invalid middleware
    definePageMeta({ middleware: 'nonexistent' })
  })
  it('types routeRules', () => {
    defineNuxtConfig({
      routeRules: {
        // @ts-expect-error Invalid middleware
        '/nonexistent': { appMiddleware: 'nonexistent' },
        // @ts-expect-error ignore global middleware
        '/global': { appMiddleware: 'global' },
        '/named': { appMiddleware: 'named' },
      },
    })
  })
  it('handles adding middleware', () => {
    addRouteMiddleware('example', (to, from) => {
      expectTypeOf(to).toEqualTypeOf<RouteLocationNormalized>()
      expectTypeOf(from).toEqualTypeOf<RouteLocationNormalized>()
      expectTypeOf(navigateTo).toEqualTypeOf<(to: RouteLocationRaw | null | undefined, options?: NavigateToOptions) => RouteLocationRaw | void | false | Promise<void | NavigationFailure | false>>()
      navigateTo('/')
      abortNavigation()
      abortNavigation('error string')
      abortNavigation(new Error('my error'))
      // @ts-expect-error Must return error or string
      abortNavigation(true)
    }, { global: true })
  })
  it('handles return types of validate', () => {
    definePageMeta({
      validate: async () => {
        await new Promise(resolve => setTimeout(resolve, 1000))
        // eslint-disable-next-line no-constant-condition
        if (0) {
          return createError({
            statusCode: 404,
            statusMessage: 'resource-type-not-found',
          })
        }
        return true
      },
    })
  })
})

describe('typed router integration', () => {
  it('allows typing useRouter', () => {
    const router = useRouter()
    // @ts-expect-error this named route does not exist
    router.push({ name: 'some-thing' })
    // this one does
    router.push({ name: 'page' })
    // @ts-expect-error this is an invalid param
    router.push({ name: 'param-id', params: { bob: 23 } })
    router.push({ name: 'param-id', params: { id: 4 } })
    // @ts-expect-error this is an invalid route
    router.push({ name: 'param' })
    // @ts-expect-error this is an invalid route
    router.push({ name: '/param' })
  })

  it('correctly reads custom names typed in `definePageMeta`', () => {
    const router = useRouter()
    router.push({ name: 'some-custom-name' })
    router.push({ name: 'param-id-view-custom', params: { id: 4 } })
  })

  it('allows typing useRoute', () => {
    const route = useRoute('param-id')
    // @ts-expect-error this param does not exist
    const _invalid = route.params.something
    // this param does
    const _valid = route.params.id
  })

  it('allows typing navigateTo', () => {
    // @ts-expect-error this named route does not exist
    navigateTo({ name: 'some-thing' })
    // this one does
    navigateTo({ name: 'page' })
    // @ts-expect-error this is an invalid param
    navigateTo({ name: 'param-id', params: { bob: 23 } })
    navigateTo({ name: 'param-id', params: { id: 4 } })
    // @ts-expect-error this is an invalid param
    navigateTo({ name: 'param-id-view-custom', params: { bob: 23 } })
    navigateTo({ name: 'param-id-view-custom', params: { id: 4 } })
  })

  it('allows typing middleware', () => {
    defineNuxtRouteMiddleware((to) => {
      expectTypeOf(to.name).not.toBeAny()
      // @ts-expect-error this route does not exist
      expectTypeOf(to.name === 'bob').toEqualTypeOf<boolean>()
      expectTypeOf(to.name === 'page').toEqualTypeOf<boolean>()
    })
  })

  it('respects pages:extend augmentation', () => {
    // added via pages:extend
    expectTypeOf(useRoute().name === 'internal-async-parent').toEqualTypeOf<boolean>()
    // @ts-expect-error this route does not exist
    expectTypeOf(useRoute().name === 'invalid').toEqualTypeOf<boolean>()
  })

  it('respects pages added via layer', () => {
    expectTypeOf(useRoute().name === 'override').toEqualTypeOf<boolean>()
  })

  it('allows typing NuxtLink', () => {
    // @ts-expect-error this named route does not exist
    h(NuxtLink, { to: { name: 'some-thing' } })
    // @ts-expect-error this named route does not exist
    h(NuxtLink, { href: { name: 'some-thing' } })
    // this one does
    h(NuxtLink, { to: { name: 'page' } })
    h(NuxtLink, { href: { name: 'page' } })
    // @ts-expect-error this is an invalid param
    h(NuxtLink, { to: { name: 'param-id', params: { bob: 23 } } })
    // @ts-expect-error this is an invalid param
    h(NuxtLink, { href: { name: 'param-id', params: { bob: 23 } } })
    h(NuxtLink, { to: { name: 'param-id', params: { id: 4 } } })
    h(NuxtLink, { href: { name: 'param-id', params: { id: 4 } } })

    // doesn't throw an error when accessing properties of component
    const _props = NuxtLink.props
  })
})

describe('layouts', () => {
  it('definePageMeta recognizes named layouts', () => {
    definePageMeta({ layout: 'custom' })
    definePageMeta({ layout: 'pascal-case' })
    definePageMeta({ layout: 'override' })
    // @ts-expect-error Invalid layout
    definePageMeta({ layout: 'invalid-layout' })
  })

  it('NuxtLayout recognizes named layouts', () => {
    h(NuxtLayout, { name: 'custom' })
    // @ts-expect-error Invalid layout
    h(NuxtLayout, { name: 'invalid-layout' })

    h(NuxtLayout, { fallback: 'custom' })
    // @ts-expect-error Invalid layout
    h(NuxtLayout, { fallback: 'invalid-layout' })
  })

  it('setPageLayout recognizes named layouts and props', () => {
    setPageLayout('custom')
    setPageLayout('pascal-case')
    setPageLayout('override')
    setPageLayout('with-props', { aProp: 42 })
    // @ts-expect-error Invalid layout
    setPageLayout('invalid-layout')
    // @ts-expect-error Invalid layout props
    setPageLayout('with-props', { aProp: 'string-instead-of-number' })
  })

  it('expect setPageLayout to raise TS error when using non-serializable props values', () => {
    // @ts-expect-error Non-serializable layout props
    setPageLayout('withFunction', { aProp: () => {}, someProp: 5 })
  })
})

describe('nuxtApp', () => {
  it('types injections provided by plugins', () => {
    expectTypeOf(useNuxtApp().$pluginInjection).toEqualTypeOf<() => ''>()
    expectTypeOf(useNuxtApp().$foo).toEqualTypeOf<() => 'String generated from foo plugin!'>()
    expectTypeOf(useNuxtApp().$router).toEqualTypeOf<Router>()
  })
  it('marks unknown injections as unknown', () => {
    expectTypeOf(useNuxtApp().doesNotExist).toEqualTypeOf<unknown>()
    expectTypeOf(useNuxtApp().$random).toEqualTypeOf<unknown>()
  })
})

describe('plugins', () => {
  it('dependsOn is strongly typed', () => {
    defineNuxtPlugin({
      // @ts-expect-error invalid plugin name
      dependsOn: ['something'],
    })
    defineNuxtPlugin({
      dependsOn: ['nuxt:router'],
    })
  })
})

describe('runtimeConfig', () => {
  it('generated runtimeConfig types', () => {
    const runtimeConfig = useRuntimeConfig()
    expectTypeOf(runtimeConfig.public.testConfig).toEqualTypeOf<number>()
    expectTypeOf(runtimeConfig.public.needsFallback).toEqualTypeOf<string>()
    expectTypeOf(runtimeConfig.privateConfig).toEqualTypeOf<string>()
    expectTypeOf(runtimeConfig.public.ids).toEqualTypeOf<(1 | 2 | 3)[]>()
    expectTypeOf(runtimeConfig.unknown).toEqualTypeOf<unknown>()

    const injectedConfig = useNuxtApp().$config
    expectTypeOf(injectedConfig.public.testConfig).toEqualTypeOf<number>()
    expectTypeOf(injectedConfig.public.needsFallback).toEqualTypeOf<string>()
    expectTypeOf(injectedConfig.privateConfig).toEqualTypeOf<string>()
    expectTypeOf(injectedConfig.public.ids).toEqualTypeOf<(1 | 2 | 3)[]>()
    expectTypeOf(injectedConfig.unknown).toEqualTypeOf<unknown>()
  })
})

describe('head', () => {
  it('types useHead', () => {
    useHead({
      base: { href: '/base' },
      link: computed(() => []),
      meta: [
        { key: 'key', name: 'description', content: 'some description ' },
        () => ({ key: 'key', name: 'description', content: 'some description ' }),
      ],
      titleTemplate: (titleChunk) => {
        return titleChunk ? `${titleChunk} - Site Title` : 'Site Title'
      },
    })
  })
  it('types head for defineNuxtComponent', () => {
    defineNuxtComponent({
      head (nuxtApp) {
        expectTypeOf(nuxtApp).not.toBeAny()
        return {
          title: 'Site Title',
        }
      },
    })

    defineNuxtComponent({
      // @ts-expect-error wrong return type for head function
      head () {
        return {
          test: true,
        }
      },
    })
  })
})

describe('components', () => {
  it('includes types for NuxtPage', () => {
    expectTypeOf(NuxtPage).not.toBeAny()
  })

  it('includes types for other components', () => {
    h(WithTypes)
    // @ts-expect-error wrong prop type for this component
    h(WithTypes, { aProp: '40' })

    // TODO: assert typed slots, exposed, generics, etc.
  })

  it('correctly includes event types with island components', () => {
    const Comp = defineComponent({
      __typeProps: {} as {
        onClick: (foo: string) => any
      },
    })
    const IslandComp = Comp as unknown as IslandComponent<typeof Comp>
    h(IslandComp, {
      // @ts-expect-error: foo must be string, not number
      onClick: (foo: number) => foo,
    })
    h(IslandComp, {
      onClick: (foo) => {
        foo satisfies string
        return foo
      },
    })
  })

  it('correctly includes event types with lazy components', () => {
    const Comp = defineComponent({
      __typeProps: {} as {
        onClick: (foo: string) => any
      },
    })
    const LazyComp = Comp as unknown as LazyComponent<typeof Comp>
    h(LazyComp, {
      // @ts-expect-error: foo must be string, not number
      onClick: (foo: number) => foo,
    })
    h(LazyComp, {
      onClick: (foo) => {
        foo satisfies string
        return foo
      },
    })
  })

  it('includes types for lazy hydration', () => {
    h(LazyWithTypes)
    h(LazyWithTypes, { hydrateAfter: 300 })
    h(LazyWithTypes, { hydrateOnIdle: true })

    // @ts-expect-error wrong prop type for this hydration strategy
    h(LazyWithTypes, { hydrateAfter: '' })
  })

  it('include fallback slot in server components', () => {
    expectTypeOf(ServerComponent.slots).toEqualTypeOf<SlotsType<{ fallback: { error: unknown } }> | undefined>()
  })
})

describe('composables', () => {
  it('allows providing default refs', () => {
    expectTypeOf(useState('test', () => ref('hello'))).toEqualTypeOf<Ref<string>>()
    expectTypeOf(useState('test', () => 'hello')).toEqualTypeOf<Ref<string>>()

    expectTypeOf(useCookie('test', { default: () => ref(500) })).toEqualTypeOf<Ref<number>>()
    expectTypeOf(useCookie('test', { default: () => 500 })).toEqualTypeOf<Ref<number>>()
    useCookie<number | null>('test').value = null

    expectTypeOf(useAsyncData('test', () => Promise.resolve(500), { default: () => ref(500) }).data).toEqualTypeOf<Ref<number>>()
    expectTypeOf(useAsyncData('test', () => Promise.resolve(500), { default: () => 500 }).data).toEqualTypeOf<Ref<number>>()
    expectTypeOf(useAsyncData('test', () => Promise.resolve('500'), { default: () => ref(500) }).data).toEqualTypeOf<Ref<string | number>>()
    expectTypeOf(useAsyncData('test', () => Promise.resolve('500'), { default: () => 500 }).data).toEqualTypeOf<Ref<string | number>>()

    expectTypeOf(useFetch('/test', { default: () => ref(500) }).data).toEqualTypeOf<Ref<unknown>>()
    expectTypeOf(useFetch('/test', { default: () => 500 }).data).toEqualTypeOf<Ref<unknown>>()
  })

  it('enforces readonly cookies', () => {
    // @ts-expect-error readonly cookie
    useCookie('test', { readonly: true }).value = 'thing'
  })

  it('correct types when using ResT type-assertion with default function', () => {
    // @ts-expect-error default type should match generic type
    useFetch<string>('/test', { default: () => 0 })
    // @ts-expect-error default type should match generic type
    useLazyFetch<string>('/test', { default: () => 0 })
    // @ts-expect-error default type should match generic type
    useAsyncData<string>(() => $fetch('/test'), { default: () => 0 })
    // @ts-expect-error default type should match generic type
    useLazyAsyncData<string>(() => $fetch('/test'), { default: () => 0 })

    expectTypeOf(useFetch<string>('/test', { default: () => 'test' }).data).toEqualTypeOf<Ref<string>>()
    expectTypeOf(useLazyFetch<string>('/test', { default: () => 'test' }).data).toEqualTypeOf<Ref<string>>()
    expectTypeOf(useAsyncData<string>(() => $fetch('/test'), { default: () => 'test' }).data).toEqualTypeOf<Ref<string>>()
    expectTypeOf(useLazyAsyncData<string>(() => $fetch('/test'), { default: () => 'test' }).data).toEqualTypeOf<Ref<string>>()

    // transform must match the explicit generic because of typescript limitations microsoft/TypeScript#14400
    expectTypeOf(useFetch<string>('/test', { transform: () => 'transformed' }).data).toEqualTypeOf<Ref<string | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyFetch<string>('/test', { transform: () => 'transformed' }).data).toEqualTypeOf<Ref<string | DefaultAsyncDataValue>>()
    expectTypeOf(useAsyncData<string>(() => $fetch('/test'), { transform: () => 'transformed' }).data).toEqualTypeOf<Ref<string | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyAsyncData<string>(() => $fetch('/test'), { transform: () => 'transformed' }).data).toEqualTypeOf<Ref<string | DefaultAsyncDataValue>>()

    expectTypeOf(useFetch<string>('/test', { default: () => 'test', transform: () => 'transformed' }).data).toEqualTypeOf<Ref<string>>()
    expectTypeOf(useLazyFetch<string>('/test', { default: () => 'test', transform: () => 'transformed' }).data).toEqualTypeOf<Ref<string>>()
    expectTypeOf(useAsyncData<string>(() => $fetch('/test'), { default: () => 'test', transform: () => 'transformed' }).data).toEqualTypeOf<Ref<string>>()
    expectTypeOf(useLazyAsyncData<string>(() => $fetch('/test'), { default: () => 'test', transform: () => 'transformed' }).data).toEqualTypeOf<Ref<string>>()
  })

  it('supports asynchronous transform', () => {
    const { data } = useAsyncData('test', () => $fetch('/test') as Promise<{ foo: 'bar' }>, {
      async transform (data) {
        await Promise.resolve()
        return data.foo
      },
    })
    expectTypeOf(data).toEqualTypeOf<Ref<'bar' | DefaultAsyncDataValue>>()
  })

  it('infer request url string literal from server/api routes', () => {
    // request can accept dynamic string type
    const dynamicStringUrl = 'https://example.com/api'
    expectTypeOf(useFetch(dynamicStringUrl).data).toEqualTypeOf<Ref<unknown>>()

    // request param should infer string literal type / show auto-complete hint base on server routes, ex: '/api/hello'
    expectTypeOf(useFetch('/api/hello').data).toEqualTypeOf<Ref<string | DefaultAsyncDataValue>>()
    expectTypeOf(useLazyFetch('/api/hello').data).toEqualTypeOf<Ref<string | DefaultAsyncDataValue>>()

    // request can accept string literal and Request object type
    expectTypeOf(useFetch('https://example.com/api').data).toEqualTypeOf<Ref<unknown>>()
    expectTypeOf(useFetch(new Request('test')).data).toEqualTypeOf<Ref<unknown>>()
  })

  it('provides proper type support when using overloads', () => {
    expectTypeOf(useState('test')).toEqualTypeOf(useState())
    expectTypeOf(useState('test', () => ({ foo: Math.random() }))).toEqualTypeOf(useState(() => ({ foo: Math.random() })))

    expectTypeOf(useAsyncData(computed(() => 'test'), () => Promise.resolve({ foo: Math.random() })))
      .toEqualTypeOf(useAsyncData(() => Promise.resolve({ foo: Math.random() })))
    expectTypeOf(useAsyncData(computed(() => 'test'), () => Promise.resolve({ foo: Math.random() }), { transform: data => data.foo }))
      .toEqualTypeOf(useAsyncData(() => Promise.resolve({ foo: Math.random() }), { transform: data => data.foo }))

    expectTypeOf(useLazyAsyncData(computed(() => 'test'), () => Promise.resolve({ foo: Math.random() })))
      .toEqualTypeOf(useLazyAsyncData(() => Promise.resolve({ foo: Math.random() })))
    expectTypeOf(useLazyAsyncData(computed(() => 'test'), () => Promise.resolve({ foo: Math.random() }), { transform: data => data.foo }))
      .toEqualTypeOf(useLazyAsyncData(() => Promise.resolve({ foo: Math.random() }), { transform: data => data.foo }))

    expectTypeOf(useAsyncData('test', () => Promise.resolve({ foo: Math.random() })))
      .toEqualTypeOf(useAsyncData(() => Promise.resolve({ foo: Math.random() })))
    expectTypeOf(useAsyncData('test', () => Promise.resolve({ foo: Math.random() }), { transform: data => data.foo }))
      .toEqualTypeOf(useAsyncData(() => Promise.resolve({ foo: Math.random() }), { transform: data => data.foo }))

    expectTypeOf(useLazyAsyncData('test', () => Promise.resolve({ foo: Math.random() })))
      .toEqualTypeOf(useLazyAsyncData(() => Promise.resolve({ foo: Math.random() })))
    expectTypeOf(useLazyAsyncData('test', () => Promise.resolve({ foo: Math.random() }), { transform: data => data.foo }))
      .toEqualTypeOf(useLazyAsyncData(() => Promise.resolve({ foo: Math.random() }), { transform: data => data.foo }))

    // Default values: #14437
    // TODO: what?!
    expectTypeOf(useAsyncData('test', () => Promise.resolve({ foo: { bar: 500 } }), { default: () => ({ bar: 500 }), transform: v => v.foo }).data).toEqualTypeOf<Ref<{ bar: number } | { bar: number }>>()
    expectTypeOf(useLazyAsyncData('test', () => Promise.resolve({ foo: { bar: 500 } }), { default: () => ({ bar: 500 }), transform: v => v.foo }))
      .toEqualTypeOf(useLazyAsyncData(() => Promise.resolve({ foo: { bar: 500 } }), { default: () => ({ bar: 500 }), transform: v => v.foo }))
    expectTypeOf(useFetch('/api/hey', { default: () => 1, transform: v => v.foo }).data).toEqualTypeOf<Ref<string | number>>()
    expectTypeOf(useLazyFetch('/api/hey', { default: () => 'bar', transform: v => v.foo }).data).toEqualTypeOf<Ref<string>>()
  })

  it('uses types compatible between useRequestHeaders and useFetch', () => {
    useFetch('/api/hey', {
      headers: useRequestHeaders(),
    })
    useFetch('/api/hey', {
      headers: useRequestHeaders(['test']),
    })
    const { test } = useRequestHeaders(['test'])
    expectTypeOf(test).toEqualTypeOf<string | undefined>()
  })

  it('allows passing reactive values in useFetch', () => {
    useFetch('/api/hey', {
      headers: {
        key: ref('test'),
      },
      query: {
        param: computed(() => 'thing'),
      },
    })
  })

  it('correctly types returns with key signatures', () => {
    interface TestType {
      id: string
      content: string[]
      [x: string]: any
    }

    const testFetch = () => Promise.resolve({}) as Promise<TestType>

    const { data: notTypedData } = useAsyncData('test', testFetch)
    expectTypeOf(notTypedData.value!.id).toEqualTypeOf<string>()
    expectTypeOf(notTypedData.value!.content).toEqualTypeOf<string[]>()
    expectTypeOf(notTypedData.value!.untypedKey).toEqualTypeOf<any>()
  })

  it('correctly types returns when using with getCachedData', () => {
    expectTypeOf(useAsyncData('test', () => Promise.resolve({ foo: 1 }), {
      getCachedData: key => useNuxtApp().payload.data[key],
    }).data).toEqualTypeOf<Ref<{ foo: number } | DefaultAsyncDataValue>>()
    useAsyncData('test', () => Promise.resolve({ foo: 1 }), {
      // @ts-expect-error cached data should return the same as value of fetcher
      getCachedData: () => ({ bar: 2 }),
    })
    useAsyncData<{ foo: number }, unknown, { foo: number }>('test', () => Promise.resolve({ foo: 1 }), {
      // @ts-expect-error cached data should return the same as asserted type of `useAsyncData`
      getCachedData: () => ({ bar: 2 }),
    })
  })
})

describe('app config', () => {
  it('merges app config as expected', () => {
    interface ExpectedMergedAppConfig {
      // eslint-disable-next-line @typescript-eslint/no-empty-object-type
      nuxt: {}
      fromLayer: boolean
      fromNuxtConfig: boolean
      nested: {
        val: number
      }
      userConfig: 123 | 456
      someThing?: {
        value?: string | false
      }
      [key: string]: unknown
    }
    expectTypeOf<AppConfig>().toEqualTypeOf<ExpectedMergedAppConfig>()
  })
})

describe('extends type declarations', () => {
  it('correctly adds references to tsconfig', () => {
    expectTypeOf<import('bing').BingInterface>().toEqualTypeOf<{ foo: 'bar' }>()
  })
})

describe('composables inference', () => {
  it('callWithNuxt', () => {
    const bob = callWithNuxt({} as any, () => true)
    expectTypeOf<typeof bob>().toEqualTypeOf<Promise<boolean>>()
  })
  it('runWithContext', () => {
    const bob = useNuxtApp().runWithContext(() => true)
    expectTypeOf<typeof bob>().toEqualTypeOf<boolean | Promise<boolean>>()
  })
})

describe('kit utilities', () => {
  it('addTypeTemplate', () => {
    // @ts-expect-error Fromage is 'cheese'
    const _fake: Fromage = 'babybel'

    const _fromage: Fromage = 'cheese'
  })
})
</file>

<file path="test/fixtures/basic-types/app/app.config.ts">
export default defineAppConfig({
  userConfig: 123,
  nested: {
    val: 2,
  },
})
</file>

<file path="test/fixtures/basic-types/extends/bar/layouts/override.vue">
<template>
  <div>
    <div>Extended layout from bar</div>
    <NuxtPage />
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/extends/bar/middleware/override.ts">
export default defineNuxtRouteMiddleware((to) => {
  to.meta.override = 'Injected by extended middleware from bar'
})
</file>

<file path="test/fixtures/basic-types/extends/bar/pages/override.vue">
<script setup>
definePageMeta({
  layout: 'override',
  middleware: 'override',
})
</script>

<template>
  <div>
    <div>Extended page from bar</div>
    <div>Middleware | override: {{ $route.meta.override }}</div>
    <ExtendsOverride />
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/extends/bar/app.config.ts">
export default {
  fromLayer: true,
}
</file>

<file path="test/fixtures/basic-types/extends/bar/index.d.ts">
declare module 'bing' {
  interface BingInterface {
    foo: 'bar'
  }
}
</file>

<file path="test/fixtures/basic-types/extends/bar/nuxt.config.ts">
export default defineNuxtConfig({})
</file>

<file path="test/fixtures/basic-types/modules/auto-registered/runtime/handler.ts">
export default defineEventHandler(() => 'handler added by auto-registered module')
</file>

<file path="test/fixtures/basic-types/modules/auto-registered/index.ts">
import { addServerHandler, createResolver, defineNuxtModule } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'auto-registered-module',
  },
  setup () {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      handler: resolver.resolve('./runtime/handler'),
      route: '/auto-registered-module',
    })
  },
})
</file>

<file path="test/fixtures/basic-types/modules/runtime/middleware.ts">
export default defineNuxtRouteMiddleware(async () => {
  await new Promise(resolve => setTimeout(resolve, 1))
  useNuxtApp()
})
</file>

<file path="test/fixtures/basic-types/modules/runtime/page.vue">
<!-- eslint-disable vue/multi-word-component-names -->

<script setup lang="ts">
import { setResponseHeader } from 'h3'

definePageMeta({
  value: 'added in pages:extend',
})

if (import.meta.server) {
  setResponseHeader(useRequestEvent()!, 'x-extend', useRoute().meta.value as string)
}
</script>

<template>
  <div>
    added in pages:extend
  </div>
</template>
</file>

<file path="test/fixtures/basic-types/modules/runtime/plugin.ts">
export default defineNuxtPlugin(async () => {
  await new Promise(resolve => setTimeout(resolve, 1))
  useNuxtApp()
})
</file>

<file path="test/fixtures/basic-types/modules/test/index.ts">
import { defineNuxtModule } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'test',
  },
})
</file>

<file path="test/fixtures/basic-types/modules/example.ts">
import { addPlugin, createResolver, defineNuxtModule, useNuxt } from 'nuxt/kit'

export default defineNuxtModule({
  defaults: {
    enabled: true,
    typeTest: (value: boolean) => typeof value === 'boolean',
  },
  meta: {
    name: 'my-module',
    configKey: 'sampleModule',
  },
  setup () {
    const resolver = createResolver(import.meta.url)

    addPlugin(resolver.resolve('./runtime/plugin'))
    useNuxt().hook('app:resolve', (app) => {
      app.middleware.push({
        name: 'unctx-test',
        path: resolver.resolve('./runtime/middleware'),
      })
    })
  },
})
</file>

<file path="test/fixtures/basic-types/modules/page-extend.ts">
import { createResolver, defineNuxtModule, useNuxt } from 'nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'page-extend',
  },
  setup () {
    const nuxt = useNuxt()
    const resolver = createResolver(import.meta.url)

    nuxt.hook('pages:extend', (pages) => {
      pages.push({
        name: 'page-extend',
        path: '/page-extend',
        file: resolver.resolve('./runtime/page.vue'),
      })
    })
  },
})
</file>

<file path="test/fixtures/basic-types/server/api/hey/index.get.ts">
export default defineEventHandler(() => ({
  foo: 'bar',
  baz: 'qux',
}))
</file>

<file path="test/fixtures/basic-types/server/api/hey/index.post.ts">
export default defineEventHandler(() => ({
  method: 'post' as const,
}))
</file>

<file path="test/fixtures/basic-types/server/api/hello.ts">
export default defineEventHandler(() => 'Hello API')
</file>

<file path="test/fixtures/basic-types/server/api/union.ts">
export default defineEventHandler(() => ({
  type: 'a',
  foo: 'bar',
}) as { type: 'a', foo: string } | { type: 'b', baz: string })
</file>

<file path="test/fixtures/basic-types/server/type-context.ts">
// @ts-expect-error Fromage is 'cheese'
const _fake: Fromage = 'babybel'

const _fromage: Fromage = 'cheese'
</file>

<file path="test/fixtures/basic-types/shared/utils/test.ts">
export const useSharedUtil = () => 'foo'
</file>

<file path="test/fixtures/basic-types/shared/other.ts">
export const foo = 'bar'
</file>

<file path="test/fixtures/basic-types/shared/shared-types.ts">
import { describe, expectTypeOf, it } from 'vitest'

import { foo } from '#shared/other'

describe('shared folder', () => {
  it('can reference its own aliases', () => {
    expectTypeOf(foo).not.toBeAny()
    expectTypeOf(foo).toEqualTypeOf<string>()
  })

  it('can reference auto-imported utils', () => {
    expectTypeOf(useSharedUtil()).toEqualTypeOf<string>()
  })
})
</file>

<file path="test/fixtures/basic-types/.gitignore">
!extends/node_modules
</file>

<file path="test/fixtures/basic-types/config-types.ts">
import { describe, expectTypeOf, it } from 'vitest'

import type { AppConfig, RuntimeValue, UpperSnakeCase } from 'nuxt/schema'
import { defineNuxtModule } from 'nuxt/kit'
import { defineNuxtConfig } from 'nuxt/config'

describe('modules', () => {
  it('augments schema automatically', () => {
    defineNuxtConfig({ sampleModule: { enabled: false } })
    // @ts-expect-error we want to ensure we throw type error on invalid option
    defineNuxtConfig({ sampleModule: { other: false } })
    // @ts-expect-error we want to ensure we throw type error on invalid key
    defineNuxtConfig({ undeclaredKey: { other: false } })
  })

  it('preserves options in defineNuxtModule setup without `.with()`', () => {
    defineNuxtModule<{ foo?: string, baz: number }>({
      defaults: {
        baz: 100,
      },
      setup: (resolvedOptions) => {
        expectTypeOf(resolvedOptions).toEqualTypeOf<{ foo?: string, baz: number }>()
      },
    })
  })

  it('correctly typed resolved options in defineNuxtModule setup using `.with()`', () => {
    defineNuxtModule<{
      foo?: string
      baz: number
    }>().with({
      defaults: {
        foo: 'bar',
      },
      setup: (resolvedOptions) => {
        expectTypeOf(resolvedOptions).toEqualTypeOf<{
          foo: string
          baz?: number | undefined
        }>()
      },
    })
  })

  it('correctly types moduleDependencies', () => {
    defineNuxtModule({
      moduleDependencies: {
        'unknown': {
          overrides: {
            foo: 'bar',
          },
        },
        '@nuxt/devtools': {
          defaults: {
            enabled: true,
            // @ts-expect-error not a valid option
            foo: 'bar',
          },
        },
      },
    })
  })
})

describe('runtimeConfig', () => {
  it('provides hints on overriding these values', () => {
    const val = defineNuxtConfig({
      runtimeConfig: {
        public: {
          // @ts-expect-error this should be a number
          testConfig: 'test',
          ids: [1, 2],
        },
      },
    })
    expectTypeOf(val.runtimeConfig!.public!.testConfig).toEqualTypeOf<undefined | RuntimeValue<number, 'You can override this value at runtime with NUXT_PUBLIC_TEST_CONFIG'>>()
    expectTypeOf(val.runtimeConfig!.privateConfig).toEqualTypeOf<undefined | RuntimeValue<string, 'You can override this value at runtime with NUXT_PRIVATE_CONFIG'>>()
    expectTypeOf(val.runtimeConfig!.baseURL).toEqualTypeOf<undefined | RuntimeValue<string, 'You can override this value at runtime with NUXT_BASE_URL'>>()
    expectTypeOf(val.runtimeConfig!.baseAPIToken).toEqualTypeOf<undefined | RuntimeValue<string, 'You can override this value at runtime with NUXT_BASE_API_TOKEN'>>()
    expectTypeOf(val.runtimeConfig!.public!.ids).toEqualTypeOf<undefined | RuntimeValue<(1 | 2 | 3)[], 'You can override this value at runtime with NUXT_PUBLIC_IDS'>>()
    expectTypeOf(val.runtimeConfig!.unknown).toEqualTypeOf<unknown>()
  })

  it('correctly converts different kinds of names to snake case', () => {
    expectTypeOf<UpperSnakeCase<'testAppName'>>().toEqualTypeOf<'TEST_APP_NAME'>()
    expectTypeOf<UpperSnakeCase<'TEST_APP_NAME'>>().toEqualTypeOf<'TEST_APP_NAME'>()
    expectTypeOf<UpperSnakeCase<'test_APP_NAME'>>().toEqualTypeOf<'TEST_APP_NAME'>()
    expectTypeOf<UpperSnakeCase<'test_app_NAME'>>().toEqualTypeOf<'TEST_APP_NAME'>()
    expectTypeOf<UpperSnakeCase<'testAppNAME'>>().toEqualTypeOf<'TEST_APP_NAME'>()
    expectTypeOf<UpperSnakeCase<'testApp123NAME'>>().toEqualTypeOf<'TEST_APP123NAME'>()
    expectTypeOf<UpperSnakeCase<'testAPPName'>>().toEqualTypeOf<'TEST_APP_NAME'>()
    expectTypeOf<UpperSnakeCase<'testAPP_Name'>>().toEqualTypeOf<'TEST_APP_NAME'>()
    expectTypeOf<UpperSnakeCase<'test_APP_Name'>>().toEqualTypeOf<'TEST_APP_NAME'>()
    expectTypeOf<UpperSnakeCase<'TESTAppName'>>().toEqualTypeOf<'TEST_APP_NAME'>()
    expectTypeOf<UpperSnakeCase<'t'>>().toEqualTypeOf<'T'>()
    expectTypeOf<UpperSnakeCase<'T'>>().toEqualTypeOf<'T'>()
  })
})

describe('head', () => {
  it('correctly types nuxt.config options', () => {
    // @ts-expect-error invalid head option
    defineNuxtConfig({ app: { head: { titleTemplate: () => 'test' } } })
    defineNuxtConfig({
      app: {
        head: {
          meta: [{ key: 'key', name: 'description', content: 'some description ' }],
          titleTemplate: 'test %s',
        },
      },
    })
  })
})

describe('app config', () => {
  it('merges app config as expected', () => {
    interface ExpectedMergedAppConfig {
      // eslint-disable-next-line @typescript-eslint/no-empty-object-type
      nuxt: {}
      fromLayer: boolean
      fromNuxtConfig: boolean
      nested: {
        val: number
      }
      userConfig: 123 | 456
      someThing?: {
        value?: string | false
      }
      [key: string]: unknown
    }
    expectTypeOf<AppConfig>().toEqualTypeOf<ExpectedMergedAppConfig>()
  })
})

describe('extends type declarations', () => {
  it('correctly adds references to tsconfig', () => {
    expectTypeOf<import('bing').BingInterface>().toEqualTypeOf<{ foo: 'bar' }>()
  })
})

describe('kit utilities', () => {
  it('addTypeTemplate', () => {
    // @ts-expect-error Fromage is 'cheese'
    const _fake: Fromage = 'babybel'

    const _fromage: Fromage = 'cheese'
  })
})
</file>

<file path="test/fixtures/basic-types/index.d.ts">
declare module 'nuxt/schema' {
  interface PublicRuntimeConfig {
    ids: (1 | 2 | 3)[]
  }
}

export {}
</file>

<file path="test/fixtures/basic-types/nuxt.config.ts">
/// <reference path="./config-types.ts" />

import { addTypeTemplate, installModule } from 'nuxt/kit'
import { typescriptBundlerResolution, withMatrix } from '../../matrix'

export default withMatrix({
  extends: [
    './extends/node_modules/foo',
  ],
  theme: './extends/bar',
  modules: [
    function () {
      addTypeTemplate({
        filename: 'test.d.ts',
        getContents: () => 'declare type Fromage = "cheese"',
      }, { nuxt: true, nitro: true, node: true })
      function _test () {
        installModule('~~/modules/example', {
          typeTest (val) {
            // @ts-expect-error module type defines val as boolean
            const b: string = val
            return !!b
          },
        })
      }
    },
    './modules/test',
    [
      '~~/modules/example',
      {
        typeTest (val) {
          // @ts-expect-error module type defines val as boolean
          const b: string = val
          return !!b
        },
      },
    ],
    function (_options, nuxt) {
      nuxt.hook('pages:extend', (pages) => {
        pages.push({
          name: 'internal-async-parent',
          path: '/internal-async-parent',
        })
      })
    },
  ],
  app: {
    head: {
      // @ts-expect-error Promises are not allowed
      title: Promise.resolve('Nuxt Fixture'),
      // @ts-expect-error Functions are not allowed
      titleTemplate: title => 'test',
      meta: [
        {
          // Allows unknown property
          property: 'og:thing',
          content: '1234567890',
        },
      ],
    },
    pageTransition: {
      // @ts-expect-error Functions are not allowed
      onBeforeEnter: el => console.log(el),
    },
  },
  appConfig: {
    fromNuxtConfig: true,
    nested: {
      val: 1,
    },
  },
  runtimeConfig: {
    baseURL: '',
    baseAPIToken: '',
    privateConfig: 'secret_key',
    public: {
      ids: [1, 2, 3],
      needsFallback: undefined,
      testConfig: 123,
    },
  },
  routeRules: {
    '/param': {
      redirect: '/param/1',
    },
    '/layout': {
      appLayout: 'custom',
    },
  },
  future: {
    typescriptBundlerResolution,
  },
  experimental: {
    typedPages: true,
    appManifest: true,
  },
  telemetry: false, // for testing telemetry types - it is auto-disabled in tests
  hooks: {
    'schema:extend' (schemas) {
      schemas.push({
        appConfig: {
          someThing: {
            value: {
              $default: 'default',
              $schema: {
                tsType: 'string | false',
              },
            },
          },
        },
      })
    },
    'prepare:types' ({ tsConfig }) {
      tsConfig.include = tsConfig.include!.filter(i => i !== '../../../../**/*')
    },
  },
})
</file>

<file path="test/fixtures/basic-types/nuxt.schema.ts">
export default defineNuxtSchema({
  appConfig: {
    /**
     * This is an example app config defined in custom schema
     * @type {123 | 456}
     */
    userConfig: 123,
  },
})
</file>

<file path="test/fixtures/basic-types/package.json">
{
  "private": true,
  "name": "fixture-basic-types",
  "scripts": {
    "build": "nuxt build",
    "test:types": "nuxt prepare && npx vue-tsc -b --noEmit"
  },
  "dependencies": {
    "nuxt": "workspace:*"
  },
  "devDependencies": {
    "ofetch": "latest",
    "unplugin-vue-router": "latest",
    "vitest": "latest",
    "vue": "latest",
    "vue-router": "latest"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="test/fixtures/basic-types/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="test/fixtures/hmr/app/components/example/test.vue">
<template>
  <div data-testid="example">
    test.vue
  </div>
</template>
</file>

<file path="test/fixtures/hmr/app/components/islands/HmrComponent.vue">
<script lang="ts" setup>
const hmrId = ref(0)
</script>

<template>
  <div>
    HMR ID:
    <span data-testid="hmr-id">{{ hmrId }}</span>
  </div>
</template>
</file>

<file path="test/fixtures/hmr/app/pages/issues/32177.vue">
<template>
  <pre data-testid="contents">{{ elements }}</pre>
</template>

<script setup>
// #HMR_REPLACE
const { data: elements } = await useAsyncData(() => ['Element 1', 'Element 2'].join(', '))
</script>
</file>

<file path="test/fixtures/hmr/app/pages/routes/index.vue">
<template>
  <div>
    <NuxtLink to="/routes/non-existent">
      To non-existent link
    </NuxtLink>
  </div>
</template>
</file>

<file path="test/fixtures/hmr/app/pages/index.vue">
<script setup lang="ts">
definePageMeta({
  some: 'stuff',
})
const count = ref(1)
</script>

<template>
  <div>
    <Title>HMR fixture</Title>
    <h1>Home page</h1>
    <div>
      Count:
      <span data-testid="count">{{ count }}</span>
    </div>
    <button @click="count++">
      Increment
    </button>
    <pre>{{ $route.meta }}</pre>
  </div>
</template>
</file>

<file path="test/fixtures/hmr/app/pages/page-meta.vue">
<script setup lang="ts">
definePageMeta({
  some: 'stuff',
})
</script>

<template>
  <div>
    <pre data-testid="meta">{{ $route.meta }}</pre>
  </div>
</template>
</file>

<file path="test/fixtures/hmr/app/pages/rename-component.vue">
<template>
  <ExampleTest />
</template>
</file>

<file path="test/fixtures/hmr/app/pages/route-rules.vue">
<script setup lang="ts">
defineRouteRules({
  headers: {
    'x-extend': 'added in routeRules',
  },
})
</script>

<template>
  <div>
    Route rules defined inline
  </div>
</template>
</file>

<file path="test/fixtures/hmr/app/pages/server-component.vue">
<template>
  <div>
    <NuxtIsland name="HmrComponent" />
  </div>
</template>
</file>

<file path="test/fixtures/hmr/app/pages/state-component.vue">
<template>
  <button
    data-testid="button"
    @click="count++"
  >
    {{ count }}
  </button>
  <!--  #hmr-template -->
</template>

<script setup>
const count = ref(0)

// #hmr-script
</script>
</file>

<file path="test/fixtures/hmr/app/pages/top-level-await.vue">
<script setup lang="ts">
// Top-level await - triggers Suspense
const { data } = await useFetch('/api/slow')
console.log('page loaded')
</script>

<template>
  <div data-testid="content">
    {{ data?.message }}
  </div>
</template>
</file>

<file path="test/fixtures/hmr/server/api/slow.ts">
export default defineEventHandler(async () => {
  await new Promise(resolve => setTimeout(resolve, 500))
  return { message: 'loaded' }
})
</file>

<file path="test/fixtures/hmr/nuxt.config.ts">
import { withMatrix } from '../../matrix'

export default withMatrix({
  experimental: {
    inlineRouteRules: true,
  },
})
</file>

<file path="test/fixtures/hmr/package.json">
{
  "private": true,
  "name": "fixture-hmr",
  "scripts": {
    "build": "nuxt build"
  },
  "dependencies": {
    "nuxt": "workspace:*"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="test/fixtures/hmr/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="test/fixtures/minimal/app.vue">
<script setup lang="ts">
import { componentNames } from '#components'

// prevent treeshaking of #components import
defineExpose({ componentNames })

// @ts-expect-error this is not usable outside a pages directory
definePageMeta({
  // this should be fully tree-shaken out
  title: 'jet common fruit chose bright planning exercise herself position wealth stiff known prepare listen leader eleven found boat dollar eye come author won thought pony biggest feel organized die vast class ask cost ball wrong chicken origin model little properly dangerous dull corner jar mighty solution pilot city locate guide gradually affect curve about snake single silly against fireplace money another involved origin sport where thin stop question go stretch although arrow rush mixture fallen power pay fifteen layers play slightly heavy built needed sing sentence diagram quarter yesterday list faster been having construction curious shoe',
})
</script>

<template>
  <div>Hello World!</div>
</template>
</file>

<file path="test/fixtures/minimal/error.vue">
<template>
  <div>Error page</div>
</template>
</file>

<file path="test/fixtures/minimal/nuxt.config.ts">
import { readFileSync } from 'node:fs'
import { fileURLToPath } from 'node:url'

const testWithInlineVue = process.env.EXTERNAL_VUE === 'false'

const nuxtEntry = fileURLToPath(new URL('../../../packages/nuxt/dist/index.mjs', import.meta.url))
const isStubbed = readFileSync(nuxtEntry, 'utf-8').includes('const _module = await jiti')

export default defineNuxtConfig({
  $production: {
    vite: {
      $client: {
        build: {
          rollupOptions: {
            output: {
              chunkFileNames: '_nuxt/[name].js',
              entryFileNames: '_nuxt/[name].js',
            },
          },
        },
      },
    },
  },
  pages: false,
  buildDir: testWithInlineVue ? '.nuxt-inline' : '.nuxt',
  sourcemap: false,
  experimental: {
    externalVue: !testWithInlineVue,
  },
  compatibilityDate: 'latest',
  nitro: {
    output: { dir: fileURLToPath(new URL(testWithInlineVue ? './.output-inline' : './.output', import.meta.url)) },
  },
  typescript: {
    typeCheck: isStubbed ? false : 'build',
  },
})
</file>

<file path="test/fixtures/minimal/package.json">
{
  "private": true,
  "name": "fixture-minimal",
  "scripts": {
    "build": "nuxt build"
  },
  "dependencies": {
    "nuxt": "workspace:*"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="test/fixtures/minimal/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="test/fixtures/minimal-pages/app/layouts/default.vue">
<template>
  <slot />
</template>
</file>

<file path="test/fixtures/minimal-pages/app/middleware/test.global.ts">
export default defineNuxtRouteMiddleware(() => {})
</file>

<file path="test/fixtures/minimal-pages/app/pages/a.client.vue">
<template>
  <div>Client-only page</div>
</template>
</file>

<file path="test/fixtures/minimal-pages/app/pages/b.server.vue">
<template>
  <div>Server-only page</div>
</template>
</file>

<file path="test/fixtures/minimal-pages/app/pages/index.vue">
<template>
  <div>Hello World!</div>
</template>
</file>

<file path="test/fixtures/minimal-pages/app/plugins/test.ts">
export default defineNuxtPlugin(() => {})
</file>

<file path="test/fixtures/minimal-pages/app/app.vue">
<template>
  <NuxtLayout><NuxtPage /></NuxtLayout>
</template>
</file>

<file path="test/fixtures/minimal-pages/app/error.vue">
<template>
  <div>Error page</div>
</template>
</file>

<file path="test/fixtures/minimal-pages/nuxt.config.ts">
import { readFileSync } from 'node:fs'
import { fileURLToPath } from 'node:url'

const nuxtEntry = fileURLToPath(new URL('../../../packages/nuxt/dist/index.mjs', import.meta.url))
const isStubbed = readFileSync(nuxtEntry, 'utf-8').includes('const _module = await jiti')

export default defineNuxtConfig({
  $production: {
    vite: {
      $client: {
        build: {
          rollupOptions: {
            output: {
              chunkFileNames: '_nuxt/[name].js',
              entryFileNames: '_nuxt/[name].js',
            },
          },
        },
      },
    },
  },
  sourcemap: false,
  compatibilityDate: 'latest',
  typescript: {
    typeCheck: isStubbed ? false : 'build',
  },
})
</file>

<file path="test/fixtures/minimal-pages/package.json">
{
  "private": true,
  "name": "fixture-minimal-pages",
  "scripts": {
    "build": "nuxt build"
  },
  "dependencies": {
    "nuxt": "workspace:*"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="test/fixtures/minimal-pages/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="test/fixtures/minimal-types/app-types.ts">
import { describe, expectTypeOf, it } from 'vitest'

describe('routing utilities', () => {
  it('allows using route composables', () => {
    const router = useRouter()
    router.push('/test')

    expectTypeOf(useRouter()).not.toBeAny()
    expectTypeOf(useRoute()).not.toBeAny()

    navigateTo('/thing')
  })
})

describe('auto-imports', () => {
  it('core composables', () => {
    ref()
    useHead({
      script: [],
      // @ts-expect-error Should show error on unknown properties
      unknown: [],
    })
  })
})

describe('config typings', () => {
  it('runtimeConfig', () => {
    const config = useRuntimeConfig()
    expectTypeOf(config.public).toEqualTypeOf<Record<string, unknown>>()
    expectTypeOf(config.app).toEqualTypeOf<{
      baseURL: string
      buildAssetsDir: string
      cdnURL: string
      [key: string]: any
    }>()
  })

  it('appConfig', () => {
    expectTypeOf(useAppConfig().foo).toEqualTypeOf<unknown>()
    expectTypeOf(useAppConfig()).toEqualTypeOf<{
      // eslint-disable-next-line @typescript-eslint/no-empty-object-type
      nuxt: {}
      [key: string]: unknown
    }>()
  })
})
</file>

<file path="test/fixtures/minimal-types/app.vue">
<template>
  <div>Hello World!</div>
</template>

<script setup lang="ts">
import './app-types'
</script>
</file>

<file path="test/fixtures/minimal-types/nuxt.config.ts">
export default defineNuxtConfig({
  modules: [],
  routeRules: {
    // Should accept any string
    '/named': { appMiddleware: 'named' },
  },
  experimental: { appManifest: true },
  compatibilityDate: 'latest',
  // @ts-expect-error Should show error on unknown properties
  unknownProp: '',
})
</file>

<file path="test/fixtures/minimal-types/package.json">
{
  "private": true,
  "name": "fixture-minimal-types",
  "scripts": {
    "build": "nuxt build",
    "test:types": "nuxt prepare && npx vue-tsc -b --noEmit"
  },
  "dependencies": {
    "nuxt": "workspace:*"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="test/fixtures/minimal-types/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="test/fixtures/runtime-compiler/app/components/Helloworld.vue">
<script>
export default defineNuxtComponent({
  template: '<div>hello, Helloworld.vue here ! </div>',
})
</script>
</file>

<file path="test/fixtures/runtime-compiler/app/components/Name.ts">
export default defineNuxtComponent({
  props: ['template', 'name'],

  /**
   * most of the time, vue compiler need at least a VNode, use h() to render the component
   */
  render () {
    return h({
      props: ['name'],
      template: this.template,
    }, {
      name: this.name,
    })
  },
})
</file>

<file path="test/fixtures/runtime-compiler/app/components/ShowTemplate.vue">
<template>
  <component
    :is="showIt"
    :name="name"
  />
</template>

<script>
export default defineNuxtComponent({
  props: {
    template: {
      required: true,
      type: String,
    },
    name: {
      type: String,
      default: () => '(missing name prop)',
    },
  },
  setup (props) {
    const showIt = h({
      template: props.template,
      props: {

        name: {
          type: String,
          default: () => '(missing name prop)',
        },
      },
    })

    return {
      showIt,
    }
  },
})
</script>
</file>

<file path="test/fixtures/runtime-compiler/app/layouts/default.vue">
<template>
  <div>
    <header>
      <h1 data-testid="page-title">
        Nuxt Runtime Compiler Tests
      </h1>
      <nav>
        <ul>
          <li>
            <NuxtLink
              to="/"
              active-class="active"
            >
              Overview
            </NuxtLink>
          </li>
          <li>
            <NuxtLink
              to="/basic-component"
              active-class="active"
            >
              Basic Component
            </NuxtLink>
          </li>
          <li>
            <NuxtLink
              to="/component-in-setup"
              active-class="active"
            >
              Computed Template
            </NuxtLink>
          </li>
          <li>
            <NuxtLink
              to="/typescript-component"
              active-class="active"
            >
              TypeScript Component
            </NuxtLink>
          </li>
          <li>
            <NuxtLink
              to="/api-template"
              active-class="active"
            >
              API Template
            </NuxtLink>
          </li>
          <li>
            <NuxtLink
              to="/full-dynamic"
              active-class="active"
            >
              Full Dynamic Component
            </NuxtLink>
          </li>
        </ul>
      </nav>
    </header>

    <main>
      <slot />
    </main>

    <footer>
      <p>
        <small>These tests verify Vue's runtime compiler works correctly in Nuxt</small>
      </p>
    </footer>
  </div>
</template>

<style>
body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
  margin: 0;
  padding: 0;
  color: #222;
  background: #fafafa;
}

header {
  background-color: #00DC82;
  color: #003543;
  padding: 1rem;
  margin-bottom: 1.5rem;
}

h1 {
  margin-top: 0;
  margin-bottom: 1rem;
}

nav ul {
  display: flex;
  list-style: none;
  padding: 0;
  margin: 0;
  flex-wrap: wrap;
  gap: 0.5rem;
}

nav li a {
  display: block;
  padding: 0.5rem 1rem;
  text-decoration: none;
  color: #003543;
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  transition: all 0.2s ease;
}

nav li a:hover {
  background-color: rgba(255, 255, 255, 0.4);
}

nav li a.active {
  background-color: #003543;
  color: white;
}

main {
  max-width: 800px;
  margin: 0 auto;
  padding: 0 1rem 2rem;
}

.test-component {
  margin-bottom: 2rem;
  padding: 1.5rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.test-component h2 {
  margin-top: 0;
  color: #003543;
}

.test-description {
  padding: 0.75rem;
  background: #f0f9f6;
  border-left: 4px solid #00DC82;
  margin-bottom: 1.5rem;
}

.border {
  border: 1px solid burlywood;
  padding: 1rem;
  background: #fffaf0;
  border-radius: 4px;
}

button {
  background: #00DC82;
  color: #003543;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

button:hover {
  background: #00c476;
}

footer {
  text-align: center;
  padding: 1rem;
  color: #666;
  border-top: 1px solid #eee;
  margin-top: 2rem;
}
</style>
</file>

<file path="test/fixtures/runtime-compiler/app/pages/api-template.vue">
<script setup lang="ts">
/**
 * Test case: API Template Component
 *
 * This demonstrates using the runtime compiler with a template
 * fetched from an API endpoint.
 */
const { data, pending } = await useAsyncData('templateString', async () => {
  const templateString = await $fetch('/api/template')
  return { templateString }
})
</script>

<template>
  <div>
    <div class="test-component">
      <h2>API Template Test</h2>

      <div class="test-description">
        <p>
          This test demonstrates using the runtime compiler with a template string
          that is fetched from an API endpoint. This is useful when templates need to be
          dynamically loaded or managed outside the application.
        </p>
      </div>

      <div
        v-if="pending"
        class="loading"
      >
        Loading template from API...
      </div>

      <template v-else>
        <h3>Component Output:</h3>
        <div class="component-display">
          <show-template
            data-testid="show-template"
            :template="data!.templateString"
            name="John"
          />
        </div>

        <h3>API Response (Template):</h3>
        <pre class="api-response"><code>{{ data!.templateString }}</code></pre>

        <h3>Implementation:</h3>
        <pre><code>
// ShowTemplate.vue
export default defineNuxtComponent({
  props: {
    template: {
      required: true,
      type: String,
    },
    name: {
      type: String,
      default: () => '(missing name prop)',
    },
  },
  setup (props) {
    const showIt = h({
      template: props.template,
      props: {
        name: {
          type: String,
          default: () => '(missing name prop)',
        },
      },
    })
    return {
      showIt,
    }
  },
})

// API Endpoint (server/api/template.get.ts)
export default defineEventHandler(() => {
  return '&lt;div data-testid="template-content"&gt;Hello my name is : {\{ name }}, i am defined by ShowTemplate.vue and my template is retrieved from the API&lt;/div&gt;'
})
        </code></pre>
      </template>
    </div>
  </div>
</template>

<style scoped>
.component-display {
  padding: 1.5rem;
  background-color: #f8f9fa;
  border-radius: 6px;
  margin-bottom: 1.5rem;
  border: 1px solid #e9ecef;
}

.loading {
  text-align: center;
  padding: 2rem;
  color: #6c757d;
  font-style: italic;
}

.api-response {
  background-color: #e9f5ff;
  color: #0366d6;
  padding: 1rem;
  border-radius: 6px;
  overflow-x: auto;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
  font-size: 0.9rem;
  margin-bottom: 1.5rem;
  white-space: pre-wrap;
  word-break: break-word;
}

pre {
  background-color: #2d2d2d;
  color: #f8f8f2;
  padding: 1rem;
  border-radius: 6px;
  overflow-x: auto;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
  font-size: 0.9rem;
  line-height: 1.5;
  white-space: pre-wrap;
}

code {
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
}
</style>
</file>

<file path="test/fixtures/runtime-compiler/app/pages/basic-component.vue">
<script setup lang="ts">
/**
 * Test case: Basic Component
 *
 * This demonstrates using a basic component with a template string
 * via defineNuxtComponent.
 */
import HelloWorld from '../components/Helloworld.vue'
</script>

<template>
  <div>
    <div class="test-component">
      <h2>Basic Component Test</h2>

      <div class="test-description">
        <p>
          This test demonstrates rendering a basic Vue component with a template string
          using <code>defineNuxtComponent</code>. The template is defined directly in the
          component file without requiring separate compilation.
        </p>
      </div>

      <h3>Component Output:</h3>
      <div class="component-display">
        <HelloWorld data-testid="hello-world" />
      </div>

      <h3>Implementation:</h3>
      <pre><code>
// Helloworld.vue
export default defineNuxtComponent({
  template: '&lt;div&gt;hello, Helloworld.vue here ! &lt;/div&gt;',
})
      </code></pre>
    </div>
  </div>
</template>

<style scoped>
.component-display {
  padding: 1.5rem;
  background-color: #f8f9fa;
  border-radius: 6px;
  margin-bottom: 1.5rem;
  border: 1px solid #e9ecef;
}

pre {
  background-color: #2d2d2d;
  color: #f8f8f2;
  padding: 1rem;
  border-radius: 6px;
  overflow-x: auto;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
  font-size: 0.9rem;
  line-height: 1.5;
}

code {
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
}
</style>
</file>

<file path="test/fixtures/runtime-compiler/app/pages/component-in-setup.vue">
<script setup lang="ts">
/**
 * Test case: Component defined in setup with computed template
 *
 * This demonstrates defining a component with a computed template string
 * that updates reactively when state changes.
 */
const count = ref(0)

// Component with a computed template that updates when count changes
const ComponentDefinedInSetup = computed(() => defineComponent({
  template: `
<div class="border">
    <div>hello i am defined in the setup of app.vue</div>
    <div>This component template is in a computed refreshed on count</div>
    count: <span data-testid="computed-count">${count.value}</span>.
    I don't recommend doing this for performance reasons; prefer passing props for mutable data.
</div>`,
}))
</script>

<template>
  <div>
    <div class="test-component">
      <h2>Computed Template Test</h2>

      <div class="test-description">
        <p>
          This test demonstrates creating a component in setup with a computed template
          that reacts to state changes. When the count changes, the component template
          is regenerated with the new value.
        </p>
      </div>

      <h3>Component Output:</h3>
      <div class="component-display">
        <ComponentDefinedInSetup data-testid="component-defined-in-setup" />
      </div>

      <div class="controls">
        <button
          data-testid="increment-count"
          @click="count++"
        >
          Increment Count: {{ count }}
        </button>
      </div>

      <h3>Implementation:</h3>
      <pre><code>
const count = ref(0)

// Component with a computed template that updates when count changes
const ComponentDefinedInSetup = computed(() => defineComponent({
  template: `
&lt;div class="border"&gt;
    &lt;div&gt;hello i am defined in the setup of app.vue&lt;/div&gt;
    &lt;div&gt;This component template is in a computed refreshed on count&lt;/div&gt;
    count: &lt;span data-testid="computed-count"&gt;${count.value}&lt;/span&gt;.
    I don't recommend doing this for performance reasons; prefer passing props for mutable data.
&lt;/div&gt;`,
}))
      </code></pre>
    </div>
  </div>
</template>

<style scoped>
.component-display {
  padding: 1.5rem;
  background-color: #f8f9fa;
  border-radius: 6px;
  margin-bottom: 1.5rem;
  border: 1px solid #e9ecef;
}

.controls {
  margin-bottom: 1.5rem;
}

pre {
  background-color: #2d2d2d;
  color: #f8f8f2;
  padding: 1rem;
  border-radius: 6px;
  overflow-x: auto;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
  font-size: 0.9rem;
  line-height: 1.5;
  white-space: pre-wrap;
}

code {
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
}
</style>
</file>

<file path="test/fixtures/runtime-compiler/app/pages/full-dynamic.vue">
<script setup lang="ts">
/**
 * Test case: Full Dynamic Component
 *
 * This demonstrates using the runtime compiler with both template and script
 * fetched from an API endpoint, creating a fully dynamic component.
 */
const { data, pending } = await useAsyncData('interactiveComponent', async () => {
  const interactiveComponent = await $fetch('/api/full-component')
  return { interactiveComponent }
})

const Interactive = defineComponent({
  props: data.value?.interactiveComponent.props,
  setup (props) {
    return new Function(
      'ref',
      'computed',
      'props',
      data.value?.interactiveComponent.setup ?? '',
    )(ref, computed, props)
  },
  template: data.value?.interactiveComponent.template,
})
</script>

<template>
  <div>
    <div class="test-component">
      <h2>Full Dynamic Component Test</h2>

      <div class="test-description">
        <p>
          This test demonstrates creating a fully dynamic component where both
          template and script logic are fetched from an API endpoint. This approach
          enables completely runtime-defined components with reactive behavior.
        </p>
      </div>

      <div
        v-if="pending"
        class="loading"
      >
        Loading component definition from API...
      </div>

      <template v-else>
        <h3>Component Output:</h3>
        <div class="component-display">
          <Interactive
            data-testid="interactive"
            lastname="Doe"
            firstname="John"
          />
        </div>

        <h3>API Response (Component Definition):</h3>
        <pre class="api-response"><code>{{ JSON.stringify(data!.interactiveComponent, null, 2) }}</code></pre>

        <div class="test-instructions">
          <h4>Interactive Test</h4>
          <p>
            Click the "click here" button in the component above to test reactivity.
            The counter should increment, demonstrating that the dynamic script is
            properly executed and reactive.
          </p>
        </div>

        <h3>Implementation:</h3>
        <pre><code>
// In your page/component
const { data } = await useAsyncData('interactiveComponent', async () => {
  const interactiveComponent = await $fetch('/api/full-component')
  return { interactiveComponent }
})

const Interactive = defineComponent({
  props: data.value?.interactiveComponent.props,
  setup(props) {
    return new Function(
      'ref',
      'computed',
      'props',
      data.value?.interactiveComponent.setup ?? '',
    )(ref, computed, props)
  },
  template: data.value?.interactiveComponent.template,
})

// API Endpoint (server/api/full-component.get.ts)
export default defineEventHandler(() => {
  return {
    props: ['lastname', 'firstname'],
    setup: `
      const fullName = computed(() => props.lastname + ' ' + props.firstname);
      const count = ref(0);
      return {fullName, count}
    `,
    template: '&lt;div&gt;my name is {\{ fullName }}, &lt;button data-testid="inc-interactive-count" @click="count++"&gt;click here&lt;/button&gt; count: &lt;span data-testid="interactive-count"&gt;{\{ count }}&lt;/span&gt;. I am defined by Interactive in the setup of App.vue. My full component definition is retrieved from the api &lt;/div&gt;',
  }
})
        </code></pre>

        <div class="note">
          <h4>Security Note</h4>
          <p>
            When using this approach in production, always sanitize templates and scripts
            from external sources. Using new Function() with untrusted content can lead to
            security vulnerabilities including code injection.
          </p>
        </div>
      </template>
    </div>
  </div>
</template>

<style scoped>
.component-display {
  padding: 1.5rem;
  background-color: #f8f9fa;
  border-radius: 6px;
  margin-bottom: 1.5rem;
  border: 1px solid #e9ecef;
}

.loading {
  text-align: center;
  padding: 2rem;
  color: #6c757d;
  font-style: italic;
}

.api-response {
  background-color: #e9f5ff;
  color: #0366d6;
  padding: 1rem;
  border-radius: 6px;
  overflow-x: auto;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
  font-size: 0.9rem;
  margin-bottom: 1.5rem;
}

.test-instructions {
  background-color: #f0f9ff;
  border-left: 4px solid #0ea5e9;
  padding: 0.75rem;
  margin-bottom: 1.5rem;
}

.test-instructions h4 {
  margin-top: 0;
  color: #0369a1;
  margin-bottom: 0.5rem;
}

.test-instructions p {
  margin: 0;
}

pre {
  background-color: #2d2d2d;
  color: #f8f8f2;
  padding: 1rem;
  border-radius: 6px;
  overflow-x: auto;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
  font-size: 0.9rem;
  line-height: 1.5;
  white-space: pre-wrap;
}

code {
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
}

.note {
  background-color: #fff1f2;
  border-left: 4px solid #f43f5e;
  padding: 0.75rem;
  margin-top: 1.5rem;
}

.note h4 {
  margin-top: 0;
  color: #be123c;
  margin-bottom: 0.5rem;
}

.note p {
  margin: 0;
}
</style>
</file>

<file path="test/fixtures/runtime-compiler/app/pages/index.vue">
<script setup lang="ts">
/**
 * Overview page for the runtime compiler tests
 * Explains the purpose of each test case
 */
</script>

<template>
  <div>
    <div class="test-component">
      <h2>Welcome to the Nuxt Runtime Compiler Test Suite</h2>

      <div class="test-description">
        <p>This test suite verifies that Vue's Runtime Compiler works correctly within Nuxt, testing various ways of using runtime-compiled components.</p>
      </div>

      <h3>Test Cases</h3>

      <ul class="test-case-list">
        <li>
          <strong>Basic Component</strong>
          <p>Tests a basic Vue component with a template string using defineNuxtComponent.</p>
        </li>

        <li>
          <strong>Computed Template</strong>
          <p>Tests a component defined in setup with a computed template string that updates reactively.</p>
        </li>

        <li>
          <strong>TypeScript Component</strong>
          <p>Tests a TypeScript component using runtime compiler with a render function.</p>
        </li>

        <li>
          <strong>API Template</strong>
          <p>Tests a component that loads its template from an API endpoint.</p>
        </li>

        <li>
          <strong>Full Dynamic Component</strong>
          <p>Tests a component with both template and setup script loaded from an API endpoint.</p>
        </li>
      </ul>

      <div class="note">
        <h4>For Developers</h4>
        <p>Each test case demonstrates a different use case of the runtime compiler. Feel free to use this as a reference for implementing your own runtime-compiled components.</p>
      </div>
    </div>
  </div>
</template>

<style scoped>
.test-case-list {
  margin: 1.5rem 0;
  padding-left: 1.5rem;
}

.test-case-list li {
  margin-bottom: 1rem;
}

.test-case-list strong {
  color: #00947e;
}

.test-case-list p {
  margin: 0.25rem 0 0;
}

.note {
  background-color: #fffde7;
  border-left: 4px solid #ffd54f;
  padding: 0.75rem;
  margin-top: 2rem;
}

.note h4 {
  margin-top: 0;
  color: #f57c00;
}

.note p {
  margin-bottom: 0;
}
</style>
</file>

<file path="test/fixtures/runtime-compiler/app/pages/typescript-component.vue">
<script setup lang="ts">
/**
 * Test case: TypeScript Component
 *
 * This demonstrates using the runtime compiler with a TypeScript component
 * that uses a render function approach.
 */
</script>

<template>
  <div>
    <div class="test-component">
      <h2>TypeScript Component Test</h2>

      <div class="test-description">
        <p>
          This test demonstrates using the runtime compiler with a TypeScript component
          that defines a template as a prop and renders it using a render function.
        </p>
      </div>

      <h3>Component Output:</h3>
      <div class="component-display">
        <Name
          data-testid="name"
          template="<div>I am the Name.ts component</div>"
        />
      </div>

      <h3>Implementation:</h3>
      <pre><code>
// Name.ts
export default defineNuxtComponent({
  props: ['template', 'name'],
  /**
   * Most of the time, Vue compiler needs at least a VNode, use h() to render the component
   */
  render () {
    return h({
      props: ['name'],
      template: this.template,
    }, {
      name: this.name,
    })
  },
})
      </code></pre>

      <div class="note">
        <h4>Note</h4>
        <p>
          This approach is useful when you need to create components programmatically
          in TypeScript with strong type checking and don't want to use string templates directly.
        </p>
      </div>
    </div>
  </div>
</template>

<style scoped>
.component-display {
  padding: 1.5rem;
  background-color: #f8f9fa;
  border-radius: 6px;
  margin-bottom: 1.5rem;
  border: 1px solid #e9ecef;
}

pre {
  background-color: #2d2d2d;
  color: #f8f8f2;
  padding: 1rem;
  border-radius: 6px;
  overflow-x: auto;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
  font-size: 0.9rem;
  line-height: 1.5;
}

code {
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
}

.note {
  background-color: #fffde7;
  border-left: 4px solid #ffd54f;
  padding: 0.75rem;
  margin-top: 1.5rem;
}

.note h4 {
  margin-top: 0;
  color: #f57c00;
  margin-bottom: 0.5rem;
}

.note p {
  margin: 0;
}
</style>
</file>

<file path="test/fixtures/runtime-compiler/server/api/full-component.get.ts">
/**
 * sometimes, CMS wants to give full control on components. This might not be a good practice.
 * SO MAKE SURE TO SANITIZE ALL YOUR STRINGS
 */
export default defineEventHandler(() => {
  return {
    props: ['lastname', 'firstname'],
    // don't forget to sanitize
    setup: `
      const fullName = computed(() => props.lastname + ' ' + props.firstname);

      const count = ref(0);

      return {fullName, count}
    `,
    template: '<div>my name is {{ fullName }}, <button data-testid="inc-interactive-count" @click="count++">click here</button> count: <span data-testid="interactive-count">{{count}}</span>. I am defined by Interactive in the setup of App.vue. My full component definition is retrieved from the api </div>',
  }
})
</file>

<file path="test/fixtures/runtime-compiler/server/api/template.get.ts">
/**
 * mock the behavior of nuxt retrieving data from an api
 */

export default defineEventHandler(() => {
  return '<div>Hello my name is : {{name}}, i am defined by ShowTemplate.vue and my template is retrieved from the API</div>'
})
</file>

<file path="test/fixtures/runtime-compiler/.gitignore">
node_modules
*.log*
.nuxt
.nitro
.cache
.output
.env
dist
</file>

<file path="test/fixtures/runtime-compiler/nuxt.config.ts">
import { withMatrix } from '../../matrix'

// https://nuxt.com/docs/4.x/api/nuxt-config
export default withMatrix({
  vue: {
    runtimeCompiler: true,
  },
  experimental: {
    externalVue: false,
  },
})
</file>

<file path="test/fixtures/runtime-compiler/package.json">
{
  "private": true,
  "name": "fixture-runtime-compiler",
  "scripts": {
    "build": "nuxt build"
  },
  "dependencies": {
    "nuxt": "workspace:*"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="test/fixtures/runtime-compiler/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="test/fixtures/spa-loader/app/spa-loading-template.html">
<div data-testid="loader">loading...</div>
</file>

<file path="test/fixtures/spa-loader/app.vue">
<script setup lang="ts">
if (import.meta.client) {
  await new Promise<void>((resolve) => {
    document.addEventListener('finishHydration', () => resolve())
  })
}
</script>

<template>
  <div data-testid="content">
    app content
  </div>
</template>
</file>

<file path="test/fixtures/spa-loader/nuxt.config.ts">
import { withMatrix } from '../../matrix'

export default withMatrix({
  devtools: { enabled: false },
  spaLoadingTemplate: true,
  routeRules: {
    '/spa': { ssr: false },
    '/ssr': { ssr: true },
  },
  experimental: {
    spaLoadingTemplateLocation: 'within',
  },
})
</file>

<file path="test/fixtures/spa-loader/package.json">
{
  "name": "fixture-spa-loader",
  "private": true,
  "scripts": {
    "dev": "nuxt dev",
    "build": "nuxt build",
    "start": "nuxt preview"
  },
  "dependencies": {
    "nuxt": "workspace:*"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="test/fixtures/spa-loader/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="test/fixtures/suspense/pages/index.vue">
<script setup lang="ts">
/**
 * Test case: Suspense Multiple Navigation
 *
 * This demonstrates Nuxt's suspense functionality when
 * rapidly navigating between pages.
 */
async function trigger () {
  document.querySelector<HTMLButtonElement>('[data-testid="btn-a"]')!.click()
  await new Promise(resolve => setTimeout(resolve, 10))
  document.querySelector<HTMLButtonElement>('[data-testid="btn-b"]')!.click()
}
</script>

<template>
  <div class="test-component">
    <h2 data-testid="index-title">
      Suspense Multiple Navigation Test
    </h2>

    <div class="test-description">
      <p>
        This test verifies that Nuxt's suspense functionality works correctly when rapidly navigating
        between pages. It demonstrates that multiple rapid navigations don't cause errors or unexpected behavior.
      </p>
    </div>

    <h3>Navigation Actions:</h3>
    <div class="component-display">
      <div class="test-actions">
        <NuxtLink
          to="/target?id=a"
          data-testid="btn-a"
          class="test-button"
        >
          Target A
        </NuxtLink>
        <NuxtLink
          to="/target?id=b"
          data-testid="btn-b"
          class="test-button"
        >
          Target B
        </NuxtLink>
      </div>
    </div>

    <button @click="trigger">
      Trigger (for manual testing)
    </button>

    <div class="test-description">
      <h4>Test Instructions</h4>
      <p>
        Click both buttons in rapid succession to verify that suspense handles
        multiple navigations correctly. The final content should reflect the last
        navigation (Target B).
      </p>
    </div>
  </div>
</template>
</file>

<file path="test/fixtures/suspense/pages/target.vue">
<script setup lang="ts">
/**
 * Target page for suspense navigation test
 */
const route = useRoute()
const id = computed(() => route.query.id || 'default')

// Simulate async data loading
await new Promise(resolve => setTimeout(resolve, 100))
</script>

<template>
  <div class="test-component">
    <h2>Target Page</h2>

    <div class="test-description">
      <p>This page demonstrates async data loading with suspense.</p>
    </div>

    <h3>Component Output:</h3>
    <div class="component-display">
      <div
        data-testid="content"
        class="content-box"
      >
        Hello {{ id }}
      </div>

      <div class="test-actions">
        <NuxtLink
          to="/"
          class="test-button"
        >
          Back to Home
        </NuxtLink>
      </div>
    </div>
  </div>
</template>

<style scoped>
.content-box {
  text-align: center;
  font-size: 1.2rem;
  margin-bottom: 1.5rem;
  padding: 1rem;
  background-color: #f0f9f6;
  border-left: 4px solid #00DC82;
  border-radius: 4px;
}
</style>
</file>

<file path="test/fixtures/suspense/app.vue">
<template>
  <div>
    <NuxtPage />
  </div>
</template>

<style>
body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
  margin: 0;
  padding: 0;
  color: #003543;
  background: #fafafa;
}

.test-component {
  margin-bottom: 2rem;
  padding: 1.5rem;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.test-component h2 {
  margin-top: 0;
  color: #003543;
}

.test-description {
  padding: 0.75rem;
  background: #f0f9f6;
  border-left: 4px solid #00DC82;
  margin-bottom: 1.5rem;
}

.component-display {
  padding: 1.5rem;
  background-color: #f8f9fa;
  border-radius: 6px;
  margin-bottom: 1.5rem;
  border: 1px solid #e9ecef;
}

button, .test-button {
  background: #00DC82;
  color: #003543;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
  text-decoration: none;
  display: inline-block;
}

button:hover, .test-button:hover {
  background: #00c476;
}

.test-actions {
  display: flex;
  gap: 1rem;
  justify-content: center;
  margin-top: 1rem;
}
</style>
</file>

<file path="test/fixtures/suspense/nuxt.config.ts">
import { withMatrix } from '../../matrix'

export default withMatrix({})
</file>

<file path="test/fixtures/suspense/package.json">
{
  "private": true,
  "name": "fixture-suspense",
  "scripts": {
    "build": "nuxt build"
  },
  "dependencies": {
    "nuxt": "workspace:*"
  },
  "devDependencies": {
    "typescript": "latest"
  },
  "engines": {
    "node": "^20.19.0 || >=22.12.0"
  }
}
</file>

<file path="test/fixtures/suspense/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="test/mocks/app-config.ts">
export default {}
</file>

<file path="test/mocks/nuxt-config.ts">
export const nuxtLinkDefaults = {
  componentName: 'NuxtLink',
}
</file>

<file path="test/mocks/paths.ts">
import { joinURL } from 'ufo'

export const baseURL = () => '/'
export const buildAssetsURL = (url: string) => joinURL('/_nuxt', url)
</file>

<file path="test/mocks/router-options.ts">
export default {}
export const hashMode = false
</file>

<file path="test/nuxt/universal/router.test.ts">
import { describe, expect, it } from 'vitest'

describe('universal router', () => {
  it('should provide a route', () => {
    expect(useRoute()).toMatchObject({
      fullPath: '/',
      hash: '',
      matched: expect.arrayContaining([]),
      meta: {},
      params: {},
      path: '/',
      query: {},
      redirectedFrom: undefined,
    })
  })
})
</file>

<file path="test/nuxt/client-only.test.ts">
import { describe, expect, it } from 'vitest'
import type { ComponentOptions } from 'vue'
import { Suspense, defineComponent, h, toDisplayString, useAttrs } from 'vue'
import { mountSuspended } from '@nuxt/test-utils/runtime'
import { flushPromises, mount } from '@vue/test-utils'

import { createClientOnly } from '../../packages/nuxt/src/app/components/client-only'
import { createClientPage } from '../../packages/nuxt/dist/components/runtime/client-component'
import { ClientOnly } from '#components'

describe('client pages', () => {
  it('should render without a wrapper', async () => {
    const { resolve, wrapper } = createWrappedClientPage()
    expect(wrapper.html()).toMatchInlineSnapshot(`
      "<div>
        <div id="fallback">loading</div>
      </div>"
    `)
    resolve()
    await flushPromises()
    expect(wrapper.html()).toMatchInlineSnapshot(`
      "<div>
        <div id="async">async resolved</div>
      </div>"
    `)
  })

  it('createClient should retrieve attributes with useAttrs()', () => {
    const wrapper = mount(createClientOnly(Client as ComponentOptions), {
      attrs: {
        id: 'client',
      },
    })

    expect(wrapper.html()).toMatchInlineSnapshot(`
      "<div id="client">{
        "id": "client"
        }</div>"
    `)
  })

  it('should be suspensed when out of hydration', async () => {
    const { resolve, wrapper } = createWrappedClientPage()

    await flushPromises()
    expect(wrapper.find('#fallback').exists()).toBe(true)
    expect(wrapper.find('#async').exists()).toBe(false)

    resolve!()
    await flushPromises()
    expect(wrapper.find('#async').exists()).toBe(true)
    expect(wrapper.find('#fallback').exists()).toBe(false)
  })
})

describe('client-only', () => {
  it('should render its children', async () => {
    const component = defineComponent({
      setup () {
        return () => h(ClientOnly, {}, {
          default: () => h('div', {}, 'client-only'),
        })
      },
    })
    const wrapper = await mountSuspended(component)
    expect(wrapper.html()).toMatchInlineSnapshot(`"<div>client-only</div>"`)
  })

  it('should support inherited attributes', async () => {
    const component = defineComponent({
      setup () {
        return () => h(ClientOnly, { class: 'test', id: 'test' }, {
          default: () => h('div', {}, 'client-only'),
        })
      },
    })
    const wrapper = await mountSuspended(component)
    expect(wrapper.html()).toMatchInlineSnapshot(`"<div class="test" id="test">client-only</div>"`)
  })
})

describe('createClientOnly', () => {
  it('should not inherit attributes if disabled', async () => {
    const NonInherited = createClientOnly({
      inheritAttrs: false,
      setup: () => () => h('div', 'foo'),
    })
    const component = defineComponent({
      setup () {
        return () => h(NonInherited, { class: 'test', id: 'test' })
      },
    })
    const wrapper = await mountSuspended(component)
    expect(wrapper.html()).toMatchInlineSnapshot(`"<div>foo</div>"`)
  })
})

const Client = defineComponent({
  name: 'TestClient',
  setup () {
    const attrs = useAttrs()
    return () => h('div', {}, toDisplayString(attrs))
  },
})

function createWrappedClientPage () {
  let resolve: () => void
  const promise = new Promise<void>((_resolve) => {
    resolve = _resolve
  })

  const comp = defineComponent({
    async setup () {
      await promise
      return () => h('div', { id: 'async' }, 'async resolved')
    },
  })

  const ClientPage = defineAsyncComponent(() => createClientPage(() => Promise.resolve(comp)))

  const wrapper = mount({
    setup () {
      return () => h('div', {}, [
        h(Suspense, {}, {
          default: () => h(ClientPage, {}),
          fallback: () => h('div', { id: 'fallback' }, 'loading'),
        }),
      ])
    },
  })

  return { resolve: resolve!, wrapper }
}
</file>

<file path="test/nuxt/components.test.ts">
/// <reference path="../fixtures/basic/.nuxt/nuxt.d.ts" />

import { describe, expect, it, vi } from 'vitest'
import { mountSuspended } from '@nuxt/test-utils/runtime'

import { nuxtLinkDefaults } from '#build/nuxt.config.mjs'

describe('nuxt-link:prefetch', () => {
  it('should prefetch on visibility by default', async () => {
    const component = defineNuxtLink(nuxtLinkDefaults)

    const { observer } = useMockObserver()

    const nuxtApp = useNuxtApp()
    nuxtApp.hooks.callHook = vi.fn(() => Promise.resolve())

    await mountSuspended(component, { props: { to: '/to' } })

    expect(nuxtApp.hooks.callHook).not.toHaveBeenCalled()

    await observer.trigger()
    expect(nuxtApp.hooks.callHook).toHaveBeenCalledTimes(1)

    await observer.trigger()
    expect(nuxtApp.hooks.callHook).toHaveBeenCalledTimes(1)
  })

  it('should prefetch with custom string `prefetchOn`', async () => {
    const component = defineNuxtLink(nuxtLinkDefaults)
    const nuxtApp = useNuxtApp()
    nuxtApp.hooks.callHook = vi.fn(() => Promise.resolve())

    const { observer } = useMockObserver()
    const wrapper = await mountSuspended(component, { props: { to: '/to', prefetchOn: 'interaction' } })

    await observer.trigger()
    expect(nuxtApp.hooks.callHook).not.toHaveBeenCalled()

    await wrapper.find('a').trigger('focus')
    expect(nuxtApp.hooks.callHook).toHaveBeenCalledTimes(1)

    await wrapper.find('a').trigger('focus')
    expect(nuxtApp.hooks.callHook).toHaveBeenCalledTimes(1)

    await wrapper.find('a').trigger('pointerenter')
    expect(nuxtApp.hooks.callHook).toHaveBeenCalledTimes(1)
  })

  it('should prefetch with custom object `prefetchOn`', async () => {
    const component = defineNuxtLink(nuxtLinkDefaults)
    const nuxtApp = useNuxtApp()
    nuxtApp.hooks.callHook = vi.fn(() => Promise.resolve())

    const { observer } = useMockObserver()
    await mountSuspended(component, { props: { to: '/to', prefetchOn: { interaction: true } } })

    await observer.trigger()
    expect(nuxtApp.hooks.callHook).toHaveBeenCalled()
  })

  it('should prefetch with custom object `prefetchOn` overriding default', async () => {
    const component = defineNuxtLink(nuxtLinkDefaults)
    const nuxtApp = useNuxtApp()
    nuxtApp.hooks.callHook = vi.fn(() => Promise.resolve())

    const { observer } = useMockObserver()
    await mountSuspended(component, { props: { to: '/to', prefetchOn: { interaction: true, visibility: false } } })

    await observer.trigger()
    expect(nuxtApp.hooks.callHook).not.toHaveBeenCalled()
  })
})

function useMockObserver () {
  let callback: (entries: Array<{ target: HTMLElement, isIntersecting: boolean }>) => unknown
  let el: HTMLElement
  const mockObserver = class IntersectionObserver {
    el: HTMLElement
    constructor (_callback?: (entries: Array<{ target: HTMLElement, isIntersecting: boolean }>) => unknown) {
      callback ||= _callback
    }

    observe = (_el: HTMLElement) => { el = _el }

    trigger = () => callback?.([{ target: el, isIntersecting: true }])
    unobserve = () => {}
    disconnect = () => {}
  }

  window.IntersectionObserver = mockObserver as any

  const observer = new mockObserver()

  return { observer }
}
</file>

<file path="test/nuxt/composables.test.ts">
/// <reference path="../fixtures/basic/.nuxt/nuxt.d.ts" />

import { afterEach, describe, expect, it, vi } from 'vitest'
import { defineEventHandler } from 'h3'
import { destr } from 'destr'

import { mountSuspended, registerEndpoint } from '@nuxt/test-utils/runtime'

import { hasProtocol } from 'ufo'
import { createClientPage } from '../../packages/nuxt/src/components/runtime/client-component'
import * as composables from '#app/composables'

import { refreshNuxtData } from '#app/composables/asyncData'
import { clearError, createError, isNuxtError, showError, useError } from '#app/composables/error'
import { onNuxtReady } from '#app/composables/ready'
import { setResponseStatus, useRequestEvent, useRequestFetch, useRequestHeaders, useResponseHeader } from '#app/composables/ssr'
import { clearNuxtState, useState } from '#app/composables/state'
import { useRequestURL } from '#app/composables/url'
import { getAppManifest, getRouteRules } from '#app/composables/manifest'
import { callOnce } from '#app/composables/once'
import { useLoadingIndicator } from '#app/composables/loading-indicator'
import { useRouteAnnouncer } from '#app/composables/route-announcer'
import { encodeURL, resolveRouteObject } from '#app/composables/router'
import { useRuntimeHook } from '#app/composables/runtime-hook'

import { shouldLoadPayload } from '#app/composables/payload'
import { NuxtPage } from '#components'
import { isTestingAppManifest } from '../matrix'

registerEndpoint('/api/test', defineEventHandler(event => ({
  method: event.method,
  headers: Object.fromEntries(event.headers.entries()),
})))

describe('app config', () => {
  it('can be updated', () => {
    const appConfig = useAppConfig()
    expect(appConfig).toStrictEqual({ nuxt: {} })

    type UpdateAppConfig = Parameters<typeof updateAppConfig>[0]

    const initConfig: UpdateAppConfig = {
      new: 'value',
      nuxt: { nested: 42 },
      regExp: /foo/g,
      date: new Date(1111, 11, 11),
      arr: [1, 2, 3],
    }
    updateAppConfig(initConfig)
    expect(appConfig).toStrictEqual(initConfig)

    const newConfig: UpdateAppConfig = {
      nuxt: { anotherNested: 24 },
      regExp: /bar/g,
      date: new Date(2222, 12, 12),
      arr: [4, 5],
    }
    updateAppConfig(newConfig)
    expect(appConfig).toStrictEqual({
      ...initConfig,
      ...newConfig,
      nuxt: { ...initConfig.nuxt, ...newConfig.nuxt },
      arr: [4, 5, 3],
    })
  })
})

describe('composables', () => {
  it('are all tested', () => {
    const testedComposables: string[] = [
      'useRouteAnnouncer',
      'clearNuxtData',
      'refreshNuxtData',
      'useAsyncData',
      'useNuxtData',
      'createError',
      'isNuxtError',
      'clearError',
      'showError',
      'useError',
      'getAppManifest',
      'useHydration',
      'getRouteRules',
      'injectHead',
      'onNuxtReady',
      'callOnce',
      'setResponseStatus',
      'prerenderRoutes',
      'useRequestEvent',
      'useRequestFetch',
      'isPrerendered',
      'useRequestHeaders',
      'useResponseHeader',
      'useCookie',
      'clearNuxtState',
      'useState',
      'useRequestURL',
      'useRoute',
      'navigateTo',
      'abortNavigation',
      'setPageLayout',
      'defineNuxtComponent',
      'useRuntimeHook',
    ]
    const skippedComposables: string[] = [
      'addRouteMiddleware',
      'defineNuxtRouteMiddleware',
      'definePayloadReducer',
      'definePayloadReviver',
      'loadPayload',
      'onBeforeRouteLeave',
      'onBeforeRouteUpdate',
      'prefetchComponents',
      'preloadComponents',
      'preloadPayload',
      'preloadRouteComponents',
      'reloadNuxtApp',
      'refreshCookie',
      'onPrehydrate',
      'useId',
      'useFetch',
      'useHead',
      'useHeadSafe',
      'useLazyFetch',
      'useLazyAsyncData',
      'useRouter',
      'useSeoMeta',
      'useServerHead',
      'useServerHeadSafe',
      'useServerSeoMeta',
      'usePreviewMode',
    ]
    expect(Object.keys(composables).sort()).toEqual([...new Set([...testedComposables, ...skippedComposables])].sort())
  })
})

describe('errors', () => {
  it('createError', () => {
    expect(createError({ statusCode: 404 }).toJSON()).toMatchInlineSnapshot(`
      {
        "message": "",
        "statusCode": 404,
      }
    `)
    expect(createError('Message').toJSON()).toMatchInlineSnapshot(`
      {
        "message": "Message",
        "statusCode": 500,
      }
    `)
  })

  it('isNuxtError', () => {
    const error = createError({ statusCode: 404 })
    expect(isNuxtError(error)).toBe(true)
    expect(isNuxtError(new Error('test'))).toBe(false)
  })

  it('global nuxt errors', () => {
    const error = useError()
    expect(error.value).toBeUndefined()
    showError('new error')
    expect(error.value).toMatchInlineSnapshot('[Error: new error]')
    clearError()
    expect(error.value).toBe(undefined)
  })
})

describe('onNuxtReady', () => {
  it('should call callback once nuxt is hydrated', async () => {
    const fn = vi.fn()
    onNuxtReady(fn)
    await new Promise(resolve => setTimeout(resolve, 1))
    expect(fn).toHaveBeenCalled()
  })
})

describe('ssr composables', () => {
  it('work on client', () => {
    // @ts-expect-error This should work for backward compatibility
    expect(setResponseStatus()).toBeUndefined()
    expect(useRequestEvent()).toBeUndefined()
    expect(useRequestFetch()).toEqual($fetch)
    expect(useRequestHeaders()).toEqual({})
    expect(prerenderRoutes('/')).toBeUndefined()
    expect(useResponseHeader('x-test').value).toBeUndefined()
  })
})

describe('useHydration', () => {
  it('should hydrate value from payload', async () => {
    let val: any
    const nuxtApp = useNuxtApp()
    useHydration('key', () => {}, (fromPayload) => { val = fromPayload })
    await nuxtApp.hooks.callHook('app:created', nuxtApp.vueApp)
    expect(val).toMatchInlineSnapshot('undefined')

    nuxtApp.payload.key = 'from payload'
    await nuxtApp.hooks.callHook('app:created', nuxtApp.vueApp)
    expect(val).toMatchInlineSnapshot('"from payload"')
  })
})

describe('useState', () => {
  it('default', () => {
    expect(useState(() => 'default').value).toBe('default')
  })

  it('registers state in payload', () => {
    useState('key', () => 'value')
    expect(Object.entries(useNuxtApp().payload.state)).toContainEqual(['$skey', 'value'])
  })
})

describe('clearNuxtState', () => {
  it('clears state in payload for single key', () => {
    const key = 'clearNuxtState-test'
    const state = useState(key, () => 'test')
    expect(state.value).toBe('test')
    clearNuxtState(key)
    expect(state.value).toBeUndefined()
  })

  it('clears state in payload for array of keys', () => {
    const key1 = 'clearNuxtState-test'
    const key2 = 'clearNuxtState-test2'
    const state1 = useState(key1, () => 'test')
    const state2 = useState(key2, () => 'test')
    expect(state1.value).toBe('test')
    expect(state2.value).toBe('test')
    clearNuxtState([key1, 'other'])
    expect(state1.value).toBeUndefined()
    expect(state2.value).toBe('test')
    clearNuxtState([key1, key2])
    expect(state1.value).toBeUndefined()
    expect(state2.value).toBeUndefined()
  })

  it('clears state in payload for function', () => {
    const key = 'clearNuxtState-test'
    const state = useState(key, () => 'test')
    expect(state.value).toBe('test')
    clearNuxtState(() => false)
    expect(state.value).toBe('test')
    clearNuxtState(k => k === key)
    expect(state.value).toBeUndefined()
  })

  it('clears all state when no key is provided', () => {
    const state1 = useState('clearNuxtState-test', () => 'test')
    const state2 = useState('clearNuxtState-test2', () => 'test')
    expect(state1.value).toBe('test')
    expect(state2.value).toBe('test')
    clearNuxtState()
    expect(state1.value).toBeUndefined()
    expect(state2.value).toBeUndefined()
  })
})

describe('url', () => {
  it('useRequestURL', () => {
    const url = useRequestURL()
    expect(url).toMatchInlineSnapshot('"http://localhost:3000/"')
    expect(url.hostname).toMatchInlineSnapshot('"localhost"')
    expect(url.port).toMatchInlineSnapshot('"3000"')
    expect(url.protocol).toMatchInlineSnapshot('"http:"')
  })
})

describe('loading state', () => {
  it('expect loading state to be changed by hooks', async () => {
    vi.useFakeTimers()
    const nuxtApp = useNuxtApp()
    const { isLoading } = useLoadingIndicator()
    vi.advanceTimersToNextTimer()
    expect(isLoading.value).toBeFalsy()
    await nuxtApp.callHook('page:loading:start')
    vi.advanceTimersToNextTimer()
    expect(isLoading.value).toBeTruthy()

    await nuxtApp.callHook('page:loading:end')
    vi.advanceTimersToNextTimer()
    expect(isLoading.value).toBeFalsy()
    vi.useRealTimers()
  })
})

describe('loading state', () => {
  it('expect loading state to be changed by force starting/stoping', async () => {
    vi.useFakeTimers()
    const nuxtApp = useNuxtApp()
    const { isLoading, start, finish } = useLoadingIndicator()
    expect(isLoading.value).toBeFalsy()
    await nuxtApp.callHook('page:loading:start')
    vi.advanceTimersToNextTimer()
    expect(isLoading.value).toBeTruthy()
    start()
    expect(isLoading.value).toBeTruthy()
    finish()
    vi.advanceTimersToNextTimer()
    expect(isLoading.value).toBeFalsy()
    vi.useRealTimers()
  })
})

describe('loading state', () => {
  it('expect error from loading state to be changed by finish({ error: true })', async () => {
    vi.useFakeTimers()
    const nuxtApp = useNuxtApp()
    const { error, start, finish } = useLoadingIndicator()
    expect(error.value).toBeFalsy()
    await nuxtApp.callHook('page:loading:start')
    start()
    finish({ error: true })
    expect(error.value).toBeTruthy()
    start()
    expect(error.value).toBeFalsy()
    finish()
    vi.useRealTimers()
  })
})

describe('loading state', () => {
  it('expect state from set opts: { force: true }', async () => {
    vi.useFakeTimers()
    const nuxtApp = useNuxtApp()
    const { isLoading, start, finish, set } = useLoadingIndicator()
    await nuxtApp.callHook('page:loading:start')
    start({ force: true })
    expect(isLoading.value).toBeTruthy()
    finish()
    vi.advanceTimersToNextTimer()
    expect(isLoading.value).toBeFalsy()
    set(0, { force: true })
    expect(isLoading.value).toBeTruthy()
    set(100, { force: true })
    expect(isLoading.value).toBeFalsy()
    vi.useRealTimers()
  })
})

describe.skipIf(!isTestingAppManifest)('app manifests', () => {
  it('getAppManifest', async () => {
    const manifest = await getAppManifest()
    // @ts-expect-error timestamp is not optional
    delete manifest.timestamp
    expect(manifest).toMatchInlineSnapshot(`
      {
        "id": "test",
        "matcher": {
          "dynamic": {},
          "static": {
            "/pre/test": {
              "redirect": "/",
            },
            "/specific-prerendered": {
              "prerender": true,
            },
          },
          "wildcard": {
            "/pre": {
              "prerender": true,
            },
          },
        },
        "prerendered": [],
      }
    `)
  })
  it('getRouteRules', () => {
    expect(getRouteRules({ path: '/' })).toMatchInlineSnapshot('{}')
    expect(getRouteRules({ path: '/pre' })).toMatchInlineSnapshot(`
      {
        "prerender": true,
      }
    `)
    expect(getRouteRules({ path: '/pre/test' })).toMatchInlineSnapshot(`
      {
        "prerender": true,
        "redirect": "/",
      }
    `)
  })
})

describe('compiled route rules', () => {
  it('isPrerendered', async () => {
    expect(await isPrerendered('/specific-prerendered')).toBeTruthy()
    expect(await isPrerendered('/prerendered/test')).toBeFalsy()
    expect(await isPrerendered('/test')).toBeFalsy()
    expect(await isPrerendered('/pre/test')).toBeFalsy()
    expect(await isPrerendered('/pre/thing')).toBeTruthy()
  })

  it('should determine if payload should be loaded based on route rules', async () => {
    // wildcard routes with prerender: true should load payloads
    const shouldLoadPre = await shouldLoadPayload('/pre/thing')
    expect(shouldLoadPre).toBe(true)

    // specific prerendered routes should load payloads
    const shouldLoadSpecific = await shouldLoadPayload('/specific-prerendered')
    expect(shouldLoadSpecific).toBe(true)

    // routes with redirect should not load payloads
    const redirectRoute = getRouteRules({ path: '/pre/test' })
    expect(redirectRoute.redirect).toBe('/')
    const shouldLoadRedirect = await shouldLoadPayload('/pre/test')
    expect(shouldLoadRedirect).toBe(false)
  })
})

describe('useRuntimeHook', () => {
  it('types work', () => {
    // @ts-expect-error should not allow unknown hooks
    useRuntimeHook('test', () => {})
    useRuntimeHook('app:beforeMount', (_app) => {
      // @ts-expect-error argument should be typed
      _app = 'test'
    })
  })

  it('should call hooks', async () => {
    const nuxtApp = useNuxtApp()
    let called = 1
    const wrapper = await mountSuspended(defineNuxtComponent({
      setup () {
        useRuntimeHook('test-hook' as any, () => {
          called++
        })
      },
      render: () => h('div', 'hi there'),
    }))
    expect(called).toBe(1)
    await nuxtApp.callHook('test-hook' as any)
    expect(called).toBe(2)
    wrapper.unmount()
    await nuxtApp.callHook('test-hook' as any)
    expect(called).toBe(2)
  })
})

describe('routing utilities: `navigateTo`', () => {
  it('navigateTo should disallow navigation to external URLs by default', () => {
    expect(() => navigateTo('https://test.com')).toThrowErrorMatchingInlineSnapshot('[Error: Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.]')
    expect(() => navigateTo('https://test.com', { external: true })).not.toThrow()
  })
  it('navigateTo should disallow navigation to data/script URLs', () => {
    const urls = [
      ['data:alert("hi")', 'data'],
      ['\0data:alert("hi")', 'data'],
    ]
    for (const [url, protocol] of urls) {
      expect(() => navigateTo(url, { external: true })).toThrowError(`Cannot navigate to a URL with '${protocol}:' protocol.`)
    }
  })
  it('navigateTo should replace current navigation state if called within middleware', () => {
    const nuxtApp = useNuxtApp()
    nuxtApp._processingMiddleware = true
    expect(navigateTo('/')).toMatchInlineSnapshot(`"/"`)
    expect(navigateTo('/', { replace: true })).toMatchInlineSnapshot(`
      {
        "path": "/",
        "replace": true,
      }
    `)
    nuxtApp._processingMiddleware = false
  })
})

describe('routing utilities: `resolveRouteObject`', () => {
  it('resolveRouteObject should correctly resolve a route object', () => {
    expect(resolveRouteObject({ path: '/test' })).toMatchInlineSnapshot(`"/test"`)
    expect(resolveRouteObject({ path: '/test', hash: '#thing', query: { foo: 'bar' } })).toMatchInlineSnapshot(`"/test?foo=bar#thing"`)
  })
})

describe('routing utilities: `encodeURL`', () => {
  const encode = (url: string) => {
    const isExternal = hasProtocol(url, { acceptRelative: true })
    return encodeURL(url, isExternal)
  }
  it('encodeURL should correctly encode a URL', () => {
    expect(encode('https://test.com')).toMatchInlineSnapshot(`"https://test.com/"`)
    expect(encode('//test.com')).toMatchInlineSnapshot(`"//test.com/"`)
    expect(encode('mailto:daniel@cœur.com')).toMatchInlineSnapshot(`"mailto:daniel@c%C5%93ur.com"`)
    const encoded = encode('/cœur?redirected=' + encodeURIComponent('https://google.com'))
    expect(new URL('/cœur', 'http://localhost').pathname).toMatchInlineSnapshot(`"/c%C5%93ur"`)
    expect(encoded).toMatchInlineSnapshot(`"/c%C5%93ur?redirected=https%3A%2F%2Fgoogle.com"`)
    expect(useRouter().resolve(encoded).query.redirected).toMatchInlineSnapshot(`"https://google.com"`)
  })
})

describe('routing utilities: `useRoute`', () => {
  const nuxtApp = useNuxtApp()
  const router = useRouter()

  function waitForPageChange () {
    return new Promise<void>(resolve => nuxtApp.hooks.hookOnce('page:finish', () => resolve()))
  }

  afterEach(() => {
    router.clearRoutes()
  })

  it('should provide a route', () => {
    expect(useRoute()).toMatchObject({
      fullPath: '/',
      hash: '',
      matched: expect.arrayContaining([]),
      meta: {},
      name: 'catchall',
      params: {},
      path: '/',
      query: {},
      redirectedFrom: undefined,
    })
  })

  it('should sync route after child suspense resolves', async () => {
    router.addRoute({
      name: 'parent-test',
      path: '/parent',
      component: defineComponent({
        setup: () => () => h('div', ['parent', h(NuxtPage)]),
      }),
      children: [
        {
          name: 'parent',
          path: '',
          component: defineComponent({
            template: '<div> parent/index </div>',
          }),
        },
        {
          name: 'parent-suspense',
          path: 'suspense',
          component: defineComponent({
            template: '<div> parent/suspense </div>',
            setup: () => new Promise(resolve => setTimeout(resolve, 1)),
          }),
        },
      ],
    })

    const el = await mountSuspended({ setup: () => () => h(NuxtPage) })
    const route = useRoute()

    await navigateTo('/parent')
    await waitForPageChange()

    expect(el.html()).toContain('<div> parent/index </div>')
    expect(route.name).toBe('parent')

    await navigateTo('/parent/suspense')

    expect(el.html()).toContain('<div> parent/index </div>')
    expect(route.name).toBe('parent')

    await waitForPageChange()

    expect(el.html()).toContain('<div> parent/suspense </div>')
    expect(route.name).toBe('parent-suspense')

    el.unmount()
    router.removeRoute('parent-test')
  })
})

describe('routing utilities: `abortNavigation`', () => {
  it('should throw an error if one is provided', () => {
    const error = useError()
    expect(() => abortNavigation({ message: 'Page not found' })).toThrowErrorMatchingInlineSnapshot('[Error: Page not found]')
    expect(error.value).toBe(undefined)
  })
  it('should block navigation if no error is provided', () => {
    expect(abortNavigation()).toMatchInlineSnapshot('false')
  })
})

describe('routing utilities: `setPageLayout`', () => {
  it('should set layout on page metadata if run outside middleware', () => {
    const route = useRoute()
    expect(route.meta.layout).toBeUndefined()
    setPageLayout('custom')
    expect(route.meta.layout).toEqual('custom')
    route.meta.layout = undefined
  })

  it('should not set layout directly if run within middleware', () => {
    const route = useRoute()
    const nuxtApp = useNuxtApp()
    nuxtApp._processingMiddleware = true
    setPageLayout('custom')
    expect(route.meta.layout).toBeUndefined()
    nuxtApp._processingMiddleware = false
  })
})

describe('defineNuxtComponent', () => {
  it('should produce a Vue component', async () => {
    const wrapper = await mountSuspended(defineNuxtComponent({
      render: () => h('div', 'hi there'),
    }))
    expect(wrapper.html()).toMatchInlineSnapshot('"<div>hi there</div>"')
  })

  it('should support Options API asyncData', async () => {
    const nuxtApp = useNuxtApp()
    nuxtApp.isHydrating = true
    nuxtApp.payload.serverRendered = true
    const ClientOnlyPage = await createClientPage(() => Promise.resolve(defineNuxtComponent({
      asyncData: () => ({
        users: ['alice', 'bob'],
      }),
      render () {
        // @ts-expect-error this is not typed
        return h('div', `Total users: ${this.users.length}`)
      },
    })))
    const wrapper = await mountSuspended(ClientOnlyPage)
    expect(wrapper.html()).toMatchInlineSnapshot(`"<div>Total users: 2</div>"`)
    nuxtApp.isHydrating = false
    nuxtApp.payload.serverRendered = false
  })

  it('should support Options API refreshNuxtData', async () => {
    let count = 0
    const component = defineNuxtComponent({
      asyncData: () => ({
        number: count++,
      }),
      setup () {
        const vm = getCurrentInstance()
        return () => {
          // @ts-expect-error go directly to jail 😈
          return h('div', vm!.render.number.value)
        }
      },
    })

    const wrapper = await mountSuspended(component)
    expect(wrapper.html()).toMatchInlineSnapshot(`"<div>0</div>"`)

    await refreshNuxtData()

    expect(wrapper.html()).toMatchInlineSnapshot(`"<div>1</div>"`)
  })

  it.todo('should support Options API head')
})

describe('useCookie', () => {
  it('should watch custom cookie refs', () => {
    const user = useCookie('userInfo', {
      default: () => ({ score: -1 }),
      maxAge: 60 * 60,
    })
    const computedVal = computed(() => user.value.score)
    expect(computedVal.value).toBe(-1)
    user.value.score++
    expect(computedVal.value).toBe(0)
  })

  it('cookie decode function should be invoked once', () => {
    // Pre-set cookies
    document.cookie = 'foo=Foo'
    document.cookie = 'bar=%7B%22s2%22%3A0%7D'
    document.cookie = 'baz=%7B%22s2%22%3A0%7D'

    let barCallCount = 0
    const bazCookie = useCookie<{ s2: number }>('baz', {
      default: () => ({ s2: -1 }),
      decode (value) {
        barCallCount++
        return destr(decodeURIComponent(value))
      },
    })
    bazCookie.value.s2++
    expect(bazCookie.value.s2).toEqual(1)
    expect(barCallCount).toBe(1)

    let quxCallCount = 0
    const quxCookie = useCookie<{ s3: number }>('qux', {
      default: () => ({ s3: -1 }),
      filter: key => key === 'bar' || key === 'baz',
      decode (value) {
        quxCallCount++
        return destr(decodeURIComponent(value))
      },
    })
    quxCookie.value.s3++
    expect(quxCookie.value.s3).toBe(0)
    expect(quxCallCount).toBe(2)
  })

  it('should not watch custom cookie refs when shallow', () => {
    for (const value of ['shallow', false] as const) {
      const user = useCookie('shallowUserInfo', {
        default: () => ({ score: -1 }),
        maxAge: 60 * 60,
        watch: value,
      })
      const computedVal = computed(() => user.value.score)
      expect(computedVal.value).toBe(-1)
      user.value.score++
      expect(computedVal.value).toBe(-1)
    }
  })

  it('should set cookie value when called on client', () => {
    useCookie('cookie-watch-false', { default: () => 'foo', watch: false })
    expect(document.cookie).toContain('cookie-watch-false=foo')

    useCookie('cookie-watch-true', { default: () => 'foo', watch: true })
    expect(document.cookie).toContain('cookie-watch-true=foo')

    useCookie('cookie-readonly', { default: () => 'foo', readonly: true })
    expect(document.cookie).toContain('cookie-readonly=foo')
  })
})

describe('callOnce', () => {
  describe.each([
    ['without options', undefined],
    ['with "render" option', { mode: 'render' as const }],
    ['with "navigation" option', { mode: 'navigation' as const }],
  ])('%s', (_name, options) => {
    const nuxtApp = useNuxtApp()
    afterEach(() => {
      nuxtApp.payload.once.clear()
    })
    it('should only call composable once', async () => {
      const fn = vi.fn()
      const execute = () => options ? callOnce(fn, options) : callOnce(fn)
      await execute()
      await execute()
      expect(fn).toHaveBeenCalledTimes(1)
    })

    it('should only call composable once when called in parallel', async () => {
      const fn = vi.fn().mockImplementation(() => new Promise(resolve => setTimeout(resolve, 1)))
      const execute = () => options ? callOnce(fn, options) : callOnce(fn)
      await Promise.all([execute(), execute(), execute()])
      expect(fn).toHaveBeenCalledTimes(1)

      const fnSync = vi.fn().mockImplementation(() => {})
      const executeSync = () => options ? callOnce(fnSync, options) : callOnce(fnSync)
      await Promise.all([executeSync(), executeSync(), executeSync()])
      expect(fnSync).toHaveBeenCalledTimes(1)
    })

    it('should use key to dedupe', async () => {
      const fn = vi.fn()
      const execute = (key?: string) => options ? callOnce(key, fn, options) : callOnce(key, fn)
      await execute('first')
      await execute('first')
      await execute('second')
      expect(fn).toHaveBeenCalledTimes(2)
    })

    it.runIf(options?.mode === 'navigation')('should rerun on navigation', async () => {
      const fn = vi.fn()
      const execute = () => options ? callOnce(fn, options) : callOnce(fn)
      await execute()
      await execute()
      expect(fn).toHaveBeenCalledTimes(1)

      await navigateTo('/test')
      await execute()
      expect(fn).toHaveBeenCalledTimes(2)
    })
  })
})

describe('route announcer', () => {
  it('should create a route announcer with default politeness', () => {
    const announcer = useRouteAnnouncer()
    expect(announcer.politeness.value).toBe('polite')
  })

  it('should create a route announcer with provided politeness', () => {
    const announcer = useRouteAnnouncer({ politeness: 'assertive' })
    expect(announcer.politeness.value).toBe('assertive')
  })

  it('should set message and politeness', () => {
    const announcer = useRouteAnnouncer()
    announcer.set('Test message with politeness', 'assertive')
    expect(announcer.message.value).toBe('Test message with politeness')
    expect(announcer.politeness.value).toBe('assertive')
  })

  it('should set message with polite politeness', () => {
    const announcer = useRouteAnnouncer()
    announcer.polite('Test message polite')
    expect(announcer.message.value).toBe('Test message polite')
    expect(announcer.politeness.value).toBe('polite')
  })

  it('should set message with assertive politeness', () => {
    const announcer = useRouteAnnouncer()
    announcer.assertive('Test message assertive')
    expect(announcer.message.value).toBe('Test message assertive')
    expect(announcer.politeness.value).toBe('assertive')
  })
})
</file>

<file path="test/nuxt/define-nuxt-component.test.ts">
import { describe, expect, it } from 'vitest'
import { defineEventHandler } from 'h3'
import { mountSuspended, registerEndpoint } from '@nuxt/test-utils/runtime'
import { createClientPage } from '../../packages/nuxt/src/components/runtime/client-component'
import { refreshNuxtData } from '#app/composables/asyncData'
import { NuxtPage } from '#components'
import { flushPromises } from '@vue/test-utils'

registerEndpoint('/api/hello', defineEventHandler(() => 'Hello API'))

describe('defineNuxtComponent', () => {
  it('should produce a Vue component', async () => {
    const component = defineNuxtComponent({
      render: () => h('div', 'hello world'),
    })

    const wrapper = await mountSuspended(component)
    expect(wrapper.html()).toBe('<div>hello world</div>')
  })

  it('should work with setup function', async () => {
    const component = defineNuxtComponent({
      setup () {
        const count = ref(0)
        return { count }
      },
      template: '<div>{{ count }}</div>',
    })

    const wrapper = await mountSuspended(component)
    expect(wrapper.html()).toBe('<div>0</div>')
  })

  it('should support Options API asyncData', async () => {
    const nuxtApp = useNuxtApp()
    nuxtApp.isHydrating = true
    nuxtApp.payload.serverRendered = true

    const component = defineNuxtComponent({
      asyncData: () => ({
        users: ['alice', 'bob'],
      }),
      render () {
        // @ts-expect-error this is not typed in options api
        return h('div', `Total users: ${this.users.length}`)
      },
    })

    const ClientOnlyPage = await createClientPage(() => Promise.resolve(component))
    const wrapper = await mountSuspended(ClientOnlyPage)
    expect(wrapper.html()).toBe('<div>Total users: 2</div>')

    nuxtApp.isHydrating = false
    nuxtApp.payload.serverRendered = false
  })

  it('should support asyncData with refreshNuxtData', async () => {
    let count = 0
    const component = defineNuxtComponent({
      asyncData: () => ({
        number: count++,
      }),
      template: '<div>{{ number }}</div>',
    })

    const wrapper = await mountSuspended(component)
    expect(wrapper.html()).toBe('<div>0</div>')

    await refreshNuxtData()
    await nextTick()
    expect(wrapper.html()).toBe('<div>1</div>')
  })

  it('should handle state and watchers correctly without duplicate updates', async () => {
    let watcherCallCount = 0

    const component = defineNuxtComponent({
      setup () {
        const state = useState('test-counter', () => 0)
        const watcher = useState('test-watcher', () => 0)

        // Should trigger once per state change
        watch(state, () => {
          watcher.value++
          watcherCallCount++
        })

        state.value++

        return {
          state,
          watcher,
          incrementState: () => state.value++,
        }
      },
      template: `
        <div>
          <button @click="incrementState">Increment</button>
          <div data-testid="state">{{ state }}</div>
          <div data-testid="watcher">{{ watcher }}</div>
        </div>
      `,
    })

    const wrapper = await mountSuspended(component)

    // Initial state: state was incremented once in setup, watcher should have triggered once
    expect(wrapper.find('[data-testid="state"]').text()).toBe('1')
    expect(wrapper.find('[data-testid="watcher"]').text()).toBe('1')
    expect(watcherCallCount).toBe(1)

    // Increment again
    await wrapper.find('button').trigger('click')
    await nextTick()

    expect(wrapper.find('[data-testid="state"]').text()).toBe('2')
    expect(wrapper.find('[data-testid="watcher"]').text()).toBe('2')
    expect(watcherCallCount).toBe(2)
  })

  it('should work with provide/inject', async () => {
    const ParentComponent = defineComponent({
      setup () {
        provide('test-key', 'test-value')
        return () => h(ChildComponent)
      },
    })

    const ChildComponent = defineNuxtComponent({
      setup () {
        const injectedValue = inject('test-key')
        return { injectedValue }
      },
      template: '<div data-testid="injected">{{ injectedValue }}</div>',
    })

    const wrapper = await mountSuspended(ParentComponent)
    expect(wrapper.find('[data-testid="injected"]').text()).toBe('test-value')
  })

  it('should work with route information', async () => {
    const component = defineNuxtComponent({
      setup () {
        const route = useRoute()
        return {
          currentPath: computed(() => route.path),
        }
      },
      template: '<div data-testid="path">{{ currentPath }}</div>',
    })

    // The runtime environment provides a default route
    const wrapper = await mountSuspended(component)
    expect(wrapper.find('[data-testid="path"]').text()).toBe('/')
  })

  it('should handle both setup and asyncData together', async () => {
    const component = defineNuxtComponent({
      asyncData: () => ({
        serverData: 'from server',
      }),
      setup () {
        const clientData = ref('from client')
        return { clientData }
      },
      template: `
        <div>
          <div data-testid="server">{{ serverData }}</div>
          <div data-testid="client">{{ clientData }}</div>
        </div>
      `,
    })

    const wrapper = await mountSuspended(component)
    expect(wrapper.find('[data-testid="server"]').text()).toBe('from server')
    expect(wrapper.find('[data-testid="client"]').text()).toBe('from client')
  })

  it('should work without setup, asyncData, or head (passthrough)', async () => {
    const component = defineNuxtComponent({
      data () {
        return { message: 'hello' }
      },
      template: '<div>{{ message }}</div>',
    })

    const wrapper = await mountSuspended(component)
    expect(wrapper.html()).toBe('<div>hello</div>')
  })

  it('should handle component name correctly', async () => {
    const component = defineNuxtComponent({
      name: 'TestComponent',
      render: () => h('div', 'named component'),
    })

    const wrapper = await mountSuspended(component)
    expect(component.name).toBe('TestComponent')
    expect(wrapper.html()).toBe('<div>named component</div>')
  })

  it('should handle errors in asyncData gracefully', async () => {
    // Test that the component still renders even with invalid asyncData
    const component = defineNuxtComponent({
      asyncData: () => 'not an object',
      render: () => h('div', 'error test'),
    })

    const wrapper = await mountSuspended(component)
    // The component should still render successfully despite the invalid asyncData
    expect(wrapper.html()).toBe('<div>error test</div>')
  })

  it('should correctly update route information during navigation', async () => {
    const router = useRouter()

    const Route1Component = defineNuxtComponent({
      name: 'Route1Component',
      setup () {
        const route = useRoute()
        return {
          path: computed(() => route.path),
        }
      },
      template: `
        <div>
          <h1>route-1</h1>
          <div data-testid="define-nuxt-component-route-1-path">{{ path }}</div>
        </div>
      `,
    })

    const Route2Component = defineNuxtComponent({
      name: 'Route2Component',
      setup () {
        const route = useRoute()
        return {
          path: computed(() => route.path),
        }
      },
      template: `
        <div>
          <h2>route-2</h2>
          <div data-testid="define-nuxt-component-route-2-path">{{ path }}</div>
        </div>
      `,
    })

    router.addRoute({
      name: 'route1',
      path: '/define-nuxt-component/route-1',
      component: Route1Component,
    })

    router.addRoute({
      name: 'route2',
      path: '/define-nuxt-component/route-2',
      component: Route2Component,
    })

    const wrapper = await mountSuspended(NuxtPage)

    await navigateTo('/define-nuxt-component/route-1')
    await flushPromises()

    expect(wrapper.find('[data-testid="define-nuxt-component-route-1-path"]').text()).toBe('/define-nuxt-component/route-1')
    expect(wrapper.find('h1').text()).toBe('route-1')

    await navigateTo('/define-nuxt-component/route-2')
    await flushPromises()

    expect(wrapper.find('[data-testid="define-nuxt-component-route-2-path"]').text()).toBe('/define-nuxt-component/route-2')
    expect(wrapper.find('h2').text()).toBe('route-2')

    await navigateTo('/define-nuxt-component/route-1')
    await flushPromises()

    expect(wrapper.find('[data-testid="define-nuxt-component-route-1-path"]').text()).toBe('/define-nuxt-component/route-1')
    expect(wrapper.find('h1').text()).toBe('route-1')

    // Cleanup routes
    router.removeRoute('route1')
    router.removeRoute('route2')

    wrapper.unmount()
  })

  it('should support legacy async data with nested components and fetchKey', async () => {
    const ChildComponent = defineNuxtComponent({
      name: 'LegacyAsyncChild',
      asyncData () {
        return {
          fooChild: 'fooChild',
        }
      },
      template: '<div>{{ fooChild }}</div>',
    })

    const MiddleComponent = defineNuxtComponent({
      name: 'LegacyAsyncMiddle',
      asyncData () {
        return {
          fooParent: 'fooParent',
        }
      },
      template: `
        <div>
          <div>{{ fooParent }}</div>
          <ChildComponent />
        </div>
      `,
      components: { ChildComponent },
    })

    const ParentComponent = defineNuxtComponent({
      name: 'LegacyAsyncParent',
      fetchKey: () => 'hello',
      async setup () {
        await nextTick()
        useRuntimeConfig() // Test that runtime config works in setup
      },
      async asyncData () {
        await nextTick()
        return {
          hello: await $fetch('/api/hello'),
        }
      },
      template: `
        <div>
          <div>{{ hello }}</div>
          <MiddleComponent />
        </div>
      `,
      components: { MiddleComponent },
    })

    const wrapper = await mountSuspended(ParentComponent)

    expect(wrapper.html()).toContain('Hello API')
    expect(wrapper.html()).toContain('fooParent')
    expect(wrapper.html()).toContain('fooChild')

    const payloadData = useNuxtApp().payload.data

    expect(payloadData['options:asyncdata:hello']).toEqual({ hello: 'Hello API' })

    const payloadValues = Object.values(payloadData)
    expect(payloadValues).toEqual(
      expect.arrayContaining([
        { hello: 'Hello API' },
        { fooParent: 'fooParent' },
        { fooChild: 'fooChild' },
      ]),
    )
  })

  it.todo('should support head option')

  it.todo('should support head as function')
})
</file>

<file path="test/nuxt/error-boundary.test.ts">
/// <reference path="../fixtures/basic/.nuxt/nuxt.d.ts" />

import { describe, expect, it, vi } from 'vitest'

import { mount } from '@vue/test-utils'
import { NuxtErrorBoundary } from '#components'

describe('NuxtErrorBoundary', () => {
  it('should render children when there is no error', () => {
    const el = mount({
      setup () {
        return () => h('div', {}, h(NuxtErrorBoundary, {}, {
          default: () => h('span', 'default'),
          error: () => h('span', 'error'),
        }))
      },
    })
    expect(el.html()).toMatchInlineSnapshot(`"<div><span>default</span></div>"`)
    el.unmount()
  })

  it('should handle error state', async () => {
    let thrown = false
    // suppress Vue warning: [Vue warn]: Component is missing template or render function:
    vi.spyOn(console, 'warn').mockImplementation(() => {})
    const el = mount({
      setup () {
        return () => h('div', {}, h(NuxtErrorBoundary, {}, {
          default: () => h(defineComponent({
            setup () {
              if (!thrown) {
                thrown = true
                throw new Error('test error')
              }
              return () => h('span', 'default')
            },
          })),
          error: (
            { error, clearError }: Parameters<InstanceType<typeof NuxtErrorBoundary>['$slots']['error']>[0],
          ) => h('button', { onClick: () => clearError() }, error.toString()),
        }))
      },
    })
    await nextTick()
    expect(el.html()).toMatchInlineSnapshot(`"<div><button>Error: test error</button></div>"`)
    await el.find('button').trigger('click')
    expect(el.html()).toMatchInlineSnapshot(`"<div><span>default</span></div>"`)
    el.unmount()
    vi.resetAllMocks()
  })
})
</file>

<file path="test/nuxt/island-pages.test.ts">
import { mountSuspended } from '@nuxt/test-utils/runtime'
import { flushPromises } from '@vue/test-utils'
import { describe, expect, it, vi } from 'vitest'
import { Suspense } from 'vue'
import { createIslandPage } from '~/packages/nuxt/src/components/runtime/server-component'

vi.mock('#app/composables/error', async (og) => {
  return {
    ...(await og()),
    showError: vi.fn(),
  }
})

describe('Island pages', () => {
  it('expect to show error', async () => {
    await mountSuspended({
      setup () {
        return () => h(Suspense, {}, {
          default: () => h(createIslandPage('pagedontexist')),
        })
      },
    })
    await flushPromises()
    expect(showError).toHaveBeenCalledOnce()
  })
})
</file>

<file path="test/nuxt/loading-indicator.test.ts">
/// <reference path="../fixtures/basic/.nuxt/nuxt.d.ts" />

import { afterEach, beforeEach, describe, expect, it } from 'vitest'

import type { RouteLocationRaw } from 'vue-router'

import { mountSuspended } from '@nuxt/test-utils/runtime'
import { flushPromises } from '@vue/test-utils'
import { NuxtLoadingIndicator, NuxtPage } from '#components'

describe('page loading indicator', () => {
  const router = useRouter()
  let resolve: undefined | (() => void)
  const nuxtApp = useNuxtApp()

  const { isLoading } = useLoadingIndicator({ duration: 1, throttle: 0, resetDelay: 0, hideDelay: 0 }) as any

  const customProp = ref(false)

  beforeEach(() => {
    resolve = undefined

    router.addRoute({
      name: 'page-load-hook',
      path: '/page-load-hook',
      component: defineComponent({
        name: '~/pages/page-load-hook.vue',
        setup: () => () => h('div', { id: 'page' }, [h('span', 'parent'), h(NuxtPage, { customProp: customProp.value })]),
      }),
      children: [
        {
          name: 'page-load-hook-index',
          path: '',
          component: defineComponent({
            props: { customProp: Boolean },
            name: '~/pages/page-load-hook/index.vue',
            async setup () {
              await new Promise<void>((r) => { resolve = r })
              return () => h('div', 'index')
            },
          }),
        },
        {
          name: 'page-load-hook-slug',
          path: ':slug',
          component: defineComponent({
            props: { customProp: Boolean },
            name: '~/pages/page-load-hook/[slug].vue',
            async setup () {
              const route = useRoute()
              await new Promise<void>((r) => { resolve = r })
              return () => h('div', [h('span', 'child'), route.fullPath])
            },
          }),
        },
        {
          name: 'page-load-hook-custom-key-slug',
          path: 'custom-key/:slug',
          meta: {
            key: to => to.path,
          },
          component: defineComponent({
            props: { customProp: Boolean },
            name: '~/pages/page-load-hook/custom-key/[slug].vue',
            async setup () {
              const route = useRoute()
              await new Promise<void>((r) => { resolve = r })
              return () => h('div', [h('span', 'child'), route.fullPath])
            },
          }),
        },
      ],
    })
  })

  afterEach(() => {
    router.removeRoute('page-load-hook')
  })

  it('should hide nuxt page load indicator after navigating from nested page to other nested page', async () => {
    let startedLoading = 0
    let stoppedLoading = 0
    nuxtApp.hook('page:loading:start', () => { startedLoading++ })
    nuxtApp.hook('page:loading:end', () => { stoppedLoading++ })

    const route = useRoute()

    const el = await mountSuspended({ setup: () => () => h('div', [h(NuxtLoadingIndicator), h(NuxtPage)]) })

    const getLoadingIndicator = () => el.getComponent('.nuxt-loading-indicator')
    const getPage = () => el.getComponent('#page')

    async function expectNavigatesWithLoading (path: string | RouteLocationRaw, onLoad?: () => void) {
      startedLoading = 0
      stoppedLoading = 0
      await navigateTo(path)
      expect(startedLoading).toBe(1)
      expect(stoppedLoading).toBe(0)

      expect(isLoading.value).toBe(true)
      expect(getLoadingIndicator().attributes().style).toContain('opacity: 1;')
      onLoad?.()

      if (isLoading.value) {
        resolve!()
        await new Promise<void>(resolve => nuxtApp.hooks.hookOnce('page:loading:end', () => { resolve() }))
          .then(() => new Promise(r => setTimeout(r, 0)))
      }

      expect(startedLoading).toBe(1)
      expect(stoppedLoading).toBe(1)

      expect(isLoading.value).toBe(false)
      expect(getLoadingIndicator().attributes().style).toContain('opacity: 0;')
    }

    await flushPromises()

    await expectNavigatesWithLoading('/page-load-hook')
    expect(getPage().html()).toMatchInlineSnapshot(`
      "<div id="page"><span>parent</span>
        <div>index</div>
      </div>"
    `)

    await expectNavigatesWithLoading('/page-load-hook/subpage')
    expect(getPage().html()).toMatchInlineSnapshot(`
      "<div id="page"><span>parent</span>
        <div><span>child</span>/page-load-hook/subpage</div>
      </div>"
    `)

    await expectNavigatesWithLoading({ query: { someQuery: 'toto' } }, () => {
      expect(route.fullPath).toMatchInlineSnapshot(`"/page-load-hook/subpage?someQuery=toto"`)
    })

    await expectNavigatesWithLoading('/page-load-hook/other-slug')
    expect(getPage().html()).toMatchInlineSnapshot(`
      "<div id="page"><span>parent</span>
        <div><span>child</span>/page-load-hook/other-slug</div>
      </div>"
    `)

    await expectNavigatesWithLoading('/page-load-hook/custom-key/abc')
    await expectNavigatesWithLoading('/page-load-hook/custom-key/abc?1')
    await expectNavigatesWithLoading('/page-load-hook/custom-key/def')

    customProp.value = true
    await nextTick(() => new Promise(r => setTimeout(r, 0))) // wait for page rerender
    await expectNavigatesWithLoading('/page-load-hook/other-slug')

    el.unmount()
  })
})
</file>

<file path="test/nuxt/nuxt-island.test.ts">
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { defineComponent, h, nextTick, popScopeId, pushScopeId } from 'vue'
import { type ServerHandler, serve } from 'srvx'
import { mountSuspended } from '@nuxt/test-utils/runtime'
import { getPort } from 'get-port-please'

import { createServerComponent } from '../../packages/nuxt/src/components/runtime/server-component'
import NuxtIsland from '../../packages/nuxt/src/app/components/nuxt-island'

async function createServer (handler: ServerHandler) {
  const port = await getPort({ host: 'localhost', public: false, random: true })
  const server = serve({
    port,
    fetch: handler,
  })

  await server.ready()

  return {
    server,
    port,
  }
}

vi.mock('#build/nuxt.config.mjs', async (original) => {
  return {
    // @ts-expect-error virtual file
    ...(await original()),
    remoteComponentIslands: true,
    selectiveClient: true,
  }
})

vi.mock('vue', async (original) => {
  const vue = await original<typeof import('vue')>()
  return {
    ...vue,
    h: vi.fn(vue.h),
  }
})

const consoleError = vi.spyOn(console, 'error')
const consoleWarn = vi.spyOn(console, 'warn')

function expectNoConsoleIssue () {
  expect(consoleError).not.toHaveBeenCalled()
  expect(consoleWarn).not.toHaveBeenCalled()
}

describe('runtime server component', () => {
  beforeEach(() => {
    consoleError.mockClear()
    consoleWarn.mockClear()
  })

  it('expect no data-v- attributes #23051', () => {
    // @ts-expect-error mock
    vi.mocked(h).mockImplementation(() => null)

    // @ts-expect-error test setup
    createServerComponent('DummyName').setup!({
      lazy: false,
    }, {
      attrs: {
        'data-v-123': '',
        'test': 1,
      },
      slots: {},
      emit: vi.fn(),
      expose: vi.fn(),
    })()

    expect(h).toHaveBeenCalledOnce()
    if (!vi.mocked(h).mock.lastCall) { throw new Error('no last call') }
    expect(vi.mocked(h).mock.lastCall![1]?.props).toBeTypeOf('object')
    expect(vi.mocked(h).mock.lastCall![1]?.props).toMatchInlineSnapshot(`
      {
        "data-v-123": "",
        "test": 1,
      }
    `)
    vi.mocked(h).mockRestore()
  })

  it('expect remote island to be rendered', async () => {
    const handler = () => new Response(JSON.stringify({
      html: '<div>hello world from another server</div>',
      state: {},
      head: { link: [], style: [] },
    }), { headers: { 'Content-Type': 'application/json' } })
    const { server, port } = await createServer(handler)
    const wrapper = await mountSuspended(NuxtIsland, {
      props: {
        name: 'Test',
        source: `http://localhost:${port}`,
      },
    })
    expect(wrapper.html()).toMatchInlineSnapshot('"<div>hello world from another server</div>"')
    await server.close()
  })

  it('expect remote island with baseURL to be rendered', async () => {
    let url: string
    const handler = (r: Request) => {
      url = r.url
      return new Response(JSON.stringify({
        html: '<div>hello world from another server</div>',
        state: {},
        head: { link: [], style: [] },
      }), { headers: { 'Content-Type': 'application/json' } })
    }
    const { server, port } = await createServer(handler)
    const wrapper = await mountSuspended(NuxtIsland, {
      props: {
        name: 'Test',
        source: `http://localhost:${port}/app`,
      },
    })
    expect(wrapper.html()).toMatchInlineSnapshot('"<div>hello world from another server</div>"')
    expect(url!.startsWith(`http://localhost:${port}/app/__nuxt_island`)).toBe(true)
    await server.close()
  })
  it('force refresh', async () => {
    let count = 0
    const stubFetch = vi.fn(() => {
      count++
      return Promise.resolve({
        id: '123',
        html: `<div>${count}</div>`,
        state: {},
        head: {
          link: [],
          style: [],
        },
        json () {
          return this
        },
        ok: true,
      })
    })

    vi.stubGlobal('fetch', stubFetch)
    const component = await mountSuspended(createServerComponent('dummyName'))
    expect(fetch).toHaveBeenCalledOnce()

    expect(component.html()).toBe('<div>1</div>')

    await component.vm.$.exposed!.refresh()
    expect(fetch).toHaveBeenCalledTimes(2)
    await nextTick()
    expect(component.html()).toBe('<div>2</div>')
    vi.mocked(fetch).mockReset()
  })

  it('expect NuxtIsland to emit an error', async () => {
    const stubFetch = vi.fn(() => {
      throw new Error('fetch error')
    })

    vi.stubGlobal('fetch', stubFetch)

    const wrapper = await mountSuspended(createServerComponent('ErrorServerComponent'), {
      props: {
        name: 'Error',
        props: {
          force: true,
        },
      },
      attachTo: 'body',
    })

    expect(fetch).toHaveBeenCalledOnce()
    expect(wrapper.emitted('error')).toHaveLength(1)
    vi.mocked(fetch).mockReset()
  })

  it('expect NuxtIsland to have parent scopeId', async () => {
    const wrapper = await mountSuspended(defineComponent({
      render () {
        pushScopeId('data-v-654e2b21')
        const vnode = h(createServerComponent('dummyName'))
        popScopeId()
        return vnode
      },
    }))

    expect(wrapper.find('*').attributes()).toHaveProperty('data-v-654e2b21')
  })
})

describe('client components', () => {
  it('expect swapping nuxt-client should not trigger errors #25289', async () => {
    const mockPath = '/nuxt-client.js'
    const componentId = 'Client-12345'

    vi.doMock(mockPath, () => ({
      default: {
        name: 'ClientComponent',
        setup () {
          return () => h('div', 'client component')
        },
      },
    }))

    const stubFetch = vi.fn(() => {
      return Promise.resolve({
        id: '123',
        html: `<div data-island-uid>hello<div data-island-uid data-island-component="${componentId}"></div></div>`,
        state: {},
        head: {
          link: [],
          style: [],
        },
        components: {
          [componentId]: {
            html: '<div>fallback</div>',
            props: {},
            chunk: mockPath,
          },
        },
        json () {
          return this
        },
        ok: true,
      })
    })

    vi.stubGlobal('fetch', stubFetch)

    const wrapper = await mountSuspended(NuxtIsland, {
      props: {
        name: 'NuxtClient',
        props: {
          force: true,
        },
      },
      attachTo: 'body',
    })

    expect(fetch).toHaveBeenCalledOnce()
    expect(removeDataIslandUid(wrapper.html())).toMatchInlineSnapshot(`
      "<div>hello<div data-island-component="Client-12345">
          <div>client component</div>
        </div>
      </div>
      <!--teleport start-->
      <!--teleport end-->"
    `)

    vi.mocked(fetch).mockImplementation(() => Promise.resolve(({
      id: '123',
      html: '<div data-island-uid>hello<div><div>fallback</div></div></div>',
      state: {},
      head: {
        link: [],
        style: [],
      },
      components: {},
      // @ts-expect-error mock
      json () {
        return this
      },
      ok: true,
    })))

    await wrapper.vm.$.exposed!.refresh()
    await nextTick()
    expect(removeDataIslandUid(wrapper.html())).toMatchInlineSnapshot(`
        "<div>hello<div>
            <div>fallback</div>
          </div>
        </div>"
      `)

    vi.mocked(fetch).mockReset()
    expectNoConsoleIssue()
  })

  it('should not replace nested client components data-island-uid', async () => {
    const componentId = 'Client-12345'

    const stubFetch = vi.fn(() => {
      return Promise.resolve({
        id: '1234',
        html: `<div data-island-uid>hello<div data-island-uid="not-to-be-replaced" data-island-component="${componentId}"></div></div>`,
        state: {},
        head: {
          link: [],
          style: [],
        },
        json () {
          return this
        },
        ok: true,
      })
    })

    vi.stubGlobal('fetch', stubFetch)

    const wrapper = await mountSuspended(NuxtIsland, {
      props: {
        name: 'WithNestedClient',
        props: {
          force: true,
        },
      },
      attachTo: 'body',
    })

    expect(fetch).toHaveBeenCalledOnce()
    expect(wrapper.html()).toContain('data-island-uid="not-to-be-replaced"')
    vi.mocked(fetch).mockReset()
    expectNoConsoleIssue()
  })

  it('pass a slot to a client components within islands', async () => {
    const mockPath = '/nuxt-client-with-slot.js'
    const componentId = 'ClientWithSlot-12345'

    vi.doMock(mockPath, () => ({
      default: defineComponent({
        name: 'ClientWithSlot',
        setup (_, { slots }) {
          return () => h('div', { class: 'client-component' }, slots.default?.())
        },
      }),
    }))

    const stubFetch = vi.fn(() => {
      return Promise.resolve({
        id: '123',
        html: `<div data-island-uid>hello<div data-island-uid data-island-component="${componentId}"></div></div>`,
        state: {},
        head: {
          link: [],
          style: [],
        },
        components: {
          [componentId]: {
            html: '<div>fallback</div>',
            props: {},
            chunk: mockPath,
            slots: {
              default: '<div>slot in client component</div>',
            },
          },
        },
        json () {
          return this
        },
        ok: true,
      })
    })

    vi.stubGlobal('fetch', stubFetch)
    const wrapper = await mountSuspended(NuxtIsland, {
      props: {
        name: 'NuxtClientWithSlot',
      },
      attachTo: 'body',
    })
    expect(fetch).toHaveBeenCalledOnce()
    expect(removeDataIslandUid(wrapper.html())).toMatchInlineSnapshot(`
      "<div>hello<div data-island-component="ClientWithSlot-12345">
          <div class="client-component">
            <div style="display: contents" data-island-slot="default">
              <div>slot in client component</div>
            </div>
          </div>
        </div>
      </div>
      <!--teleport start-->
      <!--teleport end-->"
    `)

    expectNoConsoleIssue()
  })
})

function removeDataIslandUid (html: string) {
  return html.replaceAll(/ data-island-uid="[^"]*"/g, '')
}
</file>

<file path="test/nuxt/nuxt-layout.test.ts">
/// <reference path="../fixtures/basic/.nuxt/nuxt.d.ts" />

import { afterAll, beforeAll, beforeEach, describe, expect, it } from 'vitest'

import { mountSuspended } from '@nuxt/test-utils/runtime'
import type { VueWrapper } from '@vue/test-utils'
import { flushPromises } from '@vue/test-utils'
import { NuxtLayout, NuxtPage } from '#components'
import layouts from '#build/layouts.mjs'
import { useRoute } from '#app/composables/router'

describe('NuxtLayout', () => {
  const router = useRouter()
  let resolveDeferredPage: () => void

  let routeChanges = 0
  let renders: Record<string, number> = {}
  let setups: Record<string, number> = {}
  let el: VueWrapper

  const addedLayouts = ['layout-1', 'layout-2']
  const addedPages = ['no-layout', 'layout-1', 'layout-2', 'layout-2-deferred', 'deferred']

  beforeAll(async () => {
    for (const layout of addedLayouts) {
      layouts[layout] = defineComponent({
        setup (_, ctx) {
          const route = useRoute()
          watch(() => route.path, () => routeChanges++, { immediate: true })
          const fixed = route.path

          const key = `[layout] ${layout}`
          setups[key] ??= 0
          setups[key]++

          return () => {
            renders[key] ??= 0
            renders[key]++

            // console.log([
            //   `'${layout}' layout`,
            //   'Current route: ' + route.path + ` (initialised at: ${fixed})`,
            // ])

            return h('div', {}, [
              h('h1', `'${layout}' layout`),
              h('h2', 'Current route: ' + route.path + ` (initialised at: ${fixed})`),
              ...ctx.slots.default?.() || [],
            ])
          }
        },
      })
    }
    for (const page of addedPages) {
      router.addRoute({
        name: page,
        path: `/${page}`,
        meta: {
          // @ts-expect-error dynamically-added layout is not typed
          layout: ['layout-1', 'layout-2'].find(l => page.startsWith(l)),
        },
        component: defineComponent({
          name: 'layout-slug',
          async setup () {
            const route = useRoute()
            if (page.includes('deferred')) {
              await new Promise<void>((resolve) => {
                resolveDeferredPage = resolve
              })
            } else {
              await Promise.resolve()
            }

            const key = `[page] ${page}`
            setups[key] ??= 0
            setups[key]++

            return () => {
              renders[key] ??= 0
              renders[key]++

              // console.log([`${key} Current route: ` + route.path])
              return h('h3', 'Current route: ' + route.path)
            }
          },
        }),
      })
    }

    el = await mountSuspended({ setup: () => () => h(NuxtLayout, {}, { default: () => h(NuxtPage) }) })
  })

  beforeEach(() => {
    routeChanges = 0
    renders = {}
    setups = {}
  })

  afterAll(() => {
    for (const layout of addedLayouts) {
      delete layouts[layout]
    }
    for (const page of addedPages) {
      router.removeRoute(page)
    }
  })

  it('should have access to route when initially loading', async () => {
    expect.soft(el.html()).toMatchInlineSnapshot(`"<div>catchall</div>"`)

    // accesses layout of _new_ path when layout is loaded in a route change
    await navigateTo('/layout-1')
    await flushPromises()

    expect.soft(routeChanges).toBe(1)
    expect.soft(renders).toMatchInlineSnapshot(`
      {
        "[layout] layout-1": 1,
        "[page] layout-1": 1,
      }
    `)
    expect.soft(el.html()).toMatchInlineSnapshot(`
      "<div>
        <h1>'layout-1' layout</h1>
        <h2>Current route: /layout-1 (initialised at: /layout-1)</h2>
        <h3>Current route: /layout-1</h3>
      </div>"
    `)

    // does not rerender layout when switching pages
    await navigateTo('/layout-2-deferred')
    await flushPromises()

    // TODO: avoid secondary rerender
    expect.soft(routeChanges).toBe(2 /* should be 1 */)
    expect.soft(renders).toMatchInlineSnapshot(`
      {
        "[layout] layout-1": ${2 /* should be 1 */},
        "[layout] layout-2": 1,
        "[page] layout-1": 1,
      }
    `)
    expect.soft(el.html()).toMatchInlineSnapshot(`
      "<div>
        <h1>'layout-1' layout</h1>
        <h2>Current route: /layout-1 (initialised at: /layout-1)</h2>
        <h3>Current route: /layout-1</h3>
      </div>"
    `)
    resolveDeferredPage()
    await flushPromises()
    expect.soft(renders).toMatchInlineSnapshot(`
      {
        "[layout] layout-1": 2,
        "[layout] layout-2": 1,
        "[page] layout-1": 1,
        "[page] layout-2-deferred": 1,
      }
    `)
    expect.soft(el.html()).toMatchInlineSnapshot(`
      "<div>
        <h1>'layout-2' layout</h1>
        <h2>Current route: /layout-2-deferred (initialised at: /layout-2-deferred)</h2>
        <h3>Current route: /layout-2-deferred</h3>
      </div>"
    `)
    expect.soft(routeChanges).toBe(2)

    // route only updates in layout in the new suspense fork, not the old one
    await navigateTo('/layout-2')
    await nextTick()
    await flushPromises()
    expect.soft(el.html()).toMatchInlineSnapshot(`
      "<div>
        <h1>'layout-2' layout</h1>
        <h2>Current route: /layout-2 (initialised at: /layout-2-deferred)</h2>
        <h3>Current route: /layout-2</h3>
      </div>"
    `)
    expect.soft(renders).toMatchInlineSnapshot(`
      {
        "[layout] layout-1": 2,
        "[layout] layout-2": 3,
        "[page] layout-1": 1,
        "[page] layout-2": 2,
        "[page] layout-2-deferred": 1,
      }
    `)
    expect.soft(routeChanges).toBe(3)
  })

  it.todo('should not change layout before child page resolves', async () => {
    await navigateTo('/layout-1')
    await flushPromises()

    // does not update route used in layout until page switch has finished
    await navigateTo('/deferred')
    await flushPromises()
    expect.soft(el.html()).toMatchInlineSnapshot(`
      "<div>
        <h1>'layout-1' layout</h1>
        <h2>Current route: /layout-1 (initialised at: /layout-1)</h2>
        <h3>Current route: /layout-1</h3>
      </div>"
    `)

    resolveDeferredPage()
    await flushPromises()
    expect.soft(el.html()).toMatchInlineSnapshot(`"<h3>Current route: /deferred</h3>"`)
  })
})
</file>

<file path="test/nuxt/nuxt-page.test.ts">
/// <reference path="../fixtures/basic/.nuxt/nuxt.d.ts" />

import { afterEach, beforeEach, describe, expect, it } from 'vitest'

import { mountSuspended } from '@nuxt/test-utils/runtime'
import { NuxtLayout, NuxtPage } from '#components'

describe('NuxtPage should work with keepalive options', () => {
  let visits = 0
  const router = useRouter()
  beforeEach(() => {
    visits = 0
    router.addRoute({
      name: 'home',
      path: '/home',
      component: defineComponent({
        name: 'home',
        setup () {
          visits++
          return () => h('div', 'home')
        },
      }),
    })
  })
  afterEach(() => {
    router.removeRoute('home')
  })
  // include/exclude/boolean
  it('should reload setup every time a page is visited, without keepalive', async () => {
    const el = await mountSuspended({
      setup () {
        return () => h(NuxtLayout, {}, { default: () => h(NuxtPage) })
      },
    })
    await navigateTo('/home')
    await navigateTo('/')
    await navigateTo('/home')
    expect(visits).toBe(2)
    el.unmount()
  })

  it('should not remount a page when keepalive is enabled', async () => {
    const el = await mountSuspended({
      setup () {
        return () => h(NuxtLayout, {}, { default: () => h(NuxtPage, { keepalive: true }) })
      },
    })
    await navigateTo('/home')
    await navigateTo('/')
    await navigateTo('/home')
    expect(visits).toBe(1)
    el.unmount()
  })

  it('should not remount a page when keepalive is granularly enabled (with include)', async () => {
    const el = await mountSuspended({
      setup () {
        return () => h(NuxtLayout, {}, { default: () => h(NuxtPage, { keepalive: { include: ['home'] } }) })
      },
    })
    await navigateTo('/home')
    await navigateTo('/')
    await navigateTo('/home')
    expect(visits).toBe(1)
    el.unmount()
  })

  it('should not remount a page when keepalive is granularly enabled (with exclude)', async () => {
    const el = await mountSuspended({
      setup () {
        return () => h(NuxtLayout, {}, { default: () => h(NuxtPage, { keepalive: { exclude: ['catchall'] } }) })
      },
    })
    await navigateTo('/home')
    await navigateTo('/')
    await navigateTo('/home')
    expect(visits).toBe(1)
    el.unmount()
  })

  it('should not remount a page when keepalive options are modified', async () => {
    const pages = ref('home')
    const el = await mountSuspended({
      setup () {
        return () => h(NuxtLayout, {}, { default: () => h(NuxtPage, { keepalive: { include: pages.value } }) })
      },
    })
    await navigateTo('/home')
    await navigateTo('/')
    await navigateTo('/home')
    pages.value = 'home,catchall'
    await navigateTo('/')
    await navigateTo('/home')
    expect(visits).toBe(1)
    el.unmount()
  })
})
</file>

<file path="test/nuxt/nuxt-time.test.ts">
import { describe, expect, it, vi } from 'vitest'
import { defineComponent, h } from 'vue'
import { mountSuspended } from '@nuxt/test-utils/runtime'
import { injectHead } from '#unhead/composables'

import { NuxtTime } from '#components'

describe('<NuxtTime>', () => {
  it('should not serialise data in the DOM in the client', async () => {
    const thing = await mountSuspended(
      defineComponent({
        render: () =>
          h(NuxtTime, {
            datetime: '2023-02-11T18:26:41.058Z',
            locale: 'en-GB',
            month: 'long',
            day: 'numeric',
            second: 'numeric',
            timeZone: 'UTC',
          }),
      }),
    )
    expect(thing.html()).toMatchInlineSnapshot(
      `"<time datetime="2023-02-11T18:26:41.058Z">11 February at 41</time>"`,
    )
  })

  it('should display relative time correctly', async () => {
    const datetime = Date.now() - 5 * 60 * 1000
    const thing = await mountSuspended(
      defineComponent({
        render: () =>
          h(NuxtTime, {
            datetime,
            relative: true,
            locale: 'en-GB',
          }),
      }),
    )
    expect(thing.html()).toMatchInlineSnapshot(
      `"<time datetime="${new Date(datetime).toISOString()}">5 minutes ago</time>"`,
    )
  })

  it('should work with relative\'s `numeric` prop', async () => {
    const datetime = Date.now() - 24 * 60 * 60 * 1000
    const thing = await mountSuspended(
      defineComponent({
        render: () =>
          h(NuxtTime, {
            datetime,
            relative: true,
            locale: 'en-GB',
            numeric: 'auto',
          }),
      }),
    )
    expect(thing.html()).toMatchInlineSnapshot(
      `"<time datetime="${new Date(datetime).toISOString()}">yesterday</time>"`,
    )
  })

  it('should work with relative\'s `relativeStyle` prop', async () => {
    const datetime = Date.now() - 5 * 60 * 1000
    const thing = await mountSuspended(
      defineComponent({
        render: () =>
          h(NuxtTime, {
            datetime,
            relative: true,
            locale: 'en-GB',
            relativeStyle: 'short',
          }),
      }),
    )
    expect(thing.html()).toMatchInlineSnapshot(
      `"<time datetime="${new Date(datetime).toISOString()}">5 min ago</time>"`,
    )
  })

  it('should display datetime in title', async () => {
    const datetime = Date.now() - 5 * 60 * 1000
    const thing = await mountSuspended(
      defineComponent({
        render: () =>
          h(NuxtTime, {
            datetime,
            relative: true,
            title: true,
            locale: 'en-GB',
          }),
      }),
    )
    expect(thing.html()).toMatchInlineSnapshot(
      `"<time datetime="${new Date(datetime).toISOString()}" title="${new Date(datetime).toISOString()}">5 minutes ago</time>"`,
    )
  })

  it('should display custom title', async () => {
    const datetime = Date.now() - 5 * 60 * 1000
    const thing = await mountSuspended(
      defineComponent({
        render: () =>
          h(NuxtTime, {
            datetime,
            relative: true,
            title: 'test',
            locale: 'en-GB',
          }),
      }),
    )
    expect(thing.html()).toMatchInlineSnapshot(
      `"<time datetime="${new Date(datetime).toISOString()}" title="test">5 minutes ago</time>"`,
    )
  })

  const tests = [
    [`${Date.now() - 25 * 60 * 60 * 1000}`, '1 day ago'],
    [`${Date.now() - 45 * 24 * 60 * 60 * 1000}`, '2 months ago'],
    [`${Date.now() - 15 * 30 * 24 * 60 * 60 * 1000}`, '1 year ago'],
  ]

  it.each(tests)('should generate the correct hydrateable code', async (_datetime,
    description) => {
    const datetime = Number(_datetime)
    const thing = await mountSuspended(
      defineComponent({
        render: () =>
          h(NuxtTime, {
            // not a defined prop, but we use to switch on ssr behaviour in test
            ssr: true,
            datetime,
            relative: true,
            title: 'test',
            locale: 'en-GB',
          }),
      }),
    )

    const html = thing.html()
    const id = html.match(/data-prehydrate-id="([^"]+)"/)?.[1]
    expect(thing.html()).toEqual(
      `<time data-locale="en-GB" data-relative="true" data-title="test" datetime="${new Date(datetime).toISOString()}" title="test" ssr="true" data-prehydrate-id="${id}">${description}</time>`,
    )

    vi.spyOn(document, 'querySelectorAll').mockImplementation((selector) => {
      if (selector === `[data-prehydrate-id*="${id}"]`) {
        return [thing.element] as any
      }
      return []
    })

    const head = injectHead()
    // @ts-expect-error craziness
    const innerHTML = head.entries.get(1).input.script[0].innerHTML
    const fn = new Function(innerHTML)
    fn()

    expect(window._nuxtTimeNow).toBeDefined()

    expect(thing.html()).toEqual(
      `<time data-locale="en-GB" data-relative="true" data-title="test" datetime="${new Date(datetime).toISOString()}" title="test" ssr="true" data-prehydrate-id="${id}">${description}</time>`,
    )

    vi.restoreAllMocks()
  })
})
</file>

<file path="test/nuxt/plugin.test.ts">
import { describe, expect, it, vi } from 'vitest'
import { applyPlugins } from '#app/nuxt'
import { defineNuxtPlugin } from '#app'

vi.mock('#app', async (original) => {
  return {
    ...(await original<typeof import('#app')>()),
    applyPlugin: vi.fn(async (_nuxtApp, plugin) => {
      await plugin()
    }),
  }
})

function pluginFactory (name: string, dependsOn: string[] | undefined, sequence: string[], parallel = true) {
  return defineNuxtPlugin({
    name,
    // @ts-expect-error we have a strong type for plugin names
    dependsOn,
    async setup () {
      sequence.push(`start ${name}`)
      await new Promise(resolve => setTimeout(resolve, 10))
      sequence.push(`end ${name}`)
    },
    parallel,
  })
}

describe('plugin dependsOn', () => {
  it('expect B to await A to finish before being run', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('A', undefined, sequence),
      pluginFactory('B', ['A'], sequence),
    ]

    await applyPlugins(nuxtApp, plugins)

    expect(sequence).toMatchObject([
      'start A',
      'end A',
      'start B',
      'end B',
    ])
  })

  it('expect C to await A and B to finish before being run', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('A', undefined, sequence),
      pluginFactory('B', ['A'], sequence),
      pluginFactory('C', ['A', 'B'], sequence),
    ]

    await applyPlugins(nuxtApp, plugins)

    expect(sequence).toMatchObject([
      'start A',
      'end A',
      'start B',
      'end B',
      'start C',
      'end C',
    ])
  })

  it('expect C to not wait for A to finish before being run', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('A', undefined, sequence),
      pluginFactory('B', ['A'], sequence),
      defineNuxtPlugin({
        name: 'some plugin',
        async setup () {
          sequence.push('start C')
          await new Promise(resolve => setTimeout(resolve, 5))
          sequence.push('end C')
        },
        parallel: true,
      }),
    ]

    await applyPlugins(nuxtApp, plugins)

    expect(sequence).toMatchObject([
      'start A',
      'start C',
      'end C',
      'end A',
      'start B',
      'end B',
    ])
  })

  it('expect C to block the depends on of A-B since C is sequential', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('A', undefined, sequence),
      defineNuxtPlugin({
        name: 'some plugin',
        async setup () {
          sequence.push('start C')
          await new Promise(resolve => setTimeout(resolve, 50))
          sequence.push('end C')
        },
      }),
      pluginFactory('B', ['A'], sequence),
    ]

    await applyPlugins(nuxtApp, plugins)

    expect(sequence).toMatchObject([
      'start A',
      'start C',
      'end A',
      'end C',
      'start B',
      'end B',
    ])
  })

  it('relying on plugin not registered yet', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('C', ['A'], sequence),
      pluginFactory('A', undefined, sequence, true),
      pluginFactory('E', ['B', 'C'], sequence, false),
      pluginFactory('B', undefined, sequence),
      pluginFactory('D', ['C'], sequence, false),
    ]
    await applyPlugins(nuxtApp, plugins)

    expect(sequence).toMatchObject([
      'start A',
      'start B',
      'end A',
      'start C',
      'end B',
      'end C',
      'start E',
      'start D',
      'end E',
      'end D',
    ])
  })

  it('test depending on not yet registered plugin and already resolved plugin', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('A', undefined, sequence),
      pluginFactory('B', ['A', 'C'], sequence),
      pluginFactory('C', undefined, sequence, false),
      pluginFactory('D', undefined, sequence, false),
      pluginFactory('E', ['C'], sequence, false),
    ]
    await applyPlugins(nuxtApp, plugins)

    expect(sequence).toMatchObject([
      'start A',
      'start C',
      'end A',
      'end C',
      'start B',
      'start D',
      'end B',
      'end D',
      'start E',
      'end E',
    ])
  })

  it('multiple depth of plugin dependency', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('A', undefined, sequence),
      pluginFactory('C', ['B', 'A'], sequence),
      pluginFactory('B', undefined, sequence, false),
      pluginFactory('E', ['D'], sequence, false),
      pluginFactory('D', ['C'], sequence, false),
    ]
    await applyPlugins(nuxtApp, plugins)

    expect(sequence).toMatchObject([
      'start A',
      'start B',
      'end A',
      'end B',
      'start C',
      'end C',
      'start D',
      'end D',
      'start E',
      'end E',
    ])
  })

  it('does not throw when circular dependency is not a problem', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('A', ['B'], sequence),
      pluginFactory('B', ['C'], sequence),
      pluginFactory('C', ['D'], sequence),
      pluginFactory('D', [], sequence),
    ]

    await applyPlugins(nuxtApp, plugins)
    expect(sequence).toMatchObject([
      'start D',
      'end D',
      'start C',
      'end C',
      'start B',
      'end B',
      'start A',
      'end A',
    ])
  })

  it('function plugin', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('A', undefined, sequence),
      defineNuxtPlugin(() => {
        sequence.push('start C')
        sequence.push('end C')
      }),
      pluginFactory('B', undefined, sequence, false),
    ]
    await applyPlugins(nuxtApp, plugins)

    expect(sequence).toMatchObject([
      'start A',
      'start C',
      'end C',
      'start B',
      'end A',
      'end B',
    ])
  })

  it('expect B to execute after A, C when B depends on A and C', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('A', undefined, sequence, false),
      pluginFactory('B', ['A', 'C'], sequence, false),
      pluginFactory('C', undefined, sequence, false),
    ]
    await applyPlugins(nuxtApp, plugins)

    expect(sequence).toMatchObject([
      'start A',
      'end A',
      'start C',
      'end C',
      'start B',
      'end B',
    ])
  })

  it('expect to execute plugins if a plugin depends on a plugin that does not exist', async () => {
    const nuxtApp = useNuxtApp()
    const sequence: string[] = []
    const plugins = [
      pluginFactory('B', undefined, sequence),
      pluginFactory('C', ['A', 'B'], sequence),
    ]
    await applyPlugins(nuxtApp, plugins)

    expect(sequence).toMatchObject([
      'start B',
      'end B',
      'start C',
      'end C',
    ])
  })
})

describe('plugin hooks', () => {
  it('registers hooks before executing plugins', async () => {
    const nuxtApp = useNuxtApp()

    const sequence: string[] = []
    const plugins = [
      defineNuxtPlugin({
        name: 'A',
        setup (nuxt) {
          sequence.push('start A')
          nuxt.callHook('a:setup')
        },
      }),
      defineNuxtPlugin({
        name: 'B',
        hooks: {
          'a:setup': () => {
            sequence.push('listen B')
          },
        },
      }),
    ]

    await applyPlugins(nuxtApp, plugins)
    expect(sequence).toMatchObject([
      'start A',
      'listen B',
    ])
  })
})
</file>

<file path="test/nuxt/polyfills.test.ts">
import { mount } from '@vue/test-utils'
import { describe, expect, it, vi } from 'vitest'
import { defineComponent, h } from 'vue'

describe('app/compat', () => {
  const Component = defineComponent({
    setup () {
      const visible = ref(false)
      setInterval(() => {
        visible.value = true
      }, 1000)

      return () => h('div', {}, visible.value ? h('span', { id: 'child' }) : {})
    },
  })
  it('setInterval is not auto-imported', async () => {
    vi.useFakeTimers()

    const wrapper = mount(Component)

    vi.advanceTimersByTime(1000)

    await wrapper.vm.$nextTick()

    expect(wrapper.find('#child').exists()).toBe(true)

    vi.useRealTimers()
  })
})
</file>

<file path="test/nuxt/router.options.test.ts">
/// <reference path="../fixtures/basic/.nuxt/nuxt.d.ts" />

import { afterAll, beforeAll, beforeEach, describe, expect, it, vi } from 'vitest'

import { mountSuspended } from '@nuxt/test-utils/runtime'
import type { VueWrapper } from '@vue/test-utils'
import { flushPromises } from '@vue/test-utils'
import { NuxtPage } from '#components'

describe('scrollBehavior of router options with global transition', () => {
  const router = useRouter()
  const nuxtApp = useNuxtApp()

  let wrapper: VueWrapper<unknown>
  let scrollTo: ReturnType<typeof vi.spyOn>
  const cleanups: Array<() => void> = []

  const pageTransitionFinish = vi.fn()
  const pageLoadingEnd = vi.fn()

  router.addRoute({
    name: 'transitions',
    path: '/transitions',
    component: NestedPageParent,
    children: [{ path: 'async', component: AsyncComponent }, { path: 'sync', component: SyncComponent }],
  })

  async function completeNavigation () {
    await flushPromises()

    // Ensure everything is settled
    await expect.poll(() => pageTransitionFinish.mock.calls.length).toBeGreaterThan(0)

    expect(pageTransitionFinish).toHaveBeenCalled()
    expect(pageLoadingEnd).toHaveBeenCalled()
  }

  beforeAll(async () => {
    cleanups.push(nuxtApp.hook('page:transition:finish', pageTransitionFinish))
    cleanups.push(nuxtApp.hook('page:loading:end', pageLoadingEnd))

    wrapper = await mountSuspended(defineComponent({
      setup: () => () => h(NuxtPage, {
        transition: {
          name: 'fade',
          mode: 'out-in',
          duration: 10,
        },
      }),
    }), { global: { stubs: { transition: false } } })
    await flushPromises()
  })

  beforeEach(async () => {
    await navigateTo('/')
    await flushPromises()
    vi.clearAllMocks()
    scrollTo = vi.spyOn(globalThis, 'scrollTo').mockImplementation(() => {})
  })

  afterAll(() => {
    router.removeRoute('transitions')
    wrapper.unmount()
    for (const cleanup of cleanups) {
      cleanup()
    }
  })

  it('should not trigger scrollTo when trailing slash is added/removed', async () => {
    await navigateTo('/about')
    await completeNavigation()

    expect(scrollTo).toHaveBeenCalled()
    vi.clearAllMocks()

    await navigateTo('/about/')
    await completeNavigation()

    expect(scrollTo).not.toHaveBeenCalled()
  })

  it('should call scrollTo after page transition is finished with async component', async () => {
    await navigateTo('/transitions/async')
    await completeNavigation()

    expect(scrollTo).toHaveBeenCalled()
    expect(pageTransitionFinish).toHaveBeenCalledBefore(scrollTo)
  })

  it('should call scrollTo after page transition is finished with sync component', async () => {
    await navigateTo('/transitions/sync')
    await completeNavigation()

    expect(scrollTo).toHaveBeenCalled()
    expect(pageTransitionFinish).toHaveBeenCalledBefore(scrollTo)
  })

  it('should set _runningTransition after page:start and be deleted after page:loading:end with async component', async () => {
    let runningTransitionAtStart: boolean | undefined
    let runningTransitionAtLoadingEnd: boolean | undefined

    const pageStartSpy = vi.fn(() => {
      runningTransitionAtStart = nuxtApp._runningTransition as boolean
    })
    const pageLoadingEndSpy = vi.fn(() => {
      runningTransitionAtLoadingEnd = nuxtApp._runningTransition as undefined
    })

    cleanups.push(nuxtApp.hook('page:start', pageStartSpy))
    cleanups.push(nuxtApp.hook('page:loading:end', pageLoadingEndSpy))

    await navigateTo('/transitions/async')

    // Ensure everything is settled
    await expect.poll(() => pageTransitionFinish.mock.calls.length).toBeGreaterThan(0)

    // Verify _runningTransition is true at page:start
    expect(runningTransitionAtStart).toBe(true)
    // Verify _runningTransition is still true at page:loading:end (not deleted yet)
    expect(runningTransitionAtLoadingEnd).toBeUndefined()
    // Verify _runningTransition is deleted after page:loading:end completes
    expect(nuxtApp._runningTransition).toBeUndefined()
    expect(pageStartSpy).toHaveBeenCalled()
    expect(pageLoadingEnd).toHaveBeenCalled()
    expect(scrollTo).toHaveBeenCalled()
    expect(pageTransitionFinish).toHaveBeenCalledBefore(scrollTo)
  })

  it('should set _runningTransition after page:start and be deleted after page:loading:end with sync component', async () => {
    let runningTransitionAtStart: boolean | undefined
    let runningTransitionAtLoadingEnd: boolean | undefined

    const pageStartSpy = vi.fn(() => {
      runningTransitionAtStart = nuxtApp._runningTransition as boolean
    })
    const pageLoadingEndSpy = vi.fn(() => {
      runningTransitionAtLoadingEnd = nuxtApp._runningTransition as undefined
    })

    cleanups.push(nuxtApp.hook('page:start', pageStartSpy))
    cleanups.push(nuxtApp.hook('page:loading:end', pageLoadingEndSpy))

    await navigateTo('/transitions/sync')

    // Ensure everything is settled
    await expect.poll(() => pageTransitionFinish.mock.calls.length).toBeGreaterThan(0)

    // Verify _runningTransition is true at page:start
    expect(runningTransitionAtStart).toBe(true)
    // Verify _runningTransition is still true at page:loading:end (not deleted yet)
    expect(runningTransitionAtLoadingEnd).toBeUndefined()
    // Verify _runningTransition is deleted after page:loading:end completes
    expect(nuxtApp._runningTransition).toBeUndefined()
    // Verify pageLoadingEnd and scrollTo are also called
    expect(pageStartSpy).toHaveBeenCalled()
    expect(pageLoadingEnd).toHaveBeenCalled()
    expect(scrollTo).toHaveBeenCalled()
    expect(pageTransitionFinish).toHaveBeenCalledBefore(scrollTo)
  })
})

const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))

const NestedPageParent = defineComponent({
  setup () {
    return () => h('div', [h(NuxtPage)])
  },
})

const SyncComponent = defineComponent({ setup: () => () => h('div') })
const AsyncComponent = defineComponent({
  async setup () {
    await sleep(10)
    return () => h('div')
  },
})
</file>

<file path="test/nuxt/tsconfig.json">
{
  "files": [],
  "references": [
    {
      "path": "../../.nuxt/tsconfig.app.json"
    },
    {
      "path": "../../.nuxt/tsconfig.server.json"
    },
    {
      "path": "../../.nuxt/tsconfig.shared.json"
    },
    {
      "path": "../../.nuxt/tsconfig.node.json"
    }
  ]
}
</file>

<file path="test/nuxt/use-async-data.test.ts">
/// <reference path="../fixtures/basic/.nuxt/nuxt.d.ts" />

import { beforeEach, describe, expect, it, vi } from 'vitest'
import { defineEventHandler } from 'h3'

import { mountSuspended, registerEndpoint } from '@nuxt/test-utils/runtime'

import { flushPromises } from '@vue/test-utils'
import { Transition } from 'vue'

import type { NuxtApp } from '#app/nuxt'
import { clearNuxtData, refreshNuxtData, useAsyncData, useLazyAsyncData, useNuxtData } from '#app/composables/asyncData'

registerEndpoint('/api/test', defineEventHandler(event => ({
  method: event.method,
  headers: Object.fromEntries(event.headers.entries()),
})))

registerEndpoint('/api/sleep', defineEventHandler((event) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ method: event.method, headers: Object.fromEntries(event.headers.entries()) })
    }, 100)
  })
}))

beforeEach(() => {
  vi.unstubAllGlobals()
})

describe('useAsyncData', () => {
  let uniqueKey: string
  let counter = 0

  beforeEach(() => {
    uniqueKey = `key-${++counter}`
  })

  function mountWithAsyncData (...args: any[]) {
    return new Promise<ReturnType<typeof useAsyncData> & ReturnType<typeof mountSuspended<unknown>>>((resolve) => {
      let res: ReturnType<typeof useAsyncData & ReturnType<typeof mountSuspended>>
      const component = defineComponent({
        setup () {
          res = useAsyncData(...args as [any])
          return () => h('div', [res.data.value as any])
        },
      })

      mountSuspended(component).then(c => resolve(Object.assign(c, res)))
    })
  }

  it('should work at basic level', async () => {
    const res = useAsyncData(() => Promise.resolve('test'))
    expect(Object.keys(res).sort()).toMatchInlineSnapshot(`
      [
        "clear",
        "data",
        "error",
        "execute",
        "pending",
        "refresh",
        "status",
      ]
    `)
    expect(res instanceof Promise).toBeTruthy()
    expect(res.data.value).toBe(undefined)
    await res
    expect(res.data.value).toBe('test')
  })

  it('should not execute with immediate: false', async () => {
    const immediate = await useAsyncData(() => Promise.resolve('test'))
    expect(immediate.data.value).toBe('test')
    expect(immediate.status.value).toBe('success')
    expect(immediate.pending.value).toBe(false)

    const nonimmediate = await useAsyncData(() => Promise.resolve('test'), { immediate: false })
    expect(nonimmediate.data.value).toBe(undefined)
    expect(nonimmediate.status.value).toBe('idle')
    expect(nonimmediate.pending.value).toBe(false)
  })

  it('should capture errors', async () => {
    vi.stubGlobal('__TEST_DEV__', true)

    const warn = vi.spyOn(console, 'warn').mockImplementation(() => {})

    const { data, error, status, pending } = await useAsyncData(uniqueKey, () => Promise.reject(new Error('test')), { default: () => 'default' })
    expect(data.value).toMatchInlineSnapshot('"default"')
    expect(error.value).toMatchInlineSnapshot('[Error: test]')
    expect(status.value).toBe('error')
    expect(pending.value).toBe(false)
    expect(useNuxtApp().payload._errors[uniqueKey]).toMatchInlineSnapshot('[Error: test]')

    const { data: syncedData, error: syncedError, status: syncedStatus, pending: syncedPending } = await useAsyncData(uniqueKey, () => ({} as any), { immediate: false })

    expect(syncedData.value).toBe(data.value)
    expect(syncedError.value).toBe(error.value)
    expect(syncedStatus.value).toBe(status.value)
    expect(syncedPending.value).toBe(false)

    expect(warn).toHaveBeenCalledWith(expect.stringMatching(
      /\[nuxt\] \[useAsyncData\] Incompatible options detected for "[^"]+" \(used at .*:\d+:\d+\):\n- different handler\n- different `default` value\nYou can use a different key or move the call to a composable to ensure the options are shared across calls./,
    ))
    warn.mockRestore()
    vi.unstubAllGlobals()
  })

  // https://github.com/nuxt/nuxt/issues/23411
  it('should initialize with error set to null when immediate: false', async () => {
    const { error, execute } = useAsyncData(() => Promise.resolve({}), { immediate: false })
    expect(error.value).toBe(undefined)
    await execute()
    expect(error.value).toBe(undefined)
  })

  it('should be accessible with useNuxtData', async () => {
    await useAsyncData(uniqueKey, () => Promise.resolve('test'))
    const data = useNuxtData(uniqueKey)
    expect(data.data.value).toMatchInlineSnapshot('"test"')
    clearNuxtData(uniqueKey)
    expect(data.data.value).toBeUndefined()
    expect(useNuxtData(uniqueKey).data.value).toBeUndefined()
  })

  it('should be usable _after_ a useNuxtData call', async () => {
    useNuxtApp().payload.data[uniqueKey] = null
    const { data: cachedData } = useNuxtData(uniqueKey)
    expect(cachedData.value).toMatchInlineSnapshot('null')
    const { data } = await useAsyncData(uniqueKey, () => Promise.resolve({ resolved: true }), { server: false })
    expect(cachedData.value).toMatchInlineSnapshot(`
      {
        "resolved": true,
      }
    `)
    expect(data.value).toStrictEqual(cachedData.value)
    clearNuxtData(uniqueKey)
  })

  it('should be usable _after_ a useNuxtData call after navigation', async () => {
    const getData = async () => {
      const wrapper = await mountSuspended(({
        async setup () {
          useNuxtData(uniqueKey)
          const { data } = await useAsyncData(uniqueKey, () => Promise.resolve('foo'))
          return () => h('div', [data.value])
        },
      }))
      try {
        return wrapper.html({ raw: true })
      } finally {
        wrapper.unmount()
      }
    }
    useNuxtApp().payload.data[uniqueKey] = null
    expect(await getData()).toMatchInlineSnapshot(`"<div>foo</div>"`)
    // simulate a second visit to the page
    expect(await getData()).toMatchInlineSnapshot(`"<div>foo</div>"`)
  })

  it('should be refreshable', async () => {
    await useAsyncData(uniqueKey, () => Promise.resolve('test'))
    clearNuxtData(uniqueKey)
    const data = useNuxtData(uniqueKey)
    expect(data.data.value).toBeUndefined()
    await refreshNuxtData(uniqueKey)
    expect(data.data.value).toMatchInlineSnapshot('"test"')
  })

  it('should allow overriding requests', async () => {
    vi.useFakeTimers()

    let count = 0
    let timeout = 0
    // pretending we're hydrating a server rendered app
    const nuxtApp = useNuxtApp()
    nuxtApp.payload.data[uniqueKey] = 1

    const fetcher = vi.fn(() => new Promise(resolve => setTimeout(() => resolve(++count), timeout)))
    const { data, refresh } = await useAsyncData(uniqueKey, fetcher, {
      getCachedData (key, nuxtApp, context) {
        // force bypass cache after first load (equivalent to previous `_initial: false`)
        if (context.cause === 'initial') {
          return nuxtApp.payload.data[key]
        }
      },
    })

    expect(fetcher).not.toHaveBeenCalled()
    expect.soft(count).toBe(0)
    expect.soft(data.value).toBe(1)

    timeout = 100
    const p = refresh({ dedupe: 'cancel' })

    expect(fetcher).toHaveBeenCalled()

    expect.soft(count).toBe(0)
    expect.soft(data.value).toBe(1)

    timeout = 0
    const refreshPromise = refresh()
    vi.advanceTimersByTime(0)
    await refreshPromise

    expect.soft(count).toBe(1)
    expect.soft(data.value).toBe(1)

    vi.advanceTimersByTime(100)
    await p

    expect.soft(count).toBe(2)
    expect.soft(data.value).toBe(1)

    vi.useRealTimers()
  })

  it('should be clearable', async () => {
    const { data, error, pending, status, clear } = await useAsyncData(() => Promise.resolve('test'))
    expect(data.value).toBe('test')

    clear()

    expect(data.value).toBeUndefined()
    expect(error.value).toBe(undefined)
    expect(pending.value).toBe(false)
    expect(status.value).toBe('idle')
  })

  it('should have correct status for previously fetched requests', async () => {
    vi.useFakeTimers()

    const route = useRoute()

    const res = await mountWithAsyncData(route.fullPath,
      async () => {
        await new Promise(resolve => setTimeout(resolve, 1))
        return 'test'
      }, { lazy: true },
    )

    expect(res.data.value).toBe(undefined)
    expect(res.status.value).toBe('pending')
    expect(res.pending.value).toBe(true)

    vi.advanceTimersByTime(1)
    await flushPromises()

    expect(res.data.value).toBe('test')
    expect(res.status.value).toBe('success')
    expect(res.pending.value).toBe(false)

    res.unmount()

    await flushPromises()

    expect(res.data.value).toBe(undefined)
    expect(res.status.value).toBe('idle')
    expect(res.pending.value).toBe(false)

    const res2 = await mountWithAsyncData(route.fullPath,
      async () => {
        await new Promise(resolve => setTimeout(resolve, 1))
        return 'test'
      }, { lazy: true },
    )

    expect(res2.data.value).toBe(undefined)
    expect(res2.status.value).toBe('pending')
    expect(res2.pending.value).toBe(true)

    vi.advanceTimersByTime(1)
    await flushPromises()

    expect(res2.data.value).toBe('test')
    expect(res2.status.value).toBe('success')
    expect(res2.pending.value).toBe(false)

    vi.useRealTimers()
  })

  it('should be refreshable with force and cache', async () => {
    await useAsyncData(uniqueKey, () => Promise.resolve('test'), {
      getCachedData: (key, nuxtApp, ctx) => {
        return ctx.cause
      },
    })
    await refreshNuxtData(uniqueKey)
    await nextTick()
    const data = useNuxtData(uniqueKey)
    expect(data.data.value).toMatchInlineSnapshot('"refresh:hook"')
  })

  it('allows custom access to a cache', async () => {
    const { data } = await useAsyncData(() => Promise.resolve({ val: true }), { getCachedData: () => ({ val: false }) })
    expect(data.value).toMatchInlineSnapshot(`
      {
        "val": false,
      }
    `)
  })

  it('should only call getCachedData once', async () => {
    const getCachedData = vi.fn(() => ({ val: false }))
    const { data } = await useAsyncData(() => Promise.resolve({ val: true }), { getCachedData })
    expect(data.value).toMatchInlineSnapshot(`
      {
        "val": false,
      }
    `)
    expect(getCachedData).toHaveBeenCalledTimes(1)
  })

  it('will use cache on refresh by default', async () => {
    const { data, refresh } = await useAsyncData(() => Promise.resolve('other value'), { getCachedData: () => 'cached' })
    expect(data.value).toBe('cached')
    await refresh()
    expect(data.value).toBe('cached')
  })

  it('getCachedData should receive triggeredBy on initial fetch', async () => {
    const { data } = await useAsyncData(() => Promise.resolve(''), { getCachedData: (key, nuxtApp, ctx) => ctx.cause })
    expect(data.value).toBe('initial')
  })

  it('getCachedData should receive triggeredBy on manual refresh', async () => {
    const { data, refresh } = await useAsyncData(() => Promise.resolve(''), {
      getCachedData: (key, nuxtApp, ctx) => ctx.cause,
    })
    await refresh()
    expect(data.value).toBe('refresh:manual')
  })

  it('getCachedData should receive triggeredBy on watch', async () => {
    const number = ref(0)
    const { data } = await useAsyncData(() => Promise.resolve(''), {
      getCachedData: (key, nuxtApp, ctx) => ctx.cause,
      watch: [number],
    })
    number.value = 1
    await flushPromises()
    expect(data.value).toBe('watch')
  })

  it('should use default while pending', async () => {
    const promise = useAsyncData(() => Promise.resolve('test'), { default: () => 'default' })
    const { data, pending } = promise

    expect(pending.value).toBe(true)
    expect(data.value).toMatchInlineSnapshot('"default"')

    await promise
    expect(data.value).toMatchInlineSnapshot('"test"')
  })

  it('should use default after reject', async () => {
    const { data } = await useAsyncData(() => Promise.reject(new Error('test')), { default: () => 'default' })
    expect(data.value).toMatchInlineSnapshot('"default"')
  })

  it('should execute the promise function once when dedupe option is "defer" for multiple calls', () => {
    const promiseFn = vi.fn(() => Promise.resolve('test'))
    useAsyncData(uniqueKey, promiseFn, { dedupe: 'defer' })
    useAsyncData(uniqueKey, promiseFn, { dedupe: 'defer' })
    useAsyncData(uniqueKey, promiseFn, { dedupe: 'defer' })

    expect(promiseFn).toHaveBeenCalledTimes(1)
  })

  it('should watch params deeply in a non synchronous way', async () => {
    const foo = ref('foo')
    const baz = ref('baz')
    const locale = ref('en')

    type Params = { deep: { baz: string }, foo?: string, locale?: string }
    const params = reactive<Params>({ deep: { baz: 'baz' } })

    watch(foo, (foo) => {
      params.foo = foo
      params.locale = locale.value
    }, { immediate: true })

    watch(baz, (baz) => {
      params.deep.baz = baz
    }, { immediate: true })

    const requestHistory: Array<Record<string, unknown>> = []

    // 1. first request
    await useAsyncData(uniqueKey, async () => {
      requestHistory.push(JSON.parse(JSON.stringify(params)))
      await Promise.resolve()
    }, { watch: [params] })

    // 2. second request
    foo.value = 'bar'
    locale.value = 'fr'
    // We need to wait for the debounce 0
    await new Promise(resolve => setTimeout(resolve, 5))

    // 3. third request
    baz.value = 'bar'
    await nextTick()

    expect(requestHistory).toEqual([
      {
        deep: { baz: 'baz' },
        foo: 'foo',
        locale: 'en',
      },
      {
        deep: { baz: 'baz' },
        foo: 'bar',
        locale: 'fr',
      },
      {
        deep: { baz: 'bar' },
        foo: 'bar',
        locale: 'fr',
      },
    ])
  })

  it('should execute the promise function multiple times when dedupe option is not specified for multiple calls', () => {
    const promiseFn = vi.fn(() => Promise.resolve('test'))
    useAsyncData(uniqueKey, promiseFn)
    useAsyncData(uniqueKey, promiseFn)
    useAsyncData(uniqueKey, promiseFn)

    expect(promiseFn).toHaveBeenCalledTimes(3)
  })

  it('should execute the promise function as per dedupe option when different dedupe options are used for multiple calls', () => {
    const promiseFn = vi.fn(() => Promise.resolve('test'))
    useAsyncData(uniqueKey, promiseFn, { dedupe: 'defer' })
    useAsyncData(uniqueKey, promiseFn)
    useAsyncData(uniqueKey, promiseFn, { dedupe: 'defer' })

    expect(promiseFn).toHaveBeenCalledTimes(2)
  })

  it('should warn if incompatible options are used', async () => {
    vi.stubGlobal('__TEST_DEV__', true)
    const warn = vi.spyOn(console, 'warn').mockImplementation(() => {})

    await mountWithAsyncData('dedupedKey3', () => Promise.resolve('test'), { deep: false })
    expect(warn).not.toHaveBeenCalled()
    await mountWithAsyncData('dedupedKey3', () => Promise.resolve('test'), { deep: true })
    expect(warn).toHaveBeenCalledWith(expect.stringMatching(
      /\[nuxt\] \[useAsyncData\] Incompatible options detected for "dedupedKey3" \(used at .*:\d+:\d+\):\n- mismatching `deep` option\nYou can use a different key or move the call to a composable to ensure the options are shared across calls./,
    ))

    let count = 0
    for (const opt of ['transform', 'pick', 'getCachedData'] as const) {
      warn.mockClear()
      count++

      await mountWithAsyncData(`${uniqueKey}-${count}`, () => Promise.resolve('test'), { [opt]: () => ({}) })
      await mountWithAsyncData(`${uniqueKey}-${count}`, () => Promise.resolve('test'), { [opt]: () => ({}) })
      expect(warn).not.toHaveBeenCalled()
      await mountWithAsyncData(`${uniqueKey}-${count}`, () => Promise.resolve('test'))
      expect(warn).toHaveBeenCalledWith(
        expect.stringMatching(
          new RegExp(`\\[nuxt\\] \\[useAsyncData\\] Incompatible options detected for "${uniqueKey}-${count}" \\(used at .*:\\d+:\\d+\\):\n- different \`${opt}\` option\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`),
        ))
    }

    warn.mockClear()
    count++

    await mountWithAsyncData(`${uniqueKey}-${count}`, () => Promise.resolve('test'))
    expect(warn).not.toHaveBeenCalled()
    await mountWithAsyncData(`${uniqueKey}-${count}`, () => Promise.resolve('bob'))
    expect(warn).toHaveBeenCalledWith(expect.stringMatching(
      new RegExp(`\\[nuxt\\] \\[useAsyncData\\] Incompatible options detected for "${uniqueKey}-${count}" \\(used at .*:\\d+:\\d+\\):\n- different handler\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`),
    ))

    warn.mockReset()
    vi.unstubAllGlobals()
  })

  it('should only refresh asyncdata once when watched dependency is updated', async () => {
    const promiseFn = vi.fn(() => Promise.resolve('test'))
    const route = ref('/')
    const component = defineComponent({
      setup () {
        const { data } = useAsyncData(uniqueKey, promiseFn, { watch: [route] })
        return () => h('div', [data.value])
      },
    })

    await mountSuspended(component)
    expect(promiseFn).toHaveBeenCalledTimes(1)

    await mountSuspended(component)
    expect(promiseFn).toHaveBeenCalledTimes(1)

    route.value = '/about'
    await nextTick()
    expect(promiseFn).toHaveBeenCalledTimes(2)
  })

  it('should work correctly with nested components accessing the same asyncData', async () => {
    const useCustomData = () => useAsyncData(uniqueKey, async () => {
      await Promise.resolve()
      return 'value'
    })

    const ChildComponent = defineComponent({
      setup () {
        const { data } = useCustomData()
        return () => h('div', ['Child ' + data.value])
      },
    })

    const ParentComponent = defineComponent({
      async setup () {
        const { data, pending } = await useCustomData()
        return () => h('div', [
          'Parent ' + data.value,
          h('br'),
          pending.value ? ' loading ... ' : h(ChildComponent),
        ])
      },
    })

    const wrapper = await mountSuspended(ParentComponent)
    await nextTick()
    await flushPromises()

    expect(wrapper.html()).not.toContain('loading')
  })

  const key = ref()
  const cases = [
    { name: 'ref', getter: key },
    { name: 'getter', getter: () => key.value },
  ]

  it.each(cases)('should work with keys computed from $name', async ({ name, getter }) => {
    const firstKey = `${name}-firstKey`
    const secondKey = `${name}-secondKey`
    key.value = firstKey

    const promiseFn = vi.fn(() => Promise.resolve(key.value))
    const component = defineComponent({
      setup () {
        const { data } = useAsyncData(getter, promiseFn)
        return () => h('div', [data.value])
      },
    })

    const comp = await mountSuspended(component)
    expect(promiseFn).toHaveBeenCalledTimes(1)

    key.value = secondKey
    await flushPromises()
    expect(promiseFn).toHaveBeenCalledTimes(2)

    expect(useNuxtData(firstKey).data.value).toBeUndefined()
    expect(useNuxtData(secondKey).data.value).toBe(secondKey)

    expect(useNuxtApp()._asyncData[firstKey]!.data.value).toBe(undefined)
    expect(useNuxtApp()._asyncData[secondKey]!.data.value).toBe(secondKey)

    comp.unmount()
  })

  it('should clear memory when last component using asyncData is unmounted', async () => {
    const key = 'several'
    const promiseFn = vi.fn(() => Promise.resolve('test'))
    const component = defineComponent({
      setup () {
        const { data } = useAsyncData(key, promiseFn)
        return () => h('div', [data.value])
      },
    })
    const getData = async () => {
      const component = await mountSuspended(defineComponent({
        setup () {
          const { data } = useNuxtData(key)
          return () => data.value === undefined ? 'undefined' : data.value
        },
      }))
      try {
        return component.html({ raw: true })
      } finally {
        component.unmount()
      }
    }

    const comp1 = await mountSuspended(component)
    expect(promiseFn).toHaveBeenCalledTimes(1)

    const comp2 = await mountSuspended(component)
    expect(promiseFn).toHaveBeenCalledTimes(1)

    comp1.unmount()
    await nextTick()
    expect(await getData()).toMatchInlineSnapshot('"test"')

    comp2.unmount()
    await nextTick()
    expect(await getData()).toBe('undefined')
  })

  it('should remain reactive after being reinitialised', async () => {
    const promiseFn = vi.fn((value: string) => Promise.resolve(value))
    const component = (value: string) => defineComponent({
      setup () {
        const { data } = useAsyncData('fixed', () => promiseFn(value))
        return () => h('div', [data.value])
      },
    })

    const comp1 = await mountSuspended(component('first'))
    expect(promiseFn).toHaveBeenCalledTimes(1)
    comp1.unmount()

    const comp2 = await mountSuspended(component('second'))
    expect(promiseFn).toHaveBeenCalledTimes(2)
    expect(promiseFn).toHaveBeenLastCalledWith('second')
    expect(comp2.html()).toMatchInlineSnapshot(`"<div>second</div>"`)
  })

  it('should be synced with useNuxtData', async () => {
    const { data: nuxtData } = useNuxtData('nuxtdata-sync')
    const promise = useAsyncData('nuxtdata-sync', () => Promise.resolve('test'), { default: () => 'default' })
    const { data: fetchData } = promise

    expect(fetchData.value).toMatchInlineSnapshot('"default"')

    nuxtData.value = 'before-fetch'
    expect(fetchData.value).toMatchInlineSnapshot('"before-fetch"')

    await promise
    expect(fetchData.value).toMatchInlineSnapshot('"test"')
    expect(nuxtData.value).toMatchInlineSnapshot('"test"')

    nuxtData.value = 'new value'
    expect(fetchData.value).toMatchInlineSnapshot('"new value"')
    fetchData.value = 'another value'
    expect(nuxtData.value).toMatchInlineSnapshot('"another value"')
  })

  it('should work when used in a Transition', async () => {
    const id = ref('foo')
    const ComponentWithAsyncData = defineComponent({
      props: { id: String },
      async setup (props) {
        const { data } = await useAsyncData(`quote:${props.id}`, () => Promise.resolve({ content: props.id }))
        return () => h('div', data.value?.content)
      },
    })
    const ComponentWithTransition = defineComponent({
      setup: () => () => h(Transition, { name: 'test' }, {
        default: () => h(ComponentWithAsyncData, { id: id.value, key: id.value }),
      }),
    })
    async function setTo (newId: string) {
      id.value = newId
      for (let i = 0; i < 5; i++) {
        await nextTick()
        await flushPromises()
      }
    }

    const wrapper = await mountSuspended(ComponentWithTransition, { global: { stubs: { transition: false } } })
    await setTo('foo')
    expect(wrapper.html()).toMatchInlineSnapshot(`"<div>foo</div>"`)

    await setTo('bar')
    expect(wrapper.html()).toMatchInlineSnapshot(`"<div class="">bar</div>"`)

    await setTo('foo')
    expect(wrapper.html()).toMatchInlineSnapshot(`"<div class="">foo</div>"`)
  })

  it('duplicate calls are not made after first call has finished', async () => {
    const handler = vi.fn(() => Promise.resolve('hello'))
    const getCachedData = vi.fn((key: string, nuxtApp: NuxtApp) => {
      return nuxtApp.payload.data[key]
    })

    function testAsyncData () {
      return useAsyncData(uniqueKey, handler, {
        getCachedData,
      })
    }

    const { status, data } = await testAsyncData()
    expect(status.value).toBe('success')
    expect(data.value).toBe('hello')
    expect(handler).toHaveBeenCalledTimes(1)
    expect.soft(getCachedData).toHaveBeenCalledTimes(1)

    const { status: status2, data: data2 } = testAsyncData()
    expect.soft(handler).toHaveBeenCalledTimes(1)
    expect.soft(getCachedData).toHaveBeenCalledTimes(1)
    expect.soft(data.value).toBe('hello')
    expect.soft(data2.value).toBe('hello')
    expect.soft(status.value).toBe('success')
    expect.soft(status2.value).toBe('success')

    await flushPromises()
    await nextTick()
    await flushPromises()

    expect.soft(handler).toHaveBeenCalledTimes(1)
    expect.soft(getCachedData).toHaveBeenCalledTimes(1)
  })

  it('should not execute if immediate is false and only the key changes', async () => {
    const promiseFn = vi.fn(() => Promise.resolve('test'))
    const key = shallowRef('a')
    const { status } = useAsyncData(key, promiseFn, { immediate: false })

    expect.soft(status.value).toBe('idle')
    expect.soft(promiseFn).toHaveBeenCalledTimes(0)

    key.value += 'a'
    await nextTick()
    expect.soft(status.value).toBe('idle')
    expect.soft(promiseFn).toHaveBeenCalledTimes(0)
  })

  it('should pick values from data', async () => {
    const { data } = await useAsyncData(() => Promise.resolve({ a: 1, b: 2 }), { pick: ['a'] })
    expect(data.value).toStrictEqual({ a: 1 })
  })

  it('should transform data', async () => {
    const { data } = await useAsyncData(() => Promise.resolve({ a: 1, b: 2 }), { transform: data => ({ c: data.a }) })
    expect(data.value).toStrictEqual({ c: 1 })
  })

  it('should use default value with lazy', async () => {
    vi.useFakeTimers()

    const { data, pending } = useLazyAsyncData(() => new Promise(resolve => setTimeout(() => resolve('test'), 10)), { default: () => 'default' })
    expect(pending.value).toBe(true)
    expect(data.value).toBe('default')

    vi.advanceTimersByTime(10)
    await flushPromises()

    expect(data.value).toBe('test')

    vi.useRealTimers()
  })

  it('should not execute with immediate: false and be executable', async () => {
    const promiseFn = vi.fn(() => Promise.resolve('test'))
    const { data, status, execute } = useAsyncData(promiseFn, { immediate: false })
    expect(data.value).toBe(undefined)
    expect(status.value).toBe('idle')
    expect(promiseFn).toHaveBeenCalledTimes(0)
    await execute()
    expect(data.value).toBe('test')
    expect(status.value).toBe('success')
    expect(promiseFn).toHaveBeenCalledTimes(1)
  })

  it('should handle being passed to watch', async () => {
    const q = ref<null | string>('test')
    const promiseFn = vi.fn(() => Promise.resolve('test'))
    const { execute } = useAsyncData(promiseFn, { immediate: false })
    expect(promiseFn).toHaveBeenCalledTimes(0)

    // @ts-expect-error type is not valid
    watch(q, execute)

    expect(promiseFn).toHaveBeenCalledTimes(0)

    q.value = null
    await nextTick()
    await flushPromises()
    expect(promiseFn).toHaveBeenCalledTimes(1)
  })

  it('should not refetch on the client when hydrating', () => {
    useNuxtData(uniqueKey).data.value = 'server-renderered'
    useNuxtApp().isHydrating = true
    const { data, status } = useAsyncData(uniqueKey, () => Promise.resolve('test'))
    expect(data.value).toBe('server-renderered')
    expect(status.value).toBe('success')
    useNuxtApp().isHydrating = false
  })

  it('should retain the old data when a computed key changes', async () => {
    vi.useFakeTimers()
    const page = ref('index')
    const promiseFn = vi.fn(() => new Promise(resolve => setTimeout(() => resolve(page.value), 100)))
    const { data, status } = useAsyncData(() => page.value, promiseFn)

    vi.advanceTimersToNextTimer()
    await flushPromises()
    expect(data.value).toBe('index')
    expect(promiseFn).toHaveBeenCalledTimes(1)

    page.value = 'about'
    await nextTick()
    await flushPromises()
    expect(promiseFn).toHaveBeenCalledTimes(2)
    expect(data.value).toBe('index')
    expect(status.value).toBe('pending')

    vi.advanceTimersToNextTimer()
    await flushPromises()
    await nextTick()
    expect(data.value).toBe('about')
    expect(promiseFn).toHaveBeenCalledTimes(2)
    vi.useRealTimers()
  })

  // https://github.com/nuxt/nuxt/issues/33274
  it('should not execute handler multiple times when external watch is defined before useAsyncData with computed key', async () => {
    const q = ref('')
    const promiseFn = vi.fn((query: string) => Promise.resolve(`result for: ${query}`))

    // watch must be defined before useAsyncData to reproduce the bug
    watch(q, () => {})

    const { data, error } = await useAsyncData(
      () => `query-${q.value}`,
      () => promiseFn(q.value),
      {
        watch: [q],
        immediate: true,
      },
    )

    // Initial execute
    expect(data.value).toBe('result for: ')
    expect(promiseFn).toHaveBeenCalledTimes(1)
    expect(promiseFn).toHaveBeenNthCalledWith(1, '')

    // First key change
    q.value = 's'
    await nextTick()
    await flushPromises()

    expect(promiseFn).toHaveBeenCalledTimes(2)
    expect(promiseFn).toHaveBeenNthCalledWith(2, 's')
    expect(error.value).toBe(undefined)
    expect(data.value).toBe('result for: s')

    // Second key change
    q.value = 'se'
    await nextTick()
    await flushPromises()

    expect(promiseFn).toHaveBeenCalledTimes(3)
    expect(promiseFn).toHaveBeenNthCalledWith(3, 'se')
    expect(error.value).toBe(undefined)
    expect(data.value).toBe('result for: se')
  })

  it('should automatically re-execute when watched dependency changes', async () => {
    const q = ref('')
    const promiseFn = vi.fn((query: string) => Promise.resolve(`result for: ${query}`))

    const externalWatchSpy = vi.fn()
    watch(q, externalWatchSpy)

    const { data, error } = await useAsyncData(
      () => `auto-query-${q.value}`,
      () => promiseFn(q.value),
      {
        watch: [q],
        immediate: true,
      },
    )

    expect(data.value).toBe('result for: ')
    expect(promiseFn).toHaveBeenCalledWith('')

    // First change triggers automatic request
    q.value = 's'
    await nextTick()
    await flushPromises()

    expect(error.value).toBe(undefined)
    expect(data.value).toBe('result for: s')
    expect(promiseFn).toHaveBeenCalledWith('s')

    // Second change
    q.value = 'se'
    await nextTick()
    await flushPromises()

    expect(error.value).toBe(undefined)
    expect(data.value).toBe('result for: se')
    expect(promiseFn).toHaveBeenCalledWith('se')

    expect(externalWatchSpy).toHaveBeenCalledTimes(2)
    expect(promiseFn).toHaveBeenCalledTimes(3) // initial + 2 changes
  })

  // https://github.com/nuxt/nuxt/issues/33777
  it('should continue watching params after reactive key changes', async () => {
    vi.useFakeTimers()
    try {
      const id = ref('1')
      const page = ref(0)
      const promiseFn = vi.fn((id: string, page: number) => Promise.resolve(`id: ${id}, page: ${page}`))

      const params = computed(() => ({ id: id.value, page: page.value }))

      const { data, error } = await useAsyncData(
        () => `data-${id.value}`,
        () => promiseFn(params.value.id, params.value.page),
        {
          watch: [params],
          immediate: true,
        },
      )

      // Initial call
      expect(data.value).toBe('id: 1, page: 0')
      expect(promiseFn).toHaveBeenCalledTimes(1)
      expect(promiseFn).toHaveBeenLastCalledWith('1', 0)

      // Change key: id changes from '1' to '2'
      id.value = '2'
      await nextTick()
      await flushPromises()
      await vi.advanceTimersByTimeAsync(5)

      expect(promiseFn).toHaveBeenCalledTimes(2)
      expect(promiseFn).toHaveBeenLastCalledWith('2', 0)
      expect(error.value).toBe(undefined)
      expect(data.value).toBe('id: 2, page: 0')

      // Verify params watcher continues to work after key change (issue #33777)
      page.value = 1
      await nextTick()
      await flushPromises()
      await vi.advanceTimersByTimeAsync(5)

      expect(promiseFn).toHaveBeenCalledTimes(3)
      expect(promiseFn).toHaveBeenLastCalledWith('2', 1)
      expect(error.value).toBe(undefined)
      expect(data.value).toBe('id: 2, page: 1')

      // Another params change to be thorough
      page.value = 2
      await nextTick()
      await flushPromises()
      await vi.advanceTimersByTimeAsync(5)

      expect(promiseFn).toHaveBeenCalledTimes(4)
      expect(promiseFn).toHaveBeenLastCalledWith('2', 2)
      expect(error.value).toBe(undefined)
      expect(data.value).toBe('id: 2, page: 2')
    } finally {
      vi.useRealTimers()
    }
  })

  it('should trigger AbortController on clear', () => {
    let aborted = false

    class Mock {
      signal = { aborted: false }
      abort = () => {
        this.signal.aborted = true
        aborted = true
      }
    }
    vi.stubGlobal('AbortController',
      Mock,
    )
    // Manual implementation of Promise.withResolvers for compatibility
    let resolve: (value: boolean) => void
    const promise = new Promise<boolean>((res) => { resolve = res })
    const { clear } = useAsyncData('', () => promise)
    expect(aborted).toBe(false)
    clear()
    resolve!(true)
    expect(aborted).toBe(true)
  })

  it('should be externally cancellable when executing', async () => {
    vi.useFakeTimers()
    const controller = new AbortController()
    const promiseFn = vi.fn(() => new Promise(resolve => setTimeout(() => resolve('index'), 1000)))
    const { execute, status } = useAsyncData(() => 'index', promiseFn)
    vi.advanceTimersToNextTimer()
    await flushPromises()
    expect(status.value).toBe('success')
    execute({ signal: controller.signal })
    vi.advanceTimersByTime(100)
    expect(status.value).toBe('pending')
    controller.abort('test abort')
    await flushPromises()
    expect(status.value).toBe('idle')
    vi.useRealTimers()
  })

  it('should be cancellable via abort', async () => {
    vi.useFakeTimers()
    let count = 0
    const promiseFn = vi.fn(() => new Promise(resolve => setTimeout(() => resolve(count++), 1000)))
    const { clear, status } = useAsyncData(promiseFn)
    expect(status.value).toBe('pending')
    clear()
    await nextTick()
    await flushPromises()
    expect(status.value).toBe('idle')
    expect(count).toBe(0)
    vi.useRealTimers()
  })

  it('should abort handler signal', async () => {
    vi.useFakeTimers()
    let _signal: AbortController['signal']
    const promiseFn = vi.fn((_, { signal }) => {
      _signal = signal
      return new Promise(resolve => setTimeout(() => resolve('index'), 1000))
    })
    const { clear, status } = useAsyncData(promiseFn)
    expect(status.value).toBe('pending')
    clear()
    await nextTick()
    await flushPromises()
    expect(_signal!.aborted).toBe(true)
    vi.useRealTimers()
  })

  it('should accept timeout', async () => {
    vi.useFakeTimers()
    const promiseFn = vi.fn(() => new Promise(resolve => setTimeout(() => resolve('index'), 1000)))
    const { status } = useAsyncData(promiseFn, { timeout: 1 })
    expect(status.value).toBe('pending')
    await vi.waitFor(() => { // todo: advanceTimersToNextTimer is not working here (?)
      expect(status.value).toBe('error')
    })
    vi.useRealTimers()
  })

  it('should handle already-aborted signal', async () => {
    const controller = new AbortController()
    controller.abort(new DOMException('Already aborted', 'AbortError'))

    const promiseFn = vi.fn(() => {
      return new Promise(resolve => setTimeout(() => resolve('test'), 100))
    })

    const { execute, status } = useAsyncData('already-aborted-test', promiseFn, {
      immediate: false,
    })

    execute({ signal: controller.signal })
    await flushPromises()

    // When signal is already aborted, the handler execution is aborted
    // so handler might not be called, and status is immediately set to idle
    expect(status.value).toBe('idle')
  })

  it('should merge multiple abort signals', async () => {
    vi.useFakeTimers()
    const controller1 = new AbortController()

    let receivedSignal: AbortSignal | undefined
    const promiseFn = vi.fn((_, { signal }) => {
      receivedSignal = signal
      return new Promise(resolve => setTimeout(() => resolve('test'), 1000))
    })

    const { execute, status, error } = useAsyncData('test-merge', promiseFn, { immediate: false })

    execute({ signal: controller1.signal })
    expect(status.value).toBe('pending')

    // Abort via first controller
    controller1.abort(new Error('Aborted by controller1'))
    await flushPromises()

    // External abort results in error state (not idle), with AbortError
    expect(status.value).toBe('error')
    expect(error.value).toBeTruthy()
    expect(receivedSignal?.aborted).toBe(true)

    vi.useRealTimers()
  })

  it('should work when AbortSignal.reason is unavailable (older browsers)', async () => {
    vi.useFakeTimers()

    // Mock older AbortController without .reason property
    class OldAbortController {
      signal: any = {
        aborted: false,
        addEventListener: vi.fn(),
        removeEventListener: vi.fn(),
      }

      abort () {
        this.signal.aborted = true
        // No reason property in old browsers
      }
    }

    vi.stubGlobal('AbortController', OldAbortController)

    const promiseFn = vi.fn(() => new Promise(resolve => setTimeout(() => resolve('test'), 1000)))

    const { clear, status } = useAsyncData(promiseFn)
    expect(status.value).toBe('pending')

    clear()
    await flushPromises()

    expect(status.value).toBe('idle')

    vi.unstubAllGlobals()
    vi.useRealTimers()
  })

  it('should handle abort during dedupe:defer', async () => {
    vi.useFakeTimers()
    let callCount = 0
    const promiseFn = vi.fn(() => new Promise(resolve => setTimeout(() => resolve(++callCount), 1000)))

    const { execute, clear, status } = useAsyncData(promiseFn, { dedupe: 'defer', immediate: false })

    execute()
    expect(status.value).toBe('pending')

    execute() // Should defer to existing request
    expect(promiseFn).toHaveBeenCalledTimes(1)

    clear() // Abort both
    await flushPromises()

    expect(status.value).toBe('idle')
    expect(callCount).toBe(0)

    vi.useRealTimers()
  })

  it('should handle abort during dedupe:cancel', async () => {
    vi.useFakeTimers()
    let abortedCount = 0
    const promiseFn = vi.fn((_, { signal }) => {
      signal.addEventListener('abort', () => abortedCount++)
      return new Promise(resolve => setTimeout(() => resolve('test'), 1000))
    })

    const { execute, status } = useAsyncData(promiseFn, { dedupe: 'cancel', immediate: false })

    execute()
    expect(status.value).toBe('pending')

    execute() // Should cancel previous and start new
    await flushPromises()

    expect(abortedCount).toBe(1) // First request was aborted
    expect(promiseFn).toHaveBeenCalledTimes(2)

    vi.useRealTimers()
  })

  it('should accept signal in refresh()', async () => {
    const controller = new AbortController()

    const promiseFn = vi.fn(() => Promise.resolve('test'))

    const { refresh, status } = await useAsyncData('refresh-signal-test', promiseFn)
    expect(status.value).toBe('success')

    refresh({ signal: controller.signal })
    // Abort with DOMException to get idle state
    controller.abort(new DOMException('Aborted', 'AbortError'))
    await flushPromises()

    // AbortError causes idle state (not error)
    expect(status.value).toBe('idle')
  })

  it('should clear error when clearing after error', async () => {
    const { data, error, status, clear } = await useAsyncData(() => Promise.reject(new Error('test error')))

    expect(status.value).toBe('error')
    expect(error.value).toBeTruthy()

    clear()

    expect(data.value).toBeUndefined()
    expect(error.value).toBe(undefined)
    expect(status.value).toBe('idle')
  })

  it('should abort ongoing request when clearing', async () => {
    vi.useFakeTimers()
    let aborted = false

    const promiseFn = vi.fn((_, { signal }) => {
      signal.addEventListener('abort', () => { aborted = true })
      return new Promise(resolve => setTimeout(() => resolve('test'), 1000))
    })

    const { clear, status } = useAsyncData(promiseFn)
    expect(status.value).toBe('pending')

    clear()
    await flushPromises()

    expect(aborted).toBe(true)
    expect(status.value).toBe('idle')

    vi.useRealTimers()
  })

  it('should resolve deduped promises at the same time', async () => {
    vi.useFakeTimers()
    let count = 0
    const promiseFn = vi.fn(() => new Promise(resolve => setTimeout(() => resolve(++count), 100)))

    const resolved = {
      p1: false,
      p2: false,
      p3: false,
      p4: false,
    }

    const p1 = useAsyncData('sameKey', promiseFn, { dedupe: 'cancel' })
    p1.then(() => { resolved.p1 = true })
    vi.advanceTimersByTime(90)

    const p2 = useAsyncData('sameKey', promiseFn, { dedupe: 'cancel' })
    const p3 = useAsyncData('sameKey', promiseFn, { dedupe: 'cancel' })
    const p4 = useAsyncData('sameKey', promiseFn, { dedupe: 'cancel' })
    p2.then(() => { resolved.p2 = true })
    p3.then(() => { resolved.p3 = true })
    p4.then(() => { resolved.p4 = true })

    vi.advanceTimersByTime(60)
    await flushPromises()
    expect(resolved).toEqual({ p1: false, p2: false, p3: false, p4: false })

    vi.advanceTimersByTime(40)
    const res = await Promise.all([p1, p2, p3, p4])

    expect(resolved).toEqual({ p1: true, p2: true, p3: true, p4: true })
    expect(promiseFn).toHaveBeenCalledTimes(4)

    for (const r of res) {
      expect(r.data.value).toBe(4)
    }

    vi.useRealTimers()
  })
})
</file>

<file path="test/nuxt/use-fetch.test.ts">
/// <reference path="../fixtures/basic/.nuxt/nuxt.d.ts" />

import { beforeEach, describe, expect, it, vi } from 'vitest'
import { defineEventHandler } from 'h3'

import { registerEndpoint } from '@nuxt/test-utils/runtime'

import { withQuery } from 'ufo'
import { flushPromises } from '@vue/test-utils'

import { useFetch, useLazyFetch } from '#app/composables/fetch'

interface TestData {
  method: string
  headers: Record<string, string>
}

registerEndpoint('/api/test', defineEventHandler(event => ({
  method: event.method,
  headers: Object.fromEntries(event.headers.entries()),
})))

registerEndpoint('/api/sleep', defineEventHandler((event) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ method: event.method, headers: Object.fromEntries(event.headers.entries()) })
    }, 100)
  })
}))

beforeEach(() => {
  vi.unstubAllGlobals()
})

describe('useFetch', () => {
  beforeEach(() => {
    clearNuxtData()
  })
  it('should match with/without computed values', async () => {
    const nuxtApp = useNuxtApp()
    const getPayloadEntries = () => Object.keys(nuxtApp.payload.data).length
    const baseCount = getPayloadEntries()

    await useFetch('/api/test')
    expect(getPayloadEntries()).toBe(baseCount + 1)

    /* @ts-expect-error Overriding auto-key */
    await useFetch('/api/test', { method: 'POST' }, '')
    /* @ts-expect-error Overriding auto-key */
    await useFetch('/api/test', { method: ref('POST') }, '')
    expect.soft(getPayloadEntries()).toBe(baseCount + 2)

    /* @ts-expect-error Overriding auto-key */
    await useFetch('/api/test', { query: { id: '3' } }, '')
    /* @ts-expect-error Overriding auto-key */
    await useFetch('/api/test', { query: { id: ref('3') } }, '')
    /* @ts-expect-error Overriding auto-key */
    await useFetch('/api/test', { params: { id: '3' } }, '')
    /* @ts-expect-error Overriding auto-key */
    await useFetch('/api/test', { params: { id: ref('3') } }, '')
    expect.soft(getPayloadEntries()).toBe(baseCount + 3)
  })

  it('should work with reactive keys', async () => {
    registerEndpoint('/api/initial', defineEventHandler(() => ({ url: '/api/initial' })))
    registerEndpoint('/api/updated', defineEventHandler(() => ({ url: '/api/updated' })))

    const key = ref('/api/initial')

    const { data, error } = await useFetch(key)
    expect(data.value).toEqual({ url: '/api/initial' })

    key.value = '/api/updated'

    await flushPromises()
    await nextTick()
    await flushPromises()

    expect(data.value).toEqual({ url: '/api/updated' })
    expect(error.value).toBe(undefined)
  })

  it('should not trigger rerunning fetch if `watch: false`', async () => {
    let count = 0
    registerEndpoint('/api/rerun', defineEventHandler(() => ({ count: count++ })))

    const q = ref('')
    const { data } = await useFetch('/api/rerun', {
      query: { q },
      watch: false,
    })

    expect(data.value).toStrictEqual({ count: 0 })
    q.value = 'test'

    await flushPromises()
    await nextTick()
    await flushPromises()

    expect(data.value).toStrictEqual({ count: 0 })
  })

  it.runIf(process.env.PROJECT === 'nuxt-legacy')('should work with reactive keys and immediate: false', async () => {
    registerEndpoint('/api/immediate-false', defineEventHandler(() => ({ url: '/api/immediate-false' })))

    const q = ref('')
    const { data } = await useFetch('/api/immediate-false', {
      query: { q },
      immediate: false,
    })

    expect(data.value).toBe(undefined)
    q.value = 'test'

    await flushPromises()
    await nextTick()
    await flushPromises()

    expect(data.value).toEqual({ url: '/api/immediate-false' })
  })

  it.runIf(process.env.PROJECT === 'nuxt-legacy')('should work with reactive request path and immediate: false', async () => {
    registerEndpoint('/api/immediate-false', defineEventHandler(() => ({ url: '/api/immediate-false' })))

    const q = ref('')
    const { data } = await useFetch(() => withQuery('/api/immediate-false', { q: q.value }), {
      immediate: false,
    })

    expect(data.value).toBe(undefined)
    q.value = 'test'

    await flushPromises()
    await nextTick()
    await flushPromises()

    expect(data.value).toEqual({ url: '/api/immediate-false' })
  })

  it('should be accessible immediately', async () => {
    registerEndpoint('/api/watchable-fetch', defineEventHandler(() => ({ url: '/api/watchable-fetch' })))

    const searchTerm = ref('')

    const { data } = await useFetch('/api/watchable-fetch', {
      params: { q: searchTerm },
    })

    for (const value of [undefined, 'pre', 'post', 'sync'] as const) {
      watchEffect(() => {
        expect(() => data.value).not.toThrow()
      }, { flush: value })
    }

    searchTerm.value = 'new'

    await nextTick()
    await flushPromises()
  })

  it('should handle complex objects in body', async () => {
    registerEndpoint('/api/complex-objects', defineEventHandler(() => ({ url: '/api/complex-objects' })))
    const formData = new FormData()
    formData.append('file', new File([], 'test.txt'))
    const testCases = [
      { ref: ref('test') },
      ref('test'),
      formData,
      new ArrayBuffer(),
    ]
    for (const value of testCases) {
      // @ts-expect-error auto-key is not valid in type signature
      const { data: original } = await useFetch('/api/complex-objects', { body: value }, 'autokey')
      original.value = 'new value'
      // @ts-expect-error auto-key is not valid in type signature
      const { data } = await useFetch('/api/complex-objects', { body: value, immediate: false }, 'autokey')
      expect(data.value).toEqual('new value')
    }
  })

  it('should timeout', async () => {
    vi.useFakeTimers()

    const fetchPromise = useFetch(
      // @ts-expect-error should resolve to a string
      () => new Promise(resolve => setTimeout(resolve, 5000)),
      { timeout: 1 },
    )

    vi.advanceTimersByTime(2000)

    const { status, error } = await fetchPromise

    expect(status.value).toBe('error')
    expect(error.value?.toString()).toContain(`<no response>`)

    vi.useRealTimers()
  })

  it.runIf(process.env.PROJECT === 'nuxt-legacy')('should fetch if immediate is false and only the key changes with `experimental.alwaysRunFetchOnKeyChange`', async () => {
    const key = shallowRef('a')
    const { status } = useFetch('/api/test', { key, immediate: false })

    expect.soft(status.value).toBe('idle')

    key.value += 'a'
    await nextTick()
    expect.soft(status.value).toBe('pending')
  })

  it('should handle parallel execute with `immediate: false`', async () => {
    const query = reactive({ q: 1 })
    const { execute, status } = useFetch(
      '/api/test',
      {
        query,
        immediate: false,
      },
    )
    watch(query, () => execute(), { once: true })

    expect.soft(status.value).toBe('idle')
    query.q++
    query.q++

    await nextTick()
    query.q++

    expect.soft(status.value).toBe('pending')
    await vi.waitFor(() => {
      expect(status.value).toBe('success')
    })
    query.q++
    expect.soft(status.value).toBe('pending')
  })

  it('should pick values from data', async () => {
    const { data } = await useFetch<TestData>('/api/test', { pick: ['method'] })
    expect(data.value).toEqual({ method: 'GET' })
  })

  it('should transform data', async () => {
    const { data } = await useFetch('/api/test', { transform: (data: TestData) => ({ custom: data.method }) })
    expect(data.value).toEqual({ custom: 'GET' })
  })

  it('should use default value with lazy', () => {
    const { data, pending } = useLazyFetch<TestData>('/api/test', { default: () => ({ method: 'default', headers: {} }) })
    expect(pending.value).toBe(true)
    expect(data.value).toEqual({ method: 'default', headers: {} })
    expect(data.value).not.toBeNull()
    expect(data.value.method).toEqual('default')
  })

  it('should not execute with immediate: false and be executable', async () => {
    const { data, status, execute } = useFetch<TestData>('/api/test', { immediate: false })
    expect(data.value).toBe(undefined)
    expect(status.value).toBe('idle')
    await execute()
    expect(data.value).not.toBeNull()
    if (data.value) {
      expect(data.value.method).toEqual('GET')
    }
    expect(status.value).toBe('success')
  })

  it('should cancel fetch request on clear', () => {
    let aborted = false

    class Mock {
      signal = { aborted: false }
      abort = () => {
        this.signal.aborted = true
        aborted = true
      }
    }
    vi.stubGlobal('AbortController',
      Mock,
    )
    const { clear } = useLazyFetch('/api/sleep')
    expect(aborted).toBe(false)
    clear()
    expect(aborted).toBe(true)
  })
})
</file>

<file path="test/runtime/app/router.options.ts">
import type { RouterOptions } from 'nuxt/schema'
import { defineComponent, h } from 'vue'

export default <RouterOptions> {
  routes (_routes) {
    return [
      {
        name: 'catchall',
        path: '/:catchAll(.*)*',
        component: defineComponent({
          name: 'catchall',
          setup: () => () => h('div', 'catchall'),
        }),
      },
    ]
  },
}
</file>

<file path="test/basic.test.ts">
import { readdir } from 'node:fs/promises'
import { fileURLToPath } from 'node:url'
import { describe, expect, it, vi } from 'vitest'
import { joinURL, withQuery } from 'ufo'
import { isCI, isWindows } from 'std-env'
import { join, normalize } from 'pathe'
import { $fetch, createPage, fetch, setup, startServer, url, useTestContext } from '@nuxt/test-utils/e2e'
import { $fetchComponent } from '@nuxt/test-utils/experimental'
import { createRegExp, exactly } from 'magic-regexp'
import type { NuxtIslandResponse } from 'nuxt/app'

import { asyncContext, builder, isDev, isRenderingJson, isTestingAppManifest, isWebpack } from './matrix'
import { expectNoClientErrors, gotoPath, parseData, parsePayload, renderPage } from './utils'

await setup({
  rootDir: fileURLToPath(new URL('./fixtures/basic', import.meta.url)),
  dev: isDev,
  server: true,
  browser: true,
  setupTimeout: (isWindows ? 360 : 120) * 1000,
  nuxtConfig: {
    hooks: {
      'modules:done' () {
        // TODO: investigate whether to upstream a fix to vite-plugin-vue or nuxt/test-utils
        // Vite reads its `isProduction` value from NODE_ENV and passes this to some plugins
        // like vite-plugin-vue
        if (!isDev) {
          process.env.NODE_ENV = 'production'
        }
      },
    },
  },
})

describe('server api', () => {
  it('should serialize', async () => {
    expect(await $fetch<string>('/api/hello')).toBe('Hello API')
    expect(await $fetch('/api/hey')).toEqual({
      foo: 'bar',
      baz: 'qux',
    })
  })

  it('should preserve states', async () => {
    expect(await $fetch('/api/counter')).toEqual({ count: 0 })
    expect(await $fetch('/api/counter')).toEqual({ count: 1 })
    expect(await $fetch('/api/counter')).toEqual({ count: 2 })
    expect(await $fetch('/api/counter')).toEqual({ count: 3 })
  })

  it('should auto-import', async () => {
    const res = await $fetch('/api/auto-imports')
    expect(res).toMatchInlineSnapshot(`
      {
        "autoImported": "utils",
        "fromServerDir": "test-utils",
        "thisIs": "serverAutoImported",
      }
    `)
  })
})

describe('route rules', () => {
  it('should enable spa mode', async () => {
    const headHtml = await $fetch<string>('/route-rules/spa')

    // SPA should render appHead tags
    expect(headHtml).toContain('<meta name="description" content="Nuxt Fixture">')
    expect(headHtml).toContain('<meta charset="utf-8">')
    expect(headHtml).toContain('<meta name="viewport" content="width=1024, initial-scale=1">')
    expect(headHtml.match(/<meta name="viewport" content="width=1024, initial-scale=1">/g)).toHaveLength(1)

    const { script, attrs } = parseData(headHtml)
    expect(script.serverRendered).toEqual(false)
    if (isRenderingJson) {
      expect(attrs['data-ssr']).toEqual('false')
    }
    await expectNoClientErrors('/route-rules/spa')
  })

  it('should not render loading template in spa mode if it is not enabled', async () => {
    const html = await $fetch<string>('/route-rules/spa')
    expect(html).toContain('<div id="__nuxt"></div>')
  })

  it('should allow defining route rules inline', async () => {
    const res = await fetch('/route-rules/inline')
    expect(res.status).toEqual(200)
    expect(res.headers.get('x-extend')).toEqual('added in routeRules')
  })

  it('test noScript routeRules', async () => {
    const html = await $fetch<string>('/no-scripts')
    expect(html).not.toContain('<script')
  })

  it('client-side navigation should redirect if hash included', async () => {
    const { page } = await renderPage('/')
    await page.waitForLoadState('networkidle')
    await page.getByTestId('route-rules-redirect').click()
    await vi.waitFor(() => page.url() === url('/#hello'), { timeout: 5_000 })
  })

  it('should run middleware defined in routeRules config', async () => {
    const html = await $fetch<string>('/route-rules/middleware')
    expect(html).toContain('Hello from routeRules!')
  })

  it('should set layout defined in routeRules config', async () => {
    const html = await $fetch<string>('/route-rules/layout')
    expect(html).toContain('Custom Layout')
  })
})

describe('modules', () => {
  it('should auto-register modules in ~/modules', async () => {
    const result = await $fetch<string>('/auto-registered-module')
    expect(result).toEqual('handler added by auto-registered module')
  })
})

describe('pages', () => {
  it('render index', async () => {
    const html = await $fetch<string>('/')

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    // should render text
    expect(html).toContain('Hello Nuxt 3!')
    // should inject runtime config
    expect(html).toContain('RuntimeConfig | testConfig: 123')
    expect(html).toContain('needsFallback:')
    // composables auto import
    expect(html).toContain('Composable | foo: auto imported from ~/composables/foo.ts')
    expect(html).toContain('Composable | bar: auto imported from ~/utils/useBar.ts')
    expect(html).toContain('Composable | template: auto imported from ~/composables/template.ts')
    expect(html).toContain('Composable | star: auto imported from ~/composables/nested/bar.ts via star export')
    // should import components
    expect(html).toContain('This is a custom component with a named export.')
    // should remove dev-only and replace with any fallback content
    expect(html).toContain(isDev ? 'Some dev-only info' : 'Some prod-only info')
    // should apply attributes to client-only components
    expect(html).toContain('<div style="color:red;" class="client-only"></div>')
    // should render server-only components
    expect(html.replaceAll(/ data-island-uid="[^"]*"/g, '')).toContain('<div class="server-only" style="background-color:gray;"> server-only component <div> server-only component child (non-server-only) </div></div>')
    // should register global components automatically
    expect(html).toContain('global component registered automatically')
    expect(html).toContain('global component via suffix')
    expect(html).toContain('This is a synchronously registered global component')

    await expectNoClientErrors('/')
  })

  it('supports jsx', async () => {
    const html = await $fetch<string>('/jsx')

    // should import JSX/TSX components with custom elements
    expect(html).toContain('TSX component')
    expect(html).toContain('<custom-component>custom</custom-component>')
    expect(html).toContain('Sugar Counter 12 x 2 = 24')
  })

  it('respects aliases in page metadata', async () => {
    const html = await $fetch<string>('/some-alias')
    expect(html).toContain('Hello Nuxt 3!')
  })

  it('respects redirects in page metadata', async () => {
    const { headers } = await fetch('/redirect', { redirect: 'manual' })
    expect(headers.get('location')).toEqual('/')
  })

  it('allows routes to be added dynamically', async () => {
    const html = await $fetch<string>('/add-route-test')
    expect(html).toContain('Hello Nuxt 3!')
  })

  it('includes page metadata from pages added in pages:extend hook', async () => {
    const res = await fetch('/page-extend')
    expect(res.headers.get('x-extend')).toEqual('added in pages:extend')
  })

  it('preserves page metadata added in pages:extend hook', async () => {
    const html = await $fetch<string>('/some-custom-path')
    expect (html.match(/<pre>([^<]*)<\/pre>/)?.[1]?.trim().replace(/&quot;/g, '"').replace(/&gt;/g, '>')).toMatchInlineSnapshot(`
      "{
        "name": "some-custom-name",
        "path": "/some-custom-path",
        "validate": "() => true",
        "middleware": [
          "() => true"
        ],
        "otherValue": "{\\"foo\\":\\"bar\\"}"
      }"
    `)
  })

  it('validates routes', async () => {
    const { status, headers } = await fetch('/catchall/forbidden')
    expect(status).toEqual(404)
    expect(headers.get('Set-Cookie')).toBe('set-in-plugin=true; Path=/')

    const { page } = await renderPage('/navigate-to-forbidden')

    await page.getByText('should throw a 404 error').click()
    expect(await page.getByRole('heading').textContent()).toMatchInlineSnapshot('"Page Not Found: /catchall/forbidden"')
    expect(await page.getByTestId('path').textContent()).toMatchInlineSnapshot('" Path: /catchall/forbidden"')

    await gotoPath(page, '/navigate-to-forbidden')
    await page.getByText('should be caught by catchall').click()
    expect(await page.getByRole('heading').textContent()).toMatchInlineSnapshot('"[...slug].vue"')

    await page.close()
  })

  it('validates routes with custom statusCode and statusMessage', async () => {
    const CUSTOM_ERROR_CODE = 401
    const CUSTOM_ERROR_MESSAGE = 'Custom error message'
    const ERROR_PAGE_TEXT = 'This is the error page'
    const PAGE_TEXT = 'You should not see this'

    // Check status code and message on fetch
    const res = await fetch('/validate-custom-error')
    const serverText = await res.text()

    expect(res.status).toEqual(CUSTOM_ERROR_CODE)
    expect(serverText).toContain(CUSTOM_ERROR_MESSAGE)
    expect(serverText).not.toContain(PAGE_TEXT)

    // Client-side navigation
    const { page } = await renderPage('/navigate-to-validate-custom-error')
    await page.getByText('should throw a 401 error with custom message').click()
    // error.vue has an h1 tag
    await page.waitForSelector('h1')

    const clientText = await page.innerText('body')

    expect(clientText).toContain(CUSTOM_ERROR_MESSAGE)
    expect(clientText).toContain(ERROR_PAGE_TEXT)
    expect(clientText).not.toContain(PAGE_TEXT)

    await page.close()

    // Server-side navigation
    const { page: serverPage } = await renderPage('/validate-custom-error')
    const serverPageText = await serverPage.innerText('body')

    expect(serverPageText).toContain(CUSTOM_ERROR_MESSAGE)
    expect(serverPageText).toContain(ERROR_PAGE_TEXT)
    expect(serverPageText).not.toContain(PAGE_TEXT)

    await serverPage.close()
  })

  it.runIf(isDev)('returns 500 when there is an infinite redirect', async () => {
    const { status } = await fetch('/catchall/redirect-infinite', { redirect: 'manual' })
    expect(status).toEqual(500)
  })

  it('render catchall page', async () => {
    const res = await fetch('/catchall/not-found')
    expect(res.status).toEqual(200)

    const html = await res.text()

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    expect(html).toContain('[...slug].vue')
    expect(html).toContain('catchall at not-found')

    // Middleware still runs after validation: https://github.com/nuxt/nuxt/issues/15650
    expect(html).toContain('Middleware ran: true')

    await expectNoClientErrors('/catchall/not-found')
  })

  it('should render correctly when loaded on a different path', async () => {
    const { page, pageErrors } = await renderPage()
    await page.goto(url('/proxy'))
    await page.waitForFunction(() => window.useNuxtApp?.() && !window.useNuxtApp?.().isHydrating)

    expect(await page.innerText('body')).toContain('Composable | foo: auto imported from ~/composables/foo.ts')
    expect(pageErrors).toEqual([])

    await page.close()
  })

  it('preserves query', async () => {
    const html = await $fetch<string>('/?test=true')

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    // should render text
    expect(html).toContain('Path: /?test=true')

    await expectNoClientErrors('/?test=true')
  })

  it('/nested/[foo]/[bar].vue', async () => {
    const html = await $fetch<string>('/nested/one/two')

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    expect(html).toContain('nested/[foo]/[bar].vue')
    expect(html).toContain('foo: one')
    expect(html).toContain('bar: two')
  })

  it('/nested/[foo]/index.vue', async () => {
    const html = await $fetch<string>('/nested/foobar')

    // TODO: should resolved to same entry
    // const html2 = await $fetch<string>('/nested/foobar/index')
    // expect(html).toEqual(html2)

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    expect(html).toContain('nested/[foo]/index.vue')
    expect(html).toContain('foo: foobar')

    await expectNoClientErrors('/nested/foobar')
  })

  it('/nested/[foo]/user-[group].vue', async () => {
    const html = await $fetch<string>('/nested/foobar/user-admin')

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    expect(html).toContain('nested/[foo]/user-[group].vue')
    expect(html).toContain('foo: foobar')
    expect(html).toContain('group: admin')

    await expectNoClientErrors('/nested/foobar/user-admin')
  })

  it('/parent', async () => {
    const html = await $fetch<string>('/parent')
    expect(html).toContain('parent/index')

    await expectNoClientErrors('/parent')
  })

  it('/another-parent', async () => {
    const html = await $fetch<string>('/another-parent')
    expect(html).toContain('another-parent/index')

    await expectNoClientErrors('/another-parent')
  })

  it('/client-server', async () => {
    // expect no hydration issues
    await expectNoClientErrors('/client-server')
    const { page } = await renderPage('/client-server')
    const bodyHTML = await page.innerHTML('body')
    expect(await page.locator('.placeholder-to-ensure-no-override').all()).toHaveLength(5)
    expect(await page.locator('.server').all()).toHaveLength(0)
    expect(await page.locator('.client-fragment-server.client').all()).toHaveLength(2)
    expect(await page.locator('.client-fragment-server-fragment.client').all()).toHaveLength(2)
    expect(await page.locator('.client-server.client').all()).toHaveLength(1)
    expect(await page.locator('.client-server-fragment.client').all()).toHaveLength(1)
    expect(await page.locator('.client-server-fragment.client').all()).toHaveLength(1)

    expect(bodyHTML).not.toContain('hello')
    expect(bodyHTML).toContain('world')
    await page.close()
  })

  it('/client-only-components', async () => {
    const html = await $fetch<string>('/client-only-components')
    // ensure fallbacks with classes and arbitrary attributes are rendered
    expect(html).toContain('<div class="client-only-script" foo="bar">')
    expect(html).toContain('<div class="client-only-script-setup" foo="hello">')
    expect(html).toContain('<div>Fallback</div>')
    // ensure components are not rendered server-side
    expect(html).not.toContain('Should not be server rendered')

    const { page, pageErrors } = await renderPage('/client-only-components')

    const hiddenSelectors = [
      '.string-stateful-should-be-hidden',
      '.client-script-should-be-hidden',
      '.string-stateful-script-should-be-hidden',
      '.no-state-hidden',
    ]
    const visibleSelectors = [
      '.string-stateful',
      '.string-stateful-script',
      '.client-only-script',
      '.client-only-script-setup',
      '.no-state',
    ]

    // ensure directives are correctly applied
    await Promise.all(hiddenSelectors.map(selector => page.locator(selector).isHidden()))
      .then(results => results.forEach(isHidden => expect(isHidden).toBeTruthy()))
    // ensure hidden components are still rendered
    await Promise.all(hiddenSelectors.map(selector => page.locator(selector).innerHTML()))
      .then(results => results.forEach(innerHTML => expect(innerHTML).not.toBe('')))

    // ensure single root node components are rendered once on client (should not be empty)
    await Promise.all(visibleSelectors.map(selector => page.locator(selector).innerHTML()))
      .then(results => results.forEach(innerHTML => expect(innerHTML).not.toBe('')))

    // issue #20061
    expect(await page.$eval('.client-only-script-setup', e => getComputedStyle(e).backgroundColor)).toBe('rgb(255, 0, 0)')

    // ensure multi-root-node is correctly rendered
    expect(await page.locator('.multi-root-node-count').innerHTML()).toContain('0')
    expect(await page.locator('.multi-root-node-button').innerHTML()).toContain('add 1 to count')
    expect(await page.locator('.multi-root-node-script-count').innerHTML()).toContain('0')
    expect(await page.locator('.multi-root-node-script-button').innerHTML()).toContain('add 1 to count')

    // ensure components reactivity
    await page.locator('.multi-root-node-button').click()
    await page.locator('.multi-root-node-script-button').click()
    await page.locator('.client-only-script button').click()
    await page.locator('.client-only-script-setup button').click()

    expect(await page.locator('.multi-root-node-count').innerHTML()).toContain('1')
    expect(await page.locator('.multi-root-node-script-count').innerHTML()).toContain('1')
    expect(await page.locator('.client-only-script-setup button').innerHTML()).toContain('1')
    expect(await page.locator('.client-only-script button').innerHTML()).toContain('1')

    // ensure components ref is working and reactive
    await page.locator('button.test-ref-1').click()
    await page.locator('button.test-ref-2').click()
    await page.locator('button.test-ref-3').click()
    await page.locator('button.test-ref-4').click()
    expect(await page.locator('.client-only-script-setup button').innerHTML()).toContain('2')
    expect(await page.locator('.client-only-script button').innerHTML()).toContain('2')
    expect(await page.locator('.string-stateful-script').innerHTML()).toContain('1')
    expect(await page.locator('.string-stateful').innerHTML()).toContain('1')
    const waitForConsoleLog = page.waitForEvent('console', consoleLog => consoleLog.text() === 'has $el')

    // ensure directives are reactive
    await page.locator('button#show-all').click()
    await Promise.all(hiddenSelectors.map(selector => page.locator(selector).isVisible()))
      .then(results => results.forEach(isVisible => expect(isVisible).toBeTruthy()))

    await waitForConsoleLog
    expect(pageErrors).toEqual([])
    await page.close()
    // don't expect any errors or warning on client-side navigation
    const { page: page2, consoleLogs: consoleLogs2 } = await renderPage('/')
    await page2.locator('#to-client-only-components').click()
    await page2.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/client-only-components')
    expect(consoleLogs2.some(log => log.type === 'error' || log.type === 'warning')).toBeFalsy()
    await page2.close()
  })

  it('/wrapper-expose/layout', async () => {
    const { page, consoleLogs, pageErrors } = await renderPage('/wrapper-expose/layout')
    await page.locator('.log-foo').first().click()
    expect(pageErrors.at(-1)?.toString() || consoleLogs.at(-1)!.text).toContain('.logFoo is not a function')
    await page.locator('.log-hello').first().click()
    expect(consoleLogs.at(-1)!.text).toContain('world')
    await page.locator('.add-count').first().click()
    expect(await page.locator('.count').first().innerText()).toContain('1')

    // change layout
    await page.locator('.swap-layout').click()
    await page.waitForFunction(() => document.querySelector('.count')?.innerHTML.includes('0'))
    await page.locator('.log-foo').first().click()
    expect(consoleLogs.at(-1)!.text).toContain('bar')
    await page.locator('.log-hello').first().click()
    expect(pageErrors.at(-1)?.toString() || consoleLogs.at(-1)!.text).toContain('.logHello is not a function')
    await page.locator('.add-count').first().click()
    await page.waitForFunction(() => document.querySelector('.count')?.innerHTML.includes('1'))
    // change layout
    await page.locator('.swap-layout').click()
    await page.waitForFunction(() => document.querySelector('.count')?.innerHTML.includes('0'))
    await page.close()
  })

  it('/client-only-explicit-import', async () => {
    const html = await $fetch<string>('/client-only-explicit-import')

    // ensure fallbacks with classes and arbitrary attributes are rendered
    expect(html).toContain('<div class="client-only-script" foo="bar">')
    expect(html).toContain('<div class="lazy-client-only-script-setup" foo="hello">')
    // ensure components are not rendered server-side
    expect(html).not.toContain('client only script')
    await expectNoClientErrors('/client-only-explicit-import')
  })

  it('/wrapper-expose/page', async () => {
    const { page, pageErrors, consoleLogs } = await renderPage('/wrapper-expose/page')
    await page.waitForLoadState('networkidle')
    await page.locator('#log-foo').click()
    expect(consoleLogs.at(-1)?.text).toBe('bar')
    // change page
    await page.locator('#to-hello').click()
    await page.locator('#log-foo').click()
    expect(pageErrors.at(-1)?.toString() || consoleLogs.at(-1)!.text).toContain('.foo is not a function')
    await page.locator('#log-hello').click()
    expect(consoleLogs.at(-1)?.text).toBe('world')
    await page.close()
  })

  it('client-fallback', async () => {
    const classes = [
      'clientfallback-non-stateful-setup',
      'clientfallback-non-stateful',
      'clientfallback-stateful-setup',
      'clientfallback-stateful',
      'clientfallback-async-setup',
    ]
    const html = await $fetch<string>('/client-fallback')
    // ensure failed components are not rendered server-side
    expect(html).not.toContain('This breaks in server-side setup.')
    classes.forEach(c => expect(html).not.toContain(c))
    // ensure not failed component not be rendered
    expect(html).not.toContain('Sugar Counter 12 x 0 = 0')
    // ensure NuxtClientFallback is being rendered with its fallback tag and attributes
    expect(html).toContain('<span class="break-in-ssr">this failed to render</span>')
    // ensure Fallback slot is being rendered server side
    expect(html).toContain('Hello world !')

    // ensure not failed component are correctly rendered
    expect(html).not.toContain('<p></p>')
    expect(html).toContain('hi')

    // async setup
    expect(html).toContain('Work with async setup')

    const { page, pageErrors } = await renderPage('/client-fallback')
    // ensure components reactivity once mounted
    await page.locator('#increment-count').click()
    expect(await page.locator('#sugar-counter').innerHTML()).toContain('Sugar Counter 12 x 1 = 12')
    // keep-fallback strategy
    expect(await page.locator('#keep-fallback').all()).toHaveLength(1)
    // #20833
    expect(await page.locator('body').innerHTML()).not.toContain('Hello world !')
    expect(pageErrors).toEqual([])
    await page.close()
  })

  it('/legacy-async-data-fail', async () => {
    const response = await fetch('/legacy-async-data-fail').then(r => r.text())
    expect(response).not.toContain('don\'t look at this')
    expect(response).toContain('OH NNNNNNOOOOOOOOOOO')
  })

  it('client only page', async () => {
    const response = await fetch('/client-only-page').then(r => r.text())

    // Should not contain rendered page on initial request
    expect(response).not.toContain('"hasAccessToWindow": true')
    expect(response).not.toContain('"isServer": false')

    const errors: string[] = []
    const { page: clientInitialPage } = await renderPage('/client-only-page')

    clientInitialPage.on('console', (message) => {
      const type = message.type()
      if (type === 'error' || type === 'warning') {
        errors.push(message.text())
      }
    })

    // But after hydration element should appear and contain this object
    expect(await clientInitialPage.locator('#state').textContent()).toMatchInlineSnapshot(`
      "{
        "hasAccessToWindow": true,
        "isServer": false
      }"
    `)

    expect(await clientInitialPage.locator('#server-rendered').textContent()).toMatchInlineSnapshot('"false"')

    // Then go to non client only page
    await clientInitialPage.click('a')
    await clientInitialPage.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/client-only-page/normal')

    // that page should be client rendered
    expect(await clientInitialPage.locator('#server-rendered').textContent()).toMatchInlineSnapshot('"false"')
    // and not contain any errors or warnings
    expect(errors.length).toBe(0)

    await clientInitialPage.close()
    errors.length = 0

    const { page: normalInitialPage } = await renderPage('/client-only-page/normal')

    normalInitialPage.on('console', (message) => {
      const type = message.type()
      if (type === 'error' || type === 'warning') {
        errors.push(message.text())
      }
    })

    // Now non client only page should be sever rendered
    expect(await normalInitialPage.locator('#server-rendered').textContent()).toMatchInlineSnapshot('"true"')

    // Go to client only page
    await normalInitialPage.click('a')

    await normalInitialPage.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/client-only-page')

    // and expect same object to be present
    expect(await normalInitialPage.locator('#state').textContent()).toMatchInlineSnapshot(`
      "{
        "hasAccessToWindow": true,
        "isServer": false
      }"
    `)

    // also there should not be any errors
    expect(errors.length).toBe(0)

    await normalInitialPage.close()
  })

  it('groups routes', async () => {
    for (const targetRoute of ['/group-page', '/nested-group/group-page', '/nested-group']) {
      const { status } = await fetch(targetRoute)

      expect(status).toBe(200)
    }
  })

  it.skipIf(isDev)('prerenders pages hinted with a route rule', async () => {
    const html = await $fetch('/prerender/test')
    expect(html).toContain('should be prerendered: true')
  })

  it('renders pages with special characters in route', async () => {
    const html = await $fetch('/non-ascii/ç')
    // Verify page renders successfully with layout
    expect(html).toContain('Extended layout from foo')
  })

  it.skipIf(isDev)('prerenders pages with special characters', async () => {
    const html = await $fetch('/prerender/ç')
    expect(html).toContain('should be prerendered: true')
  })

  it('should trigger page:loading:end only once', async () => {
    const { page, consoleLogs } = await renderPage('/')

    await page.getByText('to page load hook').click()
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/page-load-hook')
    const loadingEndLogs = consoleLogs.filter(c => c.text.includes('page:loading:end'))
    expect(loadingEndLogs.length).toBe(1)

    await page.close()
  })

  it('should hide nuxt page load indicator after navigate back from nested page', async () => {
    const LOAD_INDICATOR_SELECTOR = '.nuxt-loading-indicator'
    const { page } = await renderPage('/page-load-hook')
    await page.getByText('To sub page').click()
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/page-load-hook/subpage')

    await page.waitForSelector(LOAD_INDICATOR_SELECTOR)
    let isVisible = await page.isVisible(LOAD_INDICATOR_SELECTOR)
    expect(isVisible).toBe(true)

    await page.waitForSelector(LOAD_INDICATOR_SELECTOR, { state: 'hidden' })
    isVisible = await page.isVisible(LOAD_INDICATOR_SELECTOR)
    expect(isVisible).toBe(false)

    await page.goBack()

    await page.waitForSelector(LOAD_INDICATOR_SELECTOR)
    isVisible = await page.isVisible(LOAD_INDICATOR_SELECTOR)
    expect(isVisible).toBe(true)

    await page.waitForSelector(LOAD_INDICATOR_SELECTOR, { state: 'hidden' })
    isVisible = await page.isVisible(LOAD_INDICATOR_SELECTOR)
    expect(isVisible).toBe(false)

    await page.close()
  })
})

describe('nuxt composables', () => {
  it('has useRequestURL()', async () => {
    const html = await $fetch<string>('/url')
    expect(html).toContain('path: /url')
  })
  it('sets cookies correctly', async () => {
    const res = await fetch('/cookies', {
      headers: {
        cookie: Object.entries({
          'browser-accessed-but-not-used': 'provided-by-browser',
          'browser-accessed-with-default-value': 'provided-by-browser',
          'browser-set': 'provided-by-browser',
          'browser-set-to-null': 'provided-by-browser',
          'browser-set-to-null-with-default': 'provided-by-browser',
        }).map(([key, value]) => `${key}=${value}`).join('; '),
      },
    })
    const cookies = res.headers.get('set-cookie')
    expect(cookies).toMatchInlineSnapshot('"set-in-plugin=true; Path=/, accessed-with-default-value=default; Path=/, set=set; Path=/, browser-set=set; Path=/, browser-set-to-null=; Max-Age=0; Path=/, browser-set-to-null-with-default=; Max-Age=0; Path=/, browser-object-default=%7B%22foo%22%3A%22bar%22%7D; Path=/, theCookie=show; Path=/"')
  })
  it('updates cookies when they are changed', async () => {
    const { page } = await renderPage('/cookies')
    async function extractCookie () {
      const cookie = await page.evaluate(() => document.cookie)
      const raw = cookie.match(/browser-object-default=([^;]*)/)![1] ?? 'null'
      return JSON.parse(decodeURIComponent(raw))
    }
    expect(await extractCookie()).toEqual({ foo: 'bar' })
    await page.getByText('Change cookie').click()
    expect(await extractCookie()).toEqual({ foo: 'baz' })
    let text = await page.innerText('pre')
    expect(text).toContain('baz')
    await page.getByText('Change cookie').click()
    expect(await extractCookie()).toEqual({ foo: 'bar' })
    await page.evaluate(() => { document.cookie = `browser-object-default=${encodeURIComponent('{"foo":"foobar"}')}` })
    await page.getByText('Refresh cookie').click()
    text = await page.innerText('pre')
    expect(text).toContain('foobar')
    await page.close()
  })

  it('sets cookies in composable to null in all components', async () => {
    const { page } = await renderPage('/cookies')
    const parentBannerText = await page.locator('#parent-banner').textContent()
    expect(parentBannerText).toContain('parent banner')

    const childBannerText = await page.locator('#child-banner').innerText()
    expect(childBannerText).toContain('child banner')

    // Clear the composable cookie
    await page.getByText('Toggle cookie banner').click()
    await page.evaluate(() => new Promise(resolve => setTimeout(resolve, 10)))

    const parentBannerAfterToggle = await page.locator('#parent-banner').isVisible()
    expect(parentBannerAfterToggle).toBe(false)

    const childBannerAfterToggle = await page.locator('#child-banner').isVisible()
    expect(childBannerAfterToggle).toBe(false)
    await page.close()
  })

  it('supports onPrehydrate', async () => {
    const html = await $fetch<string>('/composables/on-prehydrate') as string
    /**
     * Should look something like this:
     *
     * ```html
     * <div data-prehydrate-id=":b3qlvSiBeH::df1mQEC9xH:"> onPrehydrate testing </div>
     * <script>(()=>{console.log(window)})()</script>
     * <script>document.querySelectorAll('[data-prehydrate-id*=":b3qlvSiBeH:"]').forEach(e=>{console.log(e.outerHTML)})</script>
     * <script>document.querySelectorAll('[data-prehydrate-id*=":df1mQEC9xH:"]').forEach(e=>{console.log(`other`,e.outerHTML)})</script>
     * ```
     */
    const { id1, id2 } = html.match(/<div[^>]* data-prehydrate-id=":(?<id1>[^:]+)::(?<id2>[^:]+):"> onPrehydrate testing <\/div>/)?.groups || {}
    expect(id1).toBeTruthy()
    const matches = [
      html.match(/<script[^>]*>\(\(\)=>\{console.log\(window\)\}\)\(\)<\/script>/),
      html.match(new RegExp(`<script[^>]*>document.querySelectorAll\\('\\[data-prehydrate-id\\*=":${id1}:"]'\\).forEach\\(e=>{console.log\\(e.outerHTML\\)}\\)</script>`, 'i')),
      html.match(new RegExp(`<script[^>]*>document.querySelectorAll\\('\\[data-prehydrate-id\\*=":${id2}:"]'\\).forEach\\(e=>{console.log\\(\`other\`,e.outerHTML\\)}\\)</script>`, 'i')),
    ]

    // This tests we inject all scripts correctly, and only have one occurrence of multiple calls of a composable
    expect(matches.every(s => s?.length === 1)).toBeTruthy()

    // Check for hydration/syntax errors on client side
    await expectNoClientErrors('/composables/on-prehydrate')
  })

  it('respects preview mode with a token', async () => {
    const token = 'hehe'
    const page = await createPage(`/preview?preview=true&token=${token}`)

    const hasRerunFetchOnClient = await new Promise<boolean>((resolve) => {
      page.on('console', (message) => {
        setTimeout(() => resolve(false), 4000)

        if (message.text() === 'true') { resolve(true) }
      })
    })

    expect(hasRerunFetchOnClient).toBe(true)

    expect(await page.locator('#fetched-on-client').textContent()).toContain('fetched on client')
    expect(await page.locator('#preview-mode').textContent()).toContain('preview mode enabled')

    await page.click('#use-fetch-check')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath.includes('/preview/with-use-fetch'))

    expect(await page.locator('#token-check').textContent()).toContain(token)
    expect(await page.locator('#correct-api-key-check').textContent()).toContain('true')
    await page.close()
  })

  it('respects preview mode with custom state', async () => {
    const { page } = await renderPage('/preview/with-custom-state?preview=true')

    expect(await page.locator('#data1').textContent()).toContain('data1 updated')
    expect(await page.locator('#data2').textContent()).toContain('data2')

    await page.click('#toggle-preview') // manually turns off preview mode
    await page.click('#with-use-fetch')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath.includes('/preview/with-use-fetch'))

    expect(await page.locator('#enabled').textContent()).toContain('false')
    expect(await page.locator('#token-check').textContent()).toEqual('')
    expect(await page.locator('#correct-api-key-check').textContent()).toContain('false')
    await page.close()
  })

  it('respects preview mode with custom enable', async () => {
    const { page } = await renderPage('/preview/with-custom-enable?preview=true')

    expect(await page.locator('#enabled').textContent()).toContain('false')
    await page.close()
  })

  it('respects preview mode with custom enable and customPreview', async () => {
    const { page } = await renderPage('/preview/with-custom-enable?customPreview=true')

    expect(await page.locator('#enabled').textContent()).toContain('true')
    await page.close()
  })
})

describe('rich payloads', () => {
  it('correctly serializes and revivifies complex types', async () => {
    const html = await $fetch<string>('/json-payload')
    for (const test of [
      'Date: true',
      'BigInt: true',
      'Error: true',
      'Shallow reactive: true',
      'Shallow ref: true',
      'Undefined ref: true',
      'BigInt ref:',
      'Reactive: true',
      'Ref: true',
      'Recursive objects: true',
    ]) {
      expect(html).toContain(test)
    }
  })
})

describe('nuxt links', () => {
  it('handles trailing slashes', async () => {
    const html = await $fetch<string>('/nuxt-link/trailing-slash')
    const data: Record<string, string[]> = {}
    for (const selector of ['nuxt-link', 'router-link', 'link-with-trailing-slash', 'link-without-trailing-slash']) {
      data[selector] = []
      for (const match of html.matchAll(new RegExp(`href="([^"]*)"[^>]*class="[^"]*\\b${selector}\\b`, 'g'))) {
        data[selector]!.push(match[1]!)
      }
    }
    expect(data).toMatchInlineSnapshot(`
      {
        "link-with-trailing-slash": [
          "/",
          "/nuxt-link/trailing-slash/",
          "/nuxt-link/trailing-slash/",
          "/nuxt-link/trailing-slash/?test=true&amp;thing=other/thing#thing-other",
          "/nuxt-link/trailing-slash/?test=true&amp;thing=other/thing#thing-other",
          "/nuxt-link/trailing-slash/",
          "/nuxt-link/trailing-slash/?with-state=true",
          "/nuxt-link/trailing-slash/?without-state=true",
        ],
        "link-without-trailing-slash": [
          "/",
          "/nuxt-link/trailing-slash",
          "/nuxt-link/trailing-slash",
          "/nuxt-link/trailing-slash?test=true&amp;thing=other/thing#thing-other",
          "/nuxt-link/trailing-slash?test=true&amp;thing=other/thing#thing-other",
          "/nuxt-link/trailing-slash",
          "/nuxt-link/trailing-slash?with-state=true",
          "/nuxt-link/trailing-slash?without-state=true",
        ],
        "nuxt-link": [
          "/",
          "/nuxt-link/trailing-slash",
          "/nuxt-link/trailing-slash/",
          "/nuxt-link/trailing-slash?test=true&amp;thing=other/thing#thing-other",
          "/nuxt-link/trailing-slash/?test=true&amp;thing=other/thing#thing-other",
          "/nuxt-link/trailing-slash",
          "/nuxt-link/trailing-slash?with-state=true",
          "/nuxt-link/trailing-slash?without-state=true",
        ],
        "router-link": [
          "/",
          "/nuxt-link/trailing-slash",
          "/nuxt-link/trailing-slash/",
          "/nuxt-link/trailing-slash?test=true&amp;thing=other/thing#thing-other",
          "/nuxt-link/trailing-slash/?test=true&amp;thing=other/thing#thing-other",
          "/nuxt-link/trailing-slash",
          "/nuxt-link/trailing-slash?with-state=true",
          "/nuxt-link/trailing-slash?without-state=true",
        ],
      }
    `)
  })

  it('respects external links in edge cases', async () => {
    const html = await $fetch<string>('/nuxt-link/custom-external')
    const hrefs = html.match(/<a[^>]*href="[^"]+"/g)
    expect(hrefs).toMatchInlineSnapshot(`
      [
        "<a href="https://thehackernews.com/2024/01/urgent-upgrade-gitlab-critical.html"",
        "<a href="https://thehackernews.com/2024/01/urgent-upgrade-gitlab-critical.html"",
        "<a href="/missing-page/"",
        "<a href="/missing-page/"",
      ]
    `)

    const { page, consoleLogs } = await renderPage('/nuxt-link/custom-external')
    const warnings = consoleLogs.filter(c => c.text.includes('No match found for location'))
    expect(warnings).toMatchInlineSnapshot(`[]`)
    await page.close()
  })

  it('preserves route state', async () => {
    const { page } = await renderPage('/nuxt-link/trailing-slash')

    for (const selector of ['nuxt-link', 'router-link', 'link-with-trailing-slash', 'link-without-trailing-slash']) {
      await page.locator(`.${selector}[href*=with-state]`).click()
      await page.getByTestId('window-state').getByText('bar').waitFor()

      await page.locator(`.${selector}[href*=without-state]`).click()
      await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath.includes('without-state'))
      expect(await page.getByTestId('window-state').innerText()).not.toContain('bar')
    }

    await page.close()
  })

  it('expect scroll to top on routes with same component', async () => {
    // #22402
    const page = await createPage('/big-page-1', {
      viewport: {
        width: 1000,
        height: 1000,
      },
    })
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/big-page-1')

    await page.locator('#big-page-2').scrollIntoViewIfNeeded()
    await page.waitForFunction(() => window.scrollY > 0)
    await page.locator('#big-page-2').click()
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/big-page-2')
    await page.waitForFunction(() => window.scrollY === 0)

    await page.locator('#big-page-1').scrollIntoViewIfNeeded()
    await page.waitForFunction(() => window.scrollY > 0)
    await page.locator('#big-page-1').click()
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/big-page-1')
    await page.waitForFunction(() => window.scrollY === 0)
    await page.close()
  })

  it('expect scroll to top on nested pages', async () => {
    // #20523
    const page = await createPage('/nested/foo/test', {
      viewport: {
        width: 1000,
        height: 1000,
      },
    })
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/nested/foo/test')

    await page.locator('#user-test').scrollIntoViewIfNeeded()
    await page.waitForFunction(() => window.scrollY > 0)
    await page.locator('#user-test').click()
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/nested/foo/user-test')
    await page.waitForFunction(() => window.scrollY === 0)

    await page.locator('#test').scrollIntoViewIfNeeded()
    await page.waitForFunction(() => window.scrollY > 0)
    await page.locator('#test').click()
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/nested/foo/test')
    await page.waitForFunction(() => window.scrollY === 0)
    await page.close()
  })

  it('useLink works', async () => {
    const html = await $fetch<string>('/nuxt-link/use-link')
    expect(html).toContain('<div>useLink in NuxtLink: true</div>')
    expect(html).toContain('<div>route using useLink: /nuxt-link/trailing-slash</div>')
    expect(html).toContain('<div>href using useLink: /nuxt-link/trailing-slash</div>')
    expect(html).toContain('<div>useLink2 in NuxtLink: true</div>')
    expect(html).toContain('<div>route2 using useLink: /nuxt-link/trailing-slash</div>')
    expect(html).toContain('<div>href2 using useLink: /nuxt-link/trailing-slash</div>')
    expect(html).toContain('<div>useLink3 in NuxtLink: true</div>')
    expect(html).toContain('<div>route3 using useLink: /nuxt-link/trailing-slash</div>')
    expect(html).toContain('<div>href3 using useLink: /nuxt-link/trailing-slash</div>')
  })
  it('useLink navigate importing NuxtLink works', async () => {
    const page = await createPage('/nuxt-link/use-link')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/nuxt-link/use-link')

    await page.locator('#button1').click()
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/nuxt-link/trailing-slash')
    await page.close()
  })
  it('useLink navigate using resolveComponent works', async () => {
    const page = await createPage('/nuxt-link/use-link')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/nuxt-link/use-link')

    await page.locator('#button2').click()
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/nuxt-link/trailing-slash')
    await page.close()
  })
  it('useLink navigate using resolveDynamicComponent works', async () => {
    const page = await createPage('/nuxt-link/use-link')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/nuxt-link/use-link')

    await page.locator('#button3').click()
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, '/nuxt-link/trailing-slash')
    await page.close()
  })
})

describe('head tags', () => {
  it('SSR should render tags', async () => {
    const headHtml = await $fetch<string>('/head')

    expect(headHtml).toContain('<title>Using a dynamic component - Title Template Fn Change</title>')
    expect(headHtml).not.toContain('<meta name="description" content="first">')
    expect(headHtml).toContain('<meta charset="utf-16">')
    expect(headHtml.match('meta charset')!.length).toEqual(1)
    expect(headHtml).toContain('<meta name="viewport" content="width=1024, initial-scale=1">')
    expect(headHtml.match('meta name="viewport"')!.length).toEqual(1)
    expect(headHtml).not.toContain('<meta charset="utf-8">')
    expect(headHtml).toContain('<meta name="description" content="overriding with an inline useHead call">')
    expect(headHtml).toMatch(/<html[^>]*class="html-attrs-test"/)
    expect(headHtml).toMatch(/<body[^>]*class="body-attrs-test"/)

    const bodyHtml = headHtml.match(/<body[^>]*>(.*)<\/body>/s)![1]
    expect(bodyHtml).toContain('<script src="https://a-body-appended-script.com"></script>')

    const indexHtml = await $fetch<string>('/')
    // should render charset by default
    expect(indexHtml).toContain('<meta charset="utf-8">')
    // should render <Head> components
    expect(indexHtml).toContain('<title>Basic fixture</title>')
  })

  it('SSR script setup should render tags', async () => {
    const headHtml = await $fetch<string>('/head-script-setup')

    // useHead - title & titleTemplate are working
    expect(headHtml).toContain('<title>head script setup - Nuxt Playground</title>')
    // useSeoMeta - template params
    expect(headHtml).toContain('<meta property="og:title" content="head script setup - Nuxt Playground">')
    // useSeoMeta - refs
    expect(headHtml).toContain('<meta name="description" content="head script setup description for Nuxt Playground">')
    // useServerHead - shorthands
    expect(headHtml).toContain('>/* Custom styles */</style>')
    // useHeadSafe - removes dangerous content
    expect(headHtml).not.toContain('<script id="xss-script">')
    expect(headHtml).toContain('<meta content="0;javascript:alert(1)">')
  })

  it('SPA should render appHead tags', async () => {
    const headHtml = await $fetch<string>('/head-spa')

    expect(headHtml).toContain('<meta name="description" content="Nuxt Fixture">')
    expect(headHtml).toContain('<meta charset="utf-8">')
    expect(headHtml).toContain('<meta name="viewport" content="width=1024, initial-scale=1">')
  })

  it('should render http-equiv correctly', async () => {
    const html = await $fetch<string>('/head')
    // http-equiv should be rendered kebab case
    expect(html).toContain('<meta http-equiv="content-security-policy" content="default-src https">')
  })

  // TODO: https://github.com/nuxt/nuxt/issues/32670
  it.fails('should not duplicate link tags with rel="alternate"', async () => {
    const page = await createPage('/head-component')

    await page.waitForFunction(() => window.useNuxtApp?.() && !window.useNuxtApp?.().isHydrating)

    expect(await page.locator('link[rel="alternate"]').count()).toBe(1)
    await page.close()
  })

  it('should deduplicate head tags with key', async () => {
    const page = await createPage('/head-component')
    await page.waitForFunction(() => window.useNuxtApp?.() && !window.useNuxtApp?.().isHydrating)

    expect(await page.locator('link[data-hid="dedupe-key"]').count()).toBe(1)
    expect(await page.locator('link[data-hid="dedupe-key"]').getAttribute('href')).toBe('client')
    expect(await page.locator('link[data-hid="dedupe-key"]').getAttribute('rel')).toBe('x-test')

    await page.close()

    const html = await $fetch<string>('/head-component')
    expect((html.match(/data-hid="dedupe-key"/g) || []).length).toBe(1)
    expect(html).toContain('<link rel="x-test" href="server" data-hid="dedupe-key">')
  })

  // TODO: Doesn't adds header in test environment
  // it.todo('should render stylesheet link tag (SPA mode)', async () => {
  //   const html = await $fetch<string>('/head', { headers: { 'x-nuxt-no-ssr': '1' } })
  //   expect(html).toMatch(/<link rel="stylesheet" href="\/_nuxt\/[^>]*.css"/)
  // })
})

describe('navigate', () => {
  it('should redirect to index with navigateTo', async () => {
    const { headers, status } = await fetch('/navigate-to/', { redirect: 'manual' })

    expect(headers.get('location')).toEqual('/')
    expect(status).toEqual(301)
  })

  it('respects redirects + headers in middleware', async () => {
    const res = await fetch('/navigate-some-path/', { redirect: 'manual', headers: { 'trailing-slash': 'true' } })
    expect(res.headers.get('location')).toEqual('/navigate-some-path')
    expect(res.status).toEqual(307)
    expect(await res.text()).toMatchInlineSnapshot('"<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=/navigate-some-path"></head></html>"')
  })

  it('should not overwrite headers', async () => {
    const { headers, status } = await fetch('/navigate-to-external', { redirect: 'manual' })

    expect(headers.get('location')).toEqual('/')
    expect(status).toEqual(302)
  })

  it('should not run setup function in path redirected to', async () => {
    const { headers, status } = await fetch('/navigate-to-error', { redirect: 'manual' })

    expect(headers.get('location')).toEqual('/setup-should-not-run')
    expect(status).toEqual(302)
  })

  it('supports directly aborting navigation on SSR', async () => {
    const { status } = await fetch('/navigate-to-false', { redirect: 'manual' })

    expect(status).toEqual(404)
  })

  it('expect to redirect with encoding', async () => {
    const { status, headers } = await fetch('/redirect-with-encode', { redirect: 'manual' })

    expect(status).toEqual(302)
    expect(headers.get('location') || '').toEqual(encodeURI('/cœur') + '?redirected=' + encodeURIComponent('https://google.com'))
  })
})

describe('preserves current instance', () => {
  // TODO: it's unclear why there's an error here but it must be an upstream issue
  it.todo('should not return getCurrentInstance when there\'s an error in data', async () => {
    await fetch('/instance/error')
    const html = await $fetch<string>('/instance/next-request')
    expect(html).toContain('This should be false: false')
  })
  // TODO: re-enable when https://github.com/nuxt/nuxt/issues/15164 is resolved
  it.skipIf(isWindows)('should not lose current nuxt app after await in vue component', async () => {
    const requests = await Promise.all(Array.from({ length: 100 }).map(() => $fetch<string>('/instance/next-request')))
    for (const html of requests) {
      expect(html).toContain('This should be true: true')
    }
  })
})

describe('errors', () => {
  it('should render a JSON error page', async () => {
    const res = await fetch('/error', {
      headers: {
        accept: 'application/json',
      },
    })
    expect(res.status).toBe(422)
    expect(res.statusText).toBe('This is a custom error')
    const error = await res.json()
    delete error.stack
    const url = new URL(error.url)
    url.host = 'localhost:3000'
    error.url = url.toString()
    expect(error).toMatchObject({
      message: isDev ? 'This is a custom error' : 'Server Error',
      statusCode: 422,
      statusMessage: 'This is a custom error',
      url: 'http://localhost:3000/error',
    })
  })

  it('should render a HTML error page', async () => {
    const res = await fetch('/error')
    expect(res.headers.get('Set-Cookie')).toBe('set-in-plugin=true; Path=/, some-error=was%20set; Path=/')
    expect(await res.text()).toContain('This is a custom error')
  })

  it('should not allow accessing error route directly', async () => {
    const res = await fetch('/__nuxt_error', {
      headers: {
        accept: 'application/json',
      },
    })
    expect(res.status).toBe(404)
    const error = await res.json()
    delete error.stack
    const url = new URL(error.url)
    url.host = 'localhost:3000'
    error.url = url.toString()

    expect(error).toMatchInlineSnapshot(`
      {
        "error": true,
        "message": "Page Not Found: /__nuxt_error",
        "statusCode": 404,
        "statusMessage": "Page Not Found: /__nuxt_error",
        "url": "http://localhost:3000/__nuxt_error",
      }
    `)
  })

  it('should not recursively throw an error when there is an error rendering the error page', async () => {
    const res = await $fetch<string>('/', {
      headers: {
        'x-test-recurse-error': 'true',
        'accept': 'text/html',
      },
    })
    expect(typeof res).toBe('string')
    expect(res).toContain('Hello Nuxt 3!')
  })

  // TODO: need to create test for webpack
  // TODO: need to fix this test for rspack
  it.runIf(!isDev && builder !== 'rspack')('should handle chunk loading errors', async () => {
    const { page, consoleLogs } = await renderPage()
    await page.route(/\.css/, route => route.abort('timedout')) // verify CSS link preload failure doesn't break the page
    await page.goto(url('/'))
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/' && !window.useNuxtApp?.().isHydrating)

    const initialLogs = consoleLogs.map(c => c.text).join('')
    expect(initialLogs).toContain('caught chunk load error')
    consoleLogs.length = 0

    await page.getByText('Increment state').click()
    await page.getByText('Increment state').click()
    expect(await page.innerText('div')).toContain('Some value: 3')
    await page.route(/.*/, route => route.abort('timedout'), { times: 1 })
    await page.getByText('Chunk error').click()

    await page.waitForURL(url('/chunk-error'))

    const logs = consoleLogs.map(c => c.text).join('')
    expect(logs).toContain('caught chunk load error')
    expect(logs).toContain('Failed to load resource')

    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/chunk-error')
    expect(await page.innerText('div')).toContain('Chunk error page')
    await page.locator('div').getByText('State: 3').waitFor()

    await page.close()
  })

  it('should allow catching errors within error boundaries', async () => {
    const { page } = await renderPage('/error/error-boundary')
    await page.getByText('This is the error rendering').first().waitFor()
    await page.close()

    await expectNoClientErrors('/error/error-boundary')
  })
})

describe('navigate external', () => {
  it('should redirect to example.com', async () => {
    const { headers } = await fetch('/navigate-to-external/', { redirect: 'manual' })

    expect(headers.get('location')).toEqual('https://example.com/?redirect=false#test')
  })

  it('should redirect to api endpoint', async () => {
    const { headers } = await fetch('/navigate-to-api', { redirect: 'manual' })

    expect(headers.get('location')).toEqual('/api/test')
  })
})

describe('composables', () => {
  it('`callOnce` should run code once', async () => {
    const html = await $fetch<string>('/once')

    expect(html).toContain('once.vue')
    expect(html).toContain('once: 2')

    const { page } = await renderPage('/once')
    expect(await page.getByText('once:').textContent()).toContain('once: 2')
  })
  it('`callOnce` should run code once with navigation mode during initial render', async () => {
    const html = await $fetch<string>('/once-nav-initial')

    expect(html).toContain('once.vue')
    expect(html).toContain('once: 2')

    const { page } = await renderPage('/once-nav-initial')
    expect(await page.getByText('once:').textContent()).toContain('once: 2')
  })
  it('`useId` should generate unique ids', async () => {
    // TODO: work around interesting Vue bug where async components are loaded in a different order on first import
    await $fetch<string>('/use-id')

    const sanitiseHTML = (html: string) => html.replace(/ data-[^= ]+="[^"]+"/g, '').replace(/<!--[[\]]-->/, '')

    const serverHTML = await $fetch<string>('/use-id').then(html => sanitiseHTML(html.match(/<form.*<\/form>/)![0]))
    const ids = serverHTML.match(/id="[^"]*"/g)?.map(id => id.replace(/id="([^"]*)"/, '$1')) as string[]
    const renderedForm = [
      `<h2 id="${ids[0]}"> id: ${ids[0]}</h2><div><label for="${ids[1]}">Email</label><input id="${ids[1]}" name="email" type="email"><label for="${ids[2]}">Password</label><input id="${ids[2]}" name="password" type="password"></div>`,
      `<div><label for="${ids[3]}">Email</label><input id="${ids[3]}" name="email" type="email"><label for="${ids[4]}">Password</label><input id="${ids[4]}" name="password" type="password"></div>`,
    ]
    const clientOnlyServer = '<span></span>'
    expect(serverHTML).toEqual(`<form>${renderedForm.join(clientOnlyServer)}</form>`)

    const { page, pageErrors } = await renderPage('/use-id')
    const clientHTML = await page.innerHTML('form')
    const clientIds = clientHTML
      .match(/id="[^"]*"/g)?.map(id => id.replace(/id="([^"]*)"/, '$1'))
      .filter(i => !ids.includes(i)) as string[]
    const clientOnlyClient = `<div><label for="${clientIds[0]}">Email</label><input id="${clientIds[0]}" name="email" type="email"><label for="${clientIds[1]}">Password</label><input id="${clientIds[1]}" name="password" type="password"></div>`
    expect(sanitiseHTML(clientHTML)).toEqual(`${renderedForm.join(clientOnlyClient)}`)
    expect(pageErrors).toEqual([])
    await page.close()
  })
  it('`useRouteAnnouncer` should change message on route change', async () => {
    const { page } = await renderPage('/route-announcer')
    expect(await page.getByRole('alert').textContent()).toContain('First Page')
    await page.getByRole('link').click()
    await page.getByText('Second page content').waitFor()
    expect(await page.getByRole('alert').textContent()).toContain('Second Page')
    await page.close()
  })
  it('`useRouteAnnouncer` should change message on dynamically changed title', async () => {
    const { page } = await renderPage('/route-announcer')
    await page.getByRole('button').click()
    await page.waitForFunction(() => document.title.includes('Dynamically set title'))
    expect(await page.getByRole('alert').textContent()).toContain('Dynamically set title')
    await page.close()
  })
})

describe('middlewares', () => {
  it('should redirect to index with global middleware', async () => {
    const html = await $fetch<string>('/redirect/')

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    expect(html).toContain('Hello Nuxt 3!')
  })

  it('should allow redirection from a non-existent route with `ssr: false`', async () => {
    const page = await createPage('/redirect/catchall')

    expect(await page.getByRole('heading').textContent()).toMatchInlineSnapshot('"[...slug].vue"')
    await page.close()
  })

  it('should allow aborting navigation on server-side', async () => {
    const res = await fetch('/?abort', {
      headers: {
        accept: 'application/json',
      },
    })
    expect(res.status).toEqual(401)
  })

  it('should allow aborting navigation fatally on client-side', async () => {
    const html = await $fetch<string>('/middleware-abort')
    expect(html).not.toContain('This is the error page')
    const { page } = await renderPage('/middleware-abort')
    expect(await page.innerHTML('body')).toContain('This is the error page')
    await page.close()
  })

  it('should inject auth', async () => {
    const html = await $fetch<string>('/auth')

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    expect(html).toContain('auth.vue')
    expect(html).toContain('auth: Injected by injectAuth middleware')
  })

  it('should not inject auth', async () => {
    const html = await $fetch<string>('/no-auth')

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    expect(html).toContain('no-auth.vue')
    expect(html).toContain('auth: ')
    expect(html).not.toContain('Injected by injectAuth middleware')
  })

  it('should redirect to index with http 307 with navigateTo on server side', async () => {
    const html = await fetch('/navigate-to-redirect', { redirect: 'manual' })
    expect(html.headers.get('location')).toEqual('/')
    expect(html.status).toEqual(307)
  })
})

describe('plugins', () => {
  it('basic plugin', async () => {
    const html = await $fetch<string>('/plugins')
    expect(html).toContain('myPlugin: Injected by my-plugin')
  })

  it('async plugin', async () => {
    const html = await $fetch<string>('/plugins')
    expect(html).toContain('asyncPlugin: Async plugin works! 123')
    expect(html).toContain('useFetch works!')
  })
})

describe('layouts', () => {
  it('should apply custom layout', async () => {
    const html = await $fetch<string>('/with-layout')

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    expect(html).toContain('with-layout.vue')
    expect(html).toContain('Custom Layout:')
  })
  it('should work with a dynamically set layout', async () => {
    const html = await $fetch<string>('/with-dynamic-layout')

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    expect(html).toContain('with-dynamic-layout')
    expect(html).toContain('Custom Layout:')
    expect(html).toContain('set from sets-layouts middleware')
    await expectNoClientErrors('/with-dynamic-layout')
  })
  it('should work with a computed layout', async () => {
    const html = await $fetch<string>('/with-computed-layout')

    // Snapshot
    // expect(html).toMatchInlineSnapshot()

    expect(html).toContain('with-computed-layout')
    expect(html).toContain('Custom Layout')
    await expectNoClientErrors('/with-computed-layout')
  })
  it('should allow passing custom props to a layout', async () => {
    const html = await $fetch<string>('/layouts/with-props')
    expect(html).toContain('some prop was passed')
    await expectNoClientErrors('/layouts/with-props')
  })
})

describe('composable tree shaking', () => {
  it('should work', async () => {
    const html = await $fetch<string>('/tree-shake')

    expect(html).toContain('Tree Shake Example')

    const { page, pageErrors } = await renderPage('/tree-shake')
    // ensure scoped classes are correctly assigned between client and server
    expect(await page.$eval('h1', e => getComputedStyle(e).color)).toBe('rgb(255, 192, 203)')

    expect(pageErrors).toEqual([])

    await page.close()
  })
})

describe('ignore list', () => {
  it('should ignore composable files in .nuxtignore', async () => {
    const html = await $fetch<string>('/ignore/composables')
    expect(html).toContain('was import ignored: true')
  })
  it('should ignore scanned nitro handlers in .nuxtignore', async () => {
    const { status } = await fetch('/ignore/scanned')
    expect(status).toBe(404)
  })
  it.skipIf(isDev)('should ignore public assets in .nuxtignore', async () => {
    const { status } = await fetch('/ignore/public-asset')
    expect(status).toBe(404)
  })
})

describe('server tree shaking', () => {
  it('should work', async () => {
    const html = await $fetch<string>('/client')

    expect(html).toContain('This page should not crash when rendered')
    expect(html).toContain('fallback for ClientOnly')
    expect(html).not.toContain('rendered client-side')
    expect(html).not.toContain('id="client-side"')

    const { page } = await renderPage('/client')
    await page.waitForFunction(() => window.useNuxtApp?.())
    // ensure scoped classes are correctly assigned between client and server
    expect(await page.$eval('.red', e => getComputedStyle(e).color)).toBe('rgb(255, 0, 0)')
    expect(await page.$eval('.blue', e => getComputedStyle(e).color)).toBe('rgb(0, 0, 255)')
    expect(await page.locator('#client-side').textContent()).toContain('This should be rendered client-side')

    await page.close()
  })
})

describe('extends support', () => {
  describe('layouts & pages', () => {
    it('extends foo/layouts/default & foo/pages/index', async () => {
      const html = await $fetch<string>('/foo')
      expect(html).toContain('Extended layout from foo')
      expect(html).toContain('Extended page from foo')
    })

    it('extends [bar/layouts/override & bar/pages/override] over [foo/layouts/override & foo/pages/override]', async () => {
      const html = await $fetch<string>('/override')
      expect(html).toContain('Extended layout from bar')
      expect(html).toContain('Extended page from bar')
      expect(html).toContain('This child page should not be overridden by bar')
    })
  })

  describe('components', () => {
    it('extends foo/components/ExtendsFoo', async () => {
      const html = await $fetch<string>('/foo')
      expect(html).toContain('Extended component from foo')
    })

    it('extends bar/components/ExtendsOverride over foo/components/ExtendsOverride', async () => {
      const html = await $fetch<string>('/override')
      expect(html).toContain('Extended component from bar')
    })
  })

  describe('middlewares', () => {
    it('works with layer aliases', async () => {
      const html = await $fetch<string>('/foo')
      expect(html).toContain('from layer alias')
    })
    it('extends foo/middleware/foo', async () => {
      const html = await $fetch<string>('/foo')
      expect(html).toContain('Middleware | foo: Injected by extended middleware from foo')
    })

    it('extends bar/middleware/override over foo/middleware/override', async () => {
      const html = await $fetch<string>('/override')
      expect(html).toContain('Middleware | override: Injected by extended middleware from bar')
    })
    it('global middlewares sorting', async () => {
      const html = await $fetch<string>('/catchall/middleware/ordering')
      expect(html).toContain('catchall at middleware')
    })
  })

  describe('composables', () => {
    it('extends foo/composables/foo', async () => {
      const html = await $fetch<string>('/foo')
      expect(html).toContain('Composable | useExtendsFoo: foo')
    })
    it('allows overriding composables', async () => {
      const html = await $fetch<string>('/extends')
      expect(html).toContain('test from project')
    })
  })

  describe('plugins', () => {
    it('extends foo/plugins/foo', async () => {
      const html = await $fetch<string>('/foo')
      expect(html).toContain('Plugin | foo: String generated from foo plugin!')
    })

    it('respects plugin ordering within layers', async () => {
      const html = await $fetch<string>('/catchall/plugins/ordering')
      expect(html).toContain('catchall at plugins')
    })
  })

  describe('server', () => {
    it('extends foo/server/api/foo', async () => {
      expect(await $fetch<string>('/api/foo')).toBe('foo')
    })

    it('extends foo/server/middleware/foo', async () => {
      const { headers } = await fetch('/')
      expect(headers.get('injected-header')).toEqual('foo')
    })
  })

  describe('app', () => {
    it('extends foo/app/router.options & bar/app/router.options', async () => {
      const html: string = await $fetch<string>('/')
      const routerLinkClasses = html.match(/href="\/" class="([^"]*)"/)![1]!.split(' ')
      expect(routerLinkClasses).toContain('foo-active-class')
      expect(routerLinkClasses).toContain('bar-exact-active-class')
    })
  })
})

// Bug #7337
describe('deferred app suspense resolve', () => {
  it.each(['/async-parent/child', '/internal-layout/async-parent/child'])('should wait for all suspense instance on initial hydration', async (path) => {
    const { page, consoleLogs } = await renderPage(path)

    await page.waitForFunction(() => window.useNuxtApp?.() && !window.useNuxtApp?.().isHydrating)
    // Wait for all pending micro ticks to be cleared in case hydration hasn't finished yet.
    await page.evaluate(() => new Promise(resolve => setTimeout(resolve, 10)))

    const hydrationLogs = consoleLogs.filter(log => log.text.includes('isHydrating'))
    expect(hydrationLogs.length).toBe(3)
    expect(hydrationLogs.every(log => log.text === 'isHydrating: true'))

    await page.close()
  })

  it('should wait for suspense in parent layout', async () => {
    const { page } = await renderPage('/hydration/layout')
    await page.getByText('Tests whether hydration is properly resolved within an async layout').waitFor()
    await page.close()
  })

  it('should fully hydrate even if there is a redirection on a page with `ssr: false`', async () => {
    const { page } = await renderPage()
    await page.goto(url('/hydration/spa-redirection/start'))
    await page.getByText('fully hydrated and ready to go').waitFor()
    await page.close()
  })
})

describe('nested suspense', () => {
  const navigations = ([
    ['/suspense/sync-1/async-1/', '/suspense/sync-2/async-1/'],
    ['/suspense/sync-1/sync-1/', '/suspense/sync-2/async-1/'],
    ['/suspense/async-1/async-1/', '/suspense/async-2/async-1/'],
    ['/suspense/async-1/sync-1/', '/suspense/async-2/async-1/'],
  ] as const).flatMap(([start, end]) => [
    [start, end],
    [start, end + '?layout=custom'],
    [start + '?layout=custom', end],
  ])

  it.each(navigations)('should navigate from %s to %s with no white flash', async (start, nav) => {
    const { page, consoleLogs } = await renderPage(start)

    const slug = nav.replace(/\?.*$/, '').replace(/[/-]+/g, '-')
    await page.click(`[href^="${nav}"]`)

    const text = await page.waitForFunction(slug => document.querySelector(`main:has(#child${slug})`)?.innerHTML, slug)
      .then(r => r.evaluate(r => r))

    // expect(text).toMatchInlineSnapshot()

    // const parent = await page.waitForSelector(`#${slug}`, { state: 'attached' })

    // const text = await parent.innerText()
    expect(text).toContain('Async child: 2 - 1')
    expect(text).toContain('parent: 2')

    const first = start.match(/\/suspense\/(?<parentType>a?sync)-(?<parentNum>\d)\/(?<childType>a?sync)-(?<childNum>\d)\//)!.groups!
    const last = nav.match(/\/suspense\/(?<parentType>a?sync)-(?<parentNum>\d)\/(?<childType>a?sync)-(?<childNum>\d)\//)!.groups!

    expect(consoleLogs.map(l => l.text).filter(i => !i.includes('[vite]') && !i.includes('<Suspense> is an experimental feature')).sort()).toEqual([
      // [first load] from parent
      `[${first.parentType}]`,
      ...first.parentType === 'async' ? ['[async] running async data'] : [],
      // [first load] from child
      `[${first.parentType}] [${first.childType}]`,
      ...first.childType === 'async' ? [`[${first.parentType}] [${first.parentNum}] [async] [${first.childNum}] running async data`] : [],
      // [navigation] from parent
      `[${last.parentType}]`,
      ...last.parentType === 'async' ? ['[async] running async data'] : [],
      // [navigation] from child
      `[${last.parentType}] [${last.childType}]`,
      ...last.childType === 'async' ? [`[${last.parentType}] [${last.parentNum}] [async] [${last.childNum}] running async data`] : [],
    ].sort())

    await page.close()
  })

  const outwardNavigations = [
    ['/suspense/async-2/async-1/', '/suspense/async-1/'],
    ['/suspense/async-2/sync-1/', '/suspense/async-1/'],
  ]

  it.each(outwardNavigations)('should navigate from %s to a parent %s with no white flash', async (start, nav) => {
    const { page, consoleLogs } = await renderPage(start)

    await page.waitForSelector(`main:has(#child${start.replace(/[/-]+/g, '-')})`)

    const slug = start.replace(/[/-]+/g, '-')
    await page.click(`[href^="${nav}"]`)

    // wait until child selector disappears and grab HTML of parent
    const text = await page.waitForFunction(slug => document.querySelector(`main:not(:has(#child${slug}))`)?.innerHTML, slug)
      .then(r => r.evaluate(r => r))

    expect(text).toContain('Async parent: 1')

    const first = start.match(/\/suspense\/(?<parentType>a?sync)-(?<parentNum>\d)\/(?<childType>a?sync)-(?<childNum>\d)\//)!.groups!
    const last = nav.match(/\/suspense\/(?<parentType>a?sync)-\d\//)!.groups!

    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, nav)

    expect(consoleLogs.map(l => l.text).filter(i => !i.includes('[vite]') && !i.includes('<Suspense> is an experimental feature')).sort()).toEqual([
      // [first load] from parent
      `[${first.parentType}]`,
      ...first.parentType === 'async' ? ['[async] running async data'] : [],
      // [first load] from child
      `[${first.parentType}] [${first.childType}]`,
      ...first.childType === 'async' ? [`[${first.parentType}] [${first.parentNum}] [async] [${first.childNum}] running async data`] : [],
      // [navigation] from parent
      `[${last.parentType}]`,
      ...last.parentType === 'async' ? ['[async] running async data'] : [],
    ].sort())

    await page.close()
  })

  const inwardNavigations = [
    ['/suspense/async-2/', '/suspense/async-1/async-1/'],
    ['/suspense/async-2/', '/suspense/async-1/sync-1/'],
  ]

  it.each(inwardNavigations)('should navigate from %s to a child %s with no white flash', async (start, nav) => {
    const { page, consoleLogs } = await renderPage(start)

    const slug = nav.replace(/[/-]+/g, '-')
    await page.click(`[href^="${nav}"]`)

    // wait until child selector appears and grab HTML of parent
    const text = await page.waitForFunction(slug => document.querySelector(`main:has(#child${slug})`)?.innerHTML, slug)
      .then(r => r.evaluate(r => r))

    // const text = await parent.innerText()
    expect(text).toContain('Async parent: 1')

    const first = start.match(/\/suspense\/(?<parentType>a?sync)-\d\//)!.groups!
    const last = nav.match(/\/suspense\/(?<parentType>a?sync)-(?<parentNum>\d)\/(?<childType>a?sync)-(?<childNum>\d)\//)!.groups!

    expect(consoleLogs.map(l => l.text).filter(i => !i.includes('[vite]') && !i.includes('<Suspense> is an experimental feature')).sort()).toEqual([
      // [first load] from parent
      `[${first.parentType}]`,
      ...first.parentType === 'async' ? ['[async] running async data'] : [],
      // [navigation] from parent
      `[${last.parentType}]`,
      ...last.parentType === 'async' ? ['[async] running async data'] : [],
      // [navigation] from child
      `[${last.parentType}] [${last.childType}]`,
      ...last.childType === 'async' ? [`[${last.parentType}] [${last.parentNum}] [async] [${last.childNum}] running async data`] : [],
    ].sort())

    await page.close()
  })
})

// Bug #6592
describe('page key', () => {
  it.each(['/fixed-keyed-child-parent', '/internal-layout/fixed-keyed-child-parent'])('should not cause run of setup if navigation not change page key and layout', async (path) => {
    const { page, consoleLogs } = await renderPage(`${path}/0`)

    await page.click(`[href="${path}/1"]`)
    await page.waitForSelector('#page-1')

    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, `${path}/1`)
    // Wait for all pending micro ticks to be cleared,
    // so we are not resolved too early when there are repeated page loading
    await page.evaluate(() => new Promise(resolve => setTimeout(resolve, 10)))

    expect(consoleLogs.filter(l => l.text.includes('Child Setup')).length).toBe(1)
    await page.close()
  })

  it.each(['/keyed-child-parent', '/internal-layout/keyed-child-parent'])('will cause run of setup if navigation changed page key', async (path) => {
    const { page, consoleLogs } = await renderPage(`${path}/0`)

    await page.click(`[href="${path}/1"]`)
    await page.waitForSelector('#page-1')

    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, `${path}/1`)
    // Wait for all pending micro ticks to be cleared,
    // so we are not resolved too early when there are repeated page loading
    await page.evaluate(() => new Promise(resolve => setTimeout(resolve, 10)))

    expect(consoleLogs.filter(l => l.text.includes('Child Setup')).length).toBe(2)
    await page.close()
  })
})

describe('route provider', () => {
  it('should preserve current route when navigation is suspended', async () => {
    const { page } = await renderPage('/route-provider/foo')
    await page.click('[href="/route-provider/bar"]')
    expect(await page.getByTestId('foo').innerText()).toMatchInlineSnapshot('"foo: /route-provider/foo - /route-provider/foo"')
    expect(await page.getByTestId('bar').innerText()).toMatchInlineSnapshot('"bar: /route-provider/bar - /route-provider/bar"')

    await page.close()
  })
})

// Bug #6592
describe('layout change not load page twice', () => {
  const cases = {
    '/with-layout': '/with-layout2',
    '/internal-layout/with-layout': '/internal-layout/with-layout2',
  }

  it.each(Object.entries(cases))('should not cause run of page setup to repeat if layout changed', async (path1, path2) => {
    const { page, consoleLogs } = await renderPage(path1)
    await page.click(`[href="${path2}"]`)
    await page.waitForSelector('#with-layout2')

    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, path2)
    // Wait for all pending micro ticks to be cleared,
    // so we are not resolved too early when there are repeated page loading
    await page.evaluate(() => new Promise(resolve => setTimeout(resolve, 10)))

    expect(consoleLogs.filter(l => l.text.includes('Layout2 Page Setup')).length).toBe(1)
  })
})

describe('layout switching', () => {
  // #13309
  it('does not cause TypeError: Cannot read properties of null', async () => {
    const { page, consoleLogs, pageErrors } = await renderPage('/layout-switch/start')
    await page.click('[href="/layout-switch/end"]')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/layout-switch/end')
    expect(consoleLogs.map(i => i.text).filter(l => l.match(/error/i))).toMatchInlineSnapshot('[]')
    expect(pageErrors).toMatchInlineSnapshot('[]')
    await page.close()
  })
})

describe('automatically keyed composables', () => {
  it('should automatically generate keys', async () => {
    const html = await $fetch<string>('/keyed-composables')
    expect(html).toContain('true')
    expect(html).not.toContain('false')
  })
  it('should match server-generated keys', async () => {
    await expectNoClientErrors('/keyed-composables')
  })
  it('should not automatically generate keys', async () => {
    await expectNoClientErrors('/keyed-composables/local')
    const html = await $fetch<string>('/keyed-composables/local')
    expect(html).toContain('true')
    expect(html).not.toContain('false')
  })
})

describe.runIf(isDev && !isWebpack)('css links', () => {
  it('should not inject links to CSS files that are inlined', async () => {
    const html = await $fetch<string>('/inline-only-css')
    expect(html).toContain('--inline-only')
    expect(html).not.toContain('inline-only.css')
    expect(html).toContain('assets/plugin.css')
  })
})

describe.skipIf(isDev)('module identifiers', () => {
  it('injects SSR module identifiers for inline styles', async () => {
    const { page } = await renderPage('/ssr-modules')

    const modulesJson = await page.getAttribute('#ssr-modules', 'data-modules')
    const modules: string[] = modulesJson ? JSON.parse(modulesJson) : []

    expect(modules.length).toBeGreaterThan(0)
    expect(modules.every(id => typeof id === 'string' && id.length > 0)).toBe(true)

    await page.close()
  })
})

describe.skipIf(isDev)('inlining component styles', () => {
  const globalCSS = [
    '{--plugin:"plugin"}', // CSS imported ambiently in JS/TS
    '{--global:"global";', // global css from nuxt.config
  ]
  const nonGlobalCSS = [
    '{--assets:"assets"}', // <script>
    '{--postcss:"postcss"}', // <style lang=postcss>
    '{--scoped:"scoped"}', // <style lang=css>
    '{--shared-component:"shared-component"}', // styles in a chunk shared between pages
  ]
  const inlinedCSS = [
    ...globalCSS,
    ...nonGlobalCSS,
    '{--server-only-child:"server-only-child"}', // child of a server-only component
    '{--server-only:"server-only"}', // server-only component not in client build
    // TODO: ideally both client/server components would have inlined css when used
    // '{--client-only:"client-only"}', // client-only component not in server build
    // TODO: currently functional component not associated with ssrContext (upstream bug or perf optimization?)
    // '{--functional:"functional"}', // CSS imported ambiently in a functional component
  ]

  it('should inline styles', async () => {
    const html = await $fetch<string>('/styles')
    for (const style of inlinedCSS) {
      expect.soft(html).toContain(style)
    }
  })

  it('should inline global css when accessing a page with `ssr: false` override via route rules', async () => {
    const html = await $fetch<string>('/route-rules/spa')
    for (const style of globalCSS) {
      expect.soft(html).toContain(style)
    }
  })

  it.skipIf(isWebpack /* file is inlined */)('should emit assets referenced in inlined CSS', async () => {
    // @ts-expect-error ssssh! untyped secret property
    const publicDir = useTestContext().nuxt._nitro.options.output.publicDir
    const files = await readdir(join(publicDir, '_nuxt')).catch(() => [])
    expect(files.map(m => m.replace(/\.[\w-]+(\.\w+)$/, '$1'))).toContain('css-only-asset.svg')
  })

  it('should not include inlined CSS in generated CSS file', async () => {
    const html: string = await $fetch<string>('/styles')
    const cssFiles = new Set([...html.matchAll(/<link [^>]*href="([^"]*\.css)"(?: crossorigin)?>/g)].map(m => m[1]!))
    let css = ''
    for (const file of cssFiles || []) {
      css += await $fetch<string>(file)
    }

    // should not include inlined CSS in generated CSS files
    for (const style of inlinedCSS) {
      // TODO: remove 'ambient global' CSS from generated CSS file
      if (style === '{--plugin:"plugin"}') {
        expect.soft(css).toContain(style)
        continue
      }
      // webpack can hoist component level css up to a shared css file
      if (isWebpack && nonGlobalCSS.includes(style)) {
        expect.soft(css).toContain(style)
        continue
      }
      expect.soft(css).not.toContain(style)
    }

    // should include unloadable CSS in generated CSS file
    const unloadableCSS = [
      '--virtual:red',
      '--functional:"functional"',
      '--client-only:"client-only"',
    ]
    for (const style of unloadableCSS) {
      // TODO:
      if (isWebpack && style === '--virtual:red') {
        // this is not injected at all as webpack virtual modules are a bit more complex
        expect.soft(css).not.toContain(style)
        continue
      }
      expect.soft(css).toContain(style)
    }
  })

  it('does not load stylesheet for page styles', async () => {
    const html: string = await $fetch<string>('/styles')
    const cssFiles = html.match(/<link [^>]*href="[^"]*\.css"/g)
    expect(cssFiles?.length).toBeGreaterThan(0)
    if (isWebpack) {
      // TODO: use non-hash name for webpack css files in test fixture
      expect(cssFiles).toHaveLength(2)
    } else {
      expect(cssFiles?.filter(m => m.includes('entry'))?.map(m => m.replace(/\.[^.]*\.css/, '.css'))).toMatchInlineSnapshot(`
        [
          "<link rel="stylesheet" href="/_nuxt/entry.css"",
        ]
      `)
    }
  })

  it('still downloads client-only styles', async () => {
    const page = await createPage()
    await page.goto(url('/styles'), { waitUntil: 'networkidle' })
    expect(await page.$eval('.client-only-css', e => getComputedStyle(e).color)).toBe('rgb(50, 50, 50)')

    await page.close()
  })

  it.todo('renders client-only styles only', async () => {
    const html = await $fetch<string>('/styles')
    expect(html).toContain('{--client-only:"client-only"}')
  })
})

describe('server components/islands', () => {
  it('/islands', async () => {
    const { page } = await renderPage('/islands')
    const islandRequest = page.waitForResponse(response => response.url().includes('/__nuxt_island/') && response.status() === 200)
    await page.locator('#increase-pure-component').click()
    await islandRequest

    await page.locator('#slot-in-server').getByText('Slot with in .server component').waitFor()
    await page.locator('#test-slot').getByText('Slot with name test').waitFor()

    // test fallback slot with v-for
    expect(await page.locator('.fallback-slot-content').all()).toHaveLength(2)
    // test islands update
    await page.locator('.box').getByText('"number": 101,').waitFor()
    const requests = [
      page.waitForResponse(response => response.url().includes('/__nuxt_island/LongAsyncComponent') && response.status() === 200),
      page.waitForResponse(response => response.url().includes('/__nuxt_island/AsyncServerComponent') && response.status() === 200),
    ]
    await page.locator('#update-server-components').click()
    await Promise.all(requests)

    await page.locator('#async-server-component-count').getByText('1').waitFor()
    await page.locator('#long-async-component-count').getByText('1').waitFor()

    // test islands slots interactivity
    await page.locator('#first-sugar-counter button').click()
    expect(await page.locator('#first-sugar-counter').innerHTML()).toContain('Sugar Counter 13')

    // test islands mounted client side with slot
    await page.locator('#show-island').click()
    expect(await page.locator('#island-mounted-client-side').innerHTML()).toContain('Interactive testing slot post SSR')
    expect(await page.locator('#island-mounted-client-side').innerHTML()).toContain('Sugar Counter')

    // test islands wrapped with client-only
    expect(await page.locator('#wrapped-client-only').innerHTML()).toContain('Was router enabled')

    if (!isWebpack) {
      // test nested client components
      await page.locator('.server-with-nested-client button').click()
      expect(await page.locator('.server-with-nested-client .sugar-counter').innerHTML()).toContain('Sugar Counter 13 x 1 = 13')
    }

    if (!isWebpack) {
      // test client component interactivity
      expect(await page.locator('.interactive-component-wrapper').innerHTML()).toContain('Sugar Counter 12')
      await page.locator('.interactive-component-wrapper button').click()
      expect(await page.locator('.interactive-component-wrapper').innerHTML()).toContain('Sugar Counter 13')
    }

    await page.close()
  })

  it('lazy server components', async () => {
    const { page, consoleLogs } = await renderPage('/server-components/lazy/start')

    await page.getByText('Go to page with lazy server component').click()

    const text = await page.innerText('pre')
    expect(text).toMatchInlineSnapshot('" End page <pre></pre><section id="fallback"> Loading server component </section><section id="no-fallback"><div></div></section><div></div>"')
    expect(text).not.toContain('async component that was very long')
    expect(text).toContain('Loading server component')

    // Wait for all pending micro ticks to be cleared
    // await page.waitForLoadState('networkidle')
    // await page.evaluate(() => new Promise(resolve => setTimeout(resolve, 10)))
    await page.waitForFunction(() => (document.querySelector('#no-fallback') as HTMLElement)?.innerText?.includes('async component'))
    await page.waitForFunction(() => (document.querySelector('#fallback') as HTMLElement)?.innerText?.includes('async component'))

    // test navigating back and forth for lazy <ServerWithClient> component (should not trigger any issue)
    await page.goBack({ waitUntil: 'networkidle' })
    await page.getByText('Go to page with lazy server component').click()
    await page.waitForLoadState('networkidle')

    expect(consoleLogs.filter(l => l.type === 'error')).toHaveLength(0)

    await page.close()
  })

  it('should not preload ComponentWithRef', async () => {
    // should not add <ComponentWithRef> to the modulepreload list since it is used only server side
    const { page } = await renderPage('/islands')
    const links = await page.locator('link').all()
    for (const link of links) {
      if (await link.getAttribute('rel') === 'modulepreload') {
        expect(await link.getAttribute('href')).not.toContain('ComponentWithRef')
      }
    }

    await page.close()
  })

  it('non-lazy server components', async () => {
    const { page } = await renderPage('/server-components/lazy/start')
    await page.waitForLoadState('networkidle')
    await page.getByText('Go to page without lazy server component').click()

    const text = (await page.innerText('pre')).replaceAll(/ data-island-uid="[^"]*"/g, '').replace(/data-island-component="[^"]*"/g, 'data-island-component')

    if (isWebpack) {
      expect(text).toMatchInlineSnapshot('" End page <pre></pre><section id="fallback"><div> This is a .server (20ms) async component that was very long ... <div id="async-server-component-count">42</div><div class="sugar-counter"> Sugar Counter 12 x 1 = 12 <button> Inc </button></div><!--[--><div style="display: contents;" data-island-slot="default"><!--teleport start--><!--teleport end--></div><!--]--></div></section><section id="no-fallback"><div> This is a .server (20ms) async component that was very long ... <div id="async-server-component-count">42</div><div class="sugar-counter"> Sugar Counter 12 x 1 = 12 <button> Inc </button></div><!--[--><div style="display: contents;" data-island-slot="default"><!--teleport start--><!--teleport end--></div><!--]--></div></section><div> ServerWithClient.server.vue : <p>count: 0</p> This component should not be preloaded <div><!--[--><div>a</div><div>b</div><div>c</div><!--]--></div> This is not interactive <div class="sugar-counter"> Sugar Counter 12 x 1 = 12 <button> Inc </button></div><div class="interactive-component-wrapper" style="border:solid 1px red;"> The component below is not a slot but declared as interactive <div class="sugar-counter" nuxt-client=""> Sugar Counter 12 x 1 = 12 <button> Inc </button></div></div></div>"')
    } else {
      expect(text).toMatchInlineSnapshot('" End page <pre></pre><section id="fallback"><div> This is a .server (20ms) async component that was very long ... <div id="async-server-component-count">42</div><div class="sugar-counter"> Sugar Counter 12 x 1 = 12 <button> Inc </button></div><!--[--><div style="display: contents;" data-island-slot="default"><!--teleport start--><!--teleport end--></div><!--]--></div></section><section id="no-fallback"><div> This is a .server (20ms) async component that was very long ... <div id="async-server-component-count">42</div><div class="sugar-counter"> Sugar Counter 12 x 1 = 12 <button> Inc </button></div><!--[--><div style="display: contents;" data-island-slot="default"><!--teleport start--><!--teleport end--></div><!--]--></div></section><div> ServerWithClient.server.vue : <p>count: 0</p> This component should not be preloaded <div><!--[--><div>a</div><div>b</div><div>c</div><!--]--></div> This is not interactive <div class="sugar-counter"> Sugar Counter 12 x 1 = 12 <button> Inc </button></div><div class="interactive-component-wrapper" style="border:solid 1px red;"> The component below is not a slot but declared as interactive <!--[--><div style="display: contents;" data-island-component></div><!--teleport start--><!--teleport end--><!--]--></div></div>"')
    }
    expect(text).toContain('async component that was very long')

    // Wait for all pending micro ticks to be cleared
    // await page.waitForLoadState('networkidle')
    // await page.evaluate(() => new Promise(resolve => setTimeout(resolve, 10)))
    await page.waitForFunction(() => (document.querySelector('#no-fallback') as HTMLElement)?.innerText?.includes('async component'))
    await page.waitForFunction(() => (document.querySelector('#fallback') as HTMLElement)?.innerText?.includes('async component'))

    await page.close()
  })

  it('/server-page', async () => {
    const html = await $fetch<string>('/server-page')
    // test island head
    expect(html).toContain('<meta name="author" content="Nuxt">')
    expect(html).toContain('plugin-style')
  })

  it('/server-page - client side navigation', async () => {
    const { page } = await renderPage('/')
    await page.getByText('to server page').click()
    await page.waitForLoadState('networkidle')

    expect(await page.innerHTML('head')).toContain('<meta name="author" content="Nuxt">')
    await page.close()
  })

  it.skipIf(isDev)('should allow server-only components to set prerender hints', async () => {
    // @ts-expect-error ssssh! untyped secret property
    const publicDir = useTestContext().nuxt._nitro.options.output.publicDir
    expect(await readdir(join(publicDir, 'catchall', 'some', 'url', 'from', 'server-only', 'component')).catch(() => [])).toContain(
      isRenderingJson
        ? '_payload.json'
        : '_payload.js',
    )
  })
})

describe.skipIf(isDev || isWindows || !isRenderingJson)('prefetching', () => {
  it('should prefetch components', async () => {
    await expectNoClientErrors('/prefetch/components')
  })

  it('should prefetch server components', async () => {
    await expectNoClientErrors('/prefetch/server-components')
  })

  it.skipIf(!isTestingAppManifest)('should prefetch everything needed when NuxtLink is used', async () => {
    const { page, requests } = await renderPage()

    await gotoPath(page, '/prefetch')
    await page.waitForLoadState('networkidle')

    expect(requests.some(req => req.startsWith('/__nuxt_island/AsyncServerComponent'))).toBe(true)
    requests.length = 0
    await page.click('[href="/prefetch/server-components"]')
    await page.waitForLoadState('networkidle')

    expect(await page.innerHTML('#async-server-component-count')).toBe('34')

    expect(requests.some(req => req.startsWith('/__nuxt_island/AsyncServerComponent'))).toBe(false)
    await page.close()
  })

  it('should not prefetch certain dynamic imports by default', async () => {
    const html = await $fetch<string>('/auth')
    // should not prefetch global components
    expect(html).not.toMatch(/<link [^>]*\/_nuxt\/TestGlobal[^>]*\.js"/)
    // should not prefetch all other pages
    expect(html).not.toMatch(/<link [^>]*\/_nuxt\/navigate-to[^>]*\.js"/)
  })
})

// TODO: make test less flakey on Windows
describe.runIf(isDev && (!isWindows || !isCI))('detecting invalid root nodes', () => {
  it.each(['1', '2', '3', '4'])('should detect invalid root nodes in pages (\'/invalid-root/%s\')', async (path) => {
    const { consoleLogs, page } = await renderPage(joinURL('/invalid-root', path))
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, joinURL('/invalid-root', path))
    await expect.poll(() => consoleLogs.map(w => w.text).join('\n'))
      .toContain('does not have a single root node and will cause errors when navigating between routes')

    await page.close()
  })

  it.each(['fine'])('should not complain if there is no transition (%s)', async (path) => {
    const { consoleLogs, page } = await renderPage(joinURL('/invalid-root', path))
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, joinURL('/invalid-root', path))

    const consoleLogsWarns = consoleLogs.filter(i => i.type === 'warning')
    expect(consoleLogsWarns.length).toEqual(0)

    await page.close()
  })
})

describe('public directories', () => {
  it('should directly return public directory paths', async () => {
    const html = await $fetch<string>('/assets-custom')
    expect(html).toContain('"/public.svg"')
    expect(html).toContain('"/custom/file.svg"')
  })
})

// TODO: dynamic paths in dev
describe.skipIf(isDev)('dynamic paths', () => {
  const publicFiles = ['/public.svg', '/css-only-public-asset.svg']
  const isPublicFile = (base = '/', file: string) => {
    if (isWebpack) {
      // TODO: webpack does not yet support dynamic static paths
      expect(publicFiles).toContain(file)
      return true
    }

    expect(file).toMatch(new RegExp(`^${base.replace(/\//g, '\\/')}`))
    expect(publicFiles).toContain(file.replace(base, '/'))
    return true
  }

  it('should work with no overrides', async () => {
    const html: string = await $fetch<string>('/assets')
    for (const match of html.matchAll(/(?:href|src)="(.*?)"|url\(([^)]*)\)/g)) {
      const url = match[1] || match[2]!
      if (url.startsWith('data:')) { continue }
      expect(url.startsWith('/_nuxt/') || isPublicFile('/', url)).toBeTruthy()
    }
  })

  // webpack injects CSS differently
  it.skipIf(isWebpack)('adds relative paths to CSS', async () => {
    const html: string = await $fetch<string>('/assets')
    const urls = Array.from(html.matchAll(/(href|src)="(.*?)"|url\(([^)]*)\)/g)).map(m => m[2] || m[3])
    const cssURL = urls.find(u => /_nuxt\/assets.*\.css$/.test(u!))
    expect(cssURL).toBeDefined()
    const css = await $fetch<string>(cssURL!)
    const imageUrls = new Set(Array.from(css.matchAll(/url\(([^)]*)\)/g)).map(m => m[1]!.replace(/[-.]\w{8}\./g, '.')))
    expect([...imageUrls]).toMatchInlineSnapshot(`
      [
        "./logo.svg",
        "../public.svg",
      ]
    `)
  })

  it('should allow setting base URL and build assets directory', async () => {
    await startServer({
      env: {
        NUXT_APP_BUILD_ASSETS_DIR: '/_other/',
        NUXT_APP_BASE_URL: '/foo/',
      },
    })

    const html = await $fetch<string>('/foo/assets')
    for (const match of html.matchAll(/(?:href|src)="(.*?)"|url\(([^)]*)\)/g)) {
      const url = match[1] || match[2]!
      if (url.startsWith('data:')) { continue }
      expect(url.startsWith('/foo/_other/') || isPublicFile('/foo/', url)).toBeTruthy()
    }

    expect(await $fetch<string>('/foo/url')).toContain('path: /foo/url')
  })

  it('should allow setting relative baseURL', async () => {
    await startServer({
      env: {
        NUXT_APP_BASE_URL: './',
      },
    })

    const html = await $fetch<string>('/assets')
    for (const match of html.matchAll(/(?:href|src)="(.*?)"|url\(([^)]*)\)/g)) {
      const url = match[1] || match[2]!
      if (url.startsWith('data:')) { continue }
      expect(url.startsWith('./_nuxt/') || isPublicFile('./', url)).toBeTruthy()
      expect(url.startsWith('./_nuxt/_nuxt')).toBeFalsy()
    }
  })

  it('should use baseURL when redirecting', async () => {
    await startServer({
      env: {
        NUXT_APP_BUILD_ASSETS_DIR: '/_other/',
        NUXT_APP_BASE_URL: '/foo/',
      },
    })
    const { headers } = await fetch('/foo/navigate-to/', { redirect: 'manual' })

    expect(headers.get('location')).toEqual('/foo/')
  })

  it('should allow setting CDN URL', async () => {
    await startServer({
      env: {
        NUXT_APP_BASE_URL: '/foo/',
        NUXT_APP_CDN_URL: 'https://example.com/',
        NUXT_APP_BUILD_ASSETS_DIR: '/_cdn/',
      },
    })

    const html = await $fetch<string>('/foo/assets')
    for (const match of html.matchAll(/(?:href|src)="(.*?)"|url\(([^)]*)\)/g)) {
      const url = match[1] || match[2]!
      if (url.startsWith('data:')) { continue }
      expect(url.startsWith('https://example.com/_cdn/') || isPublicFile('https://example.com/', url)).toBeTruthy()
    }
  })

  it.skipIf(isDev || isWebpack)('should render relative importmap path with relative path', async () => {
    await startServer({
      env: {
        NUXT_APP_BASE_URL: '',
        NUXT_APP_BUILD_ASSETS_DIR: 'assets/',
      },
    })

    const html = await $fetch<string>('/')
    expect(html).toContain('<script type="importmap">{"imports":{"#entry":"./assets')
  })

  it('restore server', async () => {
    await startServer()
  })
})

describe('app config', () => {
  it('should work', async () => {
    const html = await $fetch<string>('/app-config')

    const expectedAppConfig: Record<string, any> = {
      fromNuxtConfig: true,
      nested: {
        val: 2,
      },
      nuxt: {},
      fromLayer: true,
      userConfig: 123,
    }
    expect.soft(html).toContain(JSON.stringify(expectedAppConfig))

    const serverAppConfig = await $fetch<Record<string, any>>('/api/app-config')
    expect(serverAppConfig).toMatchObject({ appConfig: expectedAppConfig })
  })
})

describe('component islands', () => {
  it('renders components with route', async () => {
    const result = await $fetch<NuxtIslandResponse>('/__nuxt_island/RouteComponent.json?url=/foo')

    result.html = result.html.replace(/ data-island-uid="[^"]*"/g, '')
    if (isDev) {
      result.head.link = result.head.link?.filter(l => typeof l.href !== 'string' || (!l.href.includes('_nuxt/components/islands/RouteComponent') && !l.href.includes('PureComponent') /* TODO: fix dev bug triggered by previous fetch of /islands */))
    }

    result.head.link ||= []
    result.head.style ||= []

    expect(result).toMatchInlineSnapshot(`
      {
        "head": {
          "link": [],
          "style": [],
        },
        "html": "<pre data-island-uid>    Route: /foo
        </pre>",
      }
    `)
  })

  it('render async component', async () => {
    const result = await $fetch<NuxtIslandResponse>(withQuery('/__nuxt_island/LongAsyncComponent.json', {
      props: JSON.stringify({
        count: 3,
      }),
    }))
    if (isDev) {
      result.head.link = result.head.link?.filter(l => typeof l.href !== 'string' || (!l.href.includes('_nuxt/components/islands/LongAsyncComponent') && !l.href.includes('PureComponent') /* TODO: fix dev bug triggered by previous fetch of /islands */))
    }

    result.head.link ||= []
    result.head.style ||= []
    result.html = result.html.replaceAll(/ (?:data-island-uid|data-island-component)="[^"]*"/g, '')
    expect(result).toMatchInlineSnapshot(`
      {
        "head": {
          "link": [],
          "style": [],
        },
        "html": "<div data-island-uid><div> count is above 2 </div><!--[--><div style="display: contents;" data-island-uid data-island-slot="default"><!--teleport start--><!--teleport end--></div><!--]--> that was very long ... <div id="long-async-component-count">3</div>  <!--[--><div style="display: contents;" data-island-uid data-island-slot="test"><!--teleport start--><!--teleport end--></div><!--]--><p>hello world !!!</p><!--[--><div style="display: contents;" data-island-uid data-island-slot="hello"><!--teleport start--><!--teleport end--></div><!--teleport start--><!--teleport end--><!--]--><!--[--><div style="display: contents;" data-island-uid data-island-slot="fallback"><!--teleport start--><!--teleport end--></div><!--teleport start--><!--teleport end--><!--]--></div>",
        "slots": {
          "default": {
            "props": [],
          },
          "fallback": {
            "fallback": "<!--teleport start anchor--><!--[--><div style="display:contents;"><div>fall slot -- index: 0</div><div class="fallback-slot-content"> wonderful fallback </div></div><div style="display:contents;"><div>back slot -- index: 1</div><div class="fallback-slot-content"> wonderful fallback </div></div><!--]--><!--teleport anchor-->",
            "props": [
              {
                "t": "fall",
              },
              {
                "t": "back",
              },
            ],
          },
          "hello": {
            "fallback": "<!--teleport start anchor--><!--[--><div style="display:contents;"><div> fallback slot -- index: 0</div></div><div style="display:contents;"><div> fallback slot -- index: 1</div></div><div style="display:contents;"><div> fallback slot -- index: 2</div></div><!--]--><!--teleport anchor-->",
            "props": [
              {
                "t": 0,
              },
              {
                "t": 1,
              },
              {
                "t": 2,
              },
            ],
          },
          "test": {
            "props": [
              {
                "count": 3,
              },
            ],
          },
        },
      }
    `)
  })

  it('render .server async component', async () => {
    const result = await $fetch<NuxtIslandResponse>(withQuery('/__nuxt_island/AsyncServerComponent.json', {
      props: JSON.stringify({
        count: 2,
      }),
    }))
    if (isDev) {
      result.head.link = result.head.link?.filter(l => typeof l.href === 'string' && !l.href.includes('PureComponent') /* TODO: fix dev bug triggered by previous fetch of /islands */ && (!l.href.startsWith('_nuxt/components/islands/') || l.href.includes('AsyncServerComponent')))
    }

    result.head.link ||= []
    result.head.style ||= []
    result.props = {}
    result.components = {}
    result.slots = {}
    result.html = result.html.replaceAll(/ (?:data-island-uid|data-island-component)="[^"]*"/g, '')

    expect(result).toMatchInlineSnapshot(`
      {
        "components": {},
        "head": {
          "link": [],
          "style": [],
        },
        "html": "<div data-island-uid> This is a .server (20ms) async component that was very long ... <div id="async-server-component-count">2</div><div class="sugar-counter"> Sugar Counter 12 x 1 = 12 <button> Inc </button></div><!--[--><div style="display: contents;" data-island-uid data-island-slot="default"><!--teleport start--><!--teleport end--></div><!--]--></div>",
        "props": {},
        "slots": {},
      }
    `)
  })

  if (!isWebpack) {
    it('render server component with selective client hydration', async () => {
      const result = await $fetch<NuxtIslandResponse>('/__nuxt_island/ServerWithClient')
      if (isDev) {
        result.head.link = result.head.link?.filter(l => typeof l.href !== 'string' || (!l.href.includes('_nuxt/components/islands/LongAsyncComponent') && !l.href.includes('PureComponent') /* TODO: fix dev bug triggered by previous fetch of /islands */))

        if (!result.head.link) {
          delete result.head.link
        }
      }
      const { components } = result
      result.components = {}
      result.slots = {}
      result.html = result.html.replace(/data-island-component="[^"]*"/g, 'data-island-component')

      const teleportsEntries = Object.entries(components || {})

      result.head.link ||= []
      result.head.style ||= []

      expect(result).toMatchInlineSnapshot(`
        {
          "components": {},
          "head": {
            "link": [],
            "style": [],
          },
          "html": "<div data-island-uid> ServerWithClient.server.vue : <p>count: 0</p> This component should not be preloaded <div><!--[--><div>a</div><div>b</div><div>c</div><!--]--></div> This is not interactive <div class="sugar-counter"> Sugar Counter 12 x 1 = 12 <button> Inc </button></div><div class="interactive-component-wrapper" style="border:solid 1px red;"> The component below is not a slot but declared as interactive <!--[--><div style="display: contents;" data-island-uid data-island-component></div><!--teleport start--><!--teleport end--><!--]--></div></div>",
          "slots": {},
        }
      `)
      expect(teleportsEntries).toHaveLength(1)
      expect(teleportsEntries[0]![1].props).toMatchInlineSnapshot(`
        {
          "multiplier": 1,
        }
      `)
      expect(teleportsEntries[0]![1].html).toMatchInlineSnapshot(`"<div class="sugar-counter"> Sugar Counter 12 x 1 = 12 <button> Inc </button></div><!--teleport anchor-->"`)
    })
  }

  it('renders pure components', async () => {
    const result = await $fetch<NuxtIslandResponse>(withQuery('/__nuxt_island/PureComponent.json', {
      props: JSON.stringify({
        bool: false,
        number: 3487,
        str: 'something',
        obj: { foo: 42, bar: false, me: 'hi' },
      }),
    }))
    result.html = result.html.replace(/ data-island-uid="[^"]*"/g, '')

    if (isDev) {
      const fixtureDir = normalize(fileURLToPath(new URL('./fixtures/basic', import.meta.url)))
      for (const key in result.head) {
        if (key === 'link') {
          result.head[key] = result.head[key]?.map((h) => {
            h.href &&= (h.href).replace(fixtureDir, '/<rootDir>').replaceAll('//', '/')
            return h
          })
        }
      }
    }

    if (!isDev) {
      expect(normaliseIslandResult(result).head).toMatchInlineSnapshot(`
        {
          "style": [
            {
              "innerHTML": "pre[data-v-xxxxx]{color:#00f}",
            },
          ],
        }
      `)
    } else {
      // TODO: resolve dev bug triggered by earlier fetch of /vueuse-head page
      // https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/core/runtime/nitro/handlers/renderer.ts#L139
      result.head.link = result.head.link?.filter(l => typeof l.href !== 'string' || !l.href.includes('SharedComponent'))
      if (result.head.link?.[0]?.href) {
        result.head.link[0].href = result.head.link[0].href.replace(/scoped=[^?&]+/, 'scoped=xxxxx')
      }

      expect(result.head).toMatchInlineSnapshot(`
        {
          "link": [
            {
              "crossorigin": "",
              "href": "/_nuxt/components/islands/PureComponent.vue?vue&type=style&index=0&scoped=xxxxx&lang.css",
              "rel": "stylesheet",
            },
          ],
        }
      `)
    }

    expect(result.html.replace(/data-v-\w+|"|<!--.*-->/g, '').replace(/data-island-uid="[^"]"/g, '')).toMatchInlineSnapshot(`
      "<div data-island-uid > Was router enabled: true <br > Props: <pre >{
        number: 3487,
        str: something,
        obj: {
          foo: 42,
          bar: false,
          me: hi
        },
        bool: false
      }</pre></div>"
    `)
  })

  it('test client-side navigation', async () => {
    const { page } = await renderPage('/')
    await page.click('#islands')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/islands')

    await page.locator('#increase-pure-component').click()
    await page.waitForResponse(response => response.url().includes('/__nuxt_island/') && response.status() === 200)

    await page.locator('#slot-in-server').getByText('Slot with in .server component').waitFor()
    await page.locator('#test-slot').getByText('Slot with name test').waitFor()

    // test islands update
    expect(await page.locator('.box').innerHTML()).toContain('"number": 101,')
    const islandRequests = [
      page.waitForResponse(response => response.url().includes('/__nuxt_island/LongAsyncComponent') && response.status() === 200),
      page.waitForResponse(response => response.url().includes('/__nuxt_island/AsyncServerComponent') && response.status() === 200),
    ]
    await page.locator('#update-server-components').click()
    await Promise.all(islandRequests)

    await page.locator('#long-async-component-count').getByText('1').waitFor()

    // test islands slots interactivity
    await page.locator('#first-sugar-counter button').click()
    expect(await page.locator('#first-sugar-counter').innerHTML()).toContain('Sugar Counter 13')

    if (!isWebpack) {
      // test client component interactivity
      expect(await page.locator('.interactive-component-wrapper').innerHTML()).toContain('Sugar Counter 12')
      await page.locator('.interactive-component-wrapper button').click()
      expect(await page.locator('.interactive-component-wrapper').innerHTML()).toContain('Sugar Counter 13')
    }

    await page.close()
  })

  it.skipIf(isDev)('should not render an error when having a baseURL', async () => {
    await startServer({
      env: {
        NUXT_APP_BASE_URL: '/foo/',
      },
    })

    const result = await fetch('/foo/islands')
    expect(result.status).toBe(200)

    await startServer()
  })

  it('render island page', async () => {
    const { page } = await renderPage('/')

    const islandPageRequest = page.waitForRequest((req) => {
      return req.url().includes('/__nuxt_island/page_server-page')
    })
    await page.getByText('to server page').click()
    await islandPageRequest
    await page.locator('#server-page').waitFor()
  })

  it('should show error on 404 error for server pages during client navigation', async () => {
    const { page } = await renderPage('/')
    await page.click('[href="/server-components/lost-page"]')
    await page.getByText('This is the error page').waitFor()
  })
})

describe.runIf(isDev && !isWebpack)('vite plugins', () => {
  it('does not override vite plugins', async () => {
    expect(await $fetch<string>('/vite-plugin-without-path')).toBe('vite-plugin without path')
    expect(await $fetch<string>('/__nuxt-test')).toBe('vite-plugin with __nuxt prefix')
  })
  it('does not allow direct access to nuxt source folder', async () => {
    expect(await fetch('/app.config').then(r => r.status)).toBe(404)
  })
})

describe.skipIf(isWindows || !isRenderingJson)('payload rendering', () => {
  it('renders a payload', async () => {
    const payload = await $fetch<string>('/random/a/_payload.json', { responseType: 'text' })
    const data = parsePayload(payload)
    expect(typeof data.prerenderedAt).toEqual('number')

    expect(data.data).toMatchObject({
      hey: {
        baz: 'qux',
        foo: 'bar',
      },
      rand_a: expect.arrayContaining([expect.anything()]),
    })
  })

  // TODO: looks like this test is flaky
  it.skipIf(!isTestingAppManifest)('does not fetch a prefetched payload', { retry: 3 }, async () => {
    const { page, requests } = await renderPage()

    await gotoPath(page, '/random/a')

    // We are manually prefetching other payloads
    await page.waitForRequest(request => request.url().includes('/random/c/_payload.json'))

    // We are not triggering API requests in the payload
    expect(requests).not.toContainEqual(expect.stringContaining('/api/random'))
    expect(requests).not.toContainEqual(expect.stringContaining('/__nuxt_island'))
    // requests.length = 0

    await page.click('[href="/random/b"]')
    await page.waitForLoadState('networkidle')

    // We are not triggering API requests in the payload in client-side nav
    expect(requests).not.toContain('/api/random')
    expect(requests).not.toContainEqual(expect.stringContaining('/__nuxt_island'))

    // We are fetching a payload we did not prefetch
    expect(requests).toContainEqual(expect.stringContaining('/random/b/_payload.json'))

    // We are not refetching payloads we've already prefetched
    // expect(requests.filter(p => p.includes('_payload')).length).toBe(1)
    // requests.length = 0

    await page.click('[href="/random/c"]')
    await page.waitForLoadState('networkidle')

    // We are not triggering API requests in the payload in client-side nav
    expect(requests).not.toContain('/api/random')
    expect(requests).not.toContainEqual(expect.stringContaining('/__nuxt_island'))

    // We are not refetching payloads we've already prefetched
    // Note: we refetch on dev as urls differ between '' and '?import'
    // expect(requests.filter(p => p.includes('_payload')).length).toBe(isDev ? 1 : 0)

    await page.close()
  })

  it('should not render payloads for non prerendered/cached routes', async () => {
    // First request to trigger ISR caching
    const res = await fetch('/_payload.json')
    expect(res.status).toBe(404)
  })

  it.skipIf(!isRenderingJson)('should not include server-component HTML in payload', async () => {
    const payload = await $fetch<string>('/prefetch/server-components/_payload.json', { responseType: 'text' })
    const entries = Object.entries(parsePayload(payload))
    const [key, serializedComponent] = entries.find(([key]) => key.startsWith('AsyncServerComponent')) || []
    expect(serializedComponent).toEqual(key)
  })

  it('should render payload for ISR routes', async () => {
    const payload = await $fetch<string>('/isr/_payload.json', { responseType: 'text' })
    const data = parsePayload(payload)
    expect(data.data).toBeDefined()
    expect(data.data['isr-data']).toBeDefined()
    expect(Array.isArray(data.data['isr-data'])).toBe(true)
  })

  it('should render payload for SWR routes', async () => {
    const payload = await $fetch<string>('/swr/_payload.json', { responseType: 'text' })
    const data = parsePayload(payload)
    expect(data.data).toBeDefined()
    expect(data.data['swr-data']).toBeDefined()
    expect(Array.isArray(data.data['swr-data'])).toBe(true)
  })
})

describe.skipIf(!asyncContext)('Async context', () => {
  it('should be available', async () => {
    expect(await $fetch<string>('/async-context')).toContain('&quot;hasApp&quot;: true')
  })
})

describe.skipIf(asyncContext)('Async context', () => {
  it('should be unavailable', async () => {
    expect(await $fetch<string>('/async-context')).toContain('&quot;hasApp&quot;: false')
  })
})

describe.skipIf(isWindows)('useAsyncData', () => {
  it('works after useNuxtData call', async () => {
    const page = await createPage('/useAsyncData/nuxt-data')
    expect(await page.locator('body').getByText('resolved:true').textContent()).toContain('resolved:true')
    await page.close()
  })

  it('single request resolves', async () => {
    await expectNoClientErrors('/useAsyncData/single')
  })

  it('two requests resolve', async () => {
    await expectNoClientErrors('/useAsyncData/double')
  })

  it('two requests resolve and sync', async () => {
    await $fetch<string>('/useAsyncData/refresh')
  })

  it('two requests made at once resolve and sync', async () => {
    await expectNoClientErrors('/useAsyncData/promise-all')
  })

  it('requests status can be used', async () => {
    const html = await $fetch<string>('/useAsyncData/status')
    expect(html).toContain('true')
    expect(html).not.toContain('false')

    const page = await createPage('/useAsyncData/status')
    await page.locator('#status5-values').getByText('idle,pending,success').waitFor()
    await page.close()
  })

  it('data is null after navigation when immediate false', async () => {
    const defaultValue = 'undefined'

    const { page } = await renderPage('/useAsyncData/immediate-remove-unmounted')
    expect(await page.locator('#immediate-data').getByText(defaultValue).textContent()).toBe(defaultValue)

    await page.click('#execute-btn')
    expect(await page.locator('#immediate-data').getByText(',').textContent()).not.toContain(defaultValue)

    await page.click('#to-index')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/')

    await page.click('#to-immediate-remove-unmounted')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath === '/useAsyncData/immediate-remove-unmounted')
    expect(await page.locator('#immediate-data').getByText(defaultValue).textContent()).toBe(defaultValue)

    await page.click('#execute-btn')
    expect(await page.locator('#immediate-data').getByText(',').textContent()).not.toContain(defaultValue)

    await page.close()
  })
  it('works with useId', async () => {
    const html = await $fetch<string>('/useAsyncData/use-id')
    expect(html).toContain('<div>v-0-0-0</div> v-0-0</div>')
    await expectNoClientErrors('/useAsyncData/use-id')
  })
})

describe.runIf(isDev)('component testing', () => {
  it('should work', async () => {
    // TODO: fix in nuxt/test-utils
    const comp1 = await $fetchComponent('app/components/Counter.vue', { multiplier: 2 })
    expect(comp1).toContain('12 x 2 = 24')

    // TODO: fix in nuxt/test-utils
    const comp2 = await $fetchComponent('app/components/Counter.vue', { multiplier: 4 })
    expect(comp2).toContain('12 x 4 = 48')
  })
})

describe('keepalive', () => {
  it('should not keepalive by default', async () => {
    const { page, consoleLogs } = await renderPage('/keepalive')

    const pageName = 'not-keepalive'
    await page.click(`#${pageName}`)
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, `/keepalive/${pageName}`)

    expect(consoleLogs.map(l => l.text).filter(t => t.includes('keepalive'))).toEqual([`${pageName}: onMounted`])

    await page.close()
  })

  it('should not keepalive when included in app config but config in nuxt-page is not undefined', async () => {
    const { page, consoleLogs } = await renderPage('/keepalive')

    const pageName = 'keepalive-in-config'
    await page.click(`#${pageName}`)
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, `/keepalive/${pageName}`)

    expect(consoleLogs.map(l => l.text).filter(t => t.includes('keepalive'))).toEqual([`${pageName}: onMounted`])

    await page.close()
  })

  it('should not keepalive when included in app config but exclueded in nuxt-page', async () => {
    const { page, consoleLogs } = await renderPage('/keepalive')

    const pageName = 'not-keepalive-in-nuxtpage'
    await page.click(`#${pageName}`)
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, `/keepalive/${pageName}`)

    expect(consoleLogs.map(l => l.text).filter(t => t.includes('keepalive'))).toEqual([`${pageName}: onMounted`])

    await page.close()
  })

  it('should keepalive when included in nuxt-page', async () => {
    const { page, consoleLogs } = await renderPage('/keepalive')

    const pageName = 'keepalive-in-nuxtpage'
    await page.click(`#${pageName}`)
    await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, `/keepalive/${pageName}`)

    expect(consoleLogs.map(l => l.text).filter(t => t.includes('keepalive'))).toEqual([`${pageName}: onMounted`, `${pageName}: onActivated`])

    await page.close()
  })

  it('should preserve keepalive config when navigate routes in nuxt-page', async () => {
    const { page, consoleLogs } = await renderPage('/keepalive')

    const slugs = [
      'keepalive-in-nuxtpage',
      'keepalive-in-nuxtpage-2',
      'keepalive-in-nuxtpage',
      'not-keepalive',
      'keepalive-in-nuxtpage-2',
    ]

    for (const slug of slugs) {
      await page.click(`#${slug}`)
      await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path, `/keepalive/${slug}`)
    }

    expect(consoleLogs.map(l => l.text).filter(t => t.includes('keepalive'))).toEqual([
      'keepalive-in-nuxtpage: onMounted',
      'keepalive-in-nuxtpage: onActivated',
      'keepalive-in-nuxtpage: onDeactivated',
      'keepalive-in-nuxtpage-2: onMounted',
      'keepalive-in-nuxtpage-2: onActivated',
      'keepalive-in-nuxtpage: onActivated',
      'keepalive-in-nuxtpage-2: onDeactivated',
      'keepalive-in-nuxtpage: onDeactivated',
      'not-keepalive: onMounted',
      'keepalive-in-nuxtpage-2: onActivated',
      'not-keepalive: onUnmounted',
    ])

    await page.close()
  })
})

describe('teleports', () => {
  it('should append teleports to body', async () => {
    const html = await $fetch<string>('/teleport')

    // Teleport is prepended to body, before the __nuxt div
    expect(html).toContain('<div>Teleport</div><!--teleport anchor--><div id="__nuxt">')
    // Teleport start and end tag are rendered as expected
    expect(html).toContain('<div><!--teleport start--><!--teleport end--><h1>Normal content</h1></div>')
  })
  it('should render teleports to app teleports element', async () => {
    const html = await $fetch<string>('/nuxt-teleport')

    // Teleport is appended to body, after the __nuxt div
    expect(html).toContain('<div><!--teleport start--><!--teleport end--><h1>Normal content</h1></div></div><!--]--></div><span id="nuxt-teleport"><!--teleport start anchor--><div>Nuxt Teleport</div><!--teleport anchor--></span><script')
  })
})

describe('experimental', () => {
  it('decorators support works', async () => {
    const html = await $fetch('/experimental/decorators')
    expect(html).toContain('decorated-decorated')
    expectNoClientErrors('/experimental/decorators')
  })

  it('Node.js compatibility for client-side', async () => {
    const { page } = await renderPage('/experimental/node-compat')
    await page.locator('body').getByText('Nuxt is Awesome!').waitFor()
    expect(await page.innerHTML('body')).toContain('CWD: [available]')
    await page.close()
  }, 40_000)
})

function normaliseIslandResult (result: NuxtIslandResponse) {
  if (result.head.style) {
    for (const style of result.head.style) {
      if (typeof style !== 'string') {
        style.innerHTML &&=
          (style.innerHTML as string)
            .replace(/data-v-[a-z0-9]+/g, 'data-v-xxxxx')
          // Vite 6 enables CSS minify by default for SSR
            .replace(/blue/, '#00f')
        style.key &&= style.key.replace(/-[a-z0-9]+$/i, '')
      }
    }
  }
  return result
}

describe('import components', () => {
  let html = ''

  it('fetch import-components page', { sequential: true }, async () => {
    html = await $fetch<string>('/import-components')
  })

  it('load default component with mode all', () => {
    expect(html).toContain('default-comp-all')
  })

  it('load default component with mode client', () => {
    expect(html).toContain('default-comp-client')
  })

  it('load default component with mode server', () => {
    expect(html).toContain('default-comp-server')
  })

  it('load named component with mode all', () => {
    expect(html).toContain('named-comp-all')
  })

  it('load named component with mode client', () => {
    expect(html).toContain('named-comp-client')
  })

  it('load named component with mode server', () => {
    expect(html).toContain('named-comp-server')
  })
})

describe('lazy import components', () => {
  let html = ''

  it('fetch lazy-import-components page', { sequential: true }, async () => {
    html = await $fetch<string>('/lazy-import-components')
  })

  it('lazy load named component with mode all', () => {
    expect(html).toContain('lazy-named-comp-all')
  })

  it('lazy load named component with mode client', () => {
    expect(html).toContain('lazy-named-comp-client')
  })

  it('lazy load named component with mode server', () => {
    expect(html).toContain('lazy-named-comp-server')
  })

  const hydrationTests = {
    'in template': '',
    'with vue macros': '/macro',
  }

  describe.each(Object.entries(hydrationTests))('delayed hydration components %s', (description, path) => {
    it('lazy load delayed hydration comps at the right time', { timeout: 20_000 }, async () => {
      const html = await $fetch<string>(`/lazy-import-components/delayed-hydration${path}`)

      const hydratedText = 'This is mounted.'
      const unhydratedText = 'This is not mounted.'

      expect.soft(html).toContain(unhydratedText)
      expect.soft(html).not.toContain(hydratedText)

      const { page } = await renderPage(`/lazy-import-components/delayed-hydration${path}`)

      await page.locator('data-testid=hydrate-on-visible', { hasText: hydratedText }).waitFor()
      expect.soft(await page.locator('data-testid=hydrate-on-visible-bottom').textContent().then(r => r?.trim())).toBe(unhydratedText)

      await page.locator('data-testid=hydrate-on-interaction-default', { hasText: unhydratedText }).waitFor()
      await page.locator('data-testid=hydrate-on-interaction-click', { hasText: unhydratedText }).waitFor()

      await page.locator('data-testid=hydrate-when-always', { hasText: hydratedText }).waitFor()
      await page.locator('data-testid=hydrate-when-state', { hasText: unhydratedText }).waitFor()

      const component = page.getByTestId('hydrate-on-interaction-default')
      await component.hover()
      await page.locator('data-testid=hydrate-on-interaction-default', { hasText: hydratedText }).waitFor()

      await page.getByTestId('button-increase-state').click()
      await page.locator('data-testid=hydrate-when-state', { hasText: hydratedText }).waitFor()

      await page.getByTestId('hydrate-on-visible-bottom').scrollIntoViewIfNeeded()
      await page.locator('data-testid=hydrate-on-visible-bottom', { hasText: hydratedText }).waitFor()

      await page.locator('data-testid=hydrate-never', { hasText: unhydratedText }).waitFor()

      await page.close()
    })

    it('respects custom delayed hydration triggers and overrides defaults', async () => {
      const { page } = await renderPage(`/lazy-import-components/delayed-hydration${path}`)

      const unhydratedText = 'This is not mounted.'
      const hydratedText = 'This is mounted.'

      await page.locator('data-testid=hydrate-on-interaction-click', { hasText: unhydratedText }).waitFor({ state: 'visible' })

      await page.getByTestId('hydrate-on-interaction-click').hover()
      await page.locator('data-testid=hydrate-on-interaction-click', { hasText: unhydratedText }).waitFor({ state: 'visible' })

      await page.getByTestId('hydrate-on-interaction-click').click()
      await page.locator('data-testid=hydrate-on-interaction-click', { hasText: hydratedText }).waitFor({ state: 'visible' })
      await page.locator('data-testid=hydrate-on-interaction-click', { hasText: unhydratedText }).waitFor({ state: 'hidden' })

      await page.close()
    })

    it.runIf(description === 'in template')('does not delay hydration of components named after modifiers', async () => {
      const { page } = await renderPage('/lazy-import-components/delayed-hydration')

      await page.locator('data-testid=event-view-normal-component', { hasText: 'This is mounted.' }).waitFor()
      await page.locator('data-testid=event-view-normal-component', { hasText: 'This is not mounted.' }).waitFor({ state: 'hidden' })

      await page.close()
    })

    it('handles time-based hydration correctly', async () => {
      const unhydratedText = 'This is not mounted.'
      const html = await $fetch<string>(`/lazy-import-components/delayed-hydration${path}/time`)
      expect(html).toContain(unhydratedText)

      const { page, consoleLogs } = await renderPage(`/lazy-import-components/delayed-hydration${path}/time`)

      const hydratedText = 'This is mounted.'
      await page.locator('[data-testid=hydrate-after]', { hasText: hydratedText }).waitFor({ state: 'visible' })

      const hydrationLogs = consoleLogs.filter(log => !log.text.includes('[vite]') && !log.text.includes('<Suspense>'))
      expect(hydrationLogs.map(log => log.text)).toEqual([])

      await page.close()
    })

    it('keeps reactivity with models', async () => {
      const { page } = await renderPage(`/lazy-import-components/delayed-hydration${path}/model-event`)

      const countLocator = page.getByTestId('count')
      const incrementButton = page.getByTestId('increment')

      await countLocator.waitFor()

      for (let i = 0; i < 10; i++) {
        expect(await countLocator.textContent()).toBe(`${i}`)
        await incrementButton.hover()
        await incrementButton.click()
      }

      expect(await countLocator.textContent()).toBe('10')

      await page.close()
    })

    it('emits hydration events', async () => {
      const { page, consoleLogs } = await renderPage(`/lazy-import-components/delayed-hydration${path}/model-event`)

      const initialLogs = consoleLogs.filter(log => log.type === 'log' && log.text === 'Component hydrated')
      expect(initialLogs.length).toBe(0)

      await page.getByTestId('count').click()

      // Wait for all pending micro ticks to be cleared in case hydration hasn't finished yet.
      await page.evaluate(() => new Promise(resolve => setTimeout(resolve, 100)))
      const hydrationLogs = consoleLogs.filter(log => log.type === 'log' && log.text === 'Component hydrated')
      expect(hydrationLogs.length).toBeGreaterThan(0)

      await page.close()
    })
  })
})

describe('scrollToTop', () => {
  it('should not scroll to top when `scrollToTop` is `false`', async () => {
    const { page } = await renderPage('/route-scroll-behavior/scroll-to-top')

    await page.locator('#do-not-scroll-to-top').scrollIntoViewIfNeeded()
    await page.waitForFunction(() => window.scrollY > 0)

    await page.click('#do-not-scroll-to-top')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath.includes('/scroll-to-top/do-not-scroll-to-top'))

    const scrollY = await page.evaluate(() => window.scrollY)
    expect(scrollY !== 0).toBe(true)
  })

  it('should scroll to top when `scrollToTop` is `true`', async () => {
    const { page } = await renderPage('/route-scroll-behavior/scroll-to-top')

    await page.locator('#scroll-to-top').scrollIntoViewIfNeeded()
    await page.waitForFunction(() => window.scrollY > 0)

    await page.click('#scroll-to-top')
    await page.waitForFunction(() => window.useNuxtApp?.()._route.fullPath.includes('/scroll-to-top/scroll-to-top'))

    const scrollY = await page.evaluate(() => window.scrollY)
    expect(scrollY).toBe(0)
  })
})

describe('namespace access to useNuxtApp', () => {
  it('should return the nuxt instance when used with correct appId', async () => {
    const { page, pageErrors } = await renderPage('/namespace-nuxt-app')

    expect(pageErrors).toEqual([])

    await page.waitForFunction(() => window.useNuxtApp?.() && !window.useNuxtApp?.().isHydrating)

    // Defaulting to appId
    await page.evaluate(() => window.useNuxtApp?.())
    // Using correct configured appId
    // @ts-expect-error not public API yet
    await page.evaluate(() => window.useNuxtApp?.('nuxt-app-basic'))

    await page.close()
  })

  it('should throw an error when used with wrong appId', async () => {
    const { page, pageErrors } = await renderPage('/namespace-nuxt-app')

    expect(pageErrors).toEqual([])

    await page.waitForFunction(() => window.useNuxtApp?.() && !window.useNuxtApp?.().isHydrating)

    let error: unknown
    try {
      // Using wrong/unknown appId
      // @ts-expect-error not public API yet
      await page.evaluate(() => window.useNuxtApp?.('nuxt-app-unknown'))
    } catch (err) {
      error = err
    }

    expect(error).toBeTruthy()

    await page.close()
  })
})

describe('nuxt-time', () => {
  it('ssr', async () => {
    const html = await $fetch<string>('/components/nuxt-time')
    const snap = html.match(/<time[^>]*data-testid="fixed"[^>]*>[^<]*<\/time>/)?.[0].replace(/ data-prehydrate-id="[^"]*"/g, '')
    expect(snap).toContain(
      '<time data-month="long" data-day="numeric" datetime="2023-02-11T08:24:08.396Z" data-testid="fixed">',
    )
  })

  it.skipIf(isDev)('injects one script', async () => {
    const html = await $fetch<string>('/components/nuxt-time')

    const string = createRegExp(exactly('document.querySelectorAll'), ['g'])
    expect(html.match(string)?.length).toEqual(1)
  })

  it('has no hydration errors on the client', async () => {
    const page = await createPage(undefined, { locale: 'en-GB' })
    const logs: string[] = []

    page.on('console', (event) => {
      if (!event.text().includes('<Suspense>') && !event.text().includes('[vite]')) {
        logs.push(event.text())
      }
    })

    await page.goto(url('/components/nuxt-time'), { waitUntil: 'networkidle' })

    expect(await page.getByTestId('switchable').textContent()).toMatchInlineSnapshot(
      '"11 February at 8"',
    )
    expect(await page.getByTestId('fixed').textContent()).toMatchInlineSnapshot('"11 February"')

    await page.getByText('Switch locale').click()
    expect(await page.getByTestId('switchable').textContent()).toMatchInlineSnapshot(
      '"11 février à 8"',
    )
    expect(await page.getByTestId('fixed').textContent()).toMatchInlineSnapshot('"11 février"')

    await page.getByText('Update time').click()
    expect(await page.getByTestId('switchable').textContent()).not.toEqual('11 février à 8')
    expect(await page.getByTestId('fixed').textContent()).toMatchInlineSnapshot('"11 février"')

    // No hydration errors
    expect(logs.join('')).toMatchInlineSnapshot('""')
  })

  it('displays relative time correctly', async () => {
    const page = await createPage(undefined, { locale: 'en-GB' })
    const logs: string[] = []

    page.on('console', (event) => {
      if (!event.text().includes('<Suspense>') && !event.text().includes('[vite]')) {
        logs.push(event.text())
      }
    })

    await page.goto(url('/components/nuxt-time'), { waitUntil: 'networkidle' })

    expect(await page.getByTestId('relative').textContent()).toMatchInlineSnapshot(
      '"30 seconds ago"',
    )

    await page.getByTestId('relative').getByText('32 seconds ago').textContent()

    // No hydration errors
    expect(logs.join('')).toMatchInlineSnapshot('""')
  })
})
</file>

<file path="test/bundle.test.ts">
import { fileURLToPath } from 'node:url'
import fsp from 'node:fs/promises'
import { beforeAll, describe, expect, it } from 'vitest'
import { exec } from 'tinyexec'
import { glob } from 'tinyglobby'
import { join } from 'pathe'

describe.skipIf(process.env.SKIP_BUNDLE_SIZE === 'true' || process.env.ECOSYSTEM_CI)('minimal nuxt application', () => {
  const rootDir = fileURLToPath(new URL('./fixtures/minimal', import.meta.url))
  const pagesRootDir = fileURLToPath(new URL('./fixtures/minimal-pages', import.meta.url))

  beforeAll(async () => {
    await Promise.all([
      exec('pnpm', ['nuxt', 'build', rootDir], { nodeOptions: { env: { EXTERNAL_VUE: 'false' } } }),
      exec('pnpm', ['nuxt', 'build', rootDir], { nodeOptions: { env: { EXTERNAL_VUE: 'true' } } }),
      exec('pnpm', ['nuxt', 'build', pagesRootDir]),
    ])
  }, 120 * 1000)

  // Identical behaviour between inline/external vue options as this should only affect the server build

  it('default client bundle size', async () => {
    const [clientStats, clientStatsInlined] = await Promise.all((['.output', '.output-inline'])
      .map(outputDir => analyzeSizes(['**/*.js'], join(rootDir, outputDir, 'public'))))

    expect.soft(roundToKilobytes(clientStats!.totalBytes)).toMatchInlineSnapshot(`"112k"`)
    expect.soft(roundToKilobytes(clientStatsInlined!.totalBytes)).toMatchInlineSnapshot(`"112k"`)

    const files = new Set([...clientStats!.files, ...clientStatsInlined!.files].map(f => f.replace(/\..*\.js/, '.js')))

    expect([...files]).toMatchInlineSnapshot(`
      [
        "_nuxt/entry.js",
      ]
    `)
  })

  it('default client bundle size (pages)', async () => {
    const clientStats = await analyzeSizes(['**/*.js'], join(pagesRootDir, '.output/public'))

    expect.soft(roundToKilobytes(clientStats!.totalBytes)).toMatchInlineSnapshot(`"173k"`)

    const files = clientStats!.files.map(f => f.replace(/\..*\.js/, '.js'))

    expect([...files]).toMatchInlineSnapshot(`
      [
        "_nuxt/a.js",
        "_nuxt/client-component.js",
        "_nuxt/default.js",
        "_nuxt/entry.js",
        "_nuxt/index.js",
        "_nuxt/server-component.js",
      ]
    `)
  })

  it('default server bundle size', async () => {
    const serverDir = join(rootDir, '.output/server')

    const serverStats = await analyzeSizes(['**/*.mjs', '!node_modules'], serverDir)
    expect.soft(roundToKilobytes(serverStats.totalBytes)).toMatchInlineSnapshot(`"196k"`)

    const modules = await analyzeSizes(['node_modules/**/*'], serverDir)
    expect.soft(roundToKilobytes(modules.totalBytes)).toMatchInlineSnapshot(`"1430k"`)

    const packages = modules.files
      .filter(m => m.endsWith('package.json'))
      .map(m => m.replace('/package.json', '').replace('node_modules/', ''))
      .sort()
    expect(packages).toMatchInlineSnapshot(`
      [
        "@babel/parser",
        "@vue/compiler-core",
        "@vue/compiler-dom",
        "@vue/compiler-ssr",
        "@vue/reactivity",
        "@vue/runtime-core",
        "@vue/runtime-dom",
        "@vue/server-renderer",
        "@vue/shared",
        "devalue",
        "entities",
        "entities/dist/commonjs",
        "estree-walker",
        "hookable",
        "source-map-js",
        "ufo",
        "unhead",
        "vue",
        "vue-bundle-renderer",
      ]
    `)
  })

  it('default server bundle size (inlined vue modules)', async () => {
    const serverDir = join(rootDir, '.output-inline/server')

    const serverStats = await analyzeSizes(['**/*.mjs', '!node_modules'], serverDir)
    expect.soft(roundToKilobytes(serverStats.totalBytes)).toMatchInlineSnapshot(`"559k"`)

    const modules = await analyzeSizes(['node_modules/**/*'], serverDir)
    expect.soft(roundToKilobytes(modules.totalBytes)).toMatchInlineSnapshot(`"97.0k"`)

    const packages = modules.files
      .filter(m => m.endsWith('package.json'))
      .map(m => m.replace('/package.json', '').replace('node_modules/', ''))
      .sort()
    expect(packages).toMatchInlineSnapshot(`
      [
        "devalue",
        "hookable",
        "unhead",
      ]
    `)
  })

  it('default server bundle size (pages)', async () => {
    const serverDir = join(pagesRootDir, '.output/server')

    const serverStats = await analyzeSizes(['**/*.mjs', '!node_modules'], serverDir)
    expect.soft(roundToKilobytes(serverStats.totalBytes)).toMatchInlineSnapshot(`"290k"`)

    const modules = await analyzeSizes(['node_modules/**/*'], serverDir)
    expect.soft(roundToKilobytes(modules.totalBytes)).toMatchInlineSnapshot(`"1440k"`)

    const packages = modules.files
      .filter(m => m.endsWith('package.json'))
      .map(m => m.replace('/package.json', '').replace('node_modules/', ''))
      .sort()
    expect(packages).toMatchInlineSnapshot(`
      [
        "@babel/parser",
        "@vue/compiler-core",
        "@vue/compiler-dom",
        "@vue/compiler-ssr",
        "@vue/reactivity",
        "@vue/runtime-core",
        "@vue/runtime-dom",
        "@vue/server-renderer",
        "@vue/shared",
        "devalue",
        "entities",
        "entities/dist/commonjs",
        "estree-walker",
        "hookable",
        "source-map-js",
        "ufo",
        "unhead",
        "vue",
        "vue-bundle-renderer",
      ]
    `)
  })
})

async function analyzeSizes (pattern: string[], rootDir: string) {
  const files: string[] = await glob(pattern, { cwd: rootDir })
  let totalBytes = 0
  for (const file of files) {
    const path = join(rootDir, file)
    const isSymlink = (await fsp.lstat(path).catch(() => null))?.isSymbolicLink()

    if (!isSymlink) {
      const bytes = Buffer.byteLength(await fsp.readFile(path))
      totalBytes += bytes
    }
  }
  return { files, totalBytes }
}

function roundToKilobytes (bytes: number) {
  return (bytes / 1024).toFixed(bytes > (100 * 1024) ? 0 : 1) + 'k'
}
</file>

<file path="test/matrix.ts">
import { defu } from 'defu'
import type { NuxtConfig } from 'nuxt/schema'

export const isWebpack = process.env.TEST_BUILDER === 'webpack' || process.env.TEST_BUILDER === 'rspack'

export const isDev = process.env.TEST_ENV === 'dev'
export const isBuilt = !isDev

const _builder = process.env.TEST_BUILDER as 'webpack' | 'rspack' | 'vite' | 'vite-env-api'
export const builder = _builder === 'vite-env-api' ? 'vite' : (_builder ?? 'vite')

export const isTestingAppManifest = process.env.TEST_MANIFEST !== 'manifest-off'

export const asyncContext = process.env.TEST_CONTEXT === 'async'
export const typescriptBundlerResolution = process.env.MODULE_RESOLUTION !== 'node'

export const isRenderingJson = process.env.TEST_PAYLOAD !== 'js'

export function withMatrix (config: NuxtConfig) {
  return defu(config, {
    builder,
    future: {
      typescriptBundlerResolution,
    },
    experimental: {
      asyncContext,
      appManifest: isTestingAppManifest,
      renderJsonPayloads: isRenderingJson,
      viteEnvironmentApi: _builder === 'vite-env-api',
    },
    compatibilityDate: 'latest',
  })
}
</file>

<file path="test/prepare.ts">
import { fileURLToPath } from 'node:url'
import { rm } from 'node:fs/promises'

import { glob } from 'tinyglobby'
import { exec } from 'tinyexec'

async function initTesting () {
  const dirs = await glob(['*'], {
    onlyDirectories: true,
    cwd: fileURLToPath(new URL('./fixtures', import.meta.url)),
    absolute: true,
  })

  await Promise.all([
    // clear nuxt build files
    ...dirs.map(dir => rm(`${dir}/.nuxt`, { force: true, recursive: true })),
    // clear vite cache
    ...dirs.map(dir => rm(`${dir}/node_modules/.cache`, { force: true, recursive: true })),
  ])

  await Promise.all(
    dirs.map(dir => exec('pnpm', ['nuxt', 'prepare'], { nodeOptions: { cwd: dir } })),
  )
}

initTesting()
</file>

<file path="test/setup-env.ts">
import { consola } from 'consola'
import { vi } from 'vitest'
import { logger } from '@nuxt/kit'

consola.mockTypes(() => vi.fn())
logger.mockTypes(() => vi.fn())

const _warn = console.warn.bind(console)

const hiddenWarns = [
  '[@vue/reactivity-transform]',
  '[Vue warn]: Component',
  '[Vue router warn]',
]

console.warn = (arg0: any, ...args: any[]) => {
  if ((typeof arg0 === 'string') && hiddenWarns.some(w => arg0.includes(w))) {
    return
  }
  _warn(...args)
}

// for (const t of ['uncaughtException', 'unhandledRejection'] as const) {
//   process.on(t, (err) => {
//     console.error(`[nuxt test suite] [${t}]`, err)
//   })
// }
</file>

<file path="test/setup-runtime.ts">
import { vi } from 'vitest'

vi.mock('#app/compat/idle-callback', () => ({
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  requestIdleCallback: (cb: Function) => cb(),
  cancelIdleCallback: () => {},
}))
</file>

<file path="test/typed-router.test.ts">
import { readFileSync } from 'node:fs'
import { resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { x } from 'tinyexec'
import { describe, expect, it } from 'vitest'

const rootDir = fileURLToPath(new URL('./fixtures/basic-types', import.meta.url))

describe('typed router integration', () => {
  it('does not duplicate params in RouteNamedMap when a child route overrides the path with an absolute path', async () => {
    await x('nuxt', ['prepare', rootDir])
    const typedRouterDtsFile = resolve(rootDir, '.nuxt/types/typed-router.d.ts')
    const typedRouterDts = readFileSync(typedRouterDtsFile, 'utf8')
    // Check for the route definition (accommodates both single-line and multi-line formatting)
    expect(typedRouterDts).toMatch(/'param-id-view-custom':\s*RouteRecordInfo<\s*'param-id-view-custom',\s*'\/param\/:id\(\)\/view-custom',\s*\{\s*id:\s*ParamValue<true>\s*\},\s*\{\s*id:\s*ParamValue<false>\s*\}/)
    // Ensure params are not duplicated
    expect(typedRouterDts).not.toMatch(/\{\s*id:\s*ParamValue<\w+>,\s*id:\s*ParamValue<\w+>\s*\}/)
  })
})
</file>

<file path="test/utils.ts">
import { Script, createContext } from 'node:vm'
import { expect, vi } from 'vitest'
import type { Page } from 'playwright-core'
import { parse } from 'devalue'
import { reactive, ref, shallowReactive, shallowRef } from 'vue'
import { createError } from 'h3'
import { getBrowser, url, useTestContext } from '@nuxt/test-utils/e2e'
import { isCI } from 'std-env'
import { isRenderingJson } from './matrix'

export async function renderPage (path = '/', opts?: { retries?: number }) {
  const ctx = useTestContext()
  if (!ctx.options.browser) {
    throw new Error('`renderPage` require `options.browser` to be set')
  }

  const browser = await getBrowser()
  const page = await browser.newPage({})
  const pageErrors: Error[] = []
  const requests: string[] = []
  const consoleLogs: { type: string, text: string }[] = []

  page.on('console', (message) => {
    consoleLogs.push({
      type: message.type(),
      text: message.text(),
    })
  })
  page.on('pageerror', (err) => {
    pageErrors.push(err)
  })
  page.on('request', (req) => {
    try {
      requests.push(req.url().replace(url('/'), '/'))
    } catch {
      // TODO
    }
  })

  if (path) {
    await gotoPath(page, path, opts?.retries)
  }

  return {
    page,
    pageErrors,
    requests,
    consoleLogs,
  }
}

export async function expectNoClientErrors (path: string) {
  const ctx = useTestContext()
  if (!ctx.options.browser) {
    return
  }

  const { page, pageErrors, consoleLogs } = (await renderPage(path))!

  expect(pageErrors).toEqual([])
  expectNoErrorsOrWarnings(consoleLogs)

  await page.close()
}

export function expectNoErrorsOrWarnings (consoleLogs: Array<{ type: string, text: string }>) {
  const consoleLogErrors = consoleLogs.filter(i => i.type === 'error')
  const consoleLogWarnings = consoleLogs.filter(i => i.type === 'warning')

  expect(consoleLogErrors).toEqual([])
  expect(consoleLogWarnings).toEqual([])
}

const BASE_TIMEOUT = isCI ? 6_000 : 3_000
export async function gotoPath (page: Page, path: string, retries = 0) {
  await vi.waitFor(() => page.goto(url(path), { timeout: BASE_TIMEOUT }), { timeout: BASE_TIMEOUT * retries || BASE_TIMEOUT })
  await page.waitForFunction(path => window.useNuxtApp?.()._route.fullPath === path && !window.useNuxtApp?.().isHydrating, path)
}

const revivers = {
  NuxtError: (data: any) => createError(data),
  EmptyShallowRef: (data: any) => shallowRef(JSON.parse(data)),
  EmptyRef: (data: any) => ref(JSON.parse(data)),
  ShallowRef: (data: any) => shallowRef(data),
  ShallowReactive: (data: any) => shallowReactive(data),
  Island: (key: any) => key,
  Ref: (data: any) => ref(data),
  Reactive: (data: any) => reactive(data),
  // test fixture reviver only
  BlinkingText: () => '<revivified-blink>',
}
export function parsePayload (payload: string) {
  return parse(payload || '', revivers)
}
export function parseData (html: string) {
  if (!isRenderingJson) {
    const { script = '' } = html.match(/<script>(?<script>window.__NUXT__.*?)<\/script>/)?.groups || {}
    const _script = new Script(script)
    return {
      script: _script.runInContext(createContext({ window: {} })),
      attrs: {},
    }
  }

  const regexp = /<script type="application\/json" data-nuxt-data="[^"]+"(?<attrs>[^>]+)>(?<script>.*?)<\/script>/
  const { script, attrs = '' } = html.match(regexp)?.groups || {}
  const _attrs: Record<string, string> = {}
  for (const attr of attrs.matchAll(/( |^)(?<key>[\w-]+)="(?<value>[^"]+)"/g)) {
    _attrs[attr!.groups!.key!] = attr!.groups!.value!
  }
  return {
    script: parsePayload(script || ''),
    attrs: _attrs,
  }
}
</file>

<file path=".editorconfig">
root = true

[*]
indent_size = 2
indent_style = space
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.md]
trim_trailing_whitespace = false
</file>

<file path=".gitignore">
# Dependencies
node_modules
jspm_packages

package-lock.json
packages/*/README.md
!packages/nuxi/README.md
packages/*/LICENSE
docs/LICENSE
*/**/yarn.lock
/.yarn

# Logs
*.log

# Temp directories
.temp
.tmp
.cache

# Lychee cache
.lycheecache

# Generated dirs
dist
.nuxt
.nuxt-*
.vercel
.netlify
.output
.output-*
.gen
.test

# Junit reports
reports

# Coverage reports
coverage
*.lcov
.nyc_output

# VSCode
.vscode

# Intellij idea
*.iml
.idea
!.idea/nuxt.iml
!.idea/modules.xml
!.idea/inspectionProfiles/Project_Default.xml

# OSX
.DS_Store
.AppleDouble
.LSOverride

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

.vercel_build_output
.build-*
.env
.netlify

fixtures-temp
.pnpm-store
eslint-typegen.d.ts
.eslintcache
test-results/
playwright-report

temp

packages/ui-templates/node-compile-cache/
</file>

<file path=".markdownlint.yml">
# Default state for all rules
default: true
# Disable max line length
MD013: false
# Allow duplicated heading for different sections
MD024:
  siblings_only: true
# Allow multiple top-level headings
MD025: false
# Allow inline HTML
MD033: false
# Allow non blank lines around list
MD032: false
MD046:
  style: fenced
MD034: false
MD031: false
MD007: false
# Allow setext-style headings (for MDC YAML frontmatter with --- delimiters)
MD003: false
# Allow headings without surrounding blank lines (for MDC component props)
MD022: false
# Allow headings not at the start of the line (for indented MDC components)
MD023: false
# Do not require aligned columns in tables
MD060: false
</file>

<file path="CODEOWNERS">
* @danielroe
</file>

<file path="eslint.config.mjs">
// @ts-check
import { createConfigForNuxt } from '@nuxt/eslint-config/flat'
// @ts-expect-error missing types
import noOnlyTests from 'eslint-plugin-no-only-tests'
import typegen from 'eslint-typegen'
import perfectionist from 'eslint-plugin-perfectionist'
import { importX } from 'eslint-plugin-import-x'
import parser from '@typescript-eslint/parser'
import markdown from '@eslint/markdown'
import { runtimeDependencies } from 'nuxt/meta'

export default createConfigForNuxt({
  features: {
    stylistic: {
      commaDangle: 'always-multiline',
    },
    tooling: true,
    typescript: true,
  },
})
  .prepend(
    {
      // Ignores have to be a separate object to be treated as global ignores
      // Don't add other attributes to this object
      ignores: [
        '.goff/**',
        'packages/schema/schema/**',
        'packages/nuxt/src/app/components/welcome.vue',
        'packages/nuxt/src/app/components/error-*.vue',
        'packages/nuxt/src/core/runtime/nitro/templates/error-*',
        'packages/nitro-server/src/runtime/templates/error-*',
      ],
    },
    {
      languageOptions: {
        globals: {
          $fetch: 'readonly',
          NodeJS: 'readonly',
        },
      },
      name: 'local/settings',
      settings: {
        jsdoc: {
          ignoreInternal: true,
          tagNamePreference: {
            note: 'note',
            warning: 'warning',
          },
        },
      },
    },
  )

  .override('nuxt/javascript', {
    rules: {
      'curly': ['error', 'all'], // Including if blocks with a single statement
      'dot-notation': 'error',
      'logical-assignment-operators': ['error', 'always', { enforceForIfStatements: true }],
      'no-console': ['warn', { allow: ['warn', 'error', 'debug'] }],
      'no-lonely-if': 'error', // No single if in an "else" block
      'no-useless-rename': 'error',
      'object-shorthand': 'error',
      'prefer-const': ['error', { destructuring: 'any', ignoreReadBeforeAssign: false }],
      'require-await': 'error',
      'sort-imports': ['error', { ignoreDeclarationSort: true }],
    },
  })

  .override('nuxt/typescript/rules', {
    rules: {
      '@typescript-eslint/ban-ts-comment': [
        'error',
        {
          'ts-expect-error': 'allow-with-description',
          'ts-ignore': true,
        },
      ],
      '@typescript-eslint/no-dynamic-delete': 'off',
      '@typescript-eslint/no-unused-vars': [
        'error',
        {
          argsIgnorePattern: '^_',
          destructuredArrayIgnorePattern: '^_',
          ignoreRestSiblings: true,
          varsIgnorePattern: '',
        },
      ],
      '@typescript-eslint/triple-slash-reference': 'off',
      '@typescript-eslint/unified-signatures': 'off',
      ...{
        // TODO: Discuss if we want to enable this
        '@typescript-eslint/ban-types': 'off',
        // TODO: Discuss if we want to enable this
        '@typescript-eslint/no-explicit-any': 'off',
        // TODO: Discuss if we want to enable this
        '@typescript-eslint/no-invalid-void-type': 'off',
      },
    },
  })

  .append({
    files: ['packages/**/*.{mjs,js,ts}', '**/*.{spec,test}.{mjs,js,ts}'],
    ignores: [
      'packages/nuxt/src/app/types/augments.ts',
      'test/fixtures/basic/app/plugins/this-should-not-load.spec.js',
    ],
    languageOptions: {
      parser,
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
    rules: {
      '@typescript-eslint/no-deprecated': 'error',
    },
  })

  .override('nuxt/tooling/unicorn', {
    rules: {
      'unicorn/no-new-array': 'off',
      'unicorn/prefer-dom-node-text-content': 'off',
    },
  })

  .override('nuxt/vue/rules', {
    rules: {

    },
  })

  // Stylistic rules
  .override('nuxt/stylistic', {
    rules: {
      '@stylistic/brace-style': ['error', '1tbs', { allowSingleLine: true }],
      '@stylistic/indent-binary-ops': 'off',
      '@stylistic/max-statements-per-line': 'off',
      '@stylistic/operator-linebreak': 'off',
      '@stylistic/quote-props': ['error', 'consistent'],
      '@stylistic/space-before-function-paren': ['error', 'always'],
    },
  })

  // Append local rules
  .append(
    {
      files: ['*.{js,ts}', 'scripts/**/*.{js,ts}', 'packages/**/*.{mts,ts,mjs,js}'],
      ignores: ['packages/**/*.client.ts', 'packages/**/*.client.mts', 'packages/**/*.client.js', 'packages/**/*.client.mjs'],
      name: 'local/requires/explicit-node-imports',
      rules: {
        // Ban direct use of restricted global identifiers
        'no-restricted-globals': [
          'error',
          {
            message: 'Use explicit import: import process from "node:process" (or a scoped alias). Implicit globals are banned for clarity and tree-shakability.',
            name: 'process',
          },
          {
            message: 'Use explicit import: import { performance } from "node:perf_hooks". Implicit global performance is banned in server contexts to ensure Node.js-specific usage.',
            name: 'performance',
          },
        ],
      },
    },
    // @ts-expect-error type issues
    {
      files: ['**/*.vue', '**/*.ts', '**/*.mts', '**/*.js', '**/*.cjs', '**/*.mjs'],
      name: 'local/rules',
      plugins: {
        'import-x': importX,
      },
      rules: {
        'import-x/no-restricted-paths': [
          'error',
          {
            zones: [
              {
                from: 'packages/nuxt/src/!(core)/runtime/*',
                message: 'core should not directly import from modules.',
                target: 'packages/nuxt/src/core',
              },
              {
                from: 'packages/nuxt/src/!(app)/**/*',
                message: 'app should not directly import from modules.',
                target: 'packages/nuxt/src/app',
              },
              {
                from: 'packages/nuxt/src/app/**/index.ts',
                message: 'should not import from barrel/index files',
                target: 'packages/nuxt/src',
              },
              {
                from: 'packages/nitro',
                message: 'nitro should not directly import other packages.',
                target: 'packages/!(nitro)/**/*',
              },
            ],
          },
        ],
        'jsdoc/check-tag-names': [
          'error',
          {
            definedTags: [
              'experimental',
              '__NO_SIDE_EFFECTS__',
            ],
          },
        ],
      },
    },
    {
      files: ['packages/*/src/**'],
      ignores: ['packages/nuxt/src/app/**', '**/runtime/**/*'],
      name: 'local/import-extensions',
      plugins: {
        'import-x': importX,
      },
      rules: {
        'import/extensions': ['error', 'always', {
          ignorePackages: true,
          js: 'always',
          ts: 'always',
          vue: 'always',
        }],
      },
    },
    {
      files: ['packages/nuxt/src/app/**', 'test/**', '**/runtime/**', '**/*.test.ts'],
      name: 'local/disables/client-console',
      rules: {
        'no-console': 'off',
      },
    },
    // manually specify dependencies for nuxt browser app
    {
      files: ['packages/nuxt/src/app/**', 'packages/nuxt/src/(components,head,imports,pages)/runtime/**'],
      name: 'local/client-packages',
      rules: {
        '@typescript-eslint/no-restricted-imports': ['error', {
          'patterns': [
            {
              allowTypeImports: true,
              group: [
                // disallow everything
                '[@a-z]*',
                // except certain dependencies
                ...[
                  // vue ecosystem
                  '@unhead',
                  '@vue',
                  '@vue/shared',
                  'vue/server-renderer',
                  'vue',
                  'vue-router',
                  ...runtimeDependencies,
                  'errx', /* only used in dev */
                  // internal deps
                  'nuxt/app',
                ].map(r => `!${r}`),
                '!#[a-z]*/**', // aliases
                '!.*/**', // relative imports
              ],
            },
          ],
        }],
      },
    },
    {
      files: ['**/fixtures/**', '**/fixture/**', '**/*-fixture/**'],
      name: 'local/disables/fixtures',
      rules: {
        '@typescript-eslint/no-unused-vars': 'off',
        '@typescript-eslint/triple-slash-reference': 'off',
        'vue/multi-word-component-names': 'off',
        'vue/valid-v-for': 'off',
      },
    },
    {
      files: ['test/**', '**/*.test.ts'],
      name: 'local/disables/tests',
      plugins: {
        'no-only-tests': noOnlyTests,
      },
      rules: {
        '@typescript-eslint/no-explicit-any': 'off',
        'no-console': 'off',
        'no-only-tests/no-only-tests': 'error',
      },
    },
    // Sort rule keys in eslint config
    {
      files: ['**/eslint.config.mjs'],
      name: 'local/sort-eslint-config',
      plugins: {
        perfectionist,
      },
      rules: {
        'perfectionist/sort-objects': 'error',
      },
    },
    {
      files: ['packages/nuxt/src/app/components/welcome.vue'],
      rules: {
        'vue/multi-word-component-names': 'off',
      },
    },
    {
      files: ['**/*.md'],
      language: 'markdown/commonmark',
      name: 'local/docs-markdown',
      plugins: {
        markdown,
      },
      processor: 'markdown/markdown',
    },
    {
      // targets code-blocks in markdown files
      files: ['**/*.md/**/*'],
      rules: {
        '@stylistic/keyword-spacing': 'off',
        '@typescript-eslint/no-empty-object-type': 'off',
        '@typescript-eslint/no-unused-vars': 'off',
        'import/first': 'off',
        'no-console': 'off',
        'no-unused-vars': 'off',
        'vue/no-unused-vars': 'off',
        'vue/require-v-for-key': 'off',
      },
    },
  )

  // Generate type definitions for the eslint config
  // @ts-expect-error type issues in eslint
  .onResolved((configs) => {
    // @ts-expect-error type issues in eslint
    return typegen(configs)
  })
</file>

<file path="knip.json">
{
  "$schema": "https://unpkg.com/knip@5/schema.json",
  "ignoreBinaries": [
    "prepack"
  ],
  "ignoreWorkspaces": ["test/fixtures/basic"],
  "ignoreDependencies": [
    "bing",
    "uno.css"
  ],
  "workspaces": {
    ".": {
      "entry": [
        "scripts/*"
      ]
    },
    "test/fixtures/*": {
      "entry": [
        "nuxt.config.{js,ts}",
        "modules/*.ts",
        "types.ts"
      ]
    },
    "packages/*": {
      "entry": [
        "src/index.ts",
        "src/runtime/**/*.{js,ts,mjs}"
      ]
    },
    "packages/nuxt": {
      "entry": [
        "src/app/**/*.ts",
        "src/app/*.ts",
        "src/*/runtime/**/*.{ts,js}",
        "src/core/templates.ts",
        "src/index.ts"
      ]
    },
    "packages/rspack": {
      "entry": [
        "../webpack/src/index.ts",
        "../webpack/src/runtime/**/*.{js,ts,mjs}",
        "builder.mjs"
      ]
    },
    "packages/ui-templates": {
      "entry": [
        "lib/*.ts",
        "styles.ts"
      ]
    },
    "packages/webpack": {
      "entry": [
        "src/index.ts",
        "src/runtime/**/*.{js,ts,mjs}",
        "builder.mjs"
      ]
    }
  }
}
</file>

<file path="LICENSE">
The MIT License (MIT)

Copyright (c) 2016-present - Nuxt Team

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="lychee.toml">
# Cache the results of Lychee if ran locally in order to minimise the chance of rate limiting
cache = true

# Discard all cached requests older than this duration.
max_cache_age = "1d"
# Ignore all private link (such as localhost) to avoid errors
exclude_all_private = true
# HTTP status code: 429 (Too Many Requests) will also be treated as a valid link if Lychee gets rate limited
accept = [200, 201, 204, 206, 300, 301, 302, 303, 304, 307, 308, 999]

# Base URL or website root directory to check relative URLs.
base_url = "https://nuxt.com/"

no_progress = true

# Enable checking of fragments/anchors in links (e.g., #section-name)
# include_fragments = true

# Follow redirects
max_redirects = 1

# Set user agent to avoid bot blocking
user_agent = "Mozilla/5.0 (compatible; lychee link checker)"

# Set reasonable timeout and retry values
timeout = 20
retry_wait_time = 2
max_retries = 6

# Explicitly exclude some URLs
exclude = [
  "https://twitter.nuxt.dev/",
  "https://www.webpagetest.org/",
  "https://stackoverflow.com/help/minimal-reproducible-example",
  "https://gsap.com/",
  # dummy example URLs
  "https://myawesome-lib.js/",
  "https://awesome-lib.js/",
  "https://myawesome-lib.css/",
  "https://awesome-lib.css/",
  "https://mycdn.org/",
  "https://nuxt.new/c/v4",
  "https://nuxt.new/s/v4",
  "https://www.npmjs.com/",
  # TODO: fix upstream API issues
  "https://nuxt.com/modules",
  # single-quotes are required for regexp
  'https://res.cloudinary.com/nuxt/video/upload/(.*)',
  'https://www.npmjs.com/package/(.*)',
  '(https?:\/\/github\.com\/)(.*\/)(generate)',
  "https://github.com/nuxt-contrib/vue3-ssr-starter/generate",
  # excluded URLs from test suite
  "http://auth.com",
  "http://example1.com/",
  "http://example2.com/",
  "http://example3.com/",
  "~images/main-bg.jpg",
]
</file>

<file path="nuxt.config.ts">
// For pnpm typecheck:docs to generate correct types

import process from 'node:process'
import { fileURLToPath } from 'node:url'
import { addPluginTemplate, addRouteMiddleware, addVitePlugin } from 'nuxt/kit'

export default defineNuxtConfig({
  modules: [
    function () {
      if (!process.env.DOCS_TYPECHECK) { return }
      addPluginTemplate({
        filename: 'plugins/my-plugin.mjs',
        getContents: () => 'export default defineNuxtPlugin({ name: \'my-plugin\' })',
      })
      addRouteMiddleware({
        name: 'auth',
        path: '#build/auth.js',
      })
    },
    function (_options, nuxt) {
      // this preserves onPrehydrate so we can make assertions on the client
      nuxt.options.optimization.treeShake.composables.client ||= {}
      nuxt.options.optimization.treeShake.composables.client['#app'] = nuxt.options.optimization.treeShake.composables.client['#app']?.filter(c => c !== 'onPrehydrate') || []

      addVitePlugin(() => ({
        name: 'preserve-ssr-composables',
        enforce: 'pre',
        transform (code, id) {
          let replaced = false
          if (code.includes('export function onPrehydrate')) {
            replaced = true
            code = code.replaceAll('if (import.meta.client) { return }', '')
          }
          if (id.includes('nuxt-time.vue')) {
            replaced = true
            code = code.replace('if (import.meta.server) {', 'if (useAttrs().ssr) {')
          }
          if (replaced) {
            return code
          }
        },
      }))
    },
  ],
  pages: process.env.DOCS_TYPECHECK === 'true',
  dir: {
    app: fileURLToPath(new URL('./test/runtime/app', import.meta.url)),
  },
  vite: {
    define: {
      'import.meta.dev': 'globalThis.__TEST_DEV__',
    },
  },
  typescript: {
    shim: process.env.DOCS_TYPECHECK === 'true',
    hoist: ['@vitejs/plugin-vue', 'vue-router'],
  },
})
</file>

<file path="package.json">
{
  "name": "nuxt-framework",
  "private": true,
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nuxt/nuxt.git"
  },
  "license": "MIT",
  "type": "module",
  "scripts": {
    "build": "pnpm --filter './packages/**' prepack",
    "build:stub": "pnpm dev:prepare",
    "dev": "pnpm play",
    "dev:prepare": "pnpm --filter './packages/**' build:stub && nuxt prepare",
    "debug:build": "TIMINGS_DEBUG=true pnpm build",
    "debug:dev": "rm -rf **/node_modules/.cache/jiti && pnpm nuxt dev",
    "lint": "eslint . --cache",
    "lint:fix": "eslint . --cache --fix",
    "lint:docs": "markdownlint --ignore-path=.gitignore ./docs && case-police 'docs/**/*.md' *.md",
    "lint:docs:fix": "markdownlint --ignore-path=.gitignore ./docs --fix && case-police 'docs/**/*.md' *.md --fix",
    "lint:knip": "knip",
    "play": "nuxt dev playground",
    "play:build": "nuxt build playground",
    "play:generate": "nuxt generate playground",
    "play:preview": "nuxt preview playground",
    "test": "pnpm test:prepare && vitest run && pnpm test:fixtures:dev && pnpm test:fixtures:webpack && pnpm test:types && pnpm typecheck",
    "test:prepare": "jiti ./test/prepare.ts",
    "test:fixtures": "pnpm test:prepare && vitest run --project fixtures",
    "test:fixtures:dev": "TEST_ENV=dev pnpm test:fixtures",
    "test:fixtures:webpack": "TEST_BUILDER=webpack pnpm test:fixtures",
    "test:runtime": "vitest run --project nuxt --project nuxt-universal --project nuxt-legacy",
    "test:types": "pnpm --filter './test/fixtures/**' test:types",
    "test:unit": "vitest run --project unit",
    "test:attw": "pnpm --filter './packages/**' test:attw",
    "test:e2e": "playwright test",
    "test:e2e:debug": "playwright test --debug",
    "test:e2e:ui": "playwright test --ui",
    "test:e2e:dev": "TEST_ENV=dev playwright test",
    "test:e2e:webpack": "TEST_BUILDER=webpack playwright test",
    "typecheck": "vue-tsc --noEmit",
    "typecheck:docs": "DOCS_TYPECHECK=true pnpm nuxt prepare && nuxt-content-twoslash verify --content-dir docs --languages html"
  },
  "resolutions": {
    "@babel/core": "7.28.5",
    "@babel/helper-plugin-utils": "7.27.1",
    "@nuxt/cli": "3.31.3",
    "@nuxt/kit": "workspace:*",
    "@nuxt/nitro-server": "workspace:*",
    "@nuxt/rspack-builder": "workspace:*",
    "@nuxt/schema": "workspace:*",
    "@nuxt/vite-builder": "workspace:*",
    "@nuxt/webpack-builder": "workspace:*",
    "@rollup/plugin-commonjs": "28.0.6",
    "@types/node": "24.10.4",
    "@unhead/vue": "2.1.1",
    "@vue/compiler-core": "3.5.26",
    "@vue/compiler-dom": "3.5.26",
    "@vue/shared": "3.5.26",
    "c12": "3.3.3",
    "compatx": "0.2.0",
    "h3": "1.15.4",
    "jiti": "2.6.1",
    "magic-string": "0.30.21",
    "nitropack": "2.12.9",
    "nuxt": "workspace:*",
    "postcss": "8.5.6",
    "rollup": "4.54.0",
    "send": ">=1.2.1",
    "typescript": "5.9.3",
    "ufo": "1.6.1",
    "unbuild": "3.6.1",
    "unimport": "5.6.0",
    "unstorage": "1.17.3",
    "vite": "7.3.0",
    "vue": "3.5.26",
    "vue-router": "4.6.4",
    "webpack": "5.104.1"
  },
  "devDependencies": {
    "@arethetypeswrong/cli": "0.18.2",
    "@babel/core": "7.28.5",
    "@babel/helper-plugin-utils": "7.27.1",
    "@codspeed/core": "5.0.1",
    "@codspeed/vitest-plugin": "5.0.1",
    "@eslint/markdown": "7.5.1",
    "@nuxt/cli": "3.31.3",
    "@nuxt/eslint-config": "1.12.1",
    "@nuxt/kit": "workspace:*",
    "@nuxt/rspack-builder": "workspace:*",
    "@nuxt/test-utils": "3.22.0",
    "@nuxt/webpack-builder": "workspace:*",
    "@playwright/test": "1.57.0",
    "@rspack/core": "1.7.0",
    "@testing-library/vue": "8.1.0",
    "@types/babel__core": "7.20.5",
    "@types/babel__helper-plugin-utils": "7.10.3",
    "@types/node": "24.10.4",
    "@types/semver": "7.7.1",
    "@typescript-eslint/parser": "8.51.0",
    "@unhead/vue": "2.1.1",
    "@vitest/coverage-v8": "3.2.4",
    "@vue/test-utils": "2.4.6",
    "acorn": "8.15.0",
    "autoprefixer": "10.4.23",
    "case-police": "2.1.1",
    "changelogen": "0.6.2",
    "consola": "3.4.2",
    "cssnano": "7.1.2",
    "defu": "6.1.4",
    "destr": "2.0.5",
    "devalue": "5.6.1",
    "eslint": "9.39.2",
    "eslint-plugin-import-x": "4.16.1",
    "eslint-plugin-no-only-tests": "3.3.0",
    "eslint-plugin-perfectionist": "5.2.0",
    "eslint-typegen": "2.3.0",
    "estree-walker": "3.0.3",
    "get-port-please": "3.2.0",
    "h3": "1.15.4",
    "happy-dom": "20.0.11",
    "installed-check": "9.3.0",
    "jiti": "2.6.1",
    "knip": "5.79.0",
    "magic-regexp": "0.10.0",
    "magic-string": "0.30.21",
    "markdownlint-cli": "0.47.0",
    "memfs": "4.51.1",
    "nitropack": "2.12.9",
    "nuxt": "workspace:*",
    "nuxt-content-twoslash": "0.1.2",
    "ofetch": "1.5.1",
    "pathe": "2.0.3",
    "pkg-pr-new": "0.0.62",
    "playwright-core": "1.57.0",
    "rollup": "4.54.0",
    "semver": "7.7.3",
    "sherif": "1.9.0",
    "srvx": "0.10.0",
    "std-env": "3.10.0",
    "tinyexec": "1.0.2",
    "tinyglobby": "0.2.15",
    "ts-blank-space": "0.6.2",
    "typescript": "5.9.3",
    "ufo": "1.6.1",
    "unbuild": "3.6.1",
    "vite": "7.3.0",
    "vitest": "3.2.4",
    "vitest-environment-nuxt": "1.0.1",
    "vue": "3.5.26",
    "vue-tsc": "3.2.1",
    "webpack": "5.104.1"
  },
  "packageManager": "pnpm@10.27.0",
  "version": ""
}
</file>

<file path="playwright.config.ts">
import { defineConfig, devices } from '@playwright/test'
import type { ConfigOptions } from '@nuxt/test-utils/playwright'
import { isCI, isWindows } from 'std-env'

/**
 * Playwright configuration for Nuxt e2e tests
 * @see https://playwright.dev/docs/test-configuration
 */
export default defineConfig<ConfigOptions>({
  testDir: './test/e2e',
  testMatch: '**/*.test.ts',
  timeout: (isWindows ? 360 : 120) * 1000,
  fullyParallel: true,
  forbidOnly: !!isCI,
  retries: isCI ? 2 : 0,
  workers: isCI ? 1 : undefined,
  reporter: 'html',
  projects: [
    {
      name: 'setup fixtures',
      testMatch: /global\.setup\.ts/,
      teardown: 'cleanup fixtures',
    },
    {
      name: 'cleanup fixtures',
      testMatch: /global\.teardown\.ts/,
    },
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
      dependencies: ['setup fixtures'],
    },
  ],
})
</file>

<file path="pnpm-workspace.yaml">
packages:
  - docs
  - packages/**
  - '!packages/nuxi'
  - '!packages/test-utils'
  - '!packages/nuxt/test/package-fixture'
  - playground
  - test/fixtures/*

ignoredBuiltDependencies:
  - '@parcel/watcher'
  - esbuild
  - oxc-resolver
  - unrs-resolver

patchedDependencies:
  changelogen: patches/changelogen.patch

publicHoistPattern:
  - '*-loader'
  - 'webpack-*'

shellEmulator: true

verifyDepsBeforeRun: install
</file>

<file path="README.md">
[![Nuxt banner](./.github/assets/banner.svg)](https://nuxt.com)

# Nuxt

<p>
  <a href="https://www.npmjs.com/package/nuxt"><img src="https://img.shields.io/npm/v/nuxt.svg?style=flat&colorA=18181B&colorB=28CF8D" alt="Version"></a>
  <a href="https://www.npmjs.com/package/nuxt"><img src="https://img.shields.io/npm/dm/nuxt.svg?style=flat&colorA=18181B&colorB=28CF8D" alt="Downloads"></a>
  <a href="https://github.com/nuxt/nuxt/blob/main/LICENSE"><img src="https://img.shields.io/github/license/nuxt/nuxt.svg?style=flat&colorA=18181B&colorB=28CF8D" alt="License"></a>
  <a href="https://nuxt.com/modules"><img src="https://img.shields.io/badge/dynamic/json?url=https://nuxt.com/api/v1/modules&query=$.stats.modules&label=Modules&style=flat&colorA=18181B&colorB=28CF8D" alt="Modules"></a>
  <a href="https://nuxt.com"><img src="https://img.shields.io/badge/Nuxt%20Docs-18181B?logo=nuxt" alt="Website"></a>
  <a href="https://chat.nuxt.dev"><img src="https://img.shields.io/badge/Nuxt%20Discord-18181B?logo=discord" alt="Discord"></a>
  <a href="https://securityscorecards.dev/"><img src="https://api.securityscorecards.dev/projects/github.com/nuxt/nuxt/badge" alt="Nuxt openssf scorecard score"></a>
  <a href="https://deepwiki.com/nuxt/nuxt"><img src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki"></a>
</p>

Nuxt is a free and open-source framework with an intuitive and extendable way to create type-safe, performant and production-grade full-stack web applications and websites with Vue.js.

It provides a number of features that make it easy to build fast, SEO-friendly, and scalable web applications, including:
- Server-side rendering, static site generation, hybrid rendering and edge-side rendering
- Automatic routing with code-splitting and pre-fetching
- Data fetching and state management
- Search engine optimization and defining meta tags
- Auto imports of components, composables and utils
- TypeScript with zero configuration
- Go full-stack with our server/ directory
- Extensible with [300+ modules](https://nuxt.com/modules)
- Deployment to a variety of [hosting platforms](https://nuxt.com/deploy)
- ...[and much more](https://nuxt.com) 🚀

### Table of Contents

- 🚀 [Getting Started](#getting-started)
- 💻 [Vue Development](#vue-development)
- 📖 [Documentation](#documentation)
- 🧩 [Modules](#modules)
- ❤️ [Contribute](#contribute)
- 🏠 [Local Development](#local-development)
- 🛟 [Professional Support](#professional-support)
- 🔗 [Follow Us](#follow-us)
- ⚖️ [License](#license)

---

## <a name="getting-started">🚀 Getting Started</a>

Use the following command to create a new starter project. This will create a starter project with all the necessary files and dependencies:

```bash
npm create nuxt@latest <my-project>
```

> [!TIP]
> Discover also [nuxt.new](https://nuxt.new): Open a Nuxt starter on CodeSandbox, StackBlitz or locally to get up and running in a few seconds.

## <a name="vue-development">💻 Vue Development</a>

Simple, intuitive and powerful, Nuxt lets you write Vue components in a way that makes sense. Every repetitive task is automated, so you can focus on writing your full-stack Vue application with confidence.

Example of an `app.vue`:

```vue
<script setup lang="ts">
useSeoMeta({
  title: 'Meet Nuxt',
  description: 'The Intuitive Vue Framework.',
})
</script>

<template>
  <div id="app">
    <AppHeader />
    <NuxtPage />
    <AppFooter />
  </div>
</template>

<style scoped>
#app {
  background-color: #020420;
  color: #00DC82;
}
</style>
```

## <a name="documentation">📖 Documentation</a>

We highly recommend you take a look at the [Nuxt documentation](https://nuxt.com/docs) to level up. It’s a great resource for learning more about the framework. It covers everything from getting started to advanced topics.

## <a name="modules">🧩 Modules</a>

Discover our [list of modules](https://nuxt.com/modules) to supercharge your Nuxt project, created by the Nuxt team and community.

## <a name="contribute">❤️ Contribute</a>

We invite you to contribute and help improve Nuxt 💚

Here are a few ways you can get involved:
- **Reporting Bugs:** If you come across any bugs or issues, please check out the [reporting bugs guide](https://nuxt.com/docs/4.x/community/reporting-bugs) to learn how to submit a bug report.
- **Suggestions:** Have ideas to enhance Nuxt? We'd love to hear them! Check out the [contribution guide](https://nuxt.com/docs/4.x/community/contribution) to share your suggestions.
- **Questions:** If you have questions or need assistance, the [getting help guide](https://nuxt.com/docs/4.x/community/getting-help) provides resources to help you out.

## <a name="local-development">🏠 Local Development</a>

Follow the docs to [Set Up Your Local Development Environment](https://nuxt.com/docs/4.x/community/framework-contribution#setup) to contribute to the framework and documentation.

## <a name="professional-support">🛟 Professional Support</a>

- Technical audit & consulting: [Nuxt Experts](https://nuxt.com/enterprise/support)
- Custom development & more: [Nuxt Agencies Partners](https://nuxt.com/enterprise/agencies)

## <a name="follow-us">🔗 Follow Us</a>

<p valign="center">
  <a href="https://go.nuxt.com/discord"><img width="20px" src="./.github/assets/discord.svg" alt="Discord"></a>&nbsp;&nbsp;<a href="https://go.nuxt.com/x"><img width="20px" src="./.github/assets/twitter.svg" alt="Twitter"></a>&nbsp;&nbsp;<a href="https://go.nuxt.com/github"><img width="20px" src="./.github/assets/github.svg" alt="GitHub"></a>&nbsp;&nbsp;<a href="https://go.nuxt.com/bluesky"><img width="20px" src="./.github/assets/bluesky.svg" alt="Bluesky"></a>
</p>

## <a name="license">⚖️ License</a>

[MIT](https://github.com/nuxt/nuxt/blob/main/LICENSE)
</file>

<file path="renovate.json">
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": [
    "github>nuxt/renovate-config-nuxt",
    ":pinDevDependencies",
    ":widenPeerDependencies"
  ],
  "baseBranchPatterns": [
    "main",
    "3.x"
  ],
  "ignoreDeps": [
    "node",
    "npm"
  ],
  "packageRules": [
    {
      "groupName": "webpack",
      "matchPackageNames": [
        "/webpack/",
        "/-loader/"
      ]
    },
    {
      "groupName": "vitest",
      "matchPackageNames": [
        "vitest",
        "/^@vitest//"
      ]
    },
    {
      "matchBaseBranches": [
        "main",
        "3.x"
      ],
      "ignoreDeps": [
        "nuxt",
        "nuxt3",
        "@nuxt/kit",
        "@rollup/plugin-commonjs"
      ]
    }
  ]
}
</file>

<file path="SECURITY.md">
# Security Policy

## Reporting a Vulnerability

To report a vulnerability, please [privately report it via the Security tab](https://github.com/nuxt/nuxt/security/advisories/new) on the correct GitHub repository (see [documentation](https://docs.github.com/en/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/privately-reporting-a-security-vulnerability#privately-reporting-a-security-vulnerability)). If that is impossible, feel free to send an email to **security@nuxtjs.org** instead.

All security vulnerabilities will be promptly verified and addressed. 

While the discovery of new vulnerabilities is rare, we also recommend always using the latest versions of Nuxt and other dependencies by maintaining lock files (`yarn.lock`, `package-lock.json`, `pnpm-lock.yaml`, and `bun.lock`) in order to ensure your application remains as secure as possible.
</file>

<file path="tsconfig.json">
{
  // https://www.totaltypescript.com/tsconfig-cheat-sheet
  "compilerOptions": {
    /* Base options: */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "es2022",
    "allowJs": true,
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    "verbatimModuleSyntax": true,
    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noUncheckedSideEffectImports": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitOverride": true,
    /* If NOT transpiling with TypeScript: */
    "module": "preserve",
    "noEmit": true,
    /* If your code runs in the DOM: */
    "lib": [
      "es2022",
      "webworker",
      "dom",
      "dom.iterable"
    ],
    "paths": {
      "#app": [
        "./packages/nuxt/src/app/index"
      ],
      "#app/*": [
        "./packages/nuxt/src/app/*"
      ],
      "#unhead/composables": [
        "./packages/nuxt/src/head/runtime/composables"
      ]
    }
  },
  "exclude": [
    "**/dist/**",
    "**/.nuxt/**",
    "packages/nuxt/src/app/types/**",
    "packages/nuxt/meta.d.ts",
    "**/nuxt.d.ts",
    "**/examples/**",
    "**/docs/**",
    "**/playground/**",
    "**/test/nuxt/**",
    "**/test/fixtures/**",
    "**/test/fixtures-temp/**"
  ]
}
</file>

<file path="vitest.config.ts">
import process from 'node:process'
import { resolve } from 'pathe'
import { defineVitestProject } from '@nuxt/test-utils/config'
import { configDefaults, coverageConfigDefaults, defaultExclude, defineConfig } from 'vitest/config'
import { isCI, isWindows } from 'std-env'
import { getV8Flags } from '@codspeed/core'
import codspeedPlugin from '@codspeed/vitest-plugin'
import type { NuxtConfig } from 'nuxt/schema'
import { defu } from 'defu'

const commonSettings: NuxtConfig = {
  pages: true,
  routeRules: {
    '/specific-prerendered': { prerender: true },
    '/pre/test': { redirect: '/' },
    '/pre/**': { prerender: true },
  },
  experimental: {
    appManifest: process.env.TEST_MANIFEST !== 'manifest-off',
  },
  imports: {
    polyfills: false,
  },
}

const projects: Record<string, NuxtConfig> = {
  'nuxt': {},
  'nuxt-legacy': {
    experimental: {
      alwaysRunFetchOnKeyChange: true,
    },
  },
}

export default defineConfig({
  test: {
    coverage: {
      exclude: [...coverageConfigDefaults.exclude, 'playground', '**/test/', 'scripts'],
    },
    poolOptions: isCI ? { forks: { execArgv: getV8Flags() } } : undefined,
    projects: [
      {
        plugins: isCI ? [codspeedPlugin()] : [],
        test: {
          name: 'benchmark',
          pool: isCI ? 'forks' : undefined,
          include: [],
          benchmark: {
            include: ['**/*.bench.ts'],
          },
        },
      },
      {
        define: {
          'import.meta.dev': 'globalThis.__TEST_DEV__',
        },
        test: {
          name: 'fixtures',
          include: ['test/*.test.ts'],
          setupFiles: ['./test/setup-env.ts'],
          testTimeout: isWindows ? 60000 : 10000,
          // Excluded plugin because it should throw an error when accidentally loaded via Nuxt
          exclude: [...configDefaults.exclude, 'test/e2e/**', 'e2e/**', 'nuxt/**', '**/test.ts', '**/this-should-not-load.spec.js'],
          benchmark: { include: [] },
        },
      },
      {
        define: {
          'import.meta.dev': 'globalThis.__TEST_DEV__',
        },
        resolve: {
          alias: {
            '#build/nuxt.config.mjs': resolve('./test/mocks/nuxt-config'),
            '#build/router.options.mjs': resolve('./test/mocks/router-options'),
            '#internal/nuxt/paths': resolve('./test/mocks/paths'),
            '#build/app.config.mjs': resolve('./test/mocks/app-config'),
            '#app': resolve('./packages/nuxt/dist/app'),
          },
        },
        test: {
          name: 'unit',
          benchmark: { include: [] },
          setupFiles: ['./test/setup-env.ts'],
          include: ['packages/**/*.{test,spec}.ts'],
          testTimeout: isWindows ? 60000 : 10000,
          // Excluded plugin because it should throw an error when accidentally loaded via Nuxt
          exclude: [...configDefaults.exclude, 'test/e2e/**', 'e2e/**', 'nuxt/**', '**/test.ts', '**/this-should-not-load.spec.js'],
        },
      },
      await defineVitestProject({
        test: {
          name: 'nuxt-universal',
          dir: './test/nuxt/universal',
          environment: 'nuxt',
          environmentOptions: {
            nuxt: {
              overrides: { pages: false },
            },
          },
        },
      }),
      ...await Promise.all(Object.entries(projects).map(([project, config]) => defineVitestProject({
        define: {
          'import.meta.dev': 'globalThis.__TEST_DEV__',
        },
        test: {
          name: project,
          dir: './test/nuxt',
          exclude: [...defaultExclude, '**/universal/**'],
          environment: 'nuxt',
          setupFiles: ['./test/setup-runtime.ts'],
          env: {
            PROJECT: project,
          },
          environmentOptions: {
            nuxt: {
              overrides: defu(config, commonSettings),
            },
          },
        },
      }))),
    ],
  },
})
</file>

</files>
